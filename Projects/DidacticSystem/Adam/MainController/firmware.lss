
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000088  00800100  0000a7b4  0000a868  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000a7b4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000e5a  00800188  00800188  0000a8f0  2**0
                  ALLOC
  3 .eeprom       00000032  00810000  00810000  0000a8f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         0001a6c4  00000000  00000000  0000a924  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000be97  00000000  00000000  00024fe8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000011  00000000  00000000  00030e7f  2**0
                  CONTENTS, READONLY
  7 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00030e90  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 11 0a 	jmp	0x1422	; 0x1422 <__ctors_end>
       4:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
       8:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
       c:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      10:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      14:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      18:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      1c:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      20:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      24:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      28:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      2c:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      30:	0c 94 35 4c 	jmp	0x986a	; 0x986a <__vector_12>
      34:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      38:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      3c:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      40:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      44:	0c 94 5d 0f 	jmp	0x1eba	; 0x1eba <__vector_17>
      48:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <__vector_18>
      4c:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <__vector_19>
      50:	0c 94 8f 0c 	jmp	0x191e	; 0x191e <__vector_20>
      54:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      58:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      5c:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      60:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      64:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      68:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      6c:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      70:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      74:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      78:	0c 94 db 0c 	jmp	0x19b6	; 0x19b6 <__vector_30>
      7c:	0c 94 3f 0d 	jmp	0x1a7e	; 0x1a7e <__vector_31>
      80:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      84:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>
      88:	0c 94 56 0b 	jmp	0x16ac	; 0x16ac <__bad_interrupt>

0000008c <__trampolines_end>:
      8c:	20 28       	or	r2, r0
      8e:	74 68       	ori	r23, 0x84	; 132
      90:	72 65       	ori	r23, 0x52	; 82
      92:	73 68       	ori	r23, 0x83	; 131
      94:	6f 6c       	ori	r22, 0xCF	; 207
      96:	64 20       	and	r6, r4
      98:	25 64       	ori	r18, 0x45	; 69
      9a:	2c 20       	and	r2, r12
      9c:	41 43       	sbci	r20, 0x31	; 49
      9e:	20 76       	andi	r18, 0x60	; 96
      a0:	61 6c       	ori	r22, 0xC1	; 193
      a2:	75 65       	ori	r23, 0x55	; 85
      a4:	20 25       	eor	r18, r0
      a6:	64 29       	or	r22, r4
      a8:	0d 0a       	sbc	r0, r29
	...

000000ab <statusLockerCloseStr>:
      ab:	20 6c 6f 63 6b 65 64 20 00                           locked .

000000b4 <statusLockerOpenStr>:
      b4:	20 6f 70 65 6e 20 20 20 00                           open   .

000000bd <statusLockerSensDescStr>:
      bd:	20 6c 6f 63 6b 65 72 20 25 64 00                     locker %d.

000000c8 <__c.3634>:
      c8:	0d 0a 00                                            ...

000000cb <__c.3632>:
      cb:	0d 0a 00                                            ...

000000ce <__c.3630>:
      ce:	0d 0a 00                                            ...

000000d1 <__c.3628>:
      d1:	0d 0a 00                                            ...

000000d4 <__c.3625>:
      d4:	46 72 65 65 52 74 6f 73 2b 20 76 65 72 20 30 2e     FreeRtos+ ver 0.
      e4:	33 31 20 62 75 69 6c 64 3a 20 41 75 67 20 31 38     31 build: Aug 18
      f4:	20 32 30 31 37 2c 20 31 36 3a 31 32 3a 34 34 0d      2017, 16:12:44.
     104:	0a 00                                               ..

00000106 <__c.3674>:
     106:	75 64 70 00                                         udp.

0000010a <__c.3672>:
     10a:	74 63 70 00                                         tcp.

0000010e <__c.3670>:
     10e:	69 63 6d 70 00                                      icmp.

00000113 <__c.3668>:
     113:	69 70 00                                            ip.

00000116 <__c.3666>:
     116:	61 72 70 00                                         arp.

0000011a <__c.3664>:
     11a:	75 64 70 00                                         udp.

0000011e <__c.3662>:
     11e:	74 63 70 00                                         tcp.

00000122 <__c.3660>:
     122:	69 63 6d 70 00                                      icmp.

00000127 <__c.3658>:
     127:	69 70 00                                            ip.

0000012a <__c.3656>:
     12a:	61 72 70 00                                         arp.

0000012e <__c.3768>:
     12e:	58 6d 6f 64 65 6d 3a 20 72 6f 7a 70 6f 63 7a 79     Xmodem: rozpoczy
     13e:	6e 61 6e 69 65 20 6f 64 62 69 6f 72 75 0d 0a 00     nanie odbioru...

0000014e <__c.3718>:
     14e:	57 61 72 74 6f 73 63 20 70 72 6f 62 6b 69 20 6e     Wartosc probki n
     15e:	61 20 77 65 6a 73 63 69 75 20 25 64 3a 20 25 64     a wejsciu %d: %d
     16e:	0d 0a 00                                            ...

00000171 <__c.3649>:
     171:	41 6b 74 75 61 6c 6e 79 20 63 7a 61 73 20 25 64     Aktualny czas %d
     181:	3a 25 64 3a 25 64 0d 0a 00                          :%d:%d...

0000018a <cmdListConfigure>:
     18a:	04 08 f2 07 db 10 eb 07 b4 07 40 19 8d 07 82 07     ..........@.....
     19a:	8d 10 e9 04 c7 04 0d 11 66 04 43 04 e3 16 ec 03     ........f.C.....
     1aa:	dc 03 c3 16 d9 03 b1 03 74 16 3f 04 f1 03 01 16     ........t.?.....
     1ba:	ad 03 7f 03 ca 15 7a 03 67 03 fc 11 9d 04 91 04     ......z.g.......
     1ca:	d3 0f 89 04 7f 04 e3 0f 00 00 00 00 00 00           ..............

000001d8 <cmdListEnable>:
     1d8:	04 08 f2 07 db 10 eb 07 b4 07 40 19 ac 07 92 07     ..........@.....
     1e8:	f4 11 8d 07 82 07 8d 10 7c 07 33 07 f7 14 2d 07     ........|.3...-.
     1f8:	07 07 6e 17 02 07 d1 06 ff 0f cc 06 a6 06 44 13     ..n...........D.
     208:	a0 06 7d 06 01 12 76 06 3e 06 d0 17 38 06 24 06     ..}...v.>...8.$.
     218:	85 10 20 06 04 06 b3 17 fc 05 d7 05 9d 17 d0 05     .. .............
     228:	a6 05 df 12 9f 05 75 05 09 10 72 05 4c 05 79 12     ......u...r.L.y.
     238:	47 05 1f 05 9b 11 1b 05 08 05 89 11 04 05 f1 04     G...............
     248:	77 11 62 03 45 03 68 12 e9 04 c7 04 0d 11 c4 04     w.b.E.h.........
     258:	a4 04 e0 10 89 04 7f 04 e3 0f 78 04 69 04 ef 0f     ..........x.i...
     268:	40 03 23 03 4b 12 1d 03 fa 02 3a 12 00 00 00 00     @.#.K.....:.....
	...

0000027a <cmdListNormal>:
     27a:	04 08 f2 07 db 10 eb 07 b4 07 40 19 8d 07 82 07     ..........@.....
     28a:	8d 10 2d 07 07 07 6e 17 02 07 d1 06 ff 0f 38 06     ..-...n.......8.
     29a:	24 06 85 10 9f 05 75 05 09 10 9d 04 91 04 d3 0f     $.....u.........
     2aa:	00 00 00 00 00 00                                   ......

000002b0 <errorStrings>:
     2b0:	74 0b 6a 0b 67 0b 64 0b 61 0b 5e 0b 4b 0b 24 0b     t.j.g.d.a.^.K.$.
     2c0:	05 0b e2 0a c3 0a ae 0a                             ........

000002c8 <BladBuforaPozostaloBajtowStr>:
     2c8:	21 21 21 20 57 20 62 75 64 6f 72 7a 65 20 52 73     !!! W budorze Rs
     2d8:	34 38 35 20 70 6f 7a 6f 73 74 61 6c 6f 20 25 64     485 pozostalo %d
     2e8:	20 62 61 6a 74 6f 77 0d 0a 00                        bajtow...

000002f2 <nlStr>:
     2f2:	0d 0a 00                                            ...

000002f5 <okStr>:
     2f5:	4f 4b 0d 0a 00                                      OK...

000002fa <cmd_help_zapiszMW>:
     2fa:	5b 41 5d 20 73 61 76 65 20 65 78 65 63 75 74 69     [A] save executi
     30a:	6f 6e 20 6d 6f 64 75 6c 65 20 73 65 74 74 69 6e     on module settin
     31a:	67 73 00                                            gs.

0000031d <cmd_zapiszMW>:
     31d:	72 73 61 76 65 00                                   rsave.

00000323 <cmd_help_ustawMW>:
     323:	5b 41 5d 20 5b 43 5d 20 73 65 74 20 65 78 65 63     [A] [C] set exec
     333:	75 74 69 6f 6e 20 6d 6f 64 75 6c 65 00              ution module.

00000340 <cmd_ustawMW>:
     340:	72 73 65 74 00                                      rset.

00000345 <cmd_help_ustawR>:
     345:	5b 76 61 6c 75 65 5d 20 73 65 74 20 72 65 73 69     [value] set resi
     355:	73 74 61 6e 63 65 20 76 61 6c 75 65 00              stance value.

00000362 <cmd_ustawR>:
     362:	73 65 74 72 00                                      setr.

00000367 <cmd_help_conf_save>:
     367:	53 61 76 65 20 63 6f 6e 66 69 67 75 72 61 74 69     Save configurati
     377:	6f 6e 00                                            on.

0000037a <cmd_conf_save>:
     37a:	73 61 76 65 00                                      save.

0000037f <cmd_help_conf_mac>:
     37f:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     38f:	41 34 5d 20 5b 41 35 5d 20 5b 41 36 5d 20 73 65     A4] [A5] [A6] se
     39f:	74 20 4d 41 43 20 61 64 64 72 65 73 73 00           t MAC address.

000003ad <cmd_conf_mac>:
     3ad:	6d 61 63 00                                         mac.

000003b1 <cmd_conf_ip_gw_help>:
     3b1:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     3c1:	41 34 5d 20 73 65 74 20 64 65 66 61 75 6c 74 20     A4] set default 
     3d1:	67 61 74 65 77 61 79 00                             gateway.

000003d9 <cmd_conf_ip_gw>:
     3d9:	67 77 00                                            gw.

000003dc <cmd_conf_ip_mask_help>:
     3dc:	5b 6d 61 73 6b 5d 20 73 65 74 20 6d 61 73 6b 00     [mask] set mask.

000003ec <cmd_conf_ip_mask>:
     3ec:	6d 61 73 6b 00                                      mask.

000003f1 <cmd_help_conf_udp>:
     3f1:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     401:	41 34 5d 20 5b 73 72 63 20 70 6f 72 74 5d 20 7b     A4] [src port] {
     411:	64 73 74 20 70 6f 72 74 7d 20 73 65 74 20 75 64     dst port} set ud
     421:	70 20 63 6c 69 65 6e 74 20 49 50 20 61 64 64 72     p client IP addr
     431:	65 73 73 20 61 6e 64 20 70 6f 72 74 73 00           ess and ports.

0000043f <cmd_conf_udp>:
     43f:	75 64 70 00                                         udp.

00000443 <cmd_help_conf_ip>:
     443:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     453:	41 34 5d 20 73 65 74 20 49 50 20 61 64 64 72 65     A4] set IP addre
     463:	73 73 00                                            ss.

00000466 <cmd_conf_ip>:
     466:	69 70 00                                            ip.

00000469 <cmd_help_configure>:
     469:	43 6f 6e 66 69 67 75 72 65 20 6d 6f 64 65 00        Configure mode.

00000478 <cmd_configure>:
     478:	63 6f 6e 66 69 67 00                                config.

0000047f <cmd_help_disable>:
     47f:	56 69 65 77 20 6d 6f 64 65 00                       View mode.

00000489 <cmd_disable>:
     489:	64 69 73 61 62 6c 65 00                             disable.

00000491 <cmd_help_enable>:
     491:	45 6e 61 62 6c 65 20 6d 6f 64 65 00                 Enable mode.

0000049d <cmd_enable>:
     49d:	65 6e 61 62 6c 65 00                                enable.

000004a4 <cmd_help_ac>:
     4a4:	5b 63 68 61 6e 6e 65 6c 20 30 2d 37 5d 20 72 65     [channel 0-7] re
     4b4:	61 64 20 61 6e 61 6c 6f 67 20 76 61 6c 75 65 00     ad analog value.

000004c4 <cmd_ac>:
     4c4:	61 63 00                                            ac.

000004c7 <cmd_help_settime>:
     4c7:	5b 68 5d 20 5b 6d 5d 20 5b 73 5d 20 73 65 74 20     [h] [m] [s] set 
     4d7:	74 69 6d 65 20 28 32 34 68 20 66 6f 72 6d 61 74     time (24h format
     4e7:	29 00                                               ).

000004e9 <cmd_settime>:
     4e9:	73 65 74 74 69 6d 65 00                             settime.

000004f1 <cmd_help_spb>:
     4f1:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     501:	20 42 00                                             B.

00000504 <cmd_spb>:
     504:	73 70 62 00                                         spb.

00000508 <cmd_help_spa>:
     508:	5b 76 61 6c 75 65 5d 20 73 65 74 20 70 6f 72 74     [value] set port
     518:	20 41 00                                             A.

0000051b <cmd_spa>:
     51b:	73 70 61 00                                         spa.

0000051f <cmd_help_down>:
     51f:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     52f:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     53f:	76 65 20 64 6f 77 6e 00                             ve down.

00000547 <cmd_down>:
     547:	64 6f 77 6e 00                                      down.

0000054c <cmd_help_up>:
     54c:	5b 64 72 69 76 65 72 20 6e 6f 5d 20 5b 63 68 61     [driver no] [cha
     55c:	6e 6e 65 6c 5d 20 7b 76 61 6c 75 65 7d 20 6d 6f     nnel] {value} mo
     56c:	76 65 20 75 70 00                                   ve up.

00000572 <cmd_up>:
     572:	75 70 00                                            up.

00000575 <cmd_help_read_rf>:
     575:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 61 64     [file name] read
     585:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     595:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

0000059f <cmd_read_rf>:
     59f:	72 65 61 64 72 66 00                                readrf.

000005a6 <cmd_help_edit_rf>:
     5a6:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 64 69 74     [file name] edit
     5b6:	20 66 69 6c 65 20 6c 6f 63 61 74 65 64 20 6f 6e      file located on
     5c6:	20 72 61 6d 20 64 69 73 6b 00                        ram disk.

000005d0 <cmd_edit_rf>:
     5d0:	65 64 69 74 72 66 00                                editrf.

000005d7 <cmd_help_erase_rf>:
     5d7:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 65 72 61 73     [file name] eras
     5e7:	65 20 66 69 6c 65 20 66 72 6f 6d 20 72 61 6d 20     e file from ram 
     5f7:	64 69 73 6b 00                                      disk.

000005fc <cmd_erase_rf>:
     5fc:	65 72 61 73 65 72 66 00                             eraserf.

00000604 <cmd_help_create_rf>:
     604:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 63 72 65 61     [file name] crea
     614:	74 65 20 72 61 6d 20 66 69 6c 65 00                 te ram file.

00000620 <cmd_create_rf>:
     620:	63 72 66 00                                         crf.

00000624 <cmd_help_dir_rf>:
     624:	50 72 69 6e 74 20 72 61 6d 64 69 73 6b 20 66 69     Print ramdisk fi
     634:	6c 65 73 00                                         les.

00000638 <cmd_dir_rf>:
     638:	64 69 72 72 66 00                                   dirrf.

0000063e <cmd_help_xflash>:
     63e:	5b 64 65 76 69 63 65 20 6e 6f 5d 20 5b 66 69 6c     [device no] [fil
     64e:	65 20 6e 61 6d 65 5d 20 66 6c 61 73 68 20 64 65     e name] flash de
     65e:	76 69 63 65 20 63 6f 6e 6e 65 63 74 65 64 20 74     vice connected t
     66e:	6f 20 52 73 34 38 35 00                             o Rs485.

00000676 <cmd_xflash>:
     676:	78 66 6c 61 73 68 00                                xflash.

0000067d <cmd_help_xSend>:
     67d:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 73 65 6e 64     [file name] send
     68d:	20 66 69 6c 65 20 75 73 69 6e 67 20 78 4d 6f 64      file using xMod
     69d:	65 6d 00                                            em.

000006a0 <cmd_xSend>:
     6a0:	78 73 65 6e 64 00                                   xsend.

000006a6 <cmd_help_xRec>:
     6a6:	5b 66 69 6c 65 20 6e 61 6d 65 5d 20 72 65 63 65     [file name] rece
     6b6:	69 76 65 20 66 69 6c 65 20 75 73 69 6e 67 20 78     ive file using x
     6c6:	4d 6f 64 65 6d 00                                   Modem.

000006cc <cmd_xRec>:
     6cc:	78 72 65 63 00                                      xrec.

000006d1 <cmd_help_ping>:
     6d1:	5b 41 31 5d 20 5b 41 32 5d 20 5b 41 33 5d 20 5b     [A1] [A2] [A3] [
     6e1:	41 34 5d 20 53 65 6e 64 73 20 70 69 6e 67 20 74     A4] Sends ping t
     6f1:	68 72 6f 75 67 68 74 20 65 74 68 65 72 6e 65 74     hrought ethernet
	...

00000702 <cmd_ping>:
     702:	70 69 6e 67 00                                      ping.

00000707 <cmd_help_rping>:
     707:	5b 44 65 76 69 63 65 20 6e 6f 5d 20 53 65 6e 64     [Device no] Send
     717:	20 70 69 6e 67 20 74 6f 20 52 73 34 38 35 20 64      ping to Rs485 d
     727:	65 76 69 63 65 00                                   evice.

0000072d <cmd_rping>:
     72d:	72 70 69 6e 67 00                                   rping.

00000733 <cmd_help_net_dbg>:
     733:	5b 61 72 70 7c 69 63 6d 70 7c 69 70 7c 74 63 70     [arp|icmp|ip|tcp
     743:	7c 75 64 70 5d 20 5b 6c 65 76 65 6c 5d 20 77 72     |udp] [level] wr
     753:	69 74 65 20 64 65 62 75 67 20 69 6e 66 6f 2e 20     ite debug info. 
     763:	4c 65 76 65 6c 20 30 20 64 69 73 61 62 6c 65 20     Level 0 disable 
     773:	64 65 62 75 67 69 6e 67 00                          debuging.

0000077c <cmd_net_dbg>:
     77c:	64 65 62 75 67 00                                   debug.

00000782 <cmd_help_time>:
     782:	50 72 69 6e 74 20 74 69 6d 65 00                    Print time.

0000078d <cmd_time>:
     78d:	74 69 6d 65 00                                      time.

00000792 <cmd_help_enc_stat>:
     792:	50 72 69 6e 74 20 45 6e 63 20 32 38 6a 36 30 20     Print Enc 28j60 
     7a2:	72 65 67 69 73 74 65 72 73 00                       registers.

000007ac <cmd_enc_stat>:
     7ac:	65 6e 63 73 74 61 74 00                             encstat.

000007b4 <cmd_help_status>:
     7b4:	7b 66 69 6c 65 6e 61 6d 65 7d 20 50 72 69 6e 74     {filename} Print
     7c4:	20 64 65 76 69 63 65 20 73 74 61 74 75 73 20 6f      device status o
     7d4:	6e 20 56 54 59 20 6f 72 20 77 72 69 74 65 20 74     n VTY or write t
     7e4:	6f 20 66 69 6c 65 00                                o file.

000007eb <cmd_status>:
     7eb:	73 74 61 74 75 73 00                                status.

000007f2 <cmd_help_help>:
     7f2:	50 72 69 6e 74 20 68 65 6c 70 20 73 74 72 69 6e     Print help strin
     802:	67 00                                               g.

00000804 <cmd_help>:
     804:	68 65 6c 70 00                                      help.

00000809 <debugDisabledInfoStr>:
     809:	44 69 73 61 62 6c 65 64 20 25 73 20 64 65 62 75     Disabled %s debu
     819:	67 0d 0a 00                                         g...

0000081d <debugEnabledInfoStr>:
     81d:	45 6e 61 62 6c 65 64 20 25 73 20 64 65 62 75 67     Enabled %s debug
     82d:	0d 0a 00                                            ...

00000830 <movingCurtainPosStr>:
     830:	09 70 6f 7a 79 63 6a 61 20 20 20 25 64 0d 0a 00     .pozycja   %d...

00000840 <movingCurtainDownStr>:
     840:	4f 70 75 73 7a 63 7a 61 6e 69 65 20 72 6f 6c 65     Opuszczanie role
     850:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     860:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     870:	0d 0a 00                                            ...

00000873 <movingCurtainUpStr>:
     873:	50 6f 64 6e 6f 73 7a 65 6e 69 65 20 72 6f 6c 65     Podnoszenie role
     883:	74 79 0d 0a 09 73 74 65 72 6f 77 6e 69 6b 20 25     ty...sterownik %
     893:	64 0d 0a 09 72 6f 6c 65 74 61 20 20 20 20 25 64     d...roleta    %d
     8a3:	0d 0a 00                                            ...

000008a6 <xwyslijStartStr>:
     8a6:	58 6d 6f 64 65 6d 3a 20 54 72 61 6e 73 6d 69 73     Xmodem: Transmis
     8b6:	73 69 6f 6e 20 73 74 61 72 74 0d 0a 00              sion start...

000008c3 <readRamFIleLenStr>:
     8c3:	46 69 6c 65 20 6c 65 6e 67 74 68 3a 20 25 64 0d     File length: %d.
     8d3:	0a 00                                               ..

000008d5 <editRamFileIntroStr>:
     8d5:	57 72 69 74 69 6e 67 20 74 6f 20 66 69 6c 65 2e     Writing to file.
     8e5:	20 50 72 65 73 73 20 43 54 52 4c 2b 43 20 74 6f      Press CTRL+C to
     8f5:	20 71 75 69 74 0d 0a 00                              quit...

000008fd <statusLockerSensorsDisStr>:
     8fd:	20 20 4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73       Locker sensors
     90d:	20 64 69 73 61 62 6c 65 64 0d 0a 00                  disabled...

00000919 <statusLockerSensorsStr>:
     919:	4c 6f 63 6b 65 72 20 73 65 6e 73 6f 72 73 20 73     Locker sensors s
     929:	74 61 74 65 73 3a 0d 0a 00                          tates:...

00000932 <statusNoRs485Dev>:
     932:	20 20 43 61 6e 27 74 20 66 69 6e 64 20 61 6e 79       Can't find any
     942:	20 64 65 76 69 63 65 0d 0a 00                        device...

0000094c <statusRs485listStr>:
     94c:	44 65 74 65 63 74 65 64 20 52 53 20 34 38 35 20     Detected RS 485 
     95c:	64 65 76 69 63 65 73 3a 0d 0a 00                    devices:...

00000967 <statusIpGwStr>:
     967:	20 20 67 61 74 65 77 61 79 20 20 20 20 20 20 20       gateway       
     977:	20 20 3a 20 00                                        : .

0000097c <statusIpMaskStr>:
     97c:	20 20 6d 61 73 6b 20 20 20 20 20 20 20 20 20 20       mask          
     98c:	20 20 3a 20 00                                        : .

00000991 <statusIpStr>:
     991:	20 20 49 50 20 61 64 64 72 65 73 73 20 20 20 20       IP address    
     9a1:	20 20 3a 20 00                                        : .

000009a6 <statusMacStr>:
     9a6:	20 20 4d 61 63 20 61 64 64 72 65 73 73 20 20 20       Mac address   
     9b6:	20 20 3a 20 00                                        : .

000009bb <systemRamConfigStr>:
     9bb:	53 79 73 74 65 6d 20 73 65 74 74 69 6e 67 73 3a     System settings:
     9cb:	0d 0a 00                                            ...

000009ce <statusVoltageStr>:
     9ce:	20 20 56 6f 6c 74 61 67 65 20 20 20 20 20 20 20       Voltage       
     9de:	20 20 3a 20 25 64 20 56 0d 0a 00                      : %d V...

000009e9 <statusTemperatureStr>:
     9e9:	20 20 54 65 6d 70 65 72 61 74 75 72 65 20 20 20       Temperature   
     9f9:	20 20 3a 20 25 64 20 43 0d 0a 00                      : %d C...

00000a04 <statusRamDiskStateStr>:
     a04:	20 20 52 61 6d 20 64 69 73 63 20 73 70 61 63 65       Ram disc space
     a14:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     a24:	64 20 63 6c 75 73 74 65 72 73 0d 0a 00              d clusters...

00000a31 <statusDynamicHeapStateStr>:
     a31:	20 20 4d 61 6c 6c 6f 63 20 68 65 61 70 20 20 20       Malloc heap   
     a41:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     a51:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000a5b <statusStaticHeapStateStr>:
     a5b:	20 20 46 72 65 65 52 74 6f 73 20 68 65 61 70 20       FreeRtos heap 
     a6b:	20 20 3a 20 25 64 20 66 72 65 65 20 6f 66 20 25       : %d free of %
     a7b:	64 20 62 79 74 65 73 0d 0a 00                       d bytes...

00000a85 <statusNumberOfTasksStr>:
     a85:	20 20 4e 75 6d 62 65 72 20 6f 66 20 74 61 73 6b       Number of task
     a95:	73 20 3a 20 25 64 0d 0a 00                          s : %d...

00000a9e <systemStateStr>:
     a9e:	53 79 73 74 65 6d 20 73 74 61 74 65 3a 0d 0a 00     System state:...

00000aae <errorOpenFile>:
     aae:	43 61 6e 27 74 20 6f 70 65 6e 20 66 69 6c 65 20     Can't open file 
     abe:	25 73 0d 0a 00                                      %s...

00000ac3 <errorBootloaderNotResponding>:
     ac3:	42 6f 6f 74 6c 6f 61 64 65 72 20 69 73 20 6e 6f     Bootloader is no
     ad3:	74 20 72 65 73 70 6f 6e 64 69 6e 67 0d 0a 00        t responding...

00000ae2 <errorNoRemoteDevice>:
     ae2:	44 65 76 69 63 65 20 25 64 20 69 73 20 6e 6f 74     Device %d is not
     af2:	20 72 65 73 70 6f 6e 64 69 6e 67 20 28 25 64 29      responding (%d)
     b02:	0d 0a 00                                            ...

00000b05 <errorxModemUnknownResponse>:
     b05:	78 4d 6f 64 65 6d 20 75 6e 6b 6e 6f 77 6e 20 72     xModem unknown r
     b15:	65 73 70 6f 6e 73 65 20 30 78 25 78 0d 0a 00        esponse 0x%x...

00000b24 <errorxModemRemoteSideCan>:
     b24:	52 65 6d 6f 74 65 20 73 69 64 65 20 63 61 6e 63     Remote side canc
     b34:	65 6c 6c 65 64 20 61 74 20 66 72 61 6d 65 20 6e     elled at frame n
     b44:	6f 20 25 64 0d 0a 00                                o %d...

00000b4b <errorxModemFrameCrc>:
     b4b:	78 4d 6f 64 65 6d 20 43 52 43 20 65 72 72 6f 72     xModem CRC error
     b5b:	0d 0a 00                                            ...

00000b5e <errorxModemFrameFrameNoCorrectionNotMatch>:
     b5e:	0d 0a 00                                            ...

00000b61 <errorxModemWrongFrameNo>:
     b61:	0d 0a 00                                            ...

00000b64 <errorxModemByteSendTimeout>:
     b64:	0d 0a 00                                            ...

00000b67 <errorxModemFrameStartTimeout>:
     b67:	0d 0a 00                                            ...

00000b6a <errorNoFile>:
     b6a:	4e 6f 20 46 69 6c 65 0d 0a 00                       No File...

00000b74 <errorOK>:
     b74:	41 6c 6c 20 4f 4b 0d 0a 00                          All OK...

00000b7d <__c.3427>:
     b7d:	55 6e 6b 6e 6f 77 6e 20 70 61 63 6b 65 74 0d 0a     Unknown packet..
	...

00000b8e <__c.2010>:
     b8e:	52 65 73 74 61 72 74 0d 0a 00                       Restart...

00000b98 <__c.3649>:
     b98:	0d 0a 00                                            ...

00000b9b <__c.3647>:
     b9b:	09 00                                               ..

00000b9d <__c.3559>:
     b9d:	4f 70 65 72 61 74 69 6f 6e 20 6e 6f 74 20 61 6c     Operation not al
     bad:	6c 6f 77 65 64 0d 0a 00                             lowed...

00000bb5 <__c.3556>:
     bb5:	4f 70 65 72 61 74 69 6f 6e 20 66 61 69 6c 65 64     Operation failed
     bc5:	0d 0a 00                                            ...

00000bc8 <__c.3553>:
     bc8:	0d 0a 00                                            ...

00000bcb <__c.3551>:
     bcb:	20 00                                                .

00000bcd <__c.3549>:
     bcd:	53 79 6e 74 61 78 20 45 72 72 6f 72 2e 20 55 73     Syntax Error. Us
     bdd:	65 3a 20 00                                         e: .

00000be1 <__c.3545>:
     be1:	4f 4b 0d 0a 00                                      OK...

00000be6 <CmdlineCmdNotFound>:
     be6:	23 20 6e 6b 00                                      # nk.

00000beb <CmdlineNotice>:
     beb:	63 6d 64 6c 69 6e 65 3a 20 00                       cmdline: .

00000bf5 <CmdlinePromptConfigure>:
     bf5:	44 6f 6d 4f 73 40 00                                DomOs@.

00000bfc <CmdlinePromptEnable>:
     bfc:	44 6f 6d 4f 73 23 00                                DomOs#.

00000c03 <CmdlinePromptNormal>:
     c03:	44 6f 6d 4f 73 3e 00                                DomOs>.

00000c0a <__c.3558>:
     c0a:	09 4d 41 41 44 52 35 20 30 78 25 78 0d 0a 00        .MAADR5 0x%x...

00000c19 <__c.3556>:
     c19:	09 4d 41 41 44 52 34 20 30 78 25 78 0d 0a 00        .MAADR4 0x%x...

00000c28 <__c.3554>:
     c28:	09 4d 41 41 44 52 33 20 30 78 25 78 0d 0a 00        .MAADR3 0x%x...

00000c37 <__c.3552>:
     c37:	09 4d 41 41 44 52 32 20 30 78 25 78 0d 0a 00        .MAADR2 0x%x...

00000c46 <__c.3550>:
     c46:	09 4d 41 41 44 52 31 20 30 78 25 78 0d 0a 00        .MAADR1 0x%x...

00000c55 <__c.3548>:
     c55:	09 4d 41 41 44 52 30 20 30 78 25 78 0d 0a 00        .MAADR0 0x%x...

00000c64 <__c.3546>:
     c64:	45 4e 43 32 38 6a 36 30 20 73 74 61 6e 20 72 65     ENC28j60 stan re
     c74:	6a 65 73 74 72 6f 77 3a 0d 0a 00                    jestrow:...

00000c7f <__c.2141>:
     c7f:	4e 49 43 20 72 65 67 20 64 75 6d 70 20 6e 6f 74     NIC reg dump not
     c8f:	20 69 6d 70 6c 65 6d 65 6e 74 65 64 0d 0a 00         implemented...

00000c9e <__c.2004>:
     c9e:	0d 0a 00                                            ...

00000ca1 <__c.2002>:
     ca1:	55 52 47 20 00                                      URG .

00000ca6 <__c.2000>:
     ca6:	41 43 4b 20 00                                      ACK .

00000cab <__c.1998>:
     cab:	50 53 48 20 00                                      PSH .

00000cb0 <__c.1996>:
     cb0:	52 53 54 20 00                                      RST .

00000cb5 <__c.1994>:
     cb5:	53 59 4e 20 00                                      SYN .

00000cba <__c.1992>:
     cba:	46 49 4e 20 00                                      FIN .

00000cbf <__c.1990>:
     cbf:	46 6c 61 67 73 20 20 20 3a 20 00                    Flags   : .

00000cca <__c.1988>:
     cca:	41 63 6b 20 4e 75 6d 20 3a 20 30 78 25 78 0d 0a     Ack Num : 0x%x..
	...

00000cdb <__c.1986>:
     cdb:	53 65 71 20 4e 75 6d 20 3a 20 30 78 25 78 00        Seq Num : 0x%x.

00000cea <__c.1984>:
     cea:	44 73 74 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Dst Port: %d...

00000cf9 <__c.1982>:
     cf9:	53 72 63 20 50 6f 72 74 3a 20 25 64 0d 0a 00        Src Port: %d...

00000d08 <__c.1980>:
     d08:	54 43 50 20 48 65 61 64 65 72 0d 0a 00              TCP Header...

00000d15 <__c.1974>:
     d15:	0d 0a 00                                            ...

00000d18 <__c.1972>:
     d18:	44 65 73 74 20 20 49 50 3a 20 00                    Dest  IP: .

00000d23 <__c.1970>:
     d23:	0d 0a 00                                            ...

00000d26 <__c.1968>:
     d26:	53 6f 75 72 63 65 49 50 3a 20 00                    SourceIP: .

00000d31 <__c.1966>:
     d31:	50 72 6f 74 6f 63 6f 6c 3a 20 25 64 0d 0a 00        Protocol: %d...

00000d40 <__c.1964>:
     d40:	50 72 6f 74 6f 63 6f 6c 3a 20 55 44 50 0d 0a 00     Protocol: UDP...

00000d50 <__c.1962>:
     d50:	50 72 6f 74 6f 63 6f 6c 3a 20 54 43 50 0d 0a 00     Protocol: TCP...

00000d60 <__c.1960>:
     d60:	50 72 6f 74 6f 63 6f 6c 3a 20 49 43 4d 50 0d 0a     Protocol: ICMP..
	...

00000d71 <__c.1958>:
     d71:	4c 65 6e 67 74 68 20 20 3a 20 25 64 0d 0a 00        Length  : %d...

00000d80 <__c.1956>:
     d80:	56 65 72 20 20 20 20 20 3a 20 25 64 0d 0a 00        Ver     : %d...

00000d8f <__c.1954>:
     d8f:	49 50 20 48 65 61 64 65 72 0d 0a 00                 IP Header...

00000d9b <__c.1948>:
     d9b:	2d 3e 44 53 54 3a 00                                ->DST:.

00000da2 <__c.1946>:
     da2:	20 53 52 43 3a 00                                    SRC:.

00000da8 <__c.1944>:
     da8:	45 74 68 20 50 61 63 6b 65 74 20 54 79 70 65 3a     Eth Packet Type:
     db8:	20 30 78 25 78 00                                    0x%x.

00000dbe <__c.1938>:
     dbe:	25 64 2e 25 64 2e 25 64 2e 25 64 00                 %d.%d.%d.%d.

00000dca <__c.1932>:
     dca:	25 30 32 78 3a 25 30 32 78 3a 25 30 32 78 3a 25     %02x:%02x:%02x:%
     dda:	30 32 78 3a 25 30 32 78 3a 25 30 32 78 00           02x:%02x:%02x.

00000de8 <__c.2542>:
     de8:	0d 0a 00                                            ...

00000deb <__c.2540>:
     deb:	47 61 74 65 77 61 79 20 3a 20 00                    Gateway : .

00000df6 <__c.2538>:
     df6:	0d 0a 00                                            ...

00000df9 <__c.2536>:
     df9:	4e 65 74 6d 61 73 6b 20 3a 20 00                    Netmask : .

00000e04 <__c.2534>:
     e04:	0d 0a 00                                            ...

00000e07 <__c.2532>:
     e07:	49 50 20 41 64 64 72 20 3a 20 00                    IP Addr : .

00000e12 <__c.2526>:
     e12:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     e22:	6c 65 28 6c 65 6e 2d 45 54 48 5f 48 45 41 44 45     le(len-ETH_HEADE
     e32:	52 5f 4c 45 4e 2c 20 26 64 61 74 61 5b 45 54 48     R_LEN, &data[ETH
     e42:	5f 48 45 41 44 45 52 5f 4c 45 4e 5d 29 3b 00        _HEADER_LEN]);.

00000e51 <__c.2524>:
     e51:	64 65 62 75 67 50 72 69 6e 74 48 65 78 54 61 62     debugPrintHexTab
     e61:	6c 65 28 45 54 48 5f 48 45 41 44 45 52 5f 4c 45     le(ETH_HEADER_LE
     e71:	4e 2c 20 26 64 61 74 61 5b 30 5d 29 3b 00           N, &data[0]);.

00000e7f <__c.2522>:
     e7f:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     e8f:	74 20 74 6f 20 67 61 74 65 77 61 79 0d 0a 00        t to gateway...

00000e9e <__c.2520>:
     e9e:	53 65 6e 64 69 6e 67 20 49 50 20 70 61 63 6b 65     Sending IP packe
     eae:	74 20 6f 6e 20 6c 6f 63 61 6c 20 6e 65 74 0d 0a     t on local net..
	...

00000ebf <__c.2492>:
     ebf:	4e 45 54 20 52 78 3a 20 55 6e 6b 6e 6f 77 6e 20     NET Rx: Unknown 
     ecf:	49 50 20 70 61 63 6b 65 74 0d 0a 00                 IP packet...

00000edb <__c.2490>:
     edb:	4e 45 54 20 52 78 3a 20 55 44 50 2f 49 50 20 70     NET Rx: UDP/IP p
     eeb:	61 63 6b 65 74 0d 0a 00                             acket...

00000ef3 <__c.2488>:
     ef3:	4e 45 54 20 52 78 3a 20 49 43 4d 50 2f 49 50 20     NET Rx: ICMP/IP 
     f03:	70 61 63 6b 65 74 0d 0a 00                          packet...

00000f0c <__c.2514>:
     f0c:	43 6f 64 65 20 20 20 3a 20 30 78 25 78 0d 0a 00     Code   : 0x%x...

00000f1c <__c.2512>:
     f1c:	54 79 70 65 3a 20 30 78 25 78 20 20 20 20 00        Type: 0x%x    .

00000f2b <__c.2510>:
     f2b:	0d 0a 00                                            ...

00000f2e <__c.2508>:
     f2e:	44 73 74 49 70 41 64 64 72 3a 20 00                 DstIpAddr: .

00000f3a <__c.2506>:
     f3a:	0d 0a 00                                            ...

00000f3d <__c.2504>:
     f3d:	53 72 63 49 70 41 64 64 72 3a 20 00                 SrcIpAddr: .

00000f49 <__c.2502>:
     f49:	49 43 4d 50 20 50 61 63 6b 65 74 3a 0d 0a 00        ICMP Packet:...

00000f58 <__c.2491>:
     f58:	53 65 6e 64 69 6e 67 20 49 43 4d 50 20 50 4f 4e     Sending ICMP PON
     f68:	47 0d 0a 00                                         G...

00000f6c <__c.2488>:
     f6c:	52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72 65     Received ICMP re
     f7c:	71 75 65 73 74 3a 20 00                             quest: .

00000f84 <__c.2483>:
     f84:	55 6e 6b 6e 6f 77 6e 20 49 43 4d 50 20 74 79 70     Unknown ICMP typ
     f94:	65 52 65 63 65 69 76 65 64 20 49 43 4d 50 20 72     eReceived ICMP r
     fa4:	65 71 75 65 73 74 3a 20 00                          equest: .

00000fad <__c.2574>:
     fad:	0d 0a 00                                            ...

00000fb0 <__c.2572>:
     fb0:	20 20 00                                              .

00000fb3 <__c.2570>:
     fb3:	25 33 64 20 20 00                                   %3d  .

00000fb9 <__c.2567>:
     fb9:	0d 0a 00                                            ...

00000fbc <__c.2565>:
     fbc:	20 20 00                                              .

00000fbf <__c.2563>:
     fbf:	20 4d 59 20 20 00                                    MY  .

00000fc5 <__c.2561>:
     fc5:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fd5:	2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d     ----------------
     fe5:	2d 2d 2d 0d 0a 00                                   ---...

00000feb <__c.2559>:
     feb:	54 69 6d 65 20 45 74 68 20 41 64 64 72 65 73 73     Time Eth Address
     ffb:	20 20 20 20 20 20 20 20 49 50 20 41 64 64 72 65             IP Addre
    100b:	73 73 0d 0a 00                                      ss...

00001010 <__c.2553>:
    1010:	0d 0a 00                                            ...

00001013 <__c.2551>:
    1013:	44 73 74 50 72 6f 74 6f 41 64 64 72 3a 20 00        DstProtoAddr: .

00001022 <__c.2549>:
    1022:	0d 0a 00                                            ...

00001025 <__c.2547>:
    1025:	44 73 74 48 77 41 64 64 72 20 20 20 3a 20 00        DstHwAddr   : .

00001034 <__c.2545>:
    1034:	0d 0a 00                                            ...

00001037 <__c.2543>:
    1037:	53 72 63 50 72 6f 74 6f 41 64 64 72 3a 20 00        SrcProtoAddr: .

00001046 <__c.2541>:
    1046:	0d 0a 00                                            ...

00001049 <__c.2539>:
    1049:	53 72 63 48 77 41 64 64 72 20 20 20 3a 20 00        SrcHwAddr   : .

00001058 <__c.2537>:
    1058:	0d 0a 00                                            ...

0000105b <__c.2535>:
    105b:	55 4e 4b 4e 4f 57 4e 00                             UNKNOWN.

00001063 <__c.2533>:
    1063:	52 45 50 4c 59 00                                   REPLY.

00001069 <__c.2531>:
    1069:	52 45 51 55 45 53 54 00                             REQUEST.

00001071 <__c.2529>:
    1071:	4f 70 65 72 61 74 69 6f 6e 20 20 20 3a 20 00        Operation   : .

00001080 <__c.2527>:
    1080:	41 52 50 20 50 61 63 6b 65 74 3a 0d 0a 00           ARP Packet:...

0000108e <__c.2499>:
    108e:	0d 0a 00                                            ...

00001091 <__c.2497>:
    1091:	20 49 50 3a 20 00                                    IP: .

00001097 <__c.2495>:
    1097:	41 52 50 20 49 50 20 69 6e 20 4d 41 43 3a 20 00     ARP IP in MAC: .

000010a7 <__c.2490>:
    10a7:	53 65 6e 64 69 6e 67 20 41 52 50 20 52 65 70 6c     Sending ARP Repl
    10b7:	79 0d 0a 00                                         y...

000010bb <__c.2488>:
    10bb:	52 65 63 65 69 76 65 64 20 41 52 50 20 52 65 71     Received ARP Req
    10cb:	75 65 73 74 0d 0a 00                                uest...

000010d2 <__c.2723>:
    10d2:	48 54 54 50 20 6e 6f 74 20 69 6d 70 6c 65 6d 65     HTTP not impleme
    10e2:	6e 74 65 64 0d 0a 00                                nted...

000010e9 <__c.2692>:
    10e9:	43 61 6e 27 74 20 66 69 6e 64 20 54 43 50 20 73     Can't find TCP s
    10f9:	6f 63 6b 65 74 20 77 69 74 68 20 6c 6f 63 61 6c     ocket with local
    1109:	50 6f 72 74 20 25 64 0d 0a 00                       Port %d...

00001113 <__c.2687>:
    1113:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1123:	20 6e 6f 20 25 64 20 73 74 61 74 65 20 4c 49 53      no %d state LIS
    1133:	54 45 4e 0d 0a 00                                   TEN...

00001139 <__c.2682>:
    1139:	46 6f 75 6e 64 20 54 43 50 20 73 6f 63 6b 65 74     Found TCP socket
    1149:	20 73 74 61 74 65 20 25 64 0d 0a 00                  state %d...

00001155 <__c.2707>:
    1155:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1165:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 61 63     ection ERROR: ac
    1175:	6b 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     k flag wasn't se
    1185:	74 0d 0a 00                                         t...

00001189 <__c.2705>:
    1189:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1199:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    11a9:	61 74 65 20 63 68 61 6e 67 65 20 53 59 4e 5f 52     ate change SYN_R
    11b9:	45 43 45 49 56 45 44 2d 3e 45 53 54 41 42 49 4c     ECEIVED->ESTABIL
    11c9:	49 53 48 45 44 0d 0a 00                             ISHED...

000011d1 <__c.2703>:
    11d1:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    11e1:	65 63 74 69 6f 6e 20 45 52 52 4f 52 3a 20 73 79     ection ERROR: sy
    11f1:	6e 20 66 6c 61 67 20 77 61 73 6e 27 74 20 73 65     n flag wasn't se
    1201:	74 0d 0a 00                                         t...

00001205 <__c.2701>:
    1205:	4f 70 65 6e 69 6e 67 20 54 43 50 20 63 6f 6e 6e     Opening TCP conn
    1215:	65 63 74 69 6f 6e 20 73 6f 63 6b 65 74 20 73 74     ection socket st
    1225:	61 74 65 20 63 68 61 6e 67 65 20 4c 49 53 54 45     ate change LISTE
    1235:	4e 2d 3e 53 59 4e 5f 52 45 43 45 49 56 45 44 0d     N->SYN_RECEIVED.
    1245:	0a 00                                               ..

00001247 <__c.2535>:
    1247:	25 64 0d 0a 00                                      %d...

0000124c <__c.2533>:
    124c:	41 4e 59 0d 0a 00                                   ANY...

00001252 <__c.2531>:
    1252:	0d 0a 20 20 73 72 63 20 70 6f 72 74 20 20 20 20     ..  src port    
    1262:	3a 20 25 64 0d 0a 20 20 64 73 74 20 70 6f 72 74     : %d..  dst port
    1272:	20 20 20 20 3a 20 00                                    : .

00001279 <__c.2529>:
    1279:	0d 0a 20 20 49 50 20 20 20 20 20 20 20 20 20 20     ..  IP          
    1289:	3a 20 00                                            : .

0000128c <__c.2527>:
    128c:	55 44 50 20 63 6f 6e 66 69 67 3a 00                 UDP config:.

00001298 <__c.2511>:
    1298:	52 65 63 65 69 76 65 64 20 55 44 50 20 70 61 63     Received UDP pac
    12a8:	6b 65 74 20 28 6c 65 6e 20 25 64 29 0d 0a 00        ket (len %d)...

000012b7 <__c.2509>:
    12b7:	0d 0a 00                                            ...

000012ba <__c.2504>:
    12ba:	55 44 50 20 54 58 20 62 75 66 66 65 72 20 62 75     UDP TX buffer bu
    12ca:	73 79 0d 0a 00                                      sy...

000012cf <__c.2502>:
    12cf:	20 30 78 25 32 78 00                                 0x%2x.

000012d6 <__c.2500>:
    12d6:	52 65 63 65 69 76 65 64 20 55 44 50 20 64 61 74     Received UDP dat
    12e6:	61 3a 00                                            a:.

000012e9 <__c.2497>:
    12e9:	53 6b 69 70 70 69 6e 67 2c 20 77 72 6f 6e 67 20     Skipping, wrong 
    12f9:	70 6f 72 74 73 20 25 64 20 25 64 0d 0a 00           ports %d %d...

00001307 <__c.2495>:
    1307:	50 72 6f 63 2e 20 55 44 50 20 70 61 63 6b 65 74     Proc. UDP packet
    1317:	20 28 64 61 74 61 20 6c 65 6e 67 74 68 20 25 64      (data length %d
    1327:	29 00                                               ).

00001329 <__c.2488>:
    1329:	55 44 50 20 74 78 20 25 64 20 62 79 74 65 73 0d     UDP tx %d bytes.
    1339:	0a 00                                               ..

0000133b <__c.2486>:
    133b:	53 65 6e 64 69 6e 67 20 55 44 50 20 70 61 63 6b     Sending UDP pack
    134b:	65 74 20 28 64 61 74 61 20 6c 65 6e 67 74 68 20     et (data length 
    135b:	25 64 29 0d 0a 00                                   %d)...

00001361 <__c.3530>:
    1361:	62 6f 6f 74 6c 6f 61 64 65 72 20 6e 69 65 20 72     bootloader nie r
    1371:	6f 7a 70 6f 63 7a 61 6c 20 6f 64 62 69 6f 72 75     ozpoczal odbioru
    1381:	20 64 61 6e 79 63 68 0d 0a 00                        danych...

0000138b <__c.3528>:
    138b:	6e 61 20 75 72 7a 61 64 7a 65 6e 69 75 20 77 67     na urzadzeniu wg
    139b:	72 61 6e 79 20 6a 65 73 74 20 74 79 6c 6b 6f 20     rany jest tylko 
    13ab:	62 6f 6f 74 6c 6f 61 64 65 72 0d 0a 00              bootloader...

000013b8 <__c.3526>:
    13b8:	72 46 4c 41 53 48 20 74 69 6d 65 6f 75 74 0d 0a     rFLASH timeout..
	...

000013c9 <statusRollerDescStr2>:
    13c9:	2c 20 66 69 72 6d 77 61 72 65 20 25 73 0d 0a 00     , firmware %s...

000013d9 <statusRollerDescStrConf>:
    13d9:	20 63 6f 6e 66 69 67 20 25 78 00                     config %x.

000013e4 <statusRollerDescStr>:
    13e4:	20 25 64 20 72 6f 6c 6c 65 72 20 64 72 69 76 65      %d roller drive
    13f4:	72 3a 20 72 6f 6c 6c 65 72 20 31 20 70 6f 73 69     r: roller 1 posi
    1404:	74 69 6f 6e 20 25 64 2c 20 72 6f 6c 6c 65 72 20     tion %d, roller 
    1414:	32 20 70 6f 73 69 74 69 6f 6e 20 25 64 00           2 position %d.

00001422 <__ctors_end>:
    1422:	11 24       	eor	r1, r1
    1424:	1f be       	out	0x3f, r1	; 63
    1426:	cf ef       	ldi	r28, 0xFF	; 255
    1428:	d0 e1       	ldi	r29, 0x10	; 16
    142a:	de bf       	out	0x3e, r29	; 62
    142c:	cd bf       	out	0x3d, r28	; 61

0000142e <initExternalMem>:
xTaskHandle xHandleEnc;
xTaskHandle xHandleSensors;

void initExternalMem(void)
{
  MCUCR |= _BV(SRE);          //Włączenie pamięci zewnętrznej
    142e:	85 b7       	in	r24, 0x35	; 53
    1430:	80 68       	ori	r24, 0x80	; 128
    1432:	85 bf       	out	0x35, r24	; 53
  MCUCR |= 0x0E;
    1434:	85 b7       	in	r24, 0x35	; 53
    1436:	8e 60       	ori	r24, 0x0E	; 14
    1438:	85 bf       	out	0x35, r24	; 53
#define testZewPamiec 1
#if testZewPamiec == 1
#define SND(DTA) UDR1=DTA; \
  while( ! (UCSR1A & (1<<UDRE))); \

  UBRR1L = 7;
    143a:	87 e0       	ldi	r24, 0x07	; 7
    143c:	80 93 99 00 	sts	0x0099, r24
  UBRR1H = 0;
    1440:	10 92 98 00 	sts	0x0098, r1
  UCSR1B = 1<<TXEN1;
    1444:	88 e0       	ldi	r24, 0x08	; 8
    1446:	80 93 9a 00 	sts	0x009A, r24

  SND('\r') SND('\n') SND('M') SND('e') SND('m') SND('o') SND('r') SND('y') SND('t') SND('e') SND('s') SND('t') SND('\r') SND('\n')
    144a:	8d e0       	ldi	r24, 0x0D	; 13
    144c:	80 93 9c 00 	sts	0x009C, r24
    1450:	80 91 9b 00 	lds	r24, 0x009B
    1454:	85 ff       	sbrs	r24, 5
    1456:	fc cf       	rjmp	.-8      	; 0x1450 <initExternalMem+0x22>
    1458:	8a e0       	ldi	r24, 0x0A	; 10
    145a:	80 93 9c 00 	sts	0x009C, r24
    145e:	80 91 9b 00 	lds	r24, 0x009B
    1462:	85 ff       	sbrs	r24, 5
    1464:	fc cf       	rjmp	.-8      	; 0x145e <initExternalMem+0x30>
    1466:	8d e4       	ldi	r24, 0x4D	; 77
    1468:	80 93 9c 00 	sts	0x009C, r24
    146c:	80 91 9b 00 	lds	r24, 0x009B
    1470:	85 ff       	sbrs	r24, 5
    1472:	fc cf       	rjmp	.-8      	; 0x146c <initExternalMem+0x3e>
    1474:	85 e6       	ldi	r24, 0x65	; 101
    1476:	80 93 9c 00 	sts	0x009C, r24
    147a:	80 91 9b 00 	lds	r24, 0x009B
    147e:	85 ff       	sbrs	r24, 5
    1480:	fc cf       	rjmp	.-8      	; 0x147a <initExternalMem+0x4c>
    1482:	8d e6       	ldi	r24, 0x6D	; 109
    1484:	80 93 9c 00 	sts	0x009C, r24
    1488:	80 91 9b 00 	lds	r24, 0x009B
    148c:	85 ff       	sbrs	r24, 5
    148e:	fc cf       	rjmp	.-8      	; 0x1488 <initExternalMem+0x5a>
    1490:	8f e6       	ldi	r24, 0x6F	; 111
    1492:	80 93 9c 00 	sts	0x009C, r24
    1496:	80 91 9b 00 	lds	r24, 0x009B
    149a:	85 ff       	sbrs	r24, 5
    149c:	fc cf       	rjmp	.-8      	; 0x1496 <initExternalMem+0x68>
    149e:	82 e7       	ldi	r24, 0x72	; 114
    14a0:	80 93 9c 00 	sts	0x009C, r24
    14a4:	80 91 9b 00 	lds	r24, 0x009B
    14a8:	85 ff       	sbrs	r24, 5
    14aa:	fc cf       	rjmp	.-8      	; 0x14a4 <initExternalMem+0x76>
    14ac:	89 e7       	ldi	r24, 0x79	; 121
    14ae:	80 93 9c 00 	sts	0x009C, r24
    14b2:	80 91 9b 00 	lds	r24, 0x009B
    14b6:	85 ff       	sbrs	r24, 5
    14b8:	fc cf       	rjmp	.-8      	; 0x14b2 <initExternalMem+0x84>
    14ba:	84 e7       	ldi	r24, 0x74	; 116
    14bc:	80 93 9c 00 	sts	0x009C, r24
    14c0:	80 91 9b 00 	lds	r24, 0x009B
    14c4:	85 ff       	sbrs	r24, 5
    14c6:	fc cf       	rjmp	.-8      	; 0x14c0 <initExternalMem+0x92>
    14c8:	85 e6       	ldi	r24, 0x65	; 101
    14ca:	80 93 9c 00 	sts	0x009C, r24
    14ce:	80 91 9b 00 	lds	r24, 0x009B
    14d2:	85 ff       	sbrs	r24, 5
    14d4:	fc cf       	rjmp	.-8      	; 0x14ce <initExternalMem+0xa0>
    14d6:	83 e7       	ldi	r24, 0x73	; 115
    14d8:	80 93 9c 00 	sts	0x009C, r24
    14dc:	80 91 9b 00 	lds	r24, 0x009B
    14e0:	85 ff       	sbrs	r24, 5
    14e2:	fc cf       	rjmp	.-8      	; 0x14dc <initExternalMem+0xae>
    14e4:	84 e7       	ldi	r24, 0x74	; 116
    14e6:	80 93 9c 00 	sts	0x009C, r24
    14ea:	80 91 9b 00 	lds	r24, 0x009B
    14ee:	85 ff       	sbrs	r24, 5
    14f0:	fc cf       	rjmp	.-8      	; 0x14ea <initExternalMem+0xbc>
    14f2:	8d e0       	ldi	r24, 0x0D	; 13
    14f4:	80 93 9c 00 	sts	0x009C, r24
    14f8:	80 91 9b 00 	lds	r24, 0x009B
    14fc:	85 ff       	sbrs	r24, 5
    14fe:	fc cf       	rjmp	.-8      	; 0x14f8 <initExternalMem+0xca>
    1500:	8a e0       	ldi	r24, 0x0A	; 10
    1502:	80 93 9c 00 	sts	0x009C, r24
    1506:	80 91 9b 00 	lds	r24, 0x009B
    150a:	85 ff       	sbrs	r24, 5
    150c:	fc cf       	rjmp	.-8      	; 0x1506 <initExternalMem+0xd8>
    150e:	81 e1       	ldi	r24, 0x11	; 17
    1510:	90 e0       	ldi	r25, 0x00	; 0
    uint8_t znLo = (hiAddr & 0x0F);

    znHi = (znHi < 10) ? znHi + '0' : znHi + 'A' - 10;
    znLo = (znLo < 10) ? znLo + '0' : znLo + 'A' - 10;

    SND('\r') SND('0') SND('x') SND(znHi) SND(znLo) SND('*') SND('*') SND(' ')
    1512:	6d e0       	ldi	r22, 0x0D	; 13
    1514:	70 e3       	ldi	r23, 0x30	; 48
    1516:	c8 e7       	ldi	r28, 0x78	; 120
    1518:	4a e2       	ldi	r20, 0x2A	; 42
    151a:	d0 e2       	ldi	r29, 0x20	; 32
    for (addr = startAddr; addr <= stopAddr; addr++)
        if (*((uint8_t *) addr) != (uint8_t)((addr>>1) & 0xFF))
            isOK = 0;

    if (isOK == 1) { SND ('O') SND ('K') SND('\n') }
    else           { SND ('F') SND ('A') SND ('I') SND('L') SND('\n') }
    151c:	16 e4       	ldi	r17, 0x46	; 70
    151e:	01 e4       	ldi	r16, 0x41	; 65
    1520:	39 e4       	ldi	r19, 0x49	; 73
    1522:	d3 2e       	mov	r13, r19
    1524:	5c e4       	ldi	r21, 0x4C	; 76
    1526:	c5 2e       	mov	r12, r21
    1528:	5a e0       	ldi	r21, 0x0A	; 10
    uint8_t isOK=1;
    for (addr = startAddr; addr <= stopAddr; addr++)
        if (*((uint8_t *) addr) != (uint8_t)((addr>>1) & 0xFF))
            isOK = 0;

    if (isOK == 1) { SND ('O') SND ('K') SND('\n') }
    152a:	ef e4       	ldi	r30, 0x4F	; 79
    152c:	be 2e       	mov	r11, r30
    152e:	fb e4       	ldi	r31, 0x4B	; 75
    1530:	af 2e       	mov	r10, r31
  SND('\r') SND('\n') SND('M') SND('e') SND('m') SND('o') SND('r') SND('y') SND('t') SND('e') SND('s') SND('t') SND('\r') SND('\n')

  uint8_t hiAddr;
  for (hiAddr = 0x11; hiAddr < 0xFF; hiAddr++)
  {
    uint8_t znHi = (hiAddr>>4 & 0x0F);
    1532:	38 2f       	mov	r19, r24
    1534:	32 95       	swap	r19
    1536:	3f 70       	andi	r19, 0x0F	; 15
    uint8_t znLo = (hiAddr & 0x0F);
    1538:	28 2f       	mov	r18, r24
    153a:	2f 70       	andi	r18, 0x0F	; 15

    znHi = (znHi < 10) ? znHi + '0' : znHi + 'A' - 10;
    153c:	3a 30       	cpi	r19, 0x0A	; 10
    153e:	10 f4       	brcc	.+4      	; 0x1544 <initExternalMem+0x116>
    1540:	30 5d       	subi	r19, 0xD0	; 208
    1542:	01 c0       	rjmp	.+2      	; 0x1546 <initExternalMem+0x118>
    1544:	39 5c       	subi	r19, 0xC9	; 201
    znLo = (znLo < 10) ? znLo + '0' : znLo + 'A' - 10;
    1546:	2a 30       	cpi	r18, 0x0A	; 10
    1548:	10 f4       	brcc	.+4      	; 0x154e <initExternalMem+0x120>
    154a:	20 5d       	subi	r18, 0xD0	; 208
    154c:	01 c0       	rjmp	.+2      	; 0x1550 <initExternalMem+0x122>
    154e:	29 5c       	subi	r18, 0xC9	; 201

    SND('\r') SND('0') SND('x') SND(znHi) SND(znLo) SND('*') SND('*') SND(' ')
    1550:	60 93 9c 00 	sts	0x009C, r22
    1554:	e0 91 9b 00 	lds	r30, 0x009B
    1558:	e5 ff       	sbrs	r30, 5
    155a:	fc cf       	rjmp	.-8      	; 0x1554 <initExternalMem+0x126>
    155c:	70 93 9c 00 	sts	0x009C, r23
    1560:	e0 91 9b 00 	lds	r30, 0x009B
    1564:	e5 ff       	sbrs	r30, 5
    1566:	fc cf       	rjmp	.-8      	; 0x1560 <initExternalMem+0x132>
    1568:	c0 93 9c 00 	sts	0x009C, r28
    156c:	e0 91 9b 00 	lds	r30, 0x009B
    1570:	e5 ff       	sbrs	r30, 5
    1572:	fc cf       	rjmp	.-8      	; 0x156c <initExternalMem+0x13e>
    1574:	30 93 9c 00 	sts	0x009C, r19
    1578:	30 91 9b 00 	lds	r19, 0x009B
    157c:	35 ff       	sbrs	r19, 5
    157e:	fc cf       	rjmp	.-8      	; 0x1578 <initExternalMem+0x14a>
    1580:	20 93 9c 00 	sts	0x009C, r18
    1584:	20 91 9b 00 	lds	r18, 0x009B
    1588:	25 ff       	sbrs	r18, 5
    158a:	fc cf       	rjmp	.-8      	; 0x1584 <initExternalMem+0x156>
    158c:	40 93 9c 00 	sts	0x009C, r20
    1590:	20 91 9b 00 	lds	r18, 0x009B
    1594:	25 ff       	sbrs	r18, 5
    1596:	fc cf       	rjmp	.-8      	; 0x1590 <initExternalMem+0x162>
    1598:	40 93 9c 00 	sts	0x009C, r20
    159c:	20 91 9b 00 	lds	r18, 0x009B
    15a0:	25 ff       	sbrs	r18, 5
    15a2:	fc cf       	rjmp	.-8      	; 0x159c <initExternalMem+0x16e>
    15a4:	d0 93 9c 00 	sts	0x009C, r29
    15a8:	20 91 9b 00 	lds	r18, 0x009B
    15ac:	25 ff       	sbrs	r18, 5
    15ae:	fc cf       	rjmp	.-8      	; 0x15a8 <initExternalMem+0x17a>

    uint16_t addr;
    uint16_t startAddr = hiAddr<<8;
    15b0:	f8 2f       	mov	r31, r24
    15b2:	ee 27       	eor	r30, r30
    uint16_t stopAddr = startAddr + 0xFF;
    15b4:	9f 01       	movw	r18, r30
    15b6:	21 50       	subi	r18, 0x01	; 1
    15b8:	3f 4f       	sbci	r19, 0xFF	; 255

    for (addr = startAddr; addr <= stopAddr; addr++)
    15ba:	df 01       	movw	r26, r30
    15bc:	04 c0       	rjmp	.+8      	; 0x15c6 <initExternalMem+0x198>
        *((uint8_t *) addr) = (uint8_t)((addr>>1) & 0xFF);
    15be:	7d 01       	movw	r14, r26
    15c0:	f6 94       	lsr	r15
    15c2:	e7 94       	ror	r14
    15c4:	ed 92       	st	X+, r14

    uint16_t addr;
    uint16_t startAddr = hiAddr<<8;
    uint16_t stopAddr = startAddr + 0xFF;

    for (addr = startAddr; addr <= stopAddr; addr++)
    15c6:	2a 17       	cp	r18, r26
    15c8:	3b 07       	cpc	r19, r27
    15ca:	c8 f7       	brcc	.-14     	; 0x15be <initExternalMem+0x190>
    15cc:	99 24       	eor	r9, r9
    15ce:	93 94       	inc	r9
    15d0:	09 c0       	rjmp	.+18     	; 0x15e4 <initExternalMem+0x1b6>
    15d2:	df 01       	movw	r26, r30
    15d4:	11 96       	adiw	r26, 0x01	; 1
        *((uint8_t *) addr) = (uint8_t)((addr>>1) & 0xFF);

    uint8_t isOK=1;
    for (addr = startAddr; addr <= stopAddr; addr++)
        if (*((uint8_t *) addr) != (uint8_t)((addr>>1) & 0xFF))
    15d6:	7f 01       	movw	r14, r30
    15d8:	f6 94       	lsr	r15
    15da:	e7 94       	ror	r14
    15dc:	e0 81       	ld	r30, Z
    15de:	ee 11       	cpse	r30, r14
            isOK = 0;
    15e0:	91 2c       	mov	r9, r1
    15e2:	fd 01       	movw	r30, r26

    for (addr = startAddr; addr <= stopAddr; addr++)
        *((uint8_t *) addr) = (uint8_t)((addr>>1) & 0xFF);

    uint8_t isOK=1;
    for (addr = startAddr; addr <= stopAddr; addr++)
    15e4:	2e 17       	cp	r18, r30
    15e6:	3f 07       	cpc	r19, r31
    15e8:	a0 f7       	brcc	.-24     	; 0x15d2 <initExternalMem+0x1a4>
        if (*((uint8_t *) addr) != (uint8_t)((addr>>1) & 0xFF))
            isOK = 0;

    if (isOK == 1) { SND ('O') SND ('K') SND('\n') }
    15ea:	21 e0       	ldi	r18, 0x01	; 1
    15ec:	92 12       	cpse	r9, r18
    15ee:	18 c0       	rjmp	.+48     	; 0x1620 <initExternalMem+0x1f2>
    15f0:	b0 92 9c 00 	sts	0x009C, r11
    15f4:	20 91 9b 00 	lds	r18, 0x009B
    15f8:	25 ff       	sbrs	r18, 5
    15fa:	fc cf       	rjmp	.-8      	; 0x15f4 <initExternalMem+0x1c6>
    15fc:	a0 92 9c 00 	sts	0x009C, r10
    1600:	20 91 9b 00 	lds	r18, 0x009B
    1604:	25 ff       	sbrs	r18, 5
    1606:	fc cf       	rjmp	.-8      	; 0x1600 <initExternalMem+0x1d2>
    1608:	50 93 9c 00 	sts	0x009C, r21
    160c:	20 91 9b 00 	lds	r18, 0x009B
    1610:	25 ff       	sbrs	r18, 5
    1612:	fc cf       	rjmp	.-8      	; 0x160c <initExternalMem+0x1de>
    1614:	01 96       	adiw	r24, 0x01	; 1
  UCSR1B = 1<<TXEN1;

  SND('\r') SND('\n') SND('M') SND('e') SND('m') SND('o') SND('r') SND('y') SND('t') SND('e') SND('s') SND('t') SND('\r') SND('\n')

  uint8_t hiAddr;
  for (hiAddr = 0x11; hiAddr < 0xFF; hiAddr++)
    1616:	8f 3f       	cpi	r24, 0xFF	; 255
    1618:	91 05       	cpc	r25, r1
    161a:	09 f0       	breq	.+2      	; 0x161e <initExternalMem+0x1f0>
    161c:	8a cf       	rjmp	.-236    	; 0x1532 <initExternalMem+0x104>
    161e:	1f c0       	rjmp	.+62     	; 0x165e <initExternalMem+0x230>
    for (addr = startAddr; addr <= stopAddr; addr++)
        if (*((uint8_t *) addr) != (uint8_t)((addr>>1) & 0xFF))
            isOK = 0;

    if (isOK == 1) { SND ('O') SND ('K') SND('\n') }
    else           { SND ('F') SND ('A') SND ('I') SND('L') SND('\n') }
    1620:	10 93 9c 00 	sts	0x009C, r17
    1624:	20 91 9b 00 	lds	r18, 0x009B
    1628:	25 ff       	sbrs	r18, 5
    162a:	fc cf       	rjmp	.-8      	; 0x1624 <initExternalMem+0x1f6>
    162c:	00 93 9c 00 	sts	0x009C, r16
    1630:	20 91 9b 00 	lds	r18, 0x009B
    1634:	25 ff       	sbrs	r18, 5
    1636:	fc cf       	rjmp	.-8      	; 0x1630 <initExternalMem+0x202>
    1638:	d0 92 9c 00 	sts	0x009C, r13
    163c:	20 91 9b 00 	lds	r18, 0x009B
    1640:	25 ff       	sbrs	r18, 5
    1642:	fc cf       	rjmp	.-8      	; 0x163c <initExternalMem+0x20e>
    1644:	c0 92 9c 00 	sts	0x009C, r12
    1648:	20 91 9b 00 	lds	r18, 0x009B
    164c:	25 ff       	sbrs	r18, 5
    164e:	fc cf       	rjmp	.-8      	; 0x1648 <initExternalMem+0x21a>
    1650:	50 93 9c 00 	sts	0x009C, r21
    1654:	20 91 9b 00 	lds	r18, 0x009B
    1658:	25 ff       	sbrs	r18, 5
    165a:	fc cf       	rjmp	.-8      	; 0x1654 <initExternalMem+0x226>
    165c:	db cf       	rjmp	.-74     	; 0x1614 <initExternalMem+0x1e6>
  }
  SND ('\r') SND ('\n')
    165e:	8d e0       	ldi	r24, 0x0D	; 13
    1660:	80 93 9c 00 	sts	0x009C, r24
    1664:	80 91 9b 00 	lds	r24, 0x009B
    1668:	85 ff       	sbrs	r24, 5
    166a:	fc cf       	rjmp	.-8      	; 0x1664 <initExternalMem+0x236>
    166c:	8a e0       	ldi	r24, 0x0A	; 10
    166e:	80 93 9c 00 	sts	0x009C, r24
    1672:	80 91 9b 00 	lds	r24, 0x009B
    1676:	85 ff       	sbrs	r24, 5
    1678:	fc cf       	rjmp	.-8      	; 0x1672 <initExternalMem+0x244>

0000167a <__do_copy_data>:
#undef SND
#endif
}
    167a:	11 e0       	ldi	r17, 0x01	; 1
    167c:	a0 e0       	ldi	r26, 0x00	; 0
    167e:	b1 e0       	ldi	r27, 0x01	; 1
    1680:	e4 eb       	ldi	r30, 0xB4	; 180
    1682:	f7 ea       	ldi	r31, 0xA7	; 167
    1684:	00 e0       	ldi	r16, 0x00	; 0
    1686:	0b bf       	out	0x3b, r16	; 59
    1688:	02 c0       	rjmp	.+4      	; 0x168e <__do_copy_data+0x14>
    168a:	07 90       	elpm	r0, Z+
    168c:	0d 92       	st	X+, r0
    168e:	a8 38       	cpi	r26, 0x88	; 136
    1690:	b1 07       	cpc	r27, r17
    1692:	d9 f7       	brne	.-10     	; 0x168a <__do_copy_data+0x10>

00001694 <__do_clear_bss>:
    1694:	2f e0       	ldi	r18, 0x0F	; 15
    1696:	a8 e8       	ldi	r26, 0x88	; 136
    1698:	b1 e0       	ldi	r27, 0x01	; 1
    169a:	01 c0       	rjmp	.+2      	; 0x169e <.do_clear_bss_start>

0000169c <.do_clear_bss_loop>:
    169c:	1d 92       	st	X+, r1

0000169e <.do_clear_bss_start>:
    169e:	a2 3e       	cpi	r26, 0xE2	; 226
    16a0:	b2 07       	cpc	r27, r18
    16a2:	e1 f7       	brne	.-8      	; 0x169c <.do_clear_bss_loop>
    16a4:	0e 94 5d 4c 	call	0x98ba	; 0x98ba <main>
    16a8:	0c 94 d8 53 	jmp	0xa7b0	; 0xa7b0 <_exit>

000016ac <__bad_interrupt>:
    16ac:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000016b0 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
    16b0:	0e 94 88 49 	call	0x9310	; 0x9310 <vCoRoutineSchedule>
  }
    16b4:	fd cf       	rjmp	.-6      	; 0x16b0 <vApplicationIdleHook>

000016b6 <vApplicationTickHook>:
}

void vApplicationTickHook( void )
{
  static uint8_t tickCntr = configTICK_RATE_HZ;
  if (--tickCntr == 0)
    16b6:	80 91 00 01 	lds	r24, 0x0100
    16ba:	81 50       	subi	r24, 0x01	; 1
    16bc:	19 f0       	breq	.+6      	; 0x16c4 <vApplicationTickHook+0xe>
    16be:	80 93 00 01 	sts	0x0100, r24
    16c2:	08 95       	ret
  {
    tickCntr = configTICK_RATE_HZ;
    16c4:	84 e6       	ldi	r24, 0x64	; 100
    16c6:	80 93 00 01 	sts	0x0100, r24
    arpTimer();
    16ca:	0c 94 84 30 	jmp	0x6108	; 0x6108 <arpTimer>

000016ce <loadConfiguration>:
uint16_t udpPortSrcEep  __attribute__((section (".eeprom")));


void loadConfiguration(void)
{
  eeprom_read_block(lockSensors, lockerSensorsEEP, 4*sizeof(struct lockerSensor));
    16ce:	48 e1       	ldi	r20, 0x18	; 24
    16d0:	50 e0       	ldi	r21, 0x00	; 0
    16d2:	68 e0       	ldi	r22, 0x08	; 8
    16d4:	70 e0       	ldi	r23, 0x00	; 0
    16d6:	80 91 a0 0e 	lds	r24, 0x0EA0
    16da:	90 91 a1 0e 	lds	r25, 0x0EA1
    16de:	0c 94 3d 53 	jmp	0xa67a	; 0xa67a <eeprom_read_block>

000016e2 <saveConfiguration>:
}

void saveConfiguration(void)
{
  //saveNic();
  ipSaveConfig();
    16e2:	0e 94 31 2d 	call	0x5a62	; 0x5a62 <ipSaveConfig>
  udpSaveConfig();
    16e6:	0c 94 50 38 	jmp	0x70a0	; 0x70a0 <udpSaveConfig>

000016ea <VtyGetChar>:
  fdev_set_udata(stream, NULL);
  return;
}

int VtyGetChar(FILE *stream)
{
    16ea:	cf 93       	push	r28
    16ec:	df 93       	push	r29
    16ee:	1f 92       	push	r1
    16f0:	cd b7       	in	r28, 0x3d	; 61
    16f2:	de b7       	in	r29, 0x3e	; 62
  (void) stream;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    16f4:	20 e0       	ldi	r18, 0x00	; 0
    16f6:	4f ef       	ldi	r20, 0xFF	; 255
    16f8:	5f ef       	ldi	r21, 0xFF	; 255
    16fa:	be 01       	movw	r22, r28
    16fc:	6f 5f       	subi	r22, 0xFF	; 255
    16fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1700:	80 91 ac 0e 	lds	r24, 0x0EAC
    1704:	90 91 ad 0e 	lds	r25, 0x0EAD
    1708:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    170c:	88 23       	and	r24, r24
    170e:	19 f0       	breq	.+6      	; 0x1716 <VtyGetChar+0x2c>
    return EOF;
  return c;
    1710:	89 81       	ldd	r24, Y+1	; 0x01
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	02 c0       	rjmp	.+4      	; 0x171a <VtyGetChar+0x30>
int VtyGetChar(FILE *stream)
{
  (void) stream;
  uint8_t c;
  if (xQueueReceive(xVtyRec, &c, portMAX_DELAY) == 0)
    return EOF;
    1716:	8f ef       	ldi	r24, 0xFF	; 255
    1718:	9f ef       	ldi	r25, 0xFF	; 255
  return c;
}
    171a:	0f 90       	pop	r0
    171c:	df 91       	pop	r29
    171e:	cf 91       	pop	r28
    1720:	08 95       	ret

00001722 <initQueueStreamUSB>:
#define debug 1

/*-----------------------------------------------------------*/

void initQueueStreamUSB(FILE *stream)
{
    1722:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, VtyPutChar, VtyGetChar, _FDEV_SETUP_RW);
    1724:	8a e3       	ldi	r24, 0x3A	; 58
    1726:	9d e0       	ldi	r25, 0x0D	; 13
    1728:	91 87       	std	Z+9, r25	; 0x09
    172a:	80 87       	std	Z+8, r24	; 0x08
    172c:	85 e7       	ldi	r24, 0x75	; 117
    172e:	9b e0       	ldi	r25, 0x0B	; 11
    1730:	93 87       	std	Z+11, r25	; 0x0b
    1732:	82 87       	std	Z+10, r24	; 0x0a
    1734:	83 e0       	ldi	r24, 0x03	; 3
    1736:	83 83       	std	Z+3, r24	; 0x03
    1738:	15 86       	std	Z+13, r1	; 0x0d
    173a:	14 86       	std	Z+12, r1	; 0x0c
    173c:	08 95       	ret

0000173e <xSerialPortInitMinimal>:
  return 0;
}

void xSerialPortInitMinimal(void)
{
  portENTER_CRITICAL();
    173e:	0f b6       	in	r0, 0x3f	; 63
    1740:	f8 94       	cli
    1742:	0f 92       	push	r0
  {
    xVtyRec = xQueueCreate(64, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1744:	61 e0       	ldi	r22, 0x01	; 1
    1746:	80 e4       	ldi	r24, 0x40	; 64
    1748:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    174c:	90 93 ad 0e 	sts	0x0EAD, r25
    1750:	80 93 ac 0e 	sts	0x0EAC, r24
    xVtyTx = xQueueCreate(32, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ));
    1754:	61 e0       	ldi	r22, 0x01	; 1
    1756:	80 e2       	ldi	r24, 0x20	; 32
    1758:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    175c:	90 93 7c 0e 	sts	0x0E7C, r25
    1760:	80 93 7b 0e 	sts	0x0E7B, r24
    xRs485Rec = xQueueCreate( 16, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1764:	61 e0       	ldi	r22, 0x01	; 1
    1766:	80 e1       	ldi	r24, 0x10	; 16
    1768:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    176c:	90 93 9d 0e 	sts	0x0E9D, r25
    1770:	80 93 9c 0e 	sts	0x0E9C, r24
    xRs485Tx = xQueueCreate( 4, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
    1774:	61 e0       	ldi	r22, 0x01	; 1
    1776:	84 e0       	ldi	r24, 0x04	; 4
    1778:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    177c:	90 93 c4 0e 	sts	0x0EC4, r25
    1780:	80 93 c3 0e 	sts	0x0EC3, r24

    vSemaphoreCreateBinary(xSemaphoreRs485);
    1784:	60 e0       	ldi	r22, 0x00	; 0
    1786:	81 e0       	ldi	r24, 0x01	; 1
    1788:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    178c:	90 93 b0 0e 	sts	0x0EB0, r25
    1790:	80 93 af 0e 	sts	0x0EAF, r24
    1794:	00 97       	sbiw	r24, 0x00	; 0
    1796:	39 f0       	breq	.+14     	; 0x17a6 <xSerialPortInitMinimal+0x68>
    1798:	20 e0       	ldi	r18, 0x00	; 0
    179a:	40 e0       	ldi	r20, 0x00	; 0
    179c:	50 e0       	ldi	r21, 0x00	; 0
    179e:	60 e0       	ldi	r22, 0x00	; 0
    17a0:	70 e0       	ldi	r23, 0x00	; 0
    17a2:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
    17a6:	0f 90       	pop	r0
    17a8:	0f be       	out	0x3f, r0	; 63

  UBRR0L = 7;
    17aa:	87 e0       	ldi	r24, 0x07	; 7
    17ac:	89 b9       	out	0x09, r24	; 9
  UBRR0H = 0;
    17ae:	10 92 90 00 	sts	0x0090, r1

  UBRR1L = 7;
    17b2:	80 93 99 00 	sts	0x0099, r24
  UBRR1H = 0;
    17b6:	10 92 98 00 	sts	0x0098, r1

  UCSR0B = ((1<<TXCIE0)|(1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0));
    17ba:	88 ed       	ldi	r24, 0xD8	; 216
    17bc:	8a b9       	out	0x0a, r24	; 10
  UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    17be:	86 e8       	ldi	r24, 0x86	; 134
    17c0:	80 93 95 00 	sts	0x0095, r24
  UCSR1B = ((1<<RXCIE1)|(1<<TXEN1)|(1<<RXEN1));
    17c4:	98 e9       	ldi	r25, 0x98	; 152
    17c6:	90 93 9a 00 	sts	0x009A, r25
  UCSR1C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );     /* Set the data bits to 8. */
    17ca:	80 93 9d 00 	sts	0x009D, r24
    17ce:	08 95       	ret

000017d0 <__vector_18>:
  return;
}

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    17d0:	1f 92       	push	r1
    17d2:	0f 92       	push	r0
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	0f 92       	push	r0
    17d8:	11 24       	eor	r1, r1
    17da:	0b b6       	in	r0, 0x3b	; 59
    17dc:	0f 92       	push	r0
    17de:	2f 93       	push	r18
    17e0:	3f 93       	push	r19
    17e2:	4f 93       	push	r20
    17e4:	5f 93       	push	r21
    17e6:	6f 93       	push	r22
    17e8:	7f 93       	push	r23
    17ea:	8f 93       	push	r24
    17ec:	9f 93       	push	r25
    17ee:	af 93       	push	r26
    17f0:	bf 93       	push	r27
    17f2:	ef 93       	push	r30
    17f4:	ff 93       	push	r31
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
    17fa:	1f 92       	push	r1
    17fc:	cd b7       	in	r28, 0x3d	; 61
    17fe:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken = pdTRUE;
  signed portCHAR cChar;

  cChar = UDR0;
    1800:	8c b1       	in	r24, 0x0c	; 12
    1802:	89 83       	std	Y+1, r24	; 0x01

  xHigherPriorityTaskWoken = pdFALSE;
    1804:	10 92 01 01 	sts	0x0101, r1

//  xQueueSendFromISR( xRs485Rec, &cChar, NULL);
  xQueueSendFromISR( xRs485Rec, &cChar, &xHigherPriorityTaskWoken );
    1808:	20 e0       	ldi	r18, 0x00	; 0
    180a:	41 e0       	ldi	r20, 0x01	; 1
    180c:	51 e0       	ldi	r21, 0x01	; 1
    180e:	be 01       	movw	r22, r28
    1810:	6f 5f       	subi	r22, 0xFF	; 255
    1812:	7f 4f       	sbci	r23, 0xFF	; 255
    1814:	80 91 9c 0e 	lds	r24, 0x0E9C
    1818:	90 91 9d 0e 	lds	r25, 0x0E9D
    181c:	0e 94 36 47 	call	0x8e6c	; 0x8e6c <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    1820:	80 91 01 01 	lds	r24, 0x0101
    1824:	81 11       	cpse	r24, r1
  {
    taskYIELD();
    1826:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
  }
}
    182a:	0f 90       	pop	r0
    182c:	df 91       	pop	r29
    182e:	cf 91       	pop	r28
    1830:	ff 91       	pop	r31
    1832:	ef 91       	pop	r30
    1834:	bf 91       	pop	r27
    1836:	af 91       	pop	r26
    1838:	9f 91       	pop	r25
    183a:	8f 91       	pop	r24
    183c:	7f 91       	pop	r23
    183e:	6f 91       	pop	r22
    1840:	5f 91       	pop	r21
    1842:	4f 91       	pop	r20
    1844:	3f 91       	pop	r19
    1846:	2f 91       	pop	r18
    1848:	0f 90       	pop	r0
    184a:	0b be       	out	0x3b, r0	; 59
    184c:	0f 90       	pop	r0
    184e:	0f be       	out	0x3f, r0	; 63
    1850:	0f 90       	pop	r0
    1852:	1f 90       	pop	r1
    1854:	18 95       	reti

00001856 <uartRs485SendByte>:

void uartRs485SendByte(uint8_t data)
{
    1856:	cf 93       	push	r28
    1858:	df 93       	push	r29
    185a:	1f 92       	push	r1
    185c:	cd b7       	in	r28, 0x3d	; 61
    185e:	de b7       	in	r29, 0x3e	; 62
    1860:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xRs485Tx, &data, portMAX_DELAY);
    1862:	20 e0       	ldi	r18, 0x00	; 0
    1864:	4f ef       	ldi	r20, 0xFF	; 255
    1866:	5f ef       	ldi	r21, 0xFF	; 255
    1868:	be 01       	movw	r22, r28
    186a:	6f 5f       	subi	r22, 0xFF	; 255
    186c:	7f 4f       	sbci	r23, 0xFF	; 255
    186e:	80 91 c3 0e 	lds	r24, 0x0EC3
    1872:	90 91 c4 0e 	lds	r25, 0x0EC4
    1876:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <xQueueGenericSend>
  vInterruptRs485On();
    187a:	55 9a       	sbi	0x0a, 5	; 10
}
    187c:	0f 90       	pop	r0
    187e:	df 91       	pop	r29
    1880:	cf 91       	pop	r28
    1882:	08 95       	ret

00001884 <rs485Receive>:

uint8_t rs485Receive(uint8_t *c, uint8_t timeout)
{
  return xQueueReceive(xRs485Rec, c, timeout);
    1884:	46 2f       	mov	r20, r22
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	20 e0       	ldi	r18, 0x00	; 0
    188a:	bc 01       	movw	r22, r24
    188c:	80 91 9c 0e 	lds	r24, 0x0E9C
    1890:	90 91 9d 0e 	lds	r25, 0x0E9D
    1894:	0c 94 5e 47 	jmp	0x8ebc	; 0x8ebc <xQueueGenericReceive>

00001898 <__vector_19>:
}

ISR(USART0_UDRE_vect)
{
    1898:	1f 92       	push	r1
    189a:	0f 92       	push	r0
    189c:	0f b6       	in	r0, 0x3f	; 63
    189e:	0f 92       	push	r0
    18a0:	11 24       	eor	r1, r1
    18a2:	0b b6       	in	r0, 0x3b	; 59
    18a4:	0f 92       	push	r0
    18a6:	2f 93       	push	r18
    18a8:	3f 93       	push	r19
    18aa:	4f 93       	push	r20
    18ac:	5f 93       	push	r21
    18ae:	6f 93       	push	r22
    18b0:	7f 93       	push	r23
    18b2:	8f 93       	push	r24
    18b4:	9f 93       	push	r25
    18b6:	af 93       	push	r26
    18b8:	bf 93       	push	r27
    18ba:	ef 93       	push	r30
    18bc:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken;
  static char data;
  if(xQueueReceiveFromISR(xRs485Tx, (void *)(&data), &xHigherPriorityTaskWoken) == pdTRUE)
    18be:	4c e8       	ldi	r20, 0x8C	; 140
    18c0:	51 e0       	ldi	r21, 0x01	; 1
    18c2:	6d e8       	ldi	r22, 0x8D	; 141
    18c4:	71 e0       	ldi	r23, 0x01	; 1
    18c6:	80 91 c3 0e 	lds	r24, 0x0EC3
    18ca:	90 91 c4 0e 	lds	r25, 0x0EC4
    18ce:	0e 94 02 48 	call	0x9004	; 0x9004 <xQueueReceiveFromISR>
    18d2:	81 30       	cpi	r24, 0x01	; 1
    18d4:	49 f4       	brne	.+18     	; 0x18e8 <__vector_19+0x50>
  {
    Rs485TxStart();
    18d6:	80 91 65 00 	lds	r24, 0x0065
    18da:	80 61       	ori	r24, 0x10	; 16
    18dc:	80 93 65 00 	sts	0x0065, r24
    UDR0 = data;
    18e0:	80 91 8d 01 	lds	r24, 0x018D
    18e4:	8c b9       	out	0x0c, r24	; 12
    18e6:	03 c0       	rjmp	.+6      	; 0x18ee <__vector_19+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    18e8:	10 92 8c 01 	sts	0x018C, r1
    vInterruptRs485Off();
    18ec:	55 98       	cbi	0x0a, 5	; 10
  }
  if( xHigherPriorityTaskWoken )
    18ee:	80 91 8c 01 	lds	r24, 0x018C
    18f2:	81 11       	cpse	r24, r1
  {
    taskYIELD();
    18f4:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
  }
}
    18f8:	ff 91       	pop	r31
    18fa:	ef 91       	pop	r30
    18fc:	bf 91       	pop	r27
    18fe:	af 91       	pop	r26
    1900:	9f 91       	pop	r25
    1902:	8f 91       	pop	r24
    1904:	7f 91       	pop	r23
    1906:	6f 91       	pop	r22
    1908:	5f 91       	pop	r21
    190a:	4f 91       	pop	r20
    190c:	3f 91       	pop	r19
    190e:	2f 91       	pop	r18
    1910:	0f 90       	pop	r0
    1912:	0b be       	out	0x3b, r0	; 59
    1914:	0f 90       	pop	r0
    1916:	0f be       	out	0x3f, r0	; 63
    1918:	0f 90       	pop	r0
    191a:	1f 90       	pop	r1
    191c:	18 95       	reti

0000191e <__vector_20>:

ISR(USART0_TX_vect)
{
    191e:	1f 92       	push	r1
    1920:	0f 92       	push	r0
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	0f 92       	push	r0
    1926:	11 24       	eor	r1, r1
    1928:	8f 93       	push	r24
  if (!vIsInterruptRs485On())
    192a:	55 99       	sbic	0x0a, 5	; 10
    192c:	05 c0       	rjmp	.+10     	; 0x1938 <__vector_20+0x1a>
    Rs485TxStop();
    192e:	80 91 65 00 	lds	r24, 0x0065
    1932:	8f 7e       	andi	r24, 0xEF	; 239
    1934:	80 93 65 00 	sts	0x0065, r24
}
    1938:	8f 91       	pop	r24
    193a:	0f 90       	pop	r0
    193c:	0f be       	out	0x3f, r0	; 63
    193e:	0f 90       	pop	r0
    1940:	1f 90       	pop	r1
    1942:	18 95       	reti

00001944 <flushRs485RecBuffer>:

uint8_t flushRs485RecBuffer(void)
{
    1944:	1f 93       	push	r17
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	1f 92       	push	r1
    194c:	cd b7       	in	r28, 0x3d	; 61
    194e:	de b7       	in	r29, 0x3e	; 62
  uint8_t temp;
  uint8_t wynik = 0;
    1950:	10 e0       	ldi	r17, 0x00	; 0
  while(xQueueReceive(xRs485Rec, &temp, 10) == pdTRUE)
    1952:	20 e0       	ldi	r18, 0x00	; 0
    1954:	4a e0       	ldi	r20, 0x0A	; 10
    1956:	50 e0       	ldi	r21, 0x00	; 0
    1958:	be 01       	movw	r22, r28
    195a:	6f 5f       	subi	r22, 0xFF	; 255
    195c:	7f 4f       	sbci	r23, 0xFF	; 255
    195e:	80 91 9c 0e 	lds	r24, 0x0E9C
    1962:	90 91 9d 0e 	lds	r25, 0x0E9D
    1966:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    196a:	81 30       	cpi	r24, 0x01	; 1
    196c:	11 f4       	brne	.+4      	; 0x1972 <flushRs485RecBuffer+0x2e>
    wynik++;
    196e:	1f 5f       	subi	r17, 0xFF	; 255
    1970:	f0 cf       	rjmp	.-32     	; 0x1952 <flushRs485RecBuffer+0xe>

  return wynik;
}
    1972:	81 2f       	mov	r24, r17
    1974:	0f 90       	pop	r0
    1976:	df 91       	pop	r29
    1978:	cf 91       	pop	r28
    197a:	1f 91       	pop	r17
    197c:	08 95       	ret

0000197e <takeRs485>:

void    takeRs485(void)
{
  xSemaphoreTake(xSemaphoreRs485, portMAX_DELAY);
    197e:	20 e0       	ldi	r18, 0x00	; 0
    1980:	4f ef       	ldi	r20, 0xFF	; 255
    1982:	5f ef       	ldi	r21, 0xFF	; 255
    1984:	60 e0       	ldi	r22, 0x00	; 0
    1986:	70 e0       	ldi	r23, 0x00	; 0
    1988:	80 91 af 0e 	lds	r24, 0x0EAF
    198c:	90 91 b0 0e 	lds	r25, 0x0EB0
    1990:	0c 94 5e 47 	jmp	0x8ebc	; 0x8ebc <xQueueGenericReceive>

00001994 <releaseRs485>:
}

void    releaseRs485(void)
{
  xSemaphoreGive(xSemaphoreRs485);
    1994:	20 e0       	ldi	r18, 0x00	; 0
    1996:	40 e0       	ldi	r20, 0x00	; 0
    1998:	50 e0       	ldi	r21, 0x00	; 0
    199a:	60 e0       	ldi	r22, 0x00	; 0
    199c:	70 e0       	ldi	r23, 0x00	; 0
    199e:	80 91 af 0e 	lds	r24, 0x0EAF
    19a2:	90 91 b0 0e 	lds	r25, 0x0EB0
    19a6:	0c 94 a2 46 	jmp	0x8d44	; 0x8d44 <xQueueGenericSend>

000019aa <InterruptVtyOn>:
}

void InterruptVtyOn(void)
{
  unsigned portCHAR ucByte;
  ucByte = UCSR1B;
    19aa:	ea e9       	ldi	r30, 0x9A	; 154
    19ac:	f0 e0       	ldi	r31, 0x00	; 0
    19ae:	80 81       	ld	r24, Z
  ucByte |= serDATA_INT_ENABLE;
    19b0:	80 62       	ori	r24, 0x20	; 32
  UCSR1B = ucByte;
    19b2:	80 83       	st	Z, r24
    19b4:	08 95       	ret

000019b6 <__vector_30>:
}

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    19b6:	1f 92       	push	r1
    19b8:	0f 92       	push	r0
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	0f 92       	push	r0
    19be:	11 24       	eor	r1, r1
    19c0:	0b b6       	in	r0, 0x3b	; 59
    19c2:	0f 92       	push	r0
    19c4:	2f 93       	push	r18
    19c6:	3f 93       	push	r19
    19c8:	4f 93       	push	r20
    19ca:	5f 93       	push	r21
    19cc:	6f 93       	push	r22
    19ce:	7f 93       	push	r23
    19d0:	8f 93       	push	r24
    19d2:	9f 93       	push	r25
    19d4:	af 93       	push	r26
    19d6:	bf 93       	push	r27
    19d8:	ef 93       	push	r30
    19da:	ff 93       	push	r31
    19dc:	cf 93       	push	r28
    19de:	df 93       	push	r29
    19e0:	1f 92       	push	r1
    19e2:	cd b7       	in	r28, 0x3d	; 61
    19e4:	de b7       	in	r29, 0x3e	; 62
  static signed portBASE_TYPE xHigherPriorityTaskWoken;
  signed portCHAR cChar;

  cChar = UDR1;
    19e6:	80 91 9c 00 	lds	r24, 0x009C
    19ea:	89 83       	std	Y+1, r24	; 0x01
//  xQueueSendFromISR(xVtyRec, &cChar, NULL);

  xHigherPriorityTaskWoken = pdFALSE;
    19ec:	10 92 8b 01 	sts	0x018B, r1
  xQueueSendFromISR(xVtyRec, &cChar, &xHigherPriorityTaskWoken);
    19f0:	20 e0       	ldi	r18, 0x00	; 0
    19f2:	4b e8       	ldi	r20, 0x8B	; 139
    19f4:	51 e0       	ldi	r21, 0x01	; 1
    19f6:	be 01       	movw	r22, r28
    19f8:	6f 5f       	subi	r22, 0xFF	; 255
    19fa:	7f 4f       	sbci	r23, 0xFF	; 255
    19fc:	80 91 ac 0e 	lds	r24, 0x0EAC
    1a00:	90 91 ad 0e 	lds	r25, 0x0EAD
    1a04:	0e 94 36 47 	call	0x8e6c	; 0x8e6c <xQueueGenericSendFromISR>
  if( xHigherPriorityTaskWoken )
    1a08:	80 91 8b 01 	lds	r24, 0x018B
    1a0c:	81 11       	cpse	r24, r1
  {
    taskYIELD();
    1a0e:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
  }
}
    1a12:	0f 90       	pop	r0
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	ff 91       	pop	r31
    1a1a:	ef 91       	pop	r30
    1a1c:	bf 91       	pop	r27
    1a1e:	af 91       	pop	r26
    1a20:	9f 91       	pop	r25
    1a22:	8f 91       	pop	r24
    1a24:	7f 91       	pop	r23
    1a26:	6f 91       	pop	r22
    1a28:	5f 91       	pop	r21
    1a2a:	4f 91       	pop	r20
    1a2c:	3f 91       	pop	r19
    1a2e:	2f 91       	pop	r18
    1a30:	0f 90       	pop	r0
    1a32:	0b be       	out	0x3b, r0	; 59
    1a34:	0f 90       	pop	r0
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	0f 90       	pop	r0
    1a3a:	1f 90       	pop	r1
    1a3c:	18 95       	reti

00001a3e <uartVtySendByte>:

void uartVtySendByte(uint8_t data)
{
    1a3e:	cf 93       	push	r28
    1a40:	df 93       	push	r29
    1a42:	1f 92       	push	r1
    1a44:	cd b7       	in	r28, 0x3d	; 61
    1a46:	de b7       	in	r29, 0x3e	; 62
    1a48:	89 83       	std	Y+1, r24	; 0x01
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
    1a4a:	20 e0       	ldi	r18, 0x00	; 0
    1a4c:	4f ef       	ldi	r20, 0xFF	; 255
    1a4e:	5f ef       	ldi	r21, 0xFF	; 255
    1a50:	be 01       	movw	r22, r28
    1a52:	6f 5f       	subi	r22, 0xFF	; 255
    1a54:	7f 4f       	sbci	r23, 0xFF	; 255
    1a56:	80 91 7b 0e 	lds	r24, 0x0E7B
    1a5a:	90 91 7c 0e 	lds	r25, 0x0E7C
    1a5e:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <xQueueGenericSend>
  vInterruptVtyOn();
    1a62:	ea e9       	ldi	r30, 0x9A	; 154
    1a64:	f0 e0       	ldi	r31, 0x00	; 0
    1a66:	80 81       	ld	r24, Z
    1a68:	80 62       	ori	r24, 0x20	; 32
    1a6a:	80 83       	st	Z, r24
}
    1a6c:	0f 90       	pop	r0
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	08 95       	ret

00001a74 <VtyPutChar>:
}

int VtyPutChar(char c, FILE *stream)
{
  (void) stream;
  uartVtySendByte(c);
    1a74:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
  return 0;
}
    1a78:	80 e0       	ldi	r24, 0x00	; 0
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	08 95       	ret

00001a7e <__vector_31>:
  xQueueSend(xVtyTx, &data, portMAX_DELAY);
  vInterruptVtyOn();
}

ISR(USART1_UDRE_vect)
{
    1a7e:	1f 92       	push	r1
    1a80:	0f 92       	push	r0
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	0f 92       	push	r0
    1a86:	11 24       	eor	r1, r1
    1a88:	0b b6       	in	r0, 0x3b	; 59
    1a8a:	0f 92       	push	r0
    1a8c:	2f 93       	push	r18
    1a8e:	3f 93       	push	r19
    1a90:	4f 93       	push	r20
    1a92:	5f 93       	push	r21
    1a94:	6f 93       	push	r22
    1a96:	7f 93       	push	r23
    1a98:	8f 93       	push	r24
    1a9a:	9f 93       	push	r25
    1a9c:	af 93       	push	r26
    1a9e:	bf 93       	push	r27
    1aa0:	ef 93       	push	r30
    1aa2:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken;
  static char data;
  if(xQueueReceiveFromISR(xVtyTx, &data, &xHigherPriorityTaskWoken) == pdTRUE)
    1aa4:	49 e8       	ldi	r20, 0x89	; 137
    1aa6:	51 e0       	ldi	r21, 0x01	; 1
    1aa8:	6a e8       	ldi	r22, 0x8A	; 138
    1aaa:	71 e0       	ldi	r23, 0x01	; 1
    1aac:	80 91 7b 0e 	lds	r24, 0x0E7B
    1ab0:	90 91 7c 0e 	lds	r25, 0x0E7C
    1ab4:	0e 94 02 48 	call	0x9004	; 0x9004 <xQueueReceiveFromISR>
    1ab8:	81 30       	cpi	r24, 0x01	; 1
    1aba:	29 f4       	brne	.+10     	; 0x1ac6 <__vector_31+0x48>
  {
    UDR1 = data;
    1abc:	80 91 8a 01 	lds	r24, 0x018A
    1ac0:	80 93 9c 00 	sts	0x009C, r24
    1ac4:	07 c0       	rjmp	.+14     	; 0x1ad4 <__vector_31+0x56>
  }
  else
  {
    xHigherPriorityTaskWoken = pdFALSE;
    1ac6:	10 92 89 01 	sts	0x0189, r1
    vInterruptVtyOff();
    1aca:	80 91 9a 00 	lds	r24, 0x009A
    1ace:	8f 7d       	andi	r24, 0xDF	; 223
    1ad0:	80 93 9a 00 	sts	0x009A, r24
  }
  if( xHigherPriorityTaskWoken )
    1ad4:	80 91 89 01 	lds	r24, 0x0189
    1ad8:	81 11       	cpse	r24, r1
  {
    taskYIELD();
    1ada:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
  }
}
    1ade:	ff 91       	pop	r31
    1ae0:	ef 91       	pop	r30
    1ae2:	bf 91       	pop	r27
    1ae4:	af 91       	pop	r26
    1ae6:	9f 91       	pop	r25
    1ae8:	8f 91       	pop	r24
    1aea:	7f 91       	pop	r23
    1aec:	6f 91       	pop	r22
    1aee:	5f 91       	pop	r21
    1af0:	4f 91       	pop	r20
    1af2:	3f 91       	pop	r19
    1af4:	2f 91       	pop	r18
    1af6:	0f 90       	pop	r0
    1af8:	0b be       	out	0x3b, r0	; 59
    1afa:	0f 90       	pop	r0
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	0f 90       	pop	r0
    1b00:	1f 90       	pop	r1
    1b02:	18 95       	reti

00001b04 <hardwareInit>:
xQueueHandle      xSpiRx;             /// Kolejka z odebranymi bajtami z SPI. Blokuje transmisję do czasu zakończenia wysyłania poprzedniego bajtu

void hardwareInit(void)
{
  //DDRA = 0x00;  //External Memory
  portENTER_CRITICAL();
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	0f 92       	push	r0
  xSpiRx          = xQueueCreate(1, 1);
    1b0a:	61 e0       	ldi	r22, 0x01	; 1
    1b0c:	81 e0       	ldi	r24, 0x01	; 1
    1b0e:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    1b12:	90 93 61 0f 	sts	0x0F61, r25
    1b16:	80 93 60 0f 	sts	0x0F60, r24
  portEXIT_CRITICAL();
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63

  DDRB = 0xF7;
    1b1e:	87 ef       	ldi	r24, 0xF7	; 247
    1b20:	87 bb       	out	0x17, r24	; 23
  PORTB = 0xD1;
    1b22:	81 ed       	ldi	r24, 0xD1	; 209
    1b24:	88 bb       	out	0x18, r24	; 24
   7 - External SPI ASR 7 (MPC23S17)   0 - on;  1 - off
  */

  //DDRC = 0x00;  //External Memory

  DDRD = 0x00;
    1b26:	11 ba       	out	0x11, r1	; 17
   5 - External SPI ASR 1
   6 - External SPI ASR 2
   7 - External SPI ASR 3
   */

  DDRE  = 0x0E;
    1b28:	8e e0       	ldi	r24, 0x0E	; 14
    1b2a:	82 b9       	out	0x02, r24	; 2
  PORTE = 0x0C;
    1b2c:	8c e0       	ldi	r24, 0x0C	; 12
    1b2e:	83 b9       	out	0x03, r24	; 3
   4 - INT 4
   5 - INT 5
   6 - INT 6
   7 - INT Enc28j60
  */
  DDRF = 0x00;    //JTAG and A/C
    1b30:	10 92 61 00 	sts	0x0061, r1
  DDRG = 0x1F;
    1b34:	8f e1       	ldi	r24, 0x1F	; 31
    1b36:	80 93 64 00 	sts	0x0064, r24
    1b3a:	08 95       	ret

00001b3c <LockersMemInit>:
   */
}

void LockersMemInit(void)
{
  lockSensors = xmalloc(4 * sizeof(struct lockerSensor));
    1b3c:	88 e1       	ldi	r24, 0x18	; 24
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <xmalloc>
    1b44:	90 93 a1 0e 	sts	0x0EA1, r25
    1b48:	80 93 a0 0e 	sts	0x0EA0, r24
    1b4c:	08 95       	ret

00001b4e <printLockers>:
}

uint8_t printLockers(FILE *stream)
{
    1b4e:	5f 92       	push	r5
    1b50:	6f 92       	push	r6
    1b52:	7f 92       	push	r7
    1b54:	8f 92       	push	r8
    1b56:	9f 92       	push	r9
    1b58:	af 92       	push	r10
    1b5a:	bf 92       	push	r11
    1b5c:	cf 92       	push	r12
    1b5e:	df 92       	push	r13
    1b60:	ef 92       	push	r14
    1b62:	ff 92       	push	r15
    1b64:	0f 93       	push	r16
    1b66:	1f 93       	push	r17
    1b68:	cf 93       	push	r28
    1b6a:	df 93       	push	r29
    1b6c:	78 2e       	mov	r7, r24
    1b6e:	69 2e       	mov	r6, r25
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
    1b70:	c0 91 a0 0e 	lds	r28, 0x0EA0
    1b74:	d0 91 a1 0e 	lds	r29, 0x0EA1
    1b78:	01 e0       	ldi	r16, 0x01	; 1
    1b7a:	10 e0       	ldi	r17, 0x00	; 0
}

uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
    1b7c:	51 2c       	mov	r5, r1
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1b7e:	8d eb       	ldi	r24, 0xBD	; 189
    1b80:	e8 2e       	mov	r14, r24
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	f8 2e       	mov	r15, r24
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1b86:	9c e8       	ldi	r25, 0x8C	; 140
    1b88:	c9 2e       	mov	r12, r25
    1b8a:	90 e0       	ldi	r25, 0x00	; 0
    1b8c:	d9 2e       	mov	r13, r25
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
      else
        fprintf_P(stream, statusLockerCloseStr);
    1b8e:	2b ea       	ldi	r18, 0xAB	; 171
    1b90:	a2 2e       	mov	r10, r18
    1b92:	20 e0       	ldi	r18, 0x00	; 0
    1b94:	b2 2e       	mov	r11, r18
  {
    if (tmpLock->enabled)
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
      if (tmpLock->threshold > tmpLock->acVal)
        fprintf_P(stream, statusLockerOpenStr);
    1b96:	34 eb       	ldi	r19, 0xB4	; 180
    1b98:	83 2e       	mov	r8, r19
    1b9a:	30 e0       	ldi	r19, 0x00	; 0
    1b9c:	93 2e       	mov	r9, r19
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
  {
    if (tmpLock->enabled)
    1b9e:	88 81       	ld	r24, Y
    1ba0:	88 23       	and	r24, r24
    1ba2:	c9 f1       	breq	.+114    	; 0x1c16 <printLockers+0xc8>
    {
      fprintf_P(stream, statusLockerSensDescStr, i);
    1ba4:	1f 93       	push	r17
    1ba6:	0f 93       	push	r16
    1ba8:	ff 92       	push	r15
    1baa:	ef 92       	push	r14
    1bac:	6f 92       	push	r6
    1bae:	7f 92       	push	r7
    1bb0:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
      if (tmpLock->threshold > tmpLock->acVal)
    1bb4:	0f 90       	pop	r0
    1bb6:	0f 90       	pop	r0
    1bb8:	0f 90       	pop	r0
    1bba:	0f 90       	pop	r0
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	29 81       	ldd	r18, Y+1	; 0x01
    1bc2:	3a 81       	ldd	r19, Y+2	; 0x02
    1bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc8:	82 17       	cp	r24, r18
    1bca:	93 07       	cpc	r25, r19
    1bcc:	18 f4       	brcc	.+6      	; 0x1bd4 <printLockers+0x86>
        fprintf_P(stream, statusLockerOpenStr);
    1bce:	9f 92       	push	r9
    1bd0:	8f 92       	push	r8
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <printLockers+0x8a>
      else
        fprintf_P(stream, statusLockerCloseStr);
    1bd4:	bf 92       	push	r11
    1bd6:	af 92       	push	r10
    1bd8:	6f 92       	push	r6
    1bda:	7f 92       	push	r7
    1bdc:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    1be0:	0f 90       	pop	r0
    1be2:	0f 90       	pop	r0
    1be4:	0f 90       	pop	r0
    1be6:	0f 90       	pop	r0
      fprintf_P(stream, statusLockerSensAdditionalDescStr, tmpLock->threshold, tmpLock->acVal);
    1be8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bea:	8f 93       	push	r24
    1bec:	8b 81       	ldd	r24, Y+3	; 0x03
    1bee:	8f 93       	push	r24
    1bf0:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf2:	8f 93       	push	r24
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	8f 93       	push	r24
    1bf8:	df 92       	push	r13
    1bfa:	cf 92       	push	r12
    1bfc:	6f 92       	push	r6
    1bfe:	7f 92       	push	r7
    1c00:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
      result++;
    1c04:	53 94       	inc	r5
    1c06:	8d b7       	in	r24, 0x3d	; 61
    1c08:	9e b7       	in	r25, 0x3e	; 62
    1c0a:	08 96       	adiw	r24, 0x08	; 8
    1c0c:	0f b6       	in	r0, 0x3f	; 63
    1c0e:	f8 94       	cli
    1c10:	9e bf       	out	0x3e, r25	; 62
    1c12:	0f be       	out	0x3f, r0	; 63
    1c14:	8d bf       	out	0x3d, r24	; 61
    }
    tmpLock++;
    1c16:	26 96       	adiw	r28, 0x06	; 6
    1c18:	0f 5f       	subi	r16, 0xFF	; 255
    1c1a:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t printLockers(FILE *stream)
{
  uint8_t i;
  uint8_t result = 0;
  struct lockerSensor *tmpLock = lockSensors;
  for (i=1; i<=4; i++)
    1c1c:	05 30       	cpi	r16, 0x05	; 5
    1c1e:	11 05       	cpc	r17, r1
    1c20:	09 f0       	breq	.+2      	; 0x1c24 <printLockers+0xd6>
    1c22:	bd cf       	rjmp	.-134    	; 0x1b9e <printLockers+0x50>
      result++;
    }
    tmpLock++;
  }
  return result;
}
    1c24:	85 2d       	mov	r24, r5
    1c26:	df 91       	pop	r29
    1c28:	cf 91       	pop	r28
    1c2a:	1f 91       	pop	r17
    1c2c:	0f 91       	pop	r16
    1c2e:	ff 90       	pop	r15
    1c30:	ef 90       	pop	r14
    1c32:	df 90       	pop	r13
    1c34:	cf 90       	pop	r12
    1c36:	bf 90       	pop	r11
    1c38:	af 90       	pop	r10
    1c3a:	9f 90       	pop	r9
    1c3c:	8f 90       	pop	r8
    1c3e:	7f 90       	pop	r7
    1c40:	6f 90       	pop	r6
    1c42:	5f 90       	pop	r5
    1c44:	08 95       	ret

00001c46 <checkLockerSensors>:

void checkLockerSensors(void)
{
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
  if (lockSensors[0].enabled)
    1c4a:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c4e:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c52:	80 81       	ld	r24, Z
    1c54:	88 23       	and	r24, r24
    1c56:	39 f1       	breq	.+78     	; 0x1ca6 <checkLockerSensors+0x60>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1c58:	60 e0       	ldi	r22, 0x00	; 0
    1c5a:	80 e4       	ldi	r24, 0x40	; 64
    1c5c:	0e 94 12 26 	call	0x4c24	; 0x4c24 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1c60:	8e e1       	ldi	r24, 0x1E	; 30
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    lockSensors[0].acVal = MCP3008_getSampleSingle(LOCK_SENS_1_AC_IN);
    1c68:	c0 91 a0 0e 	lds	r28, 0x0EA0
    1c6c:	d0 91 a1 0e 	lds	r29, 0x0EA1
    1c70:	84 e0       	ldi	r24, 0x04	; 4
    1c72:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
    1c76:	9c 83       	std	Y+4, r25	; 0x04
    1c78:	8b 83       	std	Y+3, r24	; 0x03
    MPC23s17ClearBitsOnPortA(LOCK_SENS_1_LIGHT, 0);
    1c7a:	60 e0       	ldi	r22, 0x00	; 0
    1c7c:	80 e4       	ldi	r24, 0x40	; 64
    1c7e:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <MPC23s17ClearBitsOnPortA>
    lockSensors[0].locked = (lockSensors[0].acVal > lockSensors[0].threshold) ? 1 : 0;
    1c82:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1c86:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1c8a:	81 e0       	ldi	r24, 0x01	; 1
    1c8c:	43 81       	ldd	r20, Z+3	; 0x03
    1c8e:	54 81       	ldd	r21, Z+4	; 0x04
    1c90:	21 81       	ldd	r18, Z+1	; 0x01
    1c92:	32 81       	ldd	r19, Z+2	; 0x02
    1c94:	24 17       	cp	r18, r20
    1c96:	35 07       	cpc	r19, r21
    1c98:	08 f0       	brcs	.+2      	; 0x1c9c <checkLockerSensors+0x56>
    1c9a:	80 e0       	ldi	r24, 0x00	; 0
    1c9c:	85 83       	std	Z+5, r24	; 0x05
    vTaskDelay(10);
    1c9e:	8a e0       	ldi	r24, 0x0A	; 10
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
  }

  if (lockSensors[1].enabled)
    1ca6:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1caa:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1cae:	86 81       	ldd	r24, Z+6	; 0x06
    1cb0:	88 23       	and	r24, r24
    1cb2:	39 f1       	breq	.+78     	; 0x1d02 <checkLockerSensors+0xbc>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1cb4:	60 e0       	ldi	r22, 0x00	; 0
    1cb6:	80 e2       	ldi	r24, 0x20	; 32
    1cb8:	0e 94 12 26 	call	0x4c24	; 0x4c24 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1cbc:	8e e1       	ldi	r24, 0x1E	; 30
    1cbe:	90 e0       	ldi	r25, 0x00	; 0
    1cc0:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    lockSensors[1].acVal = MCP3008_getSampleSingle(LOCK_SENS_2_AC_IN);
    1cc4:	c0 91 a0 0e 	lds	r28, 0x0EA0
    1cc8:	d0 91 a1 0e 	lds	r29, 0x0EA1
    1ccc:	85 e0       	ldi	r24, 0x05	; 5
    1cce:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
    1cd2:	9a 87       	std	Y+10, r25	; 0x0a
    1cd4:	89 87       	std	Y+9, r24	; 0x09
    MPC23s17ClearBitsOnPortA(LOCK_SENS_2_LIGHT, 0);
    1cd6:	60 e0       	ldi	r22, 0x00	; 0
    1cd8:	80 e2       	ldi	r24, 0x20	; 32
    1cda:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <MPC23s17ClearBitsOnPortA>
    lockSensors[1].locked = (lockSensors[1].acVal > lockSensors[1].threshold) ? 1 : 0;
    1cde:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1ce2:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1ce6:	81 e0       	ldi	r24, 0x01	; 1
    1ce8:	41 85       	ldd	r20, Z+9	; 0x09
    1cea:	52 85       	ldd	r21, Z+10	; 0x0a
    1cec:	27 81       	ldd	r18, Z+7	; 0x07
    1cee:	30 85       	ldd	r19, Z+8	; 0x08
    1cf0:	24 17       	cp	r18, r20
    1cf2:	35 07       	cpc	r19, r21
    1cf4:	08 f0       	brcs	.+2      	; 0x1cf8 <checkLockerSensors+0xb2>
    1cf6:	80 e0       	ldi	r24, 0x00	; 0
    1cf8:	83 87       	std	Z+11, r24	; 0x0b
    vTaskDelay(10);
    1cfa:	8a e0       	ldi	r24, 0x0A	; 10
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
  }

  if (lockSensors[2].enabled)
    1d02:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d06:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d0a:	84 85       	ldd	r24, Z+12	; 0x0c
    1d0c:	88 23       	and	r24, r24
    1d0e:	39 f1       	breq	.+78     	; 0x1d5e <checkLockerSensors+0x118>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1d10:	60 e0       	ldi	r22, 0x00	; 0
    1d12:	80 e1       	ldi	r24, 0x10	; 16
    1d14:	0e 94 12 26 	call	0x4c24	; 0x4c24 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1d18:	8e e1       	ldi	r24, 0x1E	; 30
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    lockSensors[2].acVal = MCP3008_getSampleSingle(LOCK_SENS_3_AC_IN);
    1d20:	c0 91 a0 0e 	lds	r28, 0x0EA0
    1d24:	d0 91 a1 0e 	lds	r29, 0x0EA1
    1d28:	86 e0       	ldi	r24, 0x06	; 6
    1d2a:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
    1d2e:	98 8b       	std	Y+16, r25	; 0x10
    1d30:	8f 87       	std	Y+15, r24	; 0x0f
    MPC23s17ClearBitsOnPortA(LOCK_SENS_3_LIGHT, 0);
    1d32:	60 e0       	ldi	r22, 0x00	; 0
    1d34:	80 e1       	ldi	r24, 0x10	; 16
    1d36:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <MPC23s17ClearBitsOnPortA>
    lockSensors[2].locked = (lockSensors[2].acVal > lockSensors[2].threshold) ? 1 : 0;
    1d3a:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d3e:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	47 85       	ldd	r20, Z+15	; 0x0f
    1d46:	50 89       	ldd	r21, Z+16	; 0x10
    1d48:	25 85       	ldd	r18, Z+13	; 0x0d
    1d4a:	36 85       	ldd	r19, Z+14	; 0x0e
    1d4c:	24 17       	cp	r18, r20
    1d4e:	35 07       	cpc	r19, r21
    1d50:	08 f0       	brcs	.+2      	; 0x1d54 <checkLockerSensors+0x10e>
    1d52:	80 e0       	ldi	r24, 0x00	; 0
    1d54:	81 8b       	std	Z+17, r24	; 0x11
    vTaskDelay(10);
    1d56:	8a e0       	ldi	r24, 0x0A	; 10
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
  }

  if (lockSensors[3].enabled)
    1d5e:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d62:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d66:	82 89       	ldd	r24, Z+18	; 0x12
    1d68:	88 23       	and	r24, r24
    1d6a:	49 f1       	breq	.+82     	; 0x1dbe <checkLockerSensors+0x178>
  {
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1d6c:	60 e0       	ldi	r22, 0x00	; 0
    1d6e:	88 e0       	ldi	r24, 0x08	; 8
    1d70:	0e 94 12 26 	call	0x4c24	; 0x4c24 <MPC23s17SetBitsOnPortA>
    vTaskDelay(30);
    1d74:	8e e1       	ldi	r24, 0x1E	; 30
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    1d7c:	c0 91 a0 0e 	lds	r28, 0x0EA0
    1d80:	d0 91 a1 0e 	lds	r29, 0x0EA1
    1d84:	87 e0       	ldi	r24, 0x07	; 7
    1d86:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
    1d8a:	9e 8b       	std	Y+22, r25	; 0x16
    1d8c:	8d 8b       	std	Y+21, r24	; 0x15
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    1d8e:	60 e0       	ldi	r22, 0x00	; 0
    1d90:	88 e0       	ldi	r24, 0x08	; 8
    1d92:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <MPC23s17ClearBitsOnPortA>
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    1d96:	e0 91 a0 0e 	lds	r30, 0x0EA0
    1d9a:	f0 91 a1 0e 	lds	r31, 0x0EA1
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	45 89       	ldd	r20, Z+21	; 0x15
    1da2:	56 89       	ldd	r21, Z+22	; 0x16
    1da4:	23 89       	ldd	r18, Z+19	; 0x13
    1da6:	34 89       	ldd	r19, Z+20	; 0x14
    1da8:	24 17       	cp	r18, r20
    1daa:	35 07       	cpc	r19, r21
    1dac:	08 f0       	brcs	.+2      	; 0x1db0 <checkLockerSensors+0x16a>
    1dae:	80 e0       	ldi	r24, 0x00	; 0
    1db0:	87 8b       	std	Z+23, r24	; 0x17
    vTaskDelay(10);
    1db2:	8a e0       	ldi	r24, 0x0A	; 10
    1db4:	90 e0       	ldi	r25, 0x00	; 0
  }
}
    1db6:	df 91       	pop	r29
    1db8:	cf 91       	pop	r28
    MPC23s17SetBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    vTaskDelay(30);
    lockSensors[3].acVal = MCP3008_getSampleSingle(LOCK_SENS_4_AC_IN);
    MPC23s17ClearBitsOnPortA(LOCK_SENS_4_LIGHT, 0);
    lockSensors[3].locked = (lockSensors[3].acVal > lockSensors[3].threshold) ? 1 : 0;
    vTaskDelay(10);
    1dba:	0c 94 81 43 	jmp	0x8702	; 0x8702 <vTaskDelay>
  }
}
    1dbe:	df 91       	pop	r29
    1dc0:	cf 91       	pop	r28
    1dc2:	08 95       	ret

00001dc4 <spiSend>:


uint8_t spiSend(uint8_t data)
{
    1dc4:	cf 93       	push	r28
    1dc6:	df 93       	push	r29
    1dc8:	1f 92       	push	r1
    1dca:	cd b7       	in	r28, 0x3d	; 61
    1dcc:	de b7       	in	r29, 0x3e	; 62
  uint8_t result;
  SPDR = data;
    1dce:	8f b9       	out	0x0f, r24	; 15
  xQueueReceive(xSpiRx, &result, 10);
    1dd0:	20 e0       	ldi	r18, 0x00	; 0
    1dd2:	4a e0       	ldi	r20, 0x0A	; 10
    1dd4:	50 e0       	ldi	r21, 0x00	; 0
    1dd6:	be 01       	movw	r22, r28
    1dd8:	6f 5f       	subi	r22, 0xFF	; 255
    1dda:	7f 4f       	sbci	r23, 0xFF	; 255
    1ddc:	80 91 60 0f 	lds	r24, 0x0F60
    1de0:	90 91 61 0f 	lds	r25, 0x0F61
    1de4:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
  return result;
}
    1de8:	89 81       	ldd	r24, Y+1	; 0x01
    1dea:	0f 90       	pop	r0
    1dec:	df 91       	pop	r29
    1dee:	cf 91       	pop	r28
    1df0:	08 95       	ret

00001df2 <spiSendENC>:

uint8_t spiSendENC(uint8_t data)
{
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29
    1df6:	1f 92       	push	r1
    1df8:	cd b7       	in	r28, 0x3d	; 61
    1dfa:	de b7       	in	r29, 0x3e	; 62
  uint8_t result;
  SPDR = data;
    1dfc:	8f b9       	out	0x0f, r24	; 15
  xQueueReceive(xSpiRx, &result, 10);
    1dfe:	20 e0       	ldi	r18, 0x00	; 0
    1e00:	4a e0       	ldi	r20, 0x0A	; 10
    1e02:	50 e0       	ldi	r21, 0x00	; 0
    1e04:	be 01       	movw	r22, r28
    1e06:	6f 5f       	subi	r22, 0xFF	; 255
    1e08:	7f 4f       	sbci	r23, 0xFF	; 255
    1e0a:	80 91 60 0f 	lds	r24, 0x0F60
    1e0e:	90 91 61 0f 	lds	r25, 0x0F61
    1e12:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
  return result;
}
    1e16:	89 81       	ldd	r24, Y+1	; 0x01
    1e18:	0f 90       	pop	r0
    1e1a:	df 91       	pop	r29
    1e1c:	cf 91       	pop	r28
    1e1e:	08 95       	ret

00001e20 <spiSendSpinBlock>:

uint8_t spiSendSpinBlock(uint8_t data)
{
  SPDR = data;
    1e20:	8f b9       	out	0x0f, r24	; 15
  SPCR &= ~(1<<SPIE);                //Disable SPI interrupt
    1e22:	6f 98       	cbi	0x0d, 7	; 13
  while(!(SPSR&(1<<SPIF)));
    1e24:	77 9b       	sbis	0x0e, 7	; 14
    1e26:	fe cf       	rjmp	.-4      	; 0x1e24 <spiSendSpinBlock+0x4>
  data = SPSR;                       //Clearing interrupt flag
    1e28:	8e b1       	in	r24, 0x0e	; 14
  data = SPDR;                       //Resfing DPI buffer register
    1e2a:	8f b1       	in	r24, 0x0f	; 15
  SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
    1e2c:	6f 9a       	sbi	0x0d, 7	; 13
  return data;
}
    1e2e:	08 95       	ret

00001e30 <spiSendENCSpinBlock>:

uint8_t spiSendENCSpinBlock(uint8_t data)
{
  SPDR = data;
    1e30:	8f b9       	out	0x0f, r24	; 15
  SPCR &= ~(1<<SPIE);                //Disable SPI interrupt
    1e32:	6f 98       	cbi	0x0d, 7	; 13
  while(!(SPSR&(1<<SPIF)));
    1e34:	77 9b       	sbis	0x0e, 7	; 14
    1e36:	fe cf       	rjmp	.-4      	; 0x1e34 <spiSendENCSpinBlock+0x4>
  data = SPSR;                       //Clearing interrupt flag
    1e38:	8e b1       	in	r24, 0x0e	; 14
  data = SPDR;                       //Resfing DPI buffer register
    1e3a:	8f b1       	in	r24, 0x0f	; 15
  SPCR |= (1<<SPIE);                 //Enable SPI Interrupt
    1e3c:	6f 9a       	sbi	0x0d, 7	; 13
  return data;
}
    1e3e:	08 95       	ret

00001e40 <disableAllSpiDevices>:
#error Port A is memory bus
  PORTA &= disableSpiPORTA_AND;
#endif

#if disableSpiPORTB_OR != 0
  PORTB |= disableSpiPORTB_OR;
    1e40:	88 b3       	in	r24, 0x18	; 24
    1e42:	80 6c       	ori	r24, 0xC0	; 192
    1e44:	88 bb       	out	0x18, r24	; 24
#endif
#if disableSpiPORTB_AND != 0xFF
  PORTB &= disableSpiPORTB_AND;
    1e46:	c5 98       	cbi	0x18, 5	; 24
#endif
#if disableSpiPORTD_AND != 0xFF
  PORTD &= disableSpiPORTD_AND;
#endif
#if disableSpiPORTE_OR != 0
  PORTE |= disableSpiPORTE_OR;
    1e48:	1b 9a       	sbi	0x03, 3	; 3
#if disableSpiPORTF_AND != 0xFF
  PORTF &= disableSpiPORTF_AND;
#endif

#if disableSpiPORTG_OR != 0
  PORTG |= disableSpiPORTG_OR;
    1e4a:	e5 e6       	ldi	r30, 0x65	; 101
    1e4c:	f0 e0       	ldi	r31, 0x00	; 0
    1e4e:	80 81       	ld	r24, Z
    1e50:	88 60       	ori	r24, 0x08	; 8
    1e52:	80 83       	st	Z, r24
    1e54:	08 95       	ret

00001e56 <spiEnableEnc28j60>:
{
#if ENC_SPI_CS_EN_MASK_OR != 0
  ENC_SPI_CS_PORT |= ENC_SPI_CS_EN_MASK_OR;
#endif
#if ENC_SPI_CS_EN_MASK_AND != 0xFF
  ENC_SPI_CS_PORT &= ENC_SPI_CS_EN_MASK_AND;
    1e56:	1b 98       	cbi	0x03, 3	; 3
    1e58:	08 95       	ret

00001e5a <spiDisableEnc28j60>:
{
#if ENC_SPI_CS_EN_MASK_OR != 0
  ENC_SPI_CS_PORT &= (~ENC_SPI_CS_EN_MASK_OR);
#endif
#if ENC_SPI_CS_EN_MASK_AND != 0xFF
  ENC_SPI_CS_PORT |= (~ENC_SPI_CS_EN_MASK_AND);
    1e5a:	1b 9a       	sbi	0x03, 3	; 3
    1e5c:	08 95       	ret

00001e5e <enableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT |= SD_SPI_CS_EN_MASK_OR;
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT &= SD_SPI_CS_EN_MASK_AND;
    1e5e:	e5 e6       	ldi	r30, 0x65	; 101
    1e60:	f0 e0       	ldi	r31, 0x00	; 0
    1e62:	80 81       	ld	r24, Z
    1e64:	87 7f       	andi	r24, 0xF7	; 247
    1e66:	80 83       	st	Z, r24
    1e68:	08 95       	ret

00001e6a <disableSpiSd>:
{
#if SD_SPI_CS_EN_MASK_OR != 0
  SD_SPI_CS_PORT &= (~SD_SPI_CS_EN_MASK_OR);
#endif
#if SD_SPI_CS_EN_MASK_AND != 0xFF
  SD_SPI_CS_PORT |= (~SD_SPI_CS_EN_MASK_AND);
    1e6a:	e5 e6       	ldi	r30, 0x65	; 101
    1e6c:	f0 e0       	ldi	r31, 0x00	; 0
    1e6e:	80 81       	ld	r24, Z
    1e70:	88 60       	ori	r24, 0x08	; 8
    1e72:	80 83       	st	Z, r24
    1e74:	08 95       	ret

00001e76 <enableSpiMPC23S17>:
{
#if MCP23S17_SPI_CS_EN_MASK_OR != 0
  MCP23S17_SPI_CS_PORT |= MCP23S17_SPI_CS_EN_MASK_OR;
#endif
#if MCP23S17_SPI_CS_EN_MASK_AND != 0xFF
  MPC23S17_SPI_CS_PORT &= MPC23S17_SPI_CS_EN_MASK_AND;
    1e76:	c7 98       	cbi	0x18, 7	; 24
    1e78:	08 95       	ret

00001e7a <disableSpiMPC23S17>:
{
#if MCP23S17_SPI_CS_EN_MASK_OR != 0
  MCP23S17_SPI_CS_PORT &= (~MCP23S17_SPI_CS_EN_MASK_OR);
#endif
#if MCP23S17_SPI_CS_EN_MASK_AND != 0xFF
  MPC23S17_SPI_CS_PORT |= (~MPC23S17_SPI_CS_EN_MASK_AND);
    1e7a:	c7 9a       	sbi	0x18, 7	; 24
    1e7c:	08 95       	ret

00001e7e <enableSpiMCP3008>:
}

#define MCP3008_SPCR_OR_MASK ((1<<SPR1)|(1<<SPR0))
void enableSpiMCP3008(void)
{
  SPCR |= MCP3008_SPCR_OR_MASK;
    1e7e:	8d b1       	in	r24, 0x0d	; 13
    1e80:	83 60       	ori	r24, 0x03	; 3
    1e82:	8d b9       	out	0x0d, r24	; 13
#if MCP3008_SPI_CS_EN_MASK_OR != 0
  MCP3008_SPI_CS_PORT |= MCP3008_SPI_CS_EN_MASK_OR;
#endif
#if MCP3008_SPI_CS_EN_MASK_AND != 0xFF
  MCP3008_SPI_CS_PORT &= MCP3008_SPI_CS_EN_MASK_AND;
    1e84:	c6 98       	cbi	0x18, 6	; 24
    1e86:	08 95       	ret

00001e88 <disableSpiMCP3008>:

}

void disableSpiMCP3008(void)
{
  SPCR &= ~MCP3008_SPCR_OR_MASK;
    1e88:	8d b1       	in	r24, 0x0d	; 13
    1e8a:	8c 7f       	andi	r24, 0xFC	; 252
    1e8c:	8d b9       	out	0x0d, r24	; 13
  #if MCP3008_SPI_CS_EN_MASK_OR != 0
  MCP3008_SPI_CS_PORT &= (~MCP3008_SPI_CS_EN_MASK_OR);
#endif
#if MCP3008_SPI_CS_EN_MASK_AND != 0xFF
  MCP3008_SPI_CS_PORT |= (~MCP3008_SPI_CS_EN_MASK_AND);
    1e8e:	c6 9a       	sbi	0x18, 6	; 24
    1e90:	08 95       	ret

00001e92 <enableSpiMCP4150>:


#define MCP4150_SPCR_OR_MASK ((1<<SPR1)|(1<<SPR0))
void enableSpiMCP4150(void)
{
  SPCR |= MCP4150_SPCR_OR_MASK;
    1e92:	8d b1       	in	r24, 0x0d	; 13
    1e94:	83 60       	ori	r24, 0x03	; 3
    1e96:	8d b9       	out	0x0d, r24	; 13
#if MCP4150_SPI_CS_EN_MASK_OR != 0
  MCP4150_SPI_CS_PORT |= MCP4150_SPI_CS_EN_MASK_OR;
#endif
#if MCP4150_SPI_CS_EN_MASK_AND != 0xFF
  MCP4150_SPI_CS_PORT &= MCP4150_SPI_CS_EN_MASK_AND;
    1e98:	c6 98       	cbi	0x18, 6	; 24
    1e9a:	08 95       	ret

00001e9c <disableSpiMCP4150>:
#endif
}
void disableSpiMCP4150(void)
{
  SPCR &= ~MCP4150_SPCR_OR_MASK;
    1e9c:	8d b1       	in	r24, 0x0d	; 13
    1e9e:	8c 7f       	andi	r24, 0xFC	; 252
    1ea0:	8d b9       	out	0x0d, r24	; 13
  #if MCP4150_SPI_CS_EN_MASK_OR != 0
  MCP4150_SPI_CS_PORT &= (~MCP4150_SPI_CS_EN_MASK_OR);
#endif
#if MCP4150_SPI_CS_EN_MASK_AND != 0xFF
  MCP4150_SPI_CS_PORT |= (~MCP4150_SPI_CS_EN_MASK_AND);
    1ea2:	c6 9a       	sbi	0x18, 6	; 24
    1ea4:	08 95       	ret

00001ea6 <spiEnableDS1305>:

#define DS_SPCR_OR_MASK ((1<<CPHA)|(1<<SPR0))

void spiEnableDS1305(void)
{
  SPCR |= DS_SPCR_OR_MASK;
    1ea6:	8d b1       	in	r24, 0x0d	; 13
    1ea8:	85 60       	ori	r24, 0x05	; 5
    1eaa:	8d b9       	out	0x0d, r24	; 13
#if DS1305_SPI_CS_EN_MASK_OR != 0
  DS1305_SPI_CS_PORT |= DS1305_SPI_CS_EN_MASK_OR;
    1eac:	c5 9a       	sbi	0x18, 5	; 24
    1eae:	08 95       	ret

00001eb0 <spiDisableDS1305>:
#endif
}

void spiDisableDS1305(void)
{
  SPCR &= (~(DS_SPCR_OR_MASK));
    1eb0:	8d b1       	in	r24, 0x0d	; 13
    1eb2:	8a 7f       	andi	r24, 0xFA	; 250
    1eb4:	8d b9       	out	0x0d, r24	; 13
#if DS1305_SPI_CS_EN_MASK_OR != 0
  DS1305_SPI_CS_PORT &= (~(DS1305_SPI_CS_EN_MASK_OR));
    1eb6:	c5 98       	cbi	0x18, 5	; 24
    1eb8:	08 95       	ret

00001eba <__vector_17>:
  DS1305_SPI_CS_PORT |= (~(DS1305_SPI_CS_EN_MASK_AND));
#endif
}

ISR(SPI_STC_vect)
{
    1eba:	1f 92       	push	r1
    1ebc:	0f 92       	push	r0
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	0f 92       	push	r0
    1ec2:	11 24       	eor	r1, r1
    1ec4:	0b b6       	in	r0, 0x3b	; 59
    1ec6:	0f 92       	push	r0
    1ec8:	2f 93       	push	r18
    1eca:	3f 93       	push	r19
    1ecc:	4f 93       	push	r20
    1ece:	5f 93       	push	r21
    1ed0:	6f 93       	push	r22
    1ed2:	7f 93       	push	r23
    1ed4:	8f 93       	push	r24
    1ed6:	9f 93       	push	r25
    1ed8:	af 93       	push	r26
    1eda:	bf 93       	push	r27
    1edc:	ef 93       	push	r30
    1ede:	ff 93       	push	r31
  static signed portBASE_TYPE xHigherPriorityTaskWoken;

  static uint8_t data;
  data = SPDR;
    1ee0:	8f b1       	in	r24, 0x0f	; 15
    1ee2:	80 93 8f 01 	sts	0x018F, r24

  xQueueSendFromISR(xSpiRx, &data, &xHigherPriorityTaskWoken);
    1ee6:	20 e0       	ldi	r18, 0x00	; 0
    1ee8:	4e e8       	ldi	r20, 0x8E	; 142
    1eea:	51 e0       	ldi	r21, 0x01	; 1
    1eec:	6f e8       	ldi	r22, 0x8F	; 143
    1eee:	71 e0       	ldi	r23, 0x01	; 1
    1ef0:	80 91 60 0f 	lds	r24, 0x0F60
    1ef4:	90 91 61 0f 	lds	r25, 0x0F61
    1ef8:	0e 94 36 47 	call	0x8e6c	; 0x8e6c <xQueueGenericSendFromISR>

  if( xHigherPriorityTaskWoken )
    1efc:	80 91 8e 01 	lds	r24, 0x018E
    1f00:	81 11       	cpse	r24, r1
  {
    taskYIELD();
    1f02:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
  }

  //clear SPI interrupt SPI |= 1;
}
    1f06:	ff 91       	pop	r31
    1f08:	ef 91       	pop	r30
    1f0a:	bf 91       	pop	r27
    1f0c:	af 91       	pop	r26
    1f0e:	9f 91       	pop	r25
    1f10:	8f 91       	pop	r24
    1f12:	7f 91       	pop	r23
    1f14:	6f 91       	pop	r22
    1f16:	5f 91       	pop	r21
    1f18:	4f 91       	pop	r20
    1f1a:	3f 91       	pop	r19
    1f1c:	2f 91       	pop	r18
    1f1e:	0f 90       	pop	r0
    1f20:	0b be       	out	0x3b, r0	; 59
    1f22:	0f 90       	pop	r0
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	0f 90       	pop	r0
    1f28:	1f 90       	pop	r1
    1f2a:	18 95       	reti

00001f2c <sensorsTaskInit>:



void sensorsTaskInit(void)
{
  LockersMemInit();
    1f2c:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <LockersMemInit>
  rollersMemInit();
    1f30:	0c 94 f4 38 	jmp	0x71e8	; 0x71e8 <rollersMemInit>

00001f34 <sensorsTask>:
{
  (void) pvParameters;
  uint8_t addr = 255;
//  uint8_t i;

  MPC23s17SetDirA(0x00, 0);
    1f34:	60 e0       	ldi	r22, 0x00	; 0
    1f36:	80 e0       	ldi	r24, 0x00	; 0
    1f38:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <MPC23s17SetDirA>

  MPC23s17SetDirB(0x00, 0);
    1f3c:	60 e0       	ldi	r22, 0x00	; 0
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
    1f40:	0e 94 d4 25 	call	0x4ba8	; 0x4ba8 <MPC23s17SetDirB>
    voltage = (uint8_t)(tmp>>5);
    vTaskDelay(10);

    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    tmp *=10;
    1f44:	da e0       	ldi	r29, 0x0A	; 10
    temperature = (uint8_t)(tmp / 24);
    1f46:	08 e1       	ldi	r16, 0x18	; 24
    1f48:	10 e0       	ldi	r17, 0x00	; 0

  for( ; ; )
  {
    uint16_t tmp;
    //Read power suply voltage
    tmp = MCP3008_getSampleSingle(0);
    1f4a:	80 e0       	ldi	r24, 0x00	; 0
    1f4c:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
    voltage = (uint8_t)(tmp>>5);
    1f50:	25 e0       	ldi	r18, 0x05	; 5
    1f52:	96 95       	lsr	r25
    1f54:	87 95       	ror	r24
    1f56:	2a 95       	dec	r18
    1f58:	e1 f7       	brne	.-8      	; 0x1f52 <sensorsTask+0x1e>
    1f5a:	80 93 ae 0e 	sts	0x0EAE, r24
    vTaskDelay(10);
    1f5e:	8a e0       	ldi	r24, 0x0A	; 10
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>

    //Read temperature inside chasis
    tmp = MCP3008_getSampleSingle(1);
    1f66:	81 e0       	ldi	r24, 0x01	; 1
    1f68:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
    tmp *=10;
    1f6c:	9c 01       	movw	r18, r24
    1f6e:	d2 9f       	mul	r29, r18
    1f70:	c0 01       	movw	r24, r0
    1f72:	d3 9f       	mul	r29, r19
    1f74:	90 0d       	add	r25, r0
    1f76:	11 24       	eor	r1, r1
    temperature = (uint8_t)(tmp / 24);
    1f78:	b8 01       	movw	r22, r16
    1f7a:	0e 94 e3 4c 	call	0x99c6	; 0x99c6 <__udivmodhi4>
    1f7e:	60 93 a4 0e 	sts	0x0EA4, r22
    vTaskDelay(10);
    1f82:	8a e0       	ldi	r24, 0x0A	; 10
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>

    //read lock
    checkLockerSensors();
    1f8a:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <checkLockerSensors>

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1f8e:	c1 e0       	ldi	r28, 0x01	; 1
    {
      rs485rollerHello(addr);
    1f90:	8c 2f       	mov	r24, r28
    1f92:	0e 94 41 3a 	call	0x7482	; 0x7482 <rs485rollerHello>
      vTaskDelay(10);
    1f96:	8a e0       	ldi	r24, 0x0A	; 10
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    vTaskDelay(10);

    //read lock
    checkLockerSensors();

    for (addr = FIRST_ROLLER_DRIVER_ADDR; addr <= LAST_ROLLER_DRIVER_ADDR; addr++)
    1f9e:	cf 5f       	subi	r28, 0xFF	; 255
    1fa0:	c0 32       	cpi	r28, 0x20	; 32
    1fa2:	b1 f7       	brne	.-20     	; 0x1f90 <sensorsTask+0x5c>
    1fa4:	d2 cf       	rjmp	.-92     	; 0x1f4a <sensorsTask+0x16>

00001fa6 <enableFunction>:
  state->err1 = 0;
  state->err2 = 0;
}

static cliExRes_t enableFunction(cmdState_t *state)
{
    1fa6:	fc 01       	movw	r30, r24
  if (state->cliMode != RESTRICTED_NORMAL)
    1fa8:	80 a1       	ldd	r24, Z+32	; 0x20
    1faa:	83 30       	cpi	r24, 0x03	; 3
    1fac:	49 f0       	breq	.+18     	; 0x1fc0 <enableFunction+0x1a>
  {
    state->cmdList = cmdListEnable;
    1fae:	88 ed       	ldi	r24, 0xD8	; 216
    1fb0:	91 e0       	ldi	r25, 0x01	; 1
    1fb2:	92 a3       	std	Z+34, r25	; 0x22
    1fb4:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_ENABLE;
    1fb6:	81 e0       	ldi	r24, 0x01	; 1
    1fb8:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1fba:	80 e0       	ldi	r24, 0x00	; 0
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	08 95       	ret
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1fc0:	85 e0       	ldi	r24, 0x05	; 5
    1fc2:	90 e0       	ldi	r25, 0x00	; 0
}
    1fc4:	08 95       	ret

00001fc6 <disableFunction>:
static cliExRes_t disableFunction(cmdState_t *state)
{
    1fc6:	fc 01       	movw	r30, r24
  state->cmdList = cmdListNormal;
    1fc8:	8a e7       	ldi	r24, 0x7A	; 122
    1fca:	92 e0       	ldi	r25, 0x02	; 2
    1fcc:	92 a3       	std	Z+34, r25	; 0x22
    1fce:	81 a3       	std	Z+33, r24	; 0x21
  if (state->cliMode != RESTRICTED_NORMAL)
    1fd0:	80 a1       	ldd	r24, Z+32	; 0x20
    1fd2:	83 30       	cpi	r24, 0x03	; 3
    1fd4:	09 f0       	breq	.+2      	; 0x1fd8 <disableFunction+0x12>
  {
    state->cliMode = NR_NORMAL;
    1fd6:	10 a2       	std	Z+32, r1	; 0x20
  }
  return OK_SILENT;
}
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	08 95       	ret

00001fde <configureModeFunction>:
static cliExRes_t configureModeFunction(cmdState_t *state)
{
    1fde:	fc 01       	movw	r30, r24
  if (state->cliMode == NR_ENABLE)
    1fe0:	80 a1       	ldd	r24, Z+32	; 0x20
    1fe2:	81 30       	cpi	r24, 0x01	; 1
    1fe4:	49 f4       	brne	.+18     	; 0x1ff8 <configureModeFunction+0x1a>
  {
    state->cmdList = cmdListConfigure;
    1fe6:	8a e8       	ldi	r24, 0x8A	; 138
    1fe8:	91 e0       	ldi	r25, 0x01	; 1
    1fea:	92 a3       	std	Z+34, r25	; 0x22
    1fec:	81 a3       	std	Z+33, r24	; 0x21
    state->cliMode = NR_CONFIGURE;
    1fee:	82 e0       	ldi	r24, 0x02	; 2
    1ff0:	80 a3       	std	Z+32, r24	; 0x20
    return OK_SILENT;
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
    1ff4:	90 e0       	ldi	r25, 0x00	; 0
    1ff6:	08 95       	ret
  }
  return ERROR_OPERATION_NOT_ALLOWED;
    1ff8:	85 e0       	ldi	r24, 0x05	; 5
    1ffa:	90 e0       	ldi	r25, 0x00	; 0
}
    1ffc:	08 95       	ret

00001ffe <pingFunction>:
  return OK_SILENT;
}

static cliExRes_t pingFunction(cmdState_t *state)
{
  if (state->argc < 4)
    1ffe:	fc 01       	movw	r30, r24
    2000:	81 8d       	ldd	r24, Z+25	; 0x19
    2002:	84 30       	cpi	r24, 0x04	; 4
    2004:	18 f0       	brcs	.+6      	; 0x200c <pingFunction+0xe>
  //ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
  //ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
  //ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
  //Ipv4Ping(*((uint32_t *)(ip)));

  return OK_SILENT;
    2006:	80 e0       	ldi	r24, 0x00	; 0
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	08 95       	ret
}

static cliExRes_t pingFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    200c:	82 e0       	ldi	r24, 0x02	; 2
    200e:	90 e0       	ldi	r25, 0x00	; 0
  //ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
  //ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
  //Ipv4Ping(*((uint32_t *)(ip)));

  return OK_SILENT;
}
    2010:	08 95       	ret

00002012 <readRamFIleFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
{
    2012:	ff 92       	push	r15
    2014:	0f 93       	push	r16
    2016:	1f 93       	push	r17
    2018:	cf 93       	push	r28
    201a:	df 93       	push	r29
    201c:	1f 92       	push	r1
    201e:	cd b7       	in	r28, 0x3d	; 61
    2020:	de b7       	in	r29, 0x3e	; 62
    2022:	8c 01       	movw	r16, r24
  uint8_t rezultat;
  uint8_t znak = ' ';
    2024:	80 e2       	ldi	r24, 0x20	; 32
    2026:	89 83       	std	Y+1, r24	; 0x01
  if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
    2028:	b8 01       	movw	r22, r16
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2030:	62 e6       	ldi	r22, 0x62	; 98
    2032:	7f e0       	ldi	r23, 0x0F	; 15
    2034:	0e 94 bd 1b 	call	0x377a	; 0x377a <ramDyskOtworzPlik>
    2038:	88 23       	and	r24, r24
    203a:	d1 f0       	breq	.+52     	; 0x2070 <readRamFIleFunction+0x5e>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    203c:	b8 01       	movw	r22, r16
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2044:	9f 93       	push	r25
    2046:	8f 93       	push	r24
    2048:	8e ea       	ldi	r24, 0xAE	; 174
    204a:	9a e0       	ldi	r25, 0x0A	; 10
    204c:	9f 93       	push	r25
    204e:	8f 93       	push	r24
    2050:	f8 01       	movw	r30, r16
    2052:	83 8d       	ldd	r24, Z+27	; 0x1b
    2054:	8f 93       	push	r24
    2056:	82 8d       	ldd	r24, Z+26	; 0x1a
    2058:	8f 93       	push	r24
    205a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    return ERROR_INFORM;
    205e:	0f 90       	pop	r0
    2060:	0f 90       	pop	r0
    2062:	0f 90       	pop	r0
    2064:	0f 90       	pop	r0
    2066:	0f 90       	pop	r0
    2068:	0f 90       	pop	r0
    206a:	84 e0       	ldi	r24, 0x04	; 4
    206c:	90 e0       	ldi	r25, 0x00	; 0
    206e:	46 c0       	rjmp	.+140    	; 0x20fc <readRamFIleFunction+0xea>
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
    2070:	e0 91 66 0f 	lds	r30, 0x0F66
    2074:	f0 91 67 0f 	lds	r31, 0x0F67
    2078:	82 81       	ldd	r24, Z+2	; 0x02
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	98 2f       	mov	r25, r24
    207e:	88 27       	eor	r24, r24
    2080:	21 81       	ldd	r18, Z+1	; 0x01
    2082:	82 0f       	add	r24, r18
    2084:	91 1d       	adc	r25, r1
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
    2086:	9f 93       	push	r25
    2088:	8f 93       	push	r24
    208a:	83 ec       	ldi	r24, 0xC3	; 195
    208c:	98 e0       	ldi	r25, 0x08	; 8
    208e:	9f 93       	push	r25
    2090:	8f 93       	push	r24
    2092:	f8 01       	movw	r30, r16
    2094:	83 8d       	ldd	r24, Z+27	; 0x1b
    2096:	8f 93       	push	r24
    2098:	82 8d       	ldd	r24, Z+26	; 0x1a
    209a:	8f 93       	push	r24
    209c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    20a0:	0f 90       	pop	r0
    20a2:	0f 90       	pop	r0
    20a4:	0f 90       	pop	r0
    20a6:	0f 90       	pop	r0
    20a8:	0f 90       	pop	r0
    20aa:	0f 90       	pop	r0
  while (rezultat == 0)
  {
    rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
    20ac:	be 01       	movw	r22, r28
    20ae:	6f 5f       	subi	r22, 0xFF	; 255
    20b0:	7f 4f       	sbci	r23, 0xFF	; 255
    20b2:	82 e6       	ldi	r24, 0x62	; 98
    20b4:	9f e0       	ldi	r25, 0x0F	; 15
    20b6:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <ramDyskCzytajBajtZPliku>
    20ba:	f8 2e       	mov	r15, r24

    uartVtySendByte(znak);
    20bc:	89 81       	ldd	r24, Y+1	; 0x01
    20be:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
    if (znak == '\r')
    20c2:	89 81       	ldd	r24, Y+1	; 0x01
    20c4:	8d 30       	cpi	r24, 0x0D	; 13
    20c6:	19 f4       	brne	.+6      	; 0x20ce <readRamFIleFunction+0xbc>
      uartVtySendByte('\n');
    20c8:	8a e0       	ldi	r24, 0x0A	; 10
    20ca:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    return ERROR_INFORM;
  }
  uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
  fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
  while (rezultat == 0)
    20ce:	ff 20       	and	r15, r15
    20d0:	69 f3       	breq	.-38     	; 0x20ac <readRamFIleFunction+0x9a>

    uartVtySendByte(znak);
    if (znak == '\r')
      uartVtySendByte('\n');
  }
  fprintf_P(state->myStdInOut, nlStr);
    20d2:	82 ef       	ldi	r24, 0xF2	; 242
    20d4:	92 e0       	ldi	r25, 0x02	; 2
    20d6:	9f 93       	push	r25
    20d8:	8f 93       	push	r24
    20da:	f8 01       	movw	r30, r16
    20dc:	83 8d       	ldd	r24, Z+27	; 0x1b
    20de:	8f 93       	push	r24
    20e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20e2:	8f 93       	push	r24
    20e4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  ramDyskZamknijPlik(&fdVty);
    20e8:	82 e6       	ldi	r24, 0x62	; 98
    20ea:	9f e0       	ldi	r25, 0x0F	; 15
    20ec:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <ramDyskZamknijPlik>
  return OK_SILENT;
    20f0:	0f 90       	pop	r0
    20f2:	0f 90       	pop	r0
    20f4:	0f 90       	pop	r0
    20f6:	0f 90       	pop	r0
    20f8:	80 e0       	ldi	r24, 0x00	; 0
    20fa:	90 e0       	ldi	r25, 0x00	; 0
}
    20fc:	0f 90       	pop	r0
    20fe:	df 91       	pop	r29
    2100:	cf 91       	pop	r28
    2102:	1f 91       	pop	r17
    2104:	0f 91       	pop	r16
    2106:	ff 90       	pop	r15
    2108:	08 95       	ret

0000210a <writeRamFileFunction>:
  return ERROR_INFORM;
}

static cliExRes_t writeRamFileFunction(cmdState_t *state)
{
  ramDyskDir(state->myStdInOut);
    210a:	fc 01       	movw	r30, r24
    210c:	82 8d       	ldd	r24, Z+26	; 0x1a
    210e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2110:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <ramDyskDir>
  return OK_SILENT;
}
    2114:	80 e0       	ldi	r24, 0x00	; 0
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	08 95       	ret

0000211a <pokazCzasFunction>:
  nicRegDump(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
    211a:	cf 93       	push	r28
    211c:	df 93       	push	r29
    211e:	ec 01       	movw	r28, r24
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
    2120:	83 eb       	ldi	r24, 0xB3	; 179
    2122:	9e e0       	ldi	r25, 0x0E	; 14
    2124:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <readTimeDecoded>
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
    2128:	e5 eb       	ldi	r30, 0xB5	; 181
    212a:	fe e0       	ldi	r31, 0x0E	; 14
    212c:	90 81       	ld	r25, Z
    212e:	96 95       	lsr	r25
    2130:	96 95       	lsr	r25
    2132:	96 95       	lsr	r25
    2134:	80 81       	ld	r24, Z
    2136:	8f 70       	andi	r24, 0x0F	; 15
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2138:	e4 eb       	ldi	r30, 0xB4	; 180
    213a:	fe e0       	ldi	r31, 0x0E	; 14
    213c:	20 81       	ld	r18, Z
    213e:	26 95       	lsr	r18
    2140:	26 95       	lsr	r18
    2142:	26 95       	lsr	r18
    2144:	40 81       	ld	r20, Z
    2146:	4f 70       	andi	r20, 0x0F	; 15
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
    2148:	e3 eb       	ldi	r30, 0xB3	; 179
    214a:	fe e0       	ldi	r31, 0x0E	; 14
    214c:	30 81       	ld	r19, Z
    214e:	36 95       	lsr	r19
    2150:	36 95       	lsr	r19
    2152:	36 95       	lsr	r19
    2154:	50 81       	ld	r21, Z
    2156:	5f 70       	andi	r21, 0x0F	; 15
    2158:	3e 70       	andi	r19, 0x0E	; 14
    215a:	63 2f       	mov	r22, r19
    215c:	66 0f       	add	r22, r22
    215e:	66 0f       	add	r22, r22
    2160:	36 0f       	add	r19, r22
    2162:	35 0f       	add	r19, r21
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2164:	1f 92       	push	r1
    2166:	3f 93       	push	r19

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
    2168:	2e 70       	andi	r18, 0x0E	; 14
    216a:	32 2f       	mov	r19, r18
    216c:	33 0f       	add	r19, r19
    216e:	33 0f       	add	r19, r19
    2170:	23 0f       	add	r18, r19
    2172:	24 0f       	add	r18, r20
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2174:	1f 92       	push	r1
    2176:	2f 93       	push	r18
}

static cliExRes_t pokazCzasFunction(cmdState_t *state)
{
  readTimeDecoded((timeDecoded_t *)(&czasRtc));
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
    2178:	96 70       	andi	r25, 0x06	; 6
    217a:	29 2f       	mov	r18, r25
    217c:	22 0f       	add	r18, r18
    217e:	22 0f       	add	r18, r18
    2180:	92 0f       	add	r25, r18
    2182:	98 0f       	add	r25, r24
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
    2184:	1f 92       	push	r1
    2186:	9f 93       	push	r25
    2188:	81 e7       	ldi	r24, 0x71	; 113
    218a:	91 e0       	ldi	r25, 0x01	; 1
    218c:	9f 93       	push	r25
    218e:	8f 93       	push	r24
    2190:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2192:	8f 93       	push	r24
    2194:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2196:	8f 93       	push	r24
    2198:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  return OK_SILENT;
    219c:	8d b7       	in	r24, 0x3d	; 61
    219e:	9e b7       	in	r25, 0x3e	; 62
    21a0:	0a 96       	adiw	r24, 0x0a	; 10
    21a2:	0f b6       	in	r0, 0x3f	; 63
    21a4:	f8 94       	cli
    21a6:	9e bf       	out	0x3e, r25	; 62
    21a8:	0f be       	out	0x3f, r0	; 63
    21aa:	8d bf       	out	0x3d, r24	; 61
}
    21ac:	80 e0       	ldi	r24, 0x00	; 0
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	df 91       	pop	r29
    21b2:	cf 91       	pop	r28
    21b4:	08 95       	ret

000021b6 <helpFunction>:
  return OK_SILENT;
}

static cliExRes_t helpFunction(cmdState_t *state)
{
  cmdPrintHelp(state);
    21b6:	0e 94 2d 24 	call	0x485a	; 0x485a <cmdPrintHelp>
  return OK_SILENT;
}
    21ba:	80 e0       	ldi	r24, 0x00	; 0
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	08 95       	ret

000021c0 <czytajAC_Function>:
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}

static cliExRes_t czytajAC_Function(cmdState_t *state)
{
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	cf 93       	push	r28
    21c6:	df 93       	push	r29
    21c8:	1f 92       	push	r1
    21ca:	cd b7       	in	r28, 0x3d	; 61
    21cc:	de b7       	in	r29, 0x3e	; 62
    21ce:	8c 01       	movw	r16, r24
  uint8_t nrWejscia = cmdlineGetArgInt(1, state);
    21d0:	bc 01       	movw	r22, r24
    21d2:	81 e0       	ldi	r24, 0x01	; 1
    21d4:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
  uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
    21d8:	86 2f       	mov	r24, r22
    21da:	69 83       	std	Y+1, r22	; 0x01
    21dc:	0e 94 08 27 	call	0x4e10	; 0x4e10 <MCP3008_getSampleSingle>
  fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);
    21e0:	9f 93       	push	r25
    21e2:	8f 93       	push	r24
    21e4:	1f 92       	push	r1
    21e6:	69 81       	ldd	r22, Y+1	; 0x01
    21e8:	6f 93       	push	r22
    21ea:	8e e4       	ldi	r24, 0x4E	; 78
    21ec:	91 e0       	ldi	r25, 0x01	; 1
    21ee:	9f 93       	push	r25
    21f0:	8f 93       	push	r24
    21f2:	f8 01       	movw	r30, r16
    21f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    21f6:	8f 93       	push	r24
    21f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    21fa:	8f 93       	push	r24
    21fc:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  return OK_SILENT;
    2200:	0f b6       	in	r0, 0x3f	; 63
    2202:	f8 94       	cli
    2204:	de bf       	out	0x3e, r29	; 62
    2206:	0f be       	out	0x3f, r0	; 63
    2208:	cd bf       	out	0x3d, r28	; 61
}
    220a:	80 e0       	ldi	r24, 0x00	; 0
    220c:	90 e0       	ldi	r25, 0x00	; 0
    220e:	0f 90       	pop	r0
    2210:	df 91       	pop	r29
    2212:	cf 91       	pop	r28
    2214:	1f 91       	pop	r17
    2216:	0f 91       	pop	r16
    2218:	08 95       	ret

0000221a <setTimeFunction>:
  return SYNTAX_ERROR;
}


static cliExRes_t setTimeFunction(cmdState_t *state)
{
    221a:	ef 92       	push	r14
    221c:	ff 92       	push	r15
    221e:	1f 93       	push	r17
    2220:	cf 93       	push	r28
    2222:	df 93       	push	r29
    2224:	7c 01       	movw	r14, r24
  uint8_t godzina =  cmdlineGetArgInt(1, state);
    2226:	bc 01       	movw	r22, r24
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    222e:	16 2f       	mov	r17, r22
  uint8_t minuta  =  cmdlineGetArgInt(2, state);
    2230:	b7 01       	movw	r22, r14
    2232:	82 e0       	ldi	r24, 0x02	; 2
    2234:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2238:	d6 2f       	mov	r29, r22
  uint8_t sekunda =  cmdlineGetArgInt(3, state);
    223a:	b7 01       	movw	r22, r14
    223c:	83 e0       	ldi	r24, 0x03	; 3
    223e:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2242:	c6 2f       	mov	r28, r22

  ds1305start();
    2244:	0e 94 3f 25 	call	0x4a7e	; 0x4a7e <ds1305start>

  uint8_t cDzies = godzina/10;
    2248:	4a e0       	ldi	r20, 0x0A	; 10
    224a:	81 2f       	mov	r24, r17
    224c:	64 2f       	mov	r22, r20
    224e:	0e 94 d7 4c 	call	0x99ae	; 0x99ae <__udivmodqi4>
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
    2252:	98 2f       	mov	r25, r24
    2254:	93 70       	andi	r25, 0x03	; 3
    2256:	e5 eb       	ldi	r30, 0xB5	; 181
    2258:	fe e0       	ldi	r31, 0x0E	; 14
    225a:	29 2f       	mov	r18, r25
    225c:	22 95       	swap	r18
    225e:	20 7f       	andi	r18, 0xF0	; 240
    2260:	90 81       	ld	r25, Z
    2262:	9f 7c       	andi	r25, 0xCF	; 207
    2264:	92 2b       	or	r25, r18
    2266:	90 83       	st	Z, r25
  uint8_t sekunda =  cmdlineGetArgInt(3, state);

  ds1305start();

  uint8_t cDzies = godzina/10;
  uint8_t cJedn = godzina - cDzies*10;
    2268:	36 ef       	ldi	r19, 0xF6	; 246
    226a:	83 9f       	mul	r24, r19
    226c:	10 0d       	add	r17, r0
    226e:	11 24       	eor	r1, r1
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;
    2270:	81 2f       	mov	r24, r17
    2272:	8f 70       	andi	r24, 0x0F	; 15
    2274:	10 81       	ld	r17, Z
    2276:	10 7f       	andi	r17, 0xF0	; 240
    2278:	18 2b       	or	r17, r24
    227a:	10 83       	st	Z, r17

  cDzies = minuta/10;
    227c:	8d 2f       	mov	r24, r29
    227e:	0e 94 d7 4c 	call	0x99ae	; 0x99ae <__udivmodqi4>
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
    2282:	98 2f       	mov	r25, r24
    2284:	97 70       	andi	r25, 0x07	; 7
    2286:	e4 eb       	ldi	r30, 0xB4	; 180
    2288:	fe e0       	ldi	r31, 0x0E	; 14
    228a:	29 2f       	mov	r18, r25
    228c:	22 95       	swap	r18
    228e:	20 7f       	andi	r18, 0xF0	; 240
    2290:	90 81       	ld	r25, Z
    2292:	9f 78       	andi	r25, 0x8F	; 143
    2294:	92 2b       	or	r25, r18
    2296:	90 83       	st	Z, r25
  uint8_t cJedn = godzina - cDzies*10;
  czasRtc.hours.syst24.cDzies = cDzies;
  czasRtc.hours.syst24.cJedn  = cJedn;

  cDzies = minuta/10;
  cJedn = minuta - cDzies * 10;
    2298:	83 9f       	mul	r24, r19
    229a:	d0 0d       	add	r29, r0
    229c:	11 24       	eor	r1, r1
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;
    229e:	8d 2f       	mov	r24, r29
    22a0:	8f 70       	andi	r24, 0x0F	; 15
    22a2:	d0 81       	ld	r29, Z
    22a4:	d0 7f       	andi	r29, 0xF0	; 240
    22a6:	d8 2b       	or	r29, r24
    22a8:	d0 83       	st	Z, r29

  cDzies = sekunda/10;
    22aa:	8c 2f       	mov	r24, r28
    22ac:	0e 94 d7 4c 	call	0x99ae	; 0x99ae <__udivmodqi4>
  cJedn  = sekunda - cDzies * 10;
  czasRtc.seconds.cDzies = cDzies;
    22b0:	98 2f       	mov	r25, r24
    22b2:	97 70       	andi	r25, 0x07	; 7
    22b4:	e3 eb       	ldi	r30, 0xB3	; 179
    22b6:	fe e0       	ldi	r31, 0x0E	; 14
    22b8:	29 2f       	mov	r18, r25
    22ba:	22 95       	swap	r18
    22bc:	20 7f       	andi	r18, 0xF0	; 240
    22be:	90 81       	ld	r25, Z
    22c0:	9f 78       	andi	r25, 0x8F	; 143
    22c2:	92 2b       	or	r25, r18
    22c4:	90 83       	st	Z, r25
  cJedn = minuta - cDzies * 10;
  czasRtc.minutes.cDzies = cDzies;
  czasRtc.minutes.cJedn  = cJedn;

  cDzies = sekunda/10;
  cJedn  = sekunda - cDzies * 10;
    22c6:	83 9f       	mul	r24, r19
    22c8:	c0 0d       	add	r28, r0
    22ca:	11 24       	eor	r1, r1
  czasRtc.seconds.cDzies = cDzies;
  czasRtc.seconds.cJedn  = cJedn;
    22cc:	8c 2f       	mov	r24, r28
    22ce:	8f 70       	andi	r24, 0x0F	; 15
    22d0:	c0 81       	ld	r28, Z
    22d2:	c0 7f       	andi	r28, 0xF0	; 240
    22d4:	c8 2b       	or	r28, r24
    22d6:	c0 83       	st	Z, r28

  setTimeDecoded((timeDecoded_t *)(&czasRtc));
    22d8:	cf 01       	movw	r24, r30
    22da:	0e 94 3b 25 	call	0x4a76	; 0x4a76 <setTimeDecoded>
  return OK_SILENT;
}
    22de:	80 e0       	ldi	r24, 0x00	; 0
    22e0:	90 e0       	ldi	r25, 0x00	; 0
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	ff 90       	pop	r15
    22ea:	ef 90       	pop	r14
    22ec:	08 95       	ret

000022ee <ustawPortExtBFunction>:
  MPC23s17SetPortA(wyjscie, 0);
  return OK_SILENT;
}

static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
{
    22ee:	cf 93       	push	r28
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    22f0:	bc 01       	movw	r22, r24
    22f2:	81 e0       	ldi	r24, 0x01	; 1
    22f4:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    22f8:	c6 2f       	mov	r28, r22
  MPC23s17SetDirB(0x00, 0);
    22fa:	60 e0       	ldi	r22, 0x00	; 0
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	0e 94 d4 25 	call	0x4ba8	; 0x4ba8 <MPC23s17SetDirB>
  MPC23s17SetPortB(wyjscie, 0);
    2302:	60 e0       	ldi	r22, 0x00	; 0
    2304:	8c 2f       	mov	r24, r28
    2306:	0e 94 4d 26 	call	0x4c9a	; 0x4c9a <MPC23s17SetPortB>
  return OK_SILENT;
}
    230a:	80 e0       	ldi	r24, 0x00	; 0
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	cf 91       	pop	r28
    2310:	08 95       	ret

00002312 <ustawPortExtAFunction>:

  return ERROR_SILENT;
}

static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
{
    2312:	cf 93       	push	r28
  uint8_t wyjscie = cmdlineGetArgInt(1, state);
    2314:	bc 01       	movw	r22, r24
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    231c:	c6 2f       	mov	r28, r22
  MPC23s17SetDirA(0x00, 0);
    231e:	60 e0       	ldi	r22, 0x00	; 0
    2320:	80 e0       	ldi	r24, 0x00	; 0
    2322:	0e 94 ba 25 	call	0x4b74	; 0x4b74 <MPC23s17SetDirA>
  MPC23s17SetPortA(wyjscie, 0);
    2326:	60 e0       	ldi	r22, 0x00	; 0
    2328:	8c 2f       	mov	r24, r28
    232a:	0e 94 ee 25 	call	0x4bdc	; 0x4bdc <MPC23s17SetPortA>
  return OK_SILENT;
}
    232e:	80 e0       	ldi	r24, 0x00	; 0
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	cf 91       	pop	r28
    2334:	08 95       	ret

00002336 <curtainDownFunction>:
  cmdPrintHelp(state);
  return OK_SILENT;
}

static cliExRes_t curtainDownFunction(cmdState_t *state)
{
    2336:	ff 92       	push	r15
    2338:	0f 93       	push	r16
    233a:	1f 93       	push	r17
    233c:	cf 93       	push	r28
    233e:	df 93       	push	r29
    2340:	ec 01       	movw	r28, r24
  uint8_t nrRolety;
  uint8_t nrSterownika;
  uint8_t wartosc;

  nrSterownika = cmdlineGetArgInt(1, state);
    2342:	bc 01       	movw	r22, r24
    2344:	81 e0       	ldi	r24, 0x01	; 1
    2346:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    234a:	f6 2e       	mov	r15, r22
  nrRolety = cmdlineGetArgInt(2, state);
    234c:	be 01       	movw	r22, r28
    234e:	82 e0       	ldi	r24, 0x02	; 2
    2350:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
  nrRolety &= 0x01;
    2354:	16 2f       	mov	r17, r22
    2356:	11 70       	andi	r17, 0x01	; 1
  wartosc = cmdlineGetArgInt(3, state);
    2358:	be 01       	movw	r22, r28
    235a:	83 e0       	ldi	r24, 0x03	; 3
    235c:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2360:	06 2f       	mov	r16, r22

  fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
    2362:	21 2f       	mov	r18, r17
    2364:	30 e0       	ldi	r19, 0x00	; 0
    2366:	2f 5f       	subi	r18, 0xFF	; 255
    2368:	3f 4f       	sbci	r19, 0xFF	; 255
    236a:	3f 93       	push	r19
    236c:	2f 93       	push	r18
    236e:	1f 92       	push	r1
    2370:	ff 92       	push	r15
    2372:	80 e4       	ldi	r24, 0x40	; 64
    2374:	98 e0       	ldi	r25, 0x08	; 8
    2376:	9f 93       	push	r25
    2378:	8f 93       	push	r24
    237a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    237c:	8f 93       	push	r24
    237e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2380:	8f 93       	push	r24
    2382:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  if ((wartosc > 0) && (wartosc <=100))
    2386:	8f ef       	ldi	r24, 0xFF	; 255
    2388:	80 0f       	add	r24, r16
    238a:	2d b7       	in	r18, 0x3d	; 61
    238c:	3e b7       	in	r19, 0x3e	; 62
    238e:	28 5f       	subi	r18, 0xF8	; 248
    2390:	3f 4f       	sbci	r19, 0xFF	; 255
    2392:	0f b6       	in	r0, 0x3f	; 63
    2394:	f8 94       	cli
    2396:	3e bf       	out	0x3e, r19	; 62
    2398:	0f be       	out	0x3f, r0	; 63
    239a:	2d bf       	out	0x3d, r18	; 61
    239c:	84 36       	cpi	r24, 0x64	; 100
    239e:	90 f4       	brcc	.+36     	; 0x23c4 <curtainDownFunction+0x8e>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    23a0:	1f 92       	push	r1
    23a2:	0f 93       	push	r16
    23a4:	80 e3       	ldi	r24, 0x30	; 48
    23a6:	98 e0       	ldi	r25, 0x08	; 8
    23a8:	9f 93       	push	r25
    23aa:	8f 93       	push	r24
    23ac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    23ae:	8f 93       	push	r24
    23b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23b2:	8f 93       	push	r24
    23b4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    23b8:	0f 90       	pop	r0
    23ba:	0f 90       	pop	r0
    23bc:	0f 90       	pop	r0
    23be:	0f 90       	pop	r0
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
    23c4:	40 2f       	mov	r20, r16
    23c6:	61 2f       	mov	r22, r17
    23c8:	8f 2d       	mov	r24, r15
    23ca:	0e 94 99 3e 	call	0x7d32	; 0x7d32 <rs485curtainDown>

  if (result == 0)
    23ce:	88 23       	and	r24, r24
    23d0:	19 f0       	breq	.+6      	; 0x23d8 <curtainDownFunction+0xa2>
    return OK_INFORM;

  return ERROR_SILENT;
    23d2:	83 e0       	ldi	r24, 0x03	; 3
    23d4:	90 e0       	ldi	r25, 0x00	; 0
    23d6:	02 c0       	rjmp	.+4      	; 0x23dc <curtainDownFunction+0xa6>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);

  uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);

  if (result == 0)
    return OK_INFORM;
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	90 e0       	ldi	r25, 0x00	; 0

  return ERROR_SILENT;
}
    23dc:	df 91       	pop	r29
    23de:	cf 91       	pop	r28
    23e0:	1f 91       	pop	r17
    23e2:	0f 91       	pop	r16
    23e4:	ff 90       	pop	r15
    23e6:	08 95       	ret

000023e8 <statusEncFunction>:
  return OK_SILENT;
}

static cliExRes_t statusEncFunction(cmdState_t *state)
{
  nicRegDump(state->myStdInOut);
    23e8:	fc 01       	movw	r30, r24
    23ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ec:	93 8d       	ldd	r25, Z+27	; 0x1b
    23ee:	0e 94 c6 29 	call	0x538c	; 0x538c <nicRegDump>
  return OK_SILENT;
}
    23f2:	80 e0       	ldi	r24, 0x00	; 0
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	08 95       	ret

000023f8 <saveConfigFunction>:
}

static cliExRes_t saveConfigFunction(cmdState_t *state)
{
  (void) state;
  saveConfiguration();
    23f8:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <saveConfiguration>
  return OK_SILENT;
}
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	08 95       	ret

00002402 <goXmodemWyslijFunction>:

  return OK_SILENT;
}

static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
{
    2402:	cf 93       	push	r28
    2404:	df 93       	push	r29
    2406:	ec 01       	movw	r28, r24
  fprintf_P(state->myStdInOut, xwyslijStartStr);
    2408:	86 ea       	ldi	r24, 0xA6	; 166
    240a:	98 e0       	ldi	r25, 0x08	; 8
    240c:	9f 93       	push	r25
    240e:	8f 93       	push	r24
    2410:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2412:	8f 93       	push	r24
    2414:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2416:	8f 93       	push	r24
    2418:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    241c:	be 01       	movw	r22, r28
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2424:	62 e6       	ldi	r22, 0x62	; 98
    2426:	7f e0       	ldi	r23, 0x0F	; 15
    2428:	0e 94 bd 1b 	call	0x377a	; 0x377a <ramDyskOtworzPlik>
    242c:	0f 90       	pop	r0
    242e:	0f 90       	pop	r0
    2430:	0f 90       	pop	r0
    2432:	0f 90       	pop	r0
    2434:	88 23       	and	r24, r24
    2436:	c9 f0       	breq	.+50     	; 0x246a <goXmodemWyslijFunction+0x68>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    2438:	be 01       	movw	r22, r28
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2440:	9f 93       	push	r25
    2442:	8f 93       	push	r24
    2444:	8e ea       	ldi	r24, 0xAE	; 174
    2446:	9a e0       	ldi	r25, 0x0A	; 10
    2448:	9f 93       	push	r25
    244a:	8f 93       	push	r24
    244c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    244e:	8f 93       	push	r24
    2450:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2452:	8f 93       	push	r24
    2454:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    2458:	0f 90       	pop	r0
    245a:	0f 90       	pop	r0
    245c:	0f 90       	pop	r0
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	84 e0       	ldi	r24, 0x04	; 4
    2466:	90 e0       	ldi	r25, 0x00	; 0
    2468:	02 c0       	rjmp	.+4      	; 0x246e <goXmodemWyslijFunction+0x6c>
    return ERROR_INFORM;
  }
  return OK_SILENT;
    246a:	80 e0       	ldi	r24, 0x00	; 0
    246c:	90 e0       	ldi	r25, 0x00	; 0
}
    246e:	df 91       	pop	r29
    2470:	cf 91       	pop	r28
    2472:	08 95       	ret

00002474 <zapiszModWykFunction>:

  return OK_SILENT;
}
static cliExRes_t zapiszModWykFunction(cmdState_t *state)
{
  if (state->argc < 1)
    2474:	fc 01       	movw	r30, r24
    2476:	21 8d       	ldd	r18, Z+25	; 0x19
    2478:	22 23       	and	r18, r18
    247a:	51 f0       	breq	.+20     	; 0x2490 <zapiszModWykFunction+0x1c>
    247c:	bc 01       	movw	r22, r24
    return SYNTAX_ERROR;

  uint8_t adres =  cmdlineGetArgInt(1, state);
    247e:	81 e0       	ldi	r24, 0x01	; 1
    2480:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2484:	86 2f       	mov	r24, r22
  saveSettings(adres);
    2486:	0e 94 61 3e 	call	0x7cc2	; 0x7cc2 <saveSettings>
    248a:	80 e0       	ldi	r24, 0x00	; 0
    248c:	90 e0       	ldi	r25, 0x00	; 0
    248e:	08 95       	ret
  return OK_SILENT;
}
static cliExRes_t zapiszModWykFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2490:	82 e0       	ldi	r24, 0x02	; 2
    2492:	90 e0       	ldi	r25, 0x00	; 0

  uint8_t adres =  cmdlineGetArgInt(1, state);
  saveSettings(adres);
  return OK_SILENT;
}
    2494:	08 95       	ret

00002496 <ustawModWykFunction>:
  ipSetConfigGw(gw);
  return OK_SILENT;
}

static cliExRes_t ustawModWykFunction(cmdState_t *state)
{
    2496:	1f 93       	push	r17
    2498:	cf 93       	push	r28
    249a:	df 93       	push	r29
  if (state->argc < 2)
    249c:	fc 01       	movw	r30, r24
    249e:	21 8d       	ldd	r18, Z+25	; 0x19
    24a0:	22 30       	cpi	r18, 0x02	; 2
    24a2:	80 f0       	brcs	.+32     	; 0x24c4 <ustawModWykFunction+0x2e>
    24a4:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  uint8_t adres =   cmdlineGetArgInt(1, state);
    24a6:	bc 01       	movw	r22, r24
    24a8:	81 e0       	ldi	r24, 0x01	; 1
    24aa:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    24ae:	16 2f       	mov	r17, r22
  uint8_t wartosc = cmdlineGetArgHex(2, state);
    24b0:	be 01       	movw	r22, r28
    24b2:	82 e0       	ldi	r24, 0x02	; 2
    24b4:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>

  sendSettings(adres, wartosc);
    24b8:	81 2f       	mov	r24, r17
    24ba:	0e 94 1e 3e 	call	0x7c3c	; 0x7c3c <sendSettings>
    24be:	80 e0       	ldi	r24, 0x00	; 0
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	02 c0       	rjmp	.+4      	; 0x24c8 <ustawModWykFunction+0x32>
}

static cliExRes_t ustawModWykFunction(cmdState_t *state)
{
  if (state->argc < 2)
    return SYNTAX_ERROR;
    24c4:	82 e0       	ldi	r24, 0x02	; 2
    24c6:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t wartosc = cmdlineGetArgHex(2, state);

  sendSettings(adres, wartosc);

  return OK_SILENT;
}
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	1f 91       	pop	r17
    24ce:	08 95       	ret

000024d0 <ustawPortRezystor>:
  return OK_SILENT;
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
  if (state->argc < 1)
    24d0:	fc 01       	movw	r30, r24
    24d2:	21 8d       	ldd	r18, Z+25	; 0x19
    24d4:	22 23       	and	r18, r18
    24d6:	51 f0       	breq	.+20     	; 0x24ec <ustawPortRezystor+0x1c>
    24d8:	bc 01       	movw	r22, r24
    return SYNTAX_ERROR;

  uint8_t wartosc = cmdlineGetArgInt(1, state);
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    24e0:	86 2f       	mov	r24, r22

  MCP4150_setValue(wartosc);
    24e2:	0e 94 2b 27 	call	0x4e56	; 0x4e56 <MCP4150_setValue>
    24e6:	80 e0       	ldi	r24, 0x00	; 0
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	08 95       	ret
}

static cliExRes_t ustawPortRezystor(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    24ec:	82 e0       	ldi	r24, 0x02	; 2
    24ee:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t wartosc = cmdlineGetArgInt(1, state);

  MCP4150_setValue(wartosc);

  return OK_SILENT;
}
    24f0:	08 95       	ret

000024f2 <curtainUpFunction>:

  return ERROR_SILENT;
}

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
    24f2:	ff 92       	push	r15
    24f4:	0f 93       	push	r16
    24f6:	1f 93       	push	r17
    24f8:	cf 93       	push	r28
    24fa:	df 93       	push	r29
  if (state->argc < 2)
    24fc:	fc 01       	movw	r30, r24
    24fe:	21 8d       	ldd	r18, Z+25	; 0x19
    2500:	22 30       	cpi	r18, 0x02	; 2
    2502:	08 f4       	brcc	.+2      	; 0x2506 <curtainUpFunction+0x14>
    2504:	51 c0       	rjmp	.+162    	; 0x25a8 <curtainUpFunction+0xb6>
    2506:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
    2508:	bc 01       	movw	r22, r24
    250a:	81 e0       	ldi	r24, 0x01	; 1
    250c:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2510:	16 2f       	mov	r17, r22
    2512:	1f 73       	andi	r17, 0x3F	; 63
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
    2514:	be 01       	movw	r22, r28
    2516:	82 e0       	ldi	r24, 0x02	; 2
    2518:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    251c:	06 2f       	mov	r16, r22
    251e:	01 70       	andi	r16, 0x01	; 1
  uint8_t wartosc = 255;
  if (state->argc > 2)
    2520:	89 8d       	ldd	r24, Y+25	; 0x19
    2522:	83 30       	cpi	r24, 0x03	; 3
    2524:	30 f0       	brcs	.+12     	; 0x2532 <curtainUpFunction+0x40>
    wartosc = cmdlineGetArgInt(3, state);
    2526:	be 01       	movw	r22, r28
    2528:	83 e0       	ldi	r24, 0x03	; 3
    252a:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    252e:	f6 2e       	mov	r15, r22
    2530:	02 c0       	rjmp	.+4      	; 0x2536 <curtainUpFunction+0x44>
  if (state->argc < 2)
    return SYNTAX_ERROR;

  uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
  uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
  uint8_t wartosc = 255;
    2532:	ff 24       	eor	r15, r15
    2534:	fa 94       	dec	r15
  if (state->argc > 2)
    wartosc = cmdlineGetArgInt(3, state);

  fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
    2536:	80 2f       	mov	r24, r16
    2538:	90 e0       	ldi	r25, 0x00	; 0
    253a:	01 96       	adiw	r24, 0x01	; 1
    253c:	9f 93       	push	r25
    253e:	8f 93       	push	r24
    2540:	1f 92       	push	r1
    2542:	1f 93       	push	r17
    2544:	83 e7       	ldi	r24, 0x73	; 115
    2546:	98 e0       	ldi	r25, 0x08	; 8
    2548:	9f 93       	push	r25
    254a:	8f 93       	push	r24
    254c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    254e:	8f 93       	push	r24
    2550:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2552:	8f 93       	push	r24
    2554:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if ((wartosc > 0) && (wartosc <=100))
    2558:	8d b7       	in	r24, 0x3d	; 61
    255a:	9e b7       	in	r25, 0x3e	; 62
    255c:	08 96       	adiw	r24, 0x08	; 8
    255e:	0f b6       	in	r0, 0x3f	; 63
    2560:	f8 94       	cli
    2562:	9e bf       	out	0x3e, r25	; 62
    2564:	0f be       	out	0x3f, r0	; 63
    2566:	8d bf       	out	0x3d, r24	; 61
    2568:	8f ef       	ldi	r24, 0xFF	; 255
    256a:	8f 0d       	add	r24, r15
    256c:	84 36       	cpi	r24, 0x64	; 100
    256e:	90 f4       	brcc	.+36     	; 0x2594 <curtainUpFunction+0xa2>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
    2570:	1f 92       	push	r1
    2572:	ff 92       	push	r15
    2574:	80 e3       	ldi	r24, 0x30	; 48
    2576:	98 e0       	ldi	r25, 0x08	; 8
    2578:	9f 93       	push	r25
    257a:	8f 93       	push	r24
    257c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    257e:	8f 93       	push	r24
    2580:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2582:	8f 93       	push	r24
    2584:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    2588:	0f 90       	pop	r0
    258a:	0f 90       	pop	r0
    258c:	0f 90       	pop	r0
    258e:	0f 90       	pop	r0
    2590:	0f 90       	pop	r0
    2592:	0f 90       	pop	r0

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
    2594:	4f 2d       	mov	r20, r15
    2596:	60 2f       	mov	r22, r16
    2598:	81 2f       	mov	r24, r17
    259a:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <rs485curtainUp>

  if (result == 0)
    259e:	88 23       	and	r24, r24
    25a0:	31 f0       	breq	.+12     	; 0x25ae <curtainUpFunction+0xbc>
    return OK_INFORM;

  return ERROR_SILENT;
    25a2:	83 e0       	ldi	r24, 0x03	; 3
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	05 c0       	rjmp	.+10     	; 0x25b2 <curtainUpFunction+0xc0>
}

static cliExRes_t curtainUpFunction(cmdState_t *state)
{
  if (state->argc < 2)
    return SYNTAX_ERROR;
    25a8:	82 e0       	ldi	r24, 0x02	; 2
    25aa:	90 e0       	ldi	r25, 0x00	; 0
    25ac:	02 c0       	rjmp	.+4      	; 0x25b2 <curtainUpFunction+0xc0>
    fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);

  uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);

  if (result == 0)
    return OK_INFORM;
    25ae:	81 e0       	ldi	r24, 0x01	; 1
    25b0:	90 e0       	ldi	r25, 0x00	; 0

  return ERROR_SILENT;
}
    25b2:	df 91       	pop	r29
    25b4:	cf 91       	pop	r28
    25b6:	1f 91       	pop	r17
    25b8:	0f 91       	pop	r16
    25ba:	ff 90       	pop	r15
    25bc:	08 95       	ret

000025be <editRamFileFunction>:
  ramDyskDir(state->myStdInOut);
  return OK_SILENT;
}

static cliExRes_t editRamFileFunction(cmdState_t *state)
{
    25be:	0f 93       	push	r16
    25c0:	1f 93       	push	r17
    25c2:	cf 93       	push	r28
    25c4:	df 93       	push	r29
    25c6:	1f 92       	push	r1
    25c8:	cd b7       	in	r28, 0x3d	; 61
    25ca:	de b7       	in	r29, 0x3e	; 62
    25cc:	8c 01       	movw	r16, r24
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    25ce:	bc 01       	movw	r22, r24
    25d0:	81 e0       	ldi	r24, 0x01	; 1
    25d2:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    25d6:	62 e6       	ldi	r22, 0x62	; 98
    25d8:	7f e0       	ldi	r23, 0x0F	; 15
    25da:	0e 94 bd 1b 	call	0x377a	; 0x377a <ramDyskOtworzPlik>
    25de:	88 23       	and	r24, r24
    25e0:	d1 f0       	breq	.+52     	; 0x2616 <editRamFileFunction+0x58>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    25e2:	b8 01       	movw	r22, r16
    25e4:	81 e0       	ldi	r24, 0x01	; 1
    25e6:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    25ea:	9f 93       	push	r25
    25ec:	8f 93       	push	r24
    25ee:	8e ea       	ldi	r24, 0xAE	; 174
    25f0:	9a e0       	ldi	r25, 0x0A	; 10
    25f2:	9f 93       	push	r25
    25f4:	8f 93       	push	r24
    25f6:	f8 01       	movw	r30, r16
    25f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    25fa:	8f 93       	push	r24
    25fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    25fe:	8f 93       	push	r24
    2600:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    return ERROR_INFORM;
    2604:	0f 90       	pop	r0
    2606:	0f 90       	pop	r0
    2608:	0f 90       	pop	r0
    260a:	0f 90       	pop	r0
    260c:	0f 90       	pop	r0
    260e:	0f 90       	pop	r0
    2610:	84 e0       	ldi	r24, 0x04	; 4
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	33 c0       	rjmp	.+102    	; 0x267c <editRamFileFunction+0xbe>
  }
  ramDyskUstawWskaznikNaKoniec(&fdVty);
    2616:	82 e6       	ldi	r24, 0x62	; 98
    2618:	9f e0       	ldi	r25, 0x0F	; 15
    261a:	0e 94 3a 1e 	call	0x3c74	; 0x3c74 <ramDyskUstawWskaznikNaKoniec>
  uint8_t znak = 0;
    261e:	19 82       	std	Y+1, r1	; 0x01
  fprintf_P(state->myStdInOut, editRamFileIntroStr);
    2620:	85 ed       	ldi	r24, 0xD5	; 213
    2622:	98 e0       	ldi	r25, 0x08	; 8
    2624:	9f 93       	push	r25
    2626:	8f 93       	push	r24
    2628:	f8 01       	movw	r30, r16
    262a:	83 8d       	ldd	r24, Z+27	; 0x1b
    262c:	8f 93       	push	r24
    262e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2630:	8f 93       	push	r24
    2632:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    2636:	0f 90       	pop	r0
    2638:	0f 90       	pop	r0
    263a:	0f 90       	pop	r0
    263c:	0f 90       	pop	r0
  while(1)
  {
    if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
    263e:	20 e0       	ldi	r18, 0x00	; 0
    2640:	4f ef       	ldi	r20, 0xFF	; 255
    2642:	5f ef       	ldi	r21, 0xFF	; 255
    2644:	be 01       	movw	r22, r28
    2646:	6f 5f       	subi	r22, 0xFF	; 255
    2648:	7f 4f       	sbci	r23, 0xFF	; 255
    264a:	80 91 ac 0e 	lds	r24, 0x0EAC
    264e:	90 91 ad 0e 	lds	r25, 0x0EAD
    2652:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    2656:	88 23       	and	r24, r24
    2658:	91 f3       	breq	.-28     	; 0x263e <editRamFileFunction+0x80>
      continue;

    if (znak == 0x03)                                       // ^C
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	83 30       	cpi	r24, 0x03	; 3
    265e:	41 f0       	breq	.+16     	; 0x2670 <editRamFileFunction+0xb2>
      break;

    uartVtySendByte(znak);                                  //Echo
    2660:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
    ramDyskZapiszBajtDoPliku(&fdVty, znak);
    2664:	69 81       	ldd	r22, Y+1	; 0x01
    2666:	82 e6       	ldi	r24, 0x62	; 98
    2668:	9f e0       	ldi	r25, 0x0F	; 15
    266a:	0e 94 2e 1c 	call	0x385c	; 0x385c <ramDyskZapiszBajtDoPliku>
    266e:	e7 cf       	rjmp	.-50     	; 0x263e <editRamFileFunction+0x80>
  }
  ramDyskZamknijPlik(&fdVty);
    2670:	82 e6       	ldi	r24, 0x62	; 98
    2672:	9f e0       	ldi	r25, 0x0F	; 15
    2674:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <ramDyskZamknijPlik>
    2678:	80 e0       	ldi	r24, 0x00	; 0
    267a:	90 e0       	ldi	r25, 0x00	; 0
  return OK_SILENT;
}
    267c:	0f 90       	pop	r0
    267e:	df 91       	pop	r29
    2680:	cf 91       	pop	r28
    2682:	1f 91       	pop	r17
    2684:	0f 91       	pop	r16
    2686:	08 95       	ret

00002688 <goXmodemOdbierzFunction>:
  }
  return OK_SILENT;
}

static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
{
    2688:	8f 92       	push	r8
    268a:	9f 92       	push	r9
    268c:	af 92       	push	r10
    268e:	bf 92       	push	r11
    2690:	cf 92       	push	r12
    2692:	df 92       	push	r13
    2694:	ef 92       	push	r14
    2696:	ff 92       	push	r15
    2698:	0f 93       	push	r16
    269a:	1f 93       	push	r17
    269c:	cf 93       	push	r28
    269e:	df 93       	push	r29
    26a0:	00 d0       	rcall	.+0      	; 0x26a2 <goXmodemOdbierzFunction+0x1a>
    26a2:	00 d0       	rcall	.+0      	; 0x26a4 <goXmodemOdbierzFunction+0x1c>
    26a4:	00 d0       	rcall	.+0      	; 0x26a6 <goXmodemOdbierzFunction+0x1e>
    26a6:	cd b7       	in	r28, 0x3d	; 61
    26a8:	de b7       	in	r29, 0x3e	; 62
    26aa:	8c 01       	movw	r16, r24
  fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
    26ac:	8e e2       	ldi	r24, 0x2E	; 46
    26ae:	91 e0       	ldi	r25, 0x01	; 1
    26b0:	9f 93       	push	r25
    26b2:	8f 93       	push	r24
    26b4:	f8 01       	movw	r30, r16
    26b6:	83 8d       	ldd	r24, Z+27	; 0x1b
    26b8:	8f 93       	push	r24
    26ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    26bc:	8f 93       	push	r24
    26be:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
    26c2:	b8 01       	movw	r22, r16
    26c4:	81 e0       	ldi	r24, 0x01	; 1
    26c6:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    26ca:	62 e6       	ldi	r22, 0x62	; 98
    26cc:	7f e0       	ldi	r23, 0x0F	; 15
    26ce:	0e 94 bd 1b 	call	0x377a	; 0x377a <ramDyskOtworzPlik>
    26d2:	0f 90       	pop	r0
    26d4:	0f 90       	pop	r0
    26d6:	0f 90       	pop	r0
    26d8:	0f 90       	pop	r0
    26da:	88 23       	and	r24, r24
    26dc:	c1 f0       	breq	.+48     	; 0x270e <goXmodemOdbierzFunction+0x86>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    26de:	b8 01       	movw	r22, r16
    26e0:	81 e0       	ldi	r24, 0x01	; 1
    26e2:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    26e6:	9f 93       	push	r25
    26e8:	8f 93       	push	r24
    26ea:	8e ea       	ldi	r24, 0xAE	; 174
    26ec:	9a e0       	ldi	r25, 0x0A	; 10
    26ee:	9f 93       	push	r25
    26f0:	8f 93       	push	r24
    26f2:	f8 01       	movw	r30, r16
    26f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    26f6:	8f 93       	push	r24
    26f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    26fa:	8f 93       	push	r24
    26fc:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    return ERROR_INFORM;
    2700:	0f 90       	pop	r0
    2702:	0f 90       	pop	r0
    2704:	0f 90       	pop	r0
    2706:	0f 90       	pop	r0
    2708:	0f 90       	pop	r0
    270a:	0f 90       	pop	r0
    270c:	2b c0       	rjmp	.+86     	; 0x2764 <goXmodemOdbierzFunction+0xdc>
  uint8_t nrBlokuZdalnyNeg;

  uint8_t crcHi;
  uint8_t crcLo;

  state->err1=0;
    270e:	f8 01       	movw	r30, r16
    2710:	16 8e       	std	Z+30, r1	; 0x1e
    2712:	15 8e       	std	Z+29, r1	; 0x1d
  state->err2=0;
    2714:	17 8e       	std	Z+31, r1	; 0x1f
    2716:	74 e1       	ldi	r23, 0x14	; 20
    2718:	f7 2e       	mov	r15, r23
  liczbaProb = 20;
  for ( ; ; )
  {
    fputc('C'              , state->myStdInOut);
    271a:	f8 01       	movw	r30, r16
    271c:	62 8d       	ldd	r22, Z+26	; 0x1a
    271e:	73 8d       	ldd	r23, Z+27	; 0x1b
    2720:	83 e4       	ldi	r24, 0x43	; 67
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
    2728:	80 91 9b 00 	lds	r24, 0x009B
    272c:	86 ff       	sbrs	r24, 6
    272e:	fc cf       	rjmp	.-8      	; 0x2728 <goXmodemOdbierzFunction+0xa0>

    if(xQueueReceive(xVtyRec, &c, 100))
    2730:	20 e0       	ldi	r18, 0x00	; 0
    2732:	44 e6       	ldi	r20, 0x64	; 100
    2734:	50 e0       	ldi	r21, 0x00	; 0
    2736:	be 01       	movw	r22, r28
    2738:	6b 5f       	subi	r22, 0xFB	; 251
    273a:	7f 4f       	sbci	r23, 0xFF	; 255
    273c:	80 91 ac 0e 	lds	r24, 0x0EAC
    2740:	90 91 ad 0e 	lds	r25, 0x0EAD
    2744:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    2748:	88 23       	and	r24, r24
    274a:	19 f0       	breq	.+6      	; 0x2752 <goXmodemOdbierzFunction+0xca>
      if (c == SOH)
    274c:	8d 81       	ldd	r24, Y+5	; 0x05
    274e:	81 30       	cpi	r24, 0x01	; 1
    2750:	61 f0       	breq	.+24     	; 0x276a <goXmodemOdbierzFunction+0xe2>
    2752:	fa 94       	dec	r15
        break;                                                   //Rozpoczynamy transmisje

    liczbaProb--;
    if (liczbaProb == 0)
    2754:	f1 10       	cpse	r15, r1
    2756:	e1 cf       	rjmp	.-62     	; 0x271a <goXmodemOdbierzFunction+0x92>
    {
      ramDyskZamknijPlik(&fdVty);
    2758:	82 e6       	ldi	r24, 0x62	; 98
    275a:	9f e0       	ldi	r25, 0x0F	; 15
    275c:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <ramDyskZamknijPlik>
      state->errno = (uint8_t)(AllOK);
    2760:	f8 01       	movw	r30, r16
    2762:	14 8e       	std	Z+28, r1	; 0x1c
      return ERROR_INFORM;
    2764:	84 e0       	ldi	r24, 0x04	; 4
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	2f c1       	rjmp	.+606    	; 0x29c8 <goXmodemOdbierzFunction+0x340>
  }

  nrBloku = 1;
  liczbaProb = 10;

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    276a:	61 e0       	ldi	r22, 0x01	; 1
    276c:	70 e0       	ldi	r23, 0x00	; 0
    276e:	82 e6       	ldi	r24, 0x62	; 98
    2770:	9f e0       	ldi	r25, 0x0F	; 15
    2772:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <ramDyskDodajBlokXmodem>
    2776:	4c 01       	movw	r8, r24
      state->errno = (uint8_t)(AllOK);
      return ERROR_INFORM;
    }
  }

  nrBloku = 1;
    2778:	ee 24       	eor	r14, r14
    277a:	e3 94       	inc	r14
  liczbaProb = 10;
    277c:	5a e0       	ldi	r21, 0x0A	; 10
    277e:	b5 2e       	mov	r11, r21
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    2780:	63 e0       	ldi	r22, 0x03	; 3
    2782:	a6 2e       	mov	r10, r22

  zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
  zapPtrKopia     = zapPtr;
  for ( ; ; )
  {
    if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
    2784:	20 e0       	ldi	r18, 0x00	; 0
    2786:	44 e6       	ldi	r20, 0x64	; 100
    2788:	50 e0       	ldi	r21, 0x00	; 0
    278a:	be 01       	movw	r22, r28
    278c:	6c 5f       	subi	r22, 0xFC	; 252
    278e:	7f 4f       	sbci	r23, 0xFF	; 255
    2790:	80 91 ac 0e 	lds	r24, 0x0EAC
    2794:	90 91 ad 0e 	lds	r25, 0x0EAD
    2798:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    279c:	81 11       	cpse	r24, r1
    279e:	02 c0       	rjmp	.+4      	; 0x27a4 <goXmodemOdbierzFunction+0x11c>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
    27a0:	82 e0       	ldi	r24, 0x02	; 2
    27a2:	0f c0       	rjmp	.+30     	; 0x27c2 <goXmodemOdbierzFunction+0x13a>
      break;
    }

    if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
    27a4:	20 e0       	ldi	r18, 0x00	; 0
    27a6:	41 e0       	ldi	r20, 0x01	; 1
    27a8:	50 e0       	ldi	r21, 0x00	; 0
    27aa:	be 01       	movw	r22, r28
    27ac:	6d 5f       	subi	r22, 0xFD	; 253
    27ae:	7f 4f       	sbci	r23, 0xFF	; 255
    27b0:	80 91 ac 0e 	lds	r24, 0x0EAC
    27b4:	90 91 ad 0e 	lds	r25, 0x0EAD
    27b8:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    27bc:	81 11       	cpse	r24, r1
    27be:	03 c0       	rjmp	.+6      	; 0x27c6 <goXmodemOdbierzFunction+0x13e>
    {
      state->errno = (uint8_t)(xModemByteSendTimeout);
    27c0:	83 e0       	ldi	r24, 0x03	; 3
    27c2:	f8 01       	movw	r30, r16
    27c4:	d7 c0       	rjmp	.+430    	; 0x2974 <goXmodemOdbierzFunction+0x2ec>
      break;
    }

    //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
    c = 255-nrBlokuZdalnyNeg;
    27c6:	2b 81       	ldd	r18, Y+3	; 0x03
    27c8:	82 2f       	mov	r24, r18
    27ca:	80 95       	com	r24
    27cc:	8d 83       	std	Y+5, r24	; 0x05
    if (nrBlokuZdalny != c)
    27ce:	fc 80       	ldd	r15, Y+4	; 0x04
    27d0:	f8 16       	cp	r15, r24
    27d2:	49 f0       	breq	.+18     	; 0x27e6 <goXmodemOdbierzFunction+0x15e>
    {
      state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
    27d4:	85 e0       	ldi	r24, 0x05	; 5
    27d6:	f8 01       	movw	r30, r16
    27d8:	84 8f       	std	Z+28, r24	; 0x1c
      state->err1 = nrBlokuZdalny;
    27da:	8f 2d       	mov	r24, r15
    27dc:	90 e0       	ldi	r25, 0x00	; 0
    27de:	96 8f       	std	Z+30, r25	; 0x1e
    27e0:	85 8f       	std	Z+29, r24	; 0x1d
      state->err2 = nrBlokuZdalnyNeg;
    27e2:	27 8f       	std	Z+31, r18	; 0x1f
    27e4:	eb c0       	rjmp	.+470    	; 0x29bc <goXmodemOdbierzFunction+0x334>
      break;
    }

    //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od bloku 0
    c = nrBloku-1;
    27e6:	8f ef       	ldi	r24, 0xFF	; 255
    27e8:	8e 0d       	add	r24, r14
    27ea:	8d 83       	std	Y+5, r24	; 0x05
    if (nrBlokuZdalny == c)
    27ec:	f8 12       	cpse	r15, r24
    27ee:	08 c0       	rjmp	.+16     	; 0x2800 <goXmodemOdbierzFunction+0x178>
    {
      nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    27f0:	6f 2d       	mov	r22, r15
    27f2:	70 e0       	ldi	r23, 0x00	; 0
    27f4:	82 e6       	ldi	r24, 0x62	; 98
    27f6:	9f e0       	ldi	r25, 0x0F	; 15
    27f8:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <ramDyskDodajBlokXmodem>
    27fc:	4c 01       	movw	r8, r24
    27fe:	ef 2c       	mov	r14, r15
      zapPtrKopia = zapPtr;
    }

    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    2800:	fc 80       	ldd	r15, Y+4	; 0x04
    2802:	fe 14       	cp	r15, r14
    2804:	49 f0       	breq	.+18     	; 0x2818 <goXmodemOdbierzFunction+0x190>
    {
      state->errno = (uint8_t)(xModemWrongFrameNo);
    2806:	84 e0       	ldi	r24, 0x04	; 4
    2808:	f8 01       	movw	r30, r16
    280a:	84 8f       	std	Z+28, r24	; 0x1c
      state->err1 = nrBlokuZdalnyNeg;
    280c:	8b 81       	ldd	r24, Y+3	; 0x03
    280e:	90 e0       	ldi	r25, 0x00	; 0
    2810:	96 8f       	std	Z+30, r25	; 0x1e
    2812:	85 8f       	std	Z+29, r24	; 0x1d
      state->err2 = nrBloku;
    2814:	e7 8e       	std	Z+31, r14	; 0x1f
    2816:	d2 c0       	rjmp	.+420    	; 0x29bc <goXmodemOdbierzFunction+0x334>
    2818:	64 01       	movw	r12, r8
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
      zapPtrKopia = zapPtr;
    }

    //2 Sprawdzanie, czy pasuje numer bloku
    if (nrBlokuZdalny != nrBloku)
    281a:	e1 2c       	mov	r14, r1
      break;
    }

    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    {
      if(xQueueReceive(xVtyRec, &c, 10))
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	4a e0       	ldi	r20, 0x0A	; 10
    2820:	50 e0       	ldi	r21, 0x00	; 0
    2822:	be 01       	movw	r22, r28
    2824:	6b 5f       	subi	r22, 0xFB	; 251
    2826:	7f 4f       	sbci	r23, 0xFF	; 255
    2828:	80 91 ac 0e 	lds	r24, 0x0EAC
    282c:	90 91 ad 0e 	lds	r25, 0x0EAD
    2830:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    2834:	88 23       	and	r24, r24
    2836:	49 f0       	breq	.+18     	; 0x284a <goXmodemOdbierzFunction+0x1c2>
        *(zapPtr++) = c;
    2838:	8d 81       	ldd	r24, Y+5	; 0x05
    283a:	f4 01       	movw	r30, r8
    283c:	81 93       	st	Z+, r24
    283e:	4f 01       	movw	r8, r30
      state->err1 = nrBlokuZdalnyNeg;
      state->err2 = nrBloku;
      break;
    }

    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    2840:	e3 94       	inc	r14
    2842:	f0 e8       	ldi	r31, 0x80	; 128
    2844:	ef 12       	cpse	r14, r31
    2846:	ea cf       	rjmp	.-44     	; 0x281c <goXmodemOdbierzFunction+0x194>
    2848:	02 c0       	rjmp	.+4      	; 0x284e <goXmodemOdbierzFunction+0x1c6>
    {
      if(xQueueReceive(xVtyRec, &c, 10))
        *(zapPtr++) = c;
      else
      {
        state->errno = (uint8_t)(xModemByteSendTimeout);
    284a:	f8 01       	movw	r30, r16
    284c:	a4 8e       	std	Z+28, r10	; 0x1c
        break;
      }
    }
    if (!xQueueReceive(xVtyRec, &crcHi, 10))
    284e:	20 e0       	ldi	r18, 0x00	; 0
    2850:	4a e0       	ldi	r20, 0x0A	; 10
    2852:	50 e0       	ldi	r21, 0x00	; 0
    2854:	be 01       	movw	r22, r28
    2856:	6e 5f       	subi	r22, 0xFE	; 254
    2858:	7f 4f       	sbci	r23, 0xFF	; 255
    285a:	80 91 ac 0e 	lds	r24, 0x0EAC
    285e:	90 91 ad 0e 	lds	r25, 0x0EAD
    2862:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    2866:	81 11       	cpse	r24, r1
    2868:	06 c0       	rjmp	.+12     	; 0x2876 <goXmodemOdbierzFunction+0x1ee>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    286a:	86 e0       	ldi	r24, 0x06	; 6
    286c:	f8 01       	movw	r30, r16
    286e:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 2;
    2870:	82 e0       	ldi	r24, 0x02	; 2
    2872:	90 e0       	ldi	r25, 0x00	; 0
    2874:	a1 c0       	rjmp	.+322    	; 0x29b8 <goXmodemOdbierzFunction+0x330>
        break;
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    2876:	20 e0       	ldi	r18, 0x00	; 0
    2878:	4a e0       	ldi	r20, 0x0A	; 10
    287a:	50 e0       	ldi	r21, 0x00	; 0
    287c:	be 01       	movw	r22, r28
    287e:	6f 5f       	subi	r22, 0xFF	; 255
    2880:	7f 4f       	sbci	r23, 0xFF	; 255
    2882:	80 91 ac 0e 	lds	r24, 0x0EAC
    2886:	90 91 ad 0e 	lds	r25, 0x0EAD
    288a:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    288e:	81 11       	cpse	r24, r1
    2890:	06 c0       	rjmp	.+12     	; 0x289e <goXmodemOdbierzFunction+0x216>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
    2892:	86 e0       	ldi	r24, 0x06	; 6
    2894:	f8 01       	movw	r30, r16
    2896:	84 8f       	std	Z+28, r24	; 0x1c
        state->err1 = 1;
    2898:	81 e0       	ldi	r24, 0x01	; 1
    289a:	90 e0       	ldi	r25, 0x00	; 0
    289c:	8d c0       	rjmp	.+282    	; 0x29b8 <goXmodemOdbierzFunction+0x330>
    {
        state->errno = (uint8_t)(xModemFrameCrc);
        state->err1 = 2;
        break;
    }
    if (!xQueueReceive(xVtyRec, &crcLo, 10))
    289e:	30 e0       	ldi	r19, 0x00	; 0
    28a0:	80 e0       	ldi	r24, 0x00	; 0
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    //3 Zerowanie CRC
    crcLokalne=0;

    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
    28a4:	f6 01       	movw	r30, r12
    28a6:	21 91       	ld	r18, Z+
    28a8:	6f 01       	movw	r12, r30
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    28aa:	92 27       	eor	r25, r18
    28ac:	09 2e       	mov	r0, r25
    28ae:	02 94       	swap	r0
    28b0:	20 2d       	mov	r18, r0
    28b2:	2f 70       	andi	r18, 0x0F	; 15
    28b4:	29 27       	eor	r18, r25
    28b6:	49 2f       	mov	r20, r25
    28b8:	40 25       	eor	r20, r0
    28ba:	44 0f       	add	r20, r20
    28bc:	40 7e       	andi	r20, 0xE0	; 224
    28be:	24 27       	eor	r18, r20
    28c0:	40 2d       	mov	r20, r0
    28c2:	49 27       	eor	r20, r25
    28c4:	40 7f       	andi	r20, 0xF0	; 240
    28c6:	46 95       	lsr	r20
    28c8:	09 2e       	mov	r0, r25
    28ca:	00 0c       	add	r0, r0
    28cc:	44 1f       	adc	r20, r20
    28ce:	96 95       	lsr	r25
    28d0:	96 95       	lsr	r25
    28d2:	96 95       	lsr	r25
    28d4:	9f 71       	andi	r25, 0x1F	; 31
    28d6:	94 27       	eor	r25, r20
    28d8:	98 27       	eor	r25, r24
    28da:	82 2f       	mov	r24, r18

    //3 Zerowanie CRC
    crcLokalne=0;

    //4 Obliczanie CRC
    for (i=0; i < XMODEM_BUFFER_SIZE; i++)
    28dc:	3f 5f       	subi	r19, 0xFF	; 255
    28de:	30 38       	cpi	r19, 0x80	; 128
    28e0:	09 f7       	brne	.-62     	; 0x28a4 <goXmodemOdbierzFunction+0x21c>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));

    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    28e2:	2a 81       	ldd	r18, Y+2	; 0x02
    28e4:	30 e0       	ldi	r19, 0x00	; 0
    28e6:	49 2f       	mov	r20, r25
    28e8:	55 27       	eor	r21, r21
    28ea:	24 17       	cp	r18, r20
    28ec:	35 07       	cpc	r19, r21
    28ee:	61 f4       	brne	.+24     	; 0x2908 <goXmodemOdbierzFunction+0x280>
    28f0:	29 81       	ldd	r18, Y+1	; 0x01
    28f2:	30 e0       	ldi	r19, 0x00	; 0
    28f4:	99 27       	eor	r25, r25
    28f6:	28 17       	cp	r18, r24
    28f8:	39 07       	cpc	r19, r25
    28fa:	31 f4       	brne	.+12     	; 0x2908 <goXmodemOdbierzFunction+0x280>
    {
      liczbaProb = 10;
      uartVtySendByte(ACK);
    28fc:	86 e0       	ldi	r24, 0x06	; 6
    28fe:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
      crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));

    //5 Srawdzanie CRC
    if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
    {
      liczbaProb = 10;
    2902:	8a e0       	ldi	r24, 0x0A	; 10
    2904:	b8 2e       	mov	r11, r24
    2906:	0f c0       	rjmp	.+30     	; 0x2926 <goXmodemOdbierzFunction+0x29e>
      uartVtySendByte(ACK);
    }
    else
    {
      liczbaProb--;
    2908:	ba 94       	dec	r11
      nrBloku--;
    290a:	fa 94       	dec	r15
      uartVtySendByte(NAK);
    290c:	85 e1       	ldi	r24, 0x15	; 21
    290e:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
    }

    if (liczbaProb == 0)
    2912:	b1 10       	cpse	r11, r1
    2914:	08 c0       	rjmp	.+16     	; 0x2926 <goXmodemOdbierzFunction+0x29e>
    {
      state->err1 = nrBlokuZdalny;
    2916:	8c 81       	ldd	r24, Y+4	; 0x04
    2918:	90 e0       	ldi	r25, 0x00	; 0
    291a:	f8 01       	movw	r30, r16
    291c:	96 8f       	std	Z+30, r25	; 0x1e
    291e:	85 8f       	std	Z+29, r24	; 0x1d
      state->err2 = nrBloku;
    2920:	f7 8e       	std	Z+31, r15	; 0x1f
      state->errno = (uint8_t)(xModemWrongFrameNo);
    2922:	84 e0       	ldi	r24, 0x04	; 4
    2924:	27 c0       	rjmp	.+78     	; 0x2974 <goXmodemOdbierzFunction+0x2ec>
      break;
    }

    if (!xQueueReceive(xVtyRec, &temp1, 100))
    2926:	20 e0       	ldi	r18, 0x00	; 0
    2928:	44 e6       	ldi	r20, 0x64	; 100
    292a:	50 e0       	ldi	r21, 0x00	; 0
    292c:	be 01       	movw	r22, r28
    292e:	6a 5f       	subi	r22, 0xFA	; 250
    2930:	7f 4f       	sbci	r23, 0xFF	; 255
    2932:	80 91 ac 0e 	lds	r24, 0x0EAC
    2936:	90 91 ad 0e 	lds	r25, 0x0EAD
    293a:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    293e:	88 23       	and	r24, r24
    2940:	09 f4       	brne	.+2      	; 0x2944 <goXmodemOdbierzFunction+0x2bc>
    2942:	2e cf       	rjmp	.-420    	; 0x27a0 <goXmodemOdbierzFunction+0x118>
    {
      state->errno = (uint8_t)(xModemFrameStartTimeout);
      break;
    }

    if (temp1 == SOH)
    2944:	8e 81       	ldd	r24, Y+6	; 0x06
    2946:	81 30       	cpi	r24, 0x01	; 1
    2948:	69 f4       	brne	.+26     	; 0x2964 <goXmodemOdbierzFunction+0x2dc>
    {
      nrBloku++;
    294a:	ee 24       	eor	r14, r14
    294c:	e3 94       	inc	r14
    294e:	ef 0c       	add	r14, r15
      zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
    2950:	6e 2d       	mov	r22, r14
    2952:	70 e0       	ldi	r23, 0x00	; 0
    2954:	82 e6       	ldi	r24, 0x62	; 98
    2956:	9f e0       	ldi	r25, 0x0F	; 15
    2958:	0e 94 63 1e 	call	0x3cc6	; 0x3cc6 <ramDyskDodajBlokXmodem>
    295c:	4c 01       	movw	r8, r24
      zapPtrKopia = zapPtr;
      state->errno = (uint8_t)(AllOK);
    295e:	f8 01       	movw	r30, r16
    2960:	14 8e       	std	Z+28, r1	; 0x1c
    2962:	10 cf       	rjmp	.-480    	; 0x2784 <goXmodemOdbierzFunction+0xfc>
      continue;
    }

    if (temp1 == CAN)
    2964:	88 31       	cpi	r24, 0x18	; 24
    2966:	41 f4       	brne	.+16     	; 0x2978 <goXmodemOdbierzFunction+0x2f0>
    {
      state->err1 = nrBloku;
    2968:	8f 2d       	mov	r24, r15
    296a:	90 e0       	ldi	r25, 0x00	; 0
    296c:	f8 01       	movw	r30, r16
    296e:	96 8f       	std	Z+30, r25	; 0x1e
    2970:	85 8f       	std	Z+29, r24	; 0x1d
      state->errno = (uint8_t)(xModemRemoteSideCan);
    2972:	87 e0       	ldi	r24, 0x07	; 7
    2974:	84 8f       	std	Z+28, r24	; 0x1c
    2976:	22 c0       	rjmp	.+68     	; 0x29bc <goXmodemOdbierzFunction+0x334>
      break;
    }
    if (temp1 == EOT)
    2978:	84 30       	cpi	r24, 0x04	; 4
    297a:	d1 f4       	brne	.+52     	; 0x29b0 <goXmodemOdbierzFunction+0x328>
    {
      uartVtySendByte(NAK);
    297c:	85 e1       	ldi	r24, 0x15	; 21
    297e:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
      if (xQueueReceive(xVtyRec, &temp1, 10))
    2982:	20 e0       	ldi	r18, 0x00	; 0
    2984:	4a e0       	ldi	r20, 0x0A	; 10
    2986:	50 e0       	ldi	r21, 0x00	; 0
    2988:	be 01       	movw	r22, r28
    298a:	6a 5f       	subi	r22, 0xFA	; 250
    298c:	7f 4f       	sbci	r23, 0xFF	; 255
    298e:	80 91 ac 0e 	lds	r24, 0x0EAC
    2992:	90 91 ad 0e 	lds	r25, 0x0EAD
    2996:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    299a:	88 23       	and	r24, r24
    299c:	31 f0       	breq	.+12     	; 0x29aa <goXmodemOdbierzFunction+0x322>
      {
        if (temp1 == EOT)
    299e:	8e 81       	ldd	r24, Y+6	; 0x06
    29a0:	84 30       	cpi	r24, 0x04	; 4
    29a2:	19 f4       	brne	.+6      	; 0x29aa <goXmodemOdbierzFunction+0x322>
          uartVtySendByte(ACK);
    29a4:	86 e0       	ldi	r24, 0x06	; 6
    29a6:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <uartVtySendByte>
      }
      state->errno = (uint8_t)(AllOK);
    29aa:	f8 01       	movw	r30, r16
    29ac:	14 8e       	std	Z+28, r1	; 0x1c
    29ae:	06 c0       	rjmp	.+12     	; 0x29bc <goXmodemOdbierzFunction+0x334>
      break;
    }
    state->errno = (uint8_t)(xModemUnknownResponse);
    29b0:	98 e0       	ldi	r25, 0x08	; 8
    29b2:	f8 01       	movw	r30, r16
    29b4:	94 8f       	std	Z+28, r25	; 0x1c
    state->err1 = temp1;
    29b6:	90 e0       	ldi	r25, 0x00	; 0
    29b8:	96 8f       	std	Z+30, r25	; 0x1e
    29ba:	85 8f       	std	Z+29, r24	; 0x1d
    break;
  }
  ramDyskZamknijPlik(&fdVty);
    29bc:	82 e6       	ldi	r24, 0x62	; 98
    29be:	9f e0       	ldi	r25, 0x0F	; 15
    29c0:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <ramDyskZamknijPlik>
  return OK_SILENT;
    29c4:	80 e0       	ldi	r24, 0x00	; 0
    29c6:	90 e0       	ldi	r25, 0x00	; 0
}
    29c8:	26 96       	adiw	r28, 0x06	; 6
    29ca:	0f b6       	in	r0, 0x3f	; 63
    29cc:	f8 94       	cli
    29ce:	de bf       	out	0x3e, r29	; 62
    29d0:	0f be       	out	0x3f, r0	; 63
    29d2:	cd bf       	out	0x3d, r28	; 61
    29d4:	df 91       	pop	r29
    29d6:	cf 91       	pop	r28
    29d8:	1f 91       	pop	r17
    29da:	0f 91       	pop	r16
    29dc:	ff 90       	pop	r15
    29de:	ef 90       	pop	r14
    29e0:	df 90       	pop	r13
    29e2:	cf 90       	pop	r12
    29e4:	bf 90       	pop	r11
    29e6:	af 90       	pop	r10
    29e8:	9f 90       	pop	r9
    29ea:	8f 90       	pop	r8
    29ec:	08 95       	ret

000029ee <debugFunction>:
  fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
  return OK_SILENT;
}

static cliExRes_t debugFunction          (cmdState_t *state)
{
    29ee:	ff 92       	push	r15
    29f0:	0f 93       	push	r16
    29f2:	1f 93       	push	r17
    29f4:	cf 93       	push	r28
    29f6:	df 93       	push	r29
  if (state->argc < 2)
    29f8:	fc 01       	movw	r30, r24
    29fa:	21 8d       	ldd	r18, Z+25	; 0x19
    29fc:	22 30       	cpi	r18, 0x02	; 2
    29fe:	18 f4       	brcc	.+6      	; 0x2a06 <debugFunction+0x18>
    return SYNTAX_ERROR;
    2a00:	82 e0       	ldi	r24, 0x02	; 2
    2a02:	90 e0       	ldi	r25, 0x00	; 0
    2a04:	c1 c0       	rjmp	.+386    	; 0x2b88 <debugFunction+0x19a>
    2a06:	ec 01       	movw	r28, r24

  uint8_t level = cmdlineGetArgInt(2, state);
    2a08:	bc 01       	movw	r22, r24
    2a0a:	82 e0       	ldi	r24, 0x02	; 2
    2a0c:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2a10:	f6 2e       	mov	r15, r22
  const char *str = (const char*)cmdlineGetArgStr(1, state);
    2a12:	be 01       	movw	r22, r28
    2a14:	81 e0       	ldi	r24, 0x01	; 1
    2a16:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2a1a:	18 2f       	mov	r17, r24
    2a1c:	09 2f       	mov	r16, r25
  if (level == 0)
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2a1e:	43 e0       	ldi	r20, 0x03	; 3
    2a20:	50 e0       	ldi	r21, 0x00	; 0
  if (state->argc < 2)
    return SYNTAX_ERROR;

  uint8_t level = cmdlineGetArgInt(2, state);
  const char *str = (const char*)cmdlineGetArgStr(1, state);
  if (level == 0)
    2a22:	f1 10       	cpse	r15, r1
    2a24:	51 c0       	rjmp	.+162    	; 0x2ac8 <debugFunction+0xda>
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2a26:	6a e2       	ldi	r22, 0x2A	; 42
    2a28:	71 e0       	ldi	r23, 0x01	; 1
    2a2a:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2a2e:	89 2b       	or	r24, r25
    2a30:	31 f4       	brne	.+12     	; 0x2a3e <debugFunction+0x50>
    {
      setArpDebug(NULL, 0);
    2a32:	60 e0       	ldi	r22, 0x00	; 0
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	90 e0       	ldi	r25, 0x00	; 0
    2a38:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <setArpDebug>
    2a3c:	2f c0       	rjmp	.+94     	; 0x2a9c <debugFunction+0xae>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2a3e:	42 e0       	ldi	r20, 0x02	; 2
    2a40:	50 e0       	ldi	r21, 0x00	; 0
    2a42:	67 e2       	ldi	r22, 0x27	; 39
    2a44:	71 e0       	ldi	r23, 0x01	; 1
    2a46:	81 2f       	mov	r24, r17
    2a48:	90 2f       	mov	r25, r16
    2a4a:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2a4e:	89 2b       	or	r24, r25
    2a50:	31 f4       	brne	.+12     	; 0x2a5e <debugFunction+0x70>
    {
      setIpDebug(NULL, 0);
    2a52:	60 e0       	ldi	r22, 0x00	; 0
    2a54:	80 e0       	ldi	r24, 0x00	; 0
    2a56:	90 e0       	ldi	r25, 0x00	; 0
    2a58:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <setIpDebug>
    2a5c:	1f c0       	rjmp	.+62     	; 0x2a9c <debugFunction+0xae>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2a5e:	42 e0       	ldi	r20, 0x02	; 2
    2a60:	50 e0       	ldi	r21, 0x00	; 0
    2a62:	62 e2       	ldi	r22, 0x22	; 34
    2a64:	71 e0       	ldi	r23, 0x01	; 1
    2a66:	81 2f       	mov	r24, r17
    2a68:	90 2f       	mov	r25, r16
    2a6a:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2a6e:	89 2b       	or	r24, r25
    2a70:	31 f4       	brne	.+12     	; 0x2a7e <debugFunction+0x90>
    {
      setIcmpDebug(NULL, 0);
    2a72:	60 e0       	ldi	r22, 0x00	; 0
    2a74:	80 e0       	ldi	r24, 0x00	; 0
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <setIcmpDebug>
    2a7c:	0f c0       	rjmp	.+30     	; 0x2a9c <debugFunction+0xae>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2a7e:	42 e0       	ldi	r20, 0x02	; 2
    2a80:	50 e0       	ldi	r21, 0x00	; 0
    2a82:	6e e1       	ldi	r22, 0x1E	; 30
    2a84:	71 e0       	ldi	r23, 0x01	; 1
    2a86:	81 2f       	mov	r24, r17
    2a88:	90 2f       	mov	r25, r16
    2a8a:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2a8e:	89 2b       	or	r24, r25
    2a90:	51 f4       	brne	.+20     	; 0x2aa6 <debugFunction+0xb8>
    {
      setTcpDebug(NULL, 0);
    2a92:	60 e0       	ldi	r22, 0x00	; 0
    2a94:	80 e0       	ldi	r24, 0x00	; 0
    2a96:	90 e0       	ldi	r25, 0x00	; 0
    2a98:	0e 94 46 36 	call	0x6c8c	; 0x6c8c <setTcpDebug>
      fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
    2a9c:	0f 93       	push	r16
    2a9e:	1f 93       	push	r17
    2aa0:	89 e0       	ldi	r24, 0x09	; 9
    2aa2:	98 e0       	ldi	r25, 0x08	; 8
    2aa4:	61 c0       	rjmp	.+194    	; 0x2b68 <debugFunction+0x17a>
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2aa6:	42 e0       	ldi	r20, 0x02	; 2
    2aa8:	50 e0       	ldi	r21, 0x00	; 0
    2aaa:	6a e1       	ldi	r22, 0x1A	; 26
    2aac:	71 e0       	ldi	r23, 0x01	; 1
    2aae:	81 2f       	mov	r24, r17
    2ab0:	90 2f       	mov	r25, r16
    2ab2:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2ab6:	89 2b       	or	r24, r25
    2ab8:	09 f0       	breq	.+2      	; 0x2abc <debugFunction+0xce>
    2aba:	a2 cf       	rjmp	.-188    	; 0x2a00 <debugFunction+0x12>
    {
      setUdpDebug(NULL, 0);
    2abc:	60 e0       	ldi	r22, 0x00	; 0
    2abe:	80 e0       	ldi	r24, 0x00	; 0
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	0e 94 94 36 	call	0x6d28	; 0x6d28 <setUdpDebug>
    2ac6:	ea cf       	rjmp	.-44     	; 0x2a9c <debugFunction+0xae>


  }
  else                   //level > 0
  {
    if (strncmp_P(str, PSTR("arp"), 3) == 0)
    2ac8:	66 e1       	ldi	r22, 0x16	; 22
    2aca:	71 e0       	ldi	r23, 0x01	; 1
    2acc:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2ad0:	89 2b       	or	r24, r25
    2ad2:	31 f4       	brne	.+12     	; 0x2ae0 <debugFunction+0xf2>
    {
      setArpDebug(state->myStdInOut, level);
    2ad4:	6f 2d       	mov	r22, r15
    2ad6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ad8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2ada:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <setArpDebug>
    2ade:	40 c0       	rjmp	.+128    	; 0x2b60 <debugFunction+0x172>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("ip"), 2) == 0)
    2ae0:	42 e0       	ldi	r20, 0x02	; 2
    2ae2:	50 e0       	ldi	r21, 0x00	; 0
    2ae4:	63 e1       	ldi	r22, 0x13	; 19
    2ae6:	71 e0       	ldi	r23, 0x01	; 1
    2ae8:	81 2f       	mov	r24, r17
    2aea:	90 2f       	mov	r25, r16
    2aec:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2af0:	89 2b       	or	r24, r25
    2af2:	31 f4       	brne	.+12     	; 0x2b00 <debugFunction+0x112>
    {
      setIpDebug(state->myStdInOut, level);
    2af4:	6f 2d       	mov	r22, r15
    2af6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2af8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2afa:	0e 94 dd 2d 	call	0x5bba	; 0x5bba <setIpDebug>
    2afe:	30 c0       	rjmp	.+96     	; 0x2b60 <debugFunction+0x172>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("icmp"), 2) == 0)
    2b00:	42 e0       	ldi	r20, 0x02	; 2
    2b02:	50 e0       	ldi	r21, 0x00	; 0
    2b04:	6e e0       	ldi	r22, 0x0E	; 14
    2b06:	71 e0       	ldi	r23, 0x01	; 1
    2b08:	81 2f       	mov	r24, r17
    2b0a:	90 2f       	mov	r25, r16
    2b0c:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2b10:	89 2b       	or	r24, r25
    2b12:	31 f4       	brne	.+12     	; 0x2b20 <debugFunction+0x132>
    {
      setIcmpDebug(state->myStdInOut, level);
    2b14:	6f 2d       	mov	r22, r15
    2b16:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b18:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2b1a:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <setIcmpDebug>
    2b1e:	20 c0       	rjmp	.+64     	; 0x2b60 <debugFunction+0x172>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("tcp"), 2) == 0)
    2b20:	42 e0       	ldi	r20, 0x02	; 2
    2b22:	50 e0       	ldi	r21, 0x00	; 0
    2b24:	6a e0       	ldi	r22, 0x0A	; 10
    2b26:	71 e0       	ldi	r23, 0x01	; 1
    2b28:	81 2f       	mov	r24, r17
    2b2a:	90 2f       	mov	r25, r16
    2b2c:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2b30:	89 2b       	or	r24, r25
    2b32:	31 f4       	brne	.+12     	; 0x2b40 <debugFunction+0x152>
    {
      setTcpDebug(state->myStdInOut, level);
    2b34:	6f 2d       	mov	r22, r15
    2b36:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b38:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2b3a:	0e 94 46 36 	call	0x6c8c	; 0x6c8c <setTcpDebug>
    2b3e:	10 c0       	rjmp	.+32     	; 0x2b60 <debugFunction+0x172>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
      return OK_SILENT;
    }

    if (strncmp_P(str, PSTR("udp"), 2) == 0)
    2b40:	42 e0       	ldi	r20, 0x02	; 2
    2b42:	50 e0       	ldi	r21, 0x00	; 0
    2b44:	66 e0       	ldi	r22, 0x06	; 6
    2b46:	71 e0       	ldi	r23, 0x01	; 1
    2b48:	81 2f       	mov	r24, r17
    2b4a:	90 2f       	mov	r25, r16
    2b4c:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    2b50:	89 2b       	or	r24, r25
    2b52:	09 f0       	breq	.+2      	; 0x2b56 <debugFunction+0x168>
    2b54:	55 cf       	rjmp	.-342    	; 0x2a00 <debugFunction+0x12>
    {
      setUdpDebug(state->myStdInOut, level);
    2b56:	6f 2d       	mov	r22, r15
    2b58:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b5a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2b5c:	0e 94 94 36 	call	0x6d28	; 0x6d28 <setUdpDebug>
      fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	8d e1       	ldi	r24, 0x1D	; 29
    2b66:	98 e0       	ldi	r25, 0x08	; 8
    2b68:	9f 93       	push	r25
    2b6a:	8f 93       	push	r24
    2b6c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2b6e:	8f 93       	push	r24
    2b70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b72:	8f 93       	push	r24
    2b74:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    2b78:	0f 90       	pop	r0
    2b7a:	0f 90       	pop	r0
    2b7c:	0f 90       	pop	r0
    2b7e:	0f 90       	pop	r0
    2b80:	0f 90       	pop	r0
    2b82:	0f 90       	pop	r0
      return OK_SILENT;
    2b84:	80 e0       	ldi	r24, 0x00	; 0
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    }
  }

  return SYNTAX_ERROR;
}
    2b88:	df 91       	pop	r29
    2b8a:	cf 91       	pop	r28
    2b8c:	1f 91       	pop	r17
    2b8e:	0f 91       	pop	r16
    2b90:	ff 90       	pop	r15
    2b92:	08 95       	ret

00002b94 <setMacAddrFunction>:
  saveSettings(adres);
  return OK_SILENT;
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
    2b94:	cf 93       	push	r28
    2b96:	df 93       	push	r29
  if (state->argc < 6)
    2b98:	fc 01       	movw	r30, r24
    2b9a:	21 8d       	ldd	r18, Z+25	; 0x19
    2b9c:	26 30       	cpi	r18, 0x06	; 6
    2b9e:	60 f1       	brcs	.+88     	; 0x2bf8 <setMacAddrFunction+0x64>
    2ba0:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
    2ba2:	bc 01       	movw	r22, r24
    2ba4:	81 e0       	ldi	r24, 0x01	; 1
    2ba6:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>
    2baa:	60 93 80 0e 	sts	0x0E80, r22
  nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
    2bae:	be 01       	movw	r22, r28
    2bb0:	82 e0       	ldi	r24, 0x02	; 2
    2bb2:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>
    2bb6:	60 93 81 0e 	sts	0x0E81, r22
  nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
    2bba:	be 01       	movw	r22, r28
    2bbc:	83 e0       	ldi	r24, 0x03	; 3
    2bbe:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>
    2bc2:	60 93 82 0e 	sts	0x0E82, r22
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
    2bc6:	be 01       	movw	r22, r28
    2bc8:	84 e0       	ldi	r24, 0x04	; 4
    2bca:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>
    2bce:	60 93 83 0e 	sts	0x0E83, r22
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
    2bd2:	be 01       	movw	r22, r28
    2bd4:	85 e0       	ldi	r24, 0x05	; 5
    2bd6:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>
    2bda:	60 93 84 0e 	sts	0x0E84, r22
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
    2bde:	be 01       	movw	r22, r28
    2be0:	86 e0       	ldi	r24, 0x06	; 6
    2be2:	0e 94 1a 24 	call	0x4834	; 0x4834 <cmdlineGetArgHex>
    2be6:	60 93 85 0e 	sts	0x0E85, r22
  nicSetMacAddress(nicState.mac.addr);
    2bea:	80 e8       	ldi	r24, 0x80	; 128
    2bec:	9e e0       	ldi	r25, 0x0E	; 14
    2bee:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <nicSetMacAddress>
    2bf2:	80 e0       	ldi	r24, 0x00	; 0
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	02 c0       	rjmp	.+4      	; 0x2bfc <setMacAddrFunction+0x68>
}

static cliExRes_t setMacAddrFunction(cmdState_t *state)
{
  if (state->argc < 6)
    return SYNTAX_ERROR;
    2bf8:	82 e0       	ldi	r24, 0x02	; 2
    2bfa:	90 e0       	ldi	r25, 0x00	; 0
  nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
  nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
  nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
  nicSetMacAddress(nicState.mac.addr);
  return OK_SILENT;
}
    2bfc:	df 91       	pop	r29
    2bfe:	cf 91       	pop	r28
    2c00:	08 95       	ret

00002c02 <setUdpFunction>:
  ipSetConfigIp(ip);
  return OK_SILENT;
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
    2c02:	8f 92       	push	r8
    2c04:	9f 92       	push	r9
    2c06:	af 92       	push	r10
    2c08:	bf 92       	push	r11
    2c0a:	cf 92       	push	r12
    2c0c:	df 92       	push	r13
    2c0e:	ef 92       	push	r14
    2c10:	ff 92       	push	r15
    2c12:	cf 93       	push	r28
    2c14:	df 93       	push	r29
  if (state->argc < 5)
    2c16:	fc 01       	movw	r30, r24
    2c18:	21 8d       	ldd	r18, Z+25	; 0x19
    2c1a:	25 30       	cpi	r18, 0x05	; 5
    2c1c:	08 f4       	brcc	.+2      	; 0x2c20 <setUdpFunction+0x1e>
    2c1e:	54 c0       	rjmp	.+168    	; 0x2cc8 <setUdpFunction+0xc6>
    2c20:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
    2c22:	bc 01       	movw	r22, r24
    2c24:	81 e0       	ldi	r24, 0x01	; 1
    2c26:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2c2a:	6b 01       	movw	r12, r22
    2c2c:	7c 01       	movw	r14, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2c2e:	be 01       	movw	r22, r28
    2c30:	82 e0       	ldi	r24, 0x02	; 2
    2c32:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2c36:	4b 01       	movw	r8, r22
    2c38:	5c 01       	movw	r10, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
    2c3a:	be 01       	movw	r22, r28
    2c3c:	83 e0       	ldi	r24, 0x03	; 3
    2c3e:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
{
  if (state->argc < 5)
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2c42:	ba 2c       	mov	r11, r10
    2c44:	a9 2c       	mov	r10, r9
    2c46:	98 2c       	mov	r9, r8
    2c48:	88 24       	eor	r8, r8
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
    2c4a:	55 27       	eor	r21, r21
    2c4c:	44 27       	eor	r20, r20
    2c4e:	d5 01       	movw	r26, r10
    2c50:	c4 01       	movw	r24, r8
    2c52:	84 0f       	add	r24, r20
    2c54:	95 1f       	adc	r25, r21
    2c56:	a6 1f       	adc	r26, r22
    2c58:	b7 1f       	adc	r27, r23
{
  if (state->argc < 5)
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2c5a:	c8 0e       	add	r12, r24
    2c5c:	d9 1e       	adc	r13, r25
    2c5e:	ea 1e       	adc	r14, r26
    2c60:	fb 1e       	adc	r15, r27
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
    2c62:	be 01       	movw	r22, r28
    2c64:	84 e0       	ldi	r24, 0x04	; 4
    2c66:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
  udpSocket->dstIp = ip;
    2c6a:	e0 91 a2 0e 	lds	r30, 0x0EA2
    2c6e:	f0 91 a3 0e 	lds	r31, 0x0EA3
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
    2c72:	b6 2f       	mov	r27, r22
    2c74:	aa 27       	eor	r26, r26
    2c76:	99 27       	eor	r25, r25
    2c78:	88 27       	eor	r24, r24
static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
    2c7a:	8c 0d       	add	r24, r12
    2c7c:	9d 1d       	adc	r25, r13
    2c7e:	ae 1d       	adc	r26, r14
    2c80:	bf 1d       	adc	r27, r15
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
  udpSocket->dstIp = ip;
    2c82:	86 83       	std	Z+6, r24	; 0x06
    2c84:	97 83       	std	Z+7, r25	; 0x07
    2c86:	a0 87       	std	Z+8, r26	; 0x08
    2c88:	b1 87       	std	Z+9, r27	; 0x09

  uint16_t port = cmdlineGetArgInt(5, state);
    2c8a:	be 01       	movw	r22, r28
    2c8c:	85 e0       	ldi	r24, 0x05	; 5
    2c8e:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
  udpSocket->srcPort = htons(port);
    2c92:	e0 90 a2 0e 	lds	r14, 0x0EA2
    2c96:	f0 90 a3 0e 	lds	r15, 0x0EA3
    2c9a:	cb 01       	movw	r24, r22
    2c9c:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    2ca0:	f7 01       	movw	r30, r14
    2ca2:	95 83       	std	Z+5, r25	; 0x05
    2ca4:	84 83       	std	Z+4, r24	; 0x04

  if (state->argc > 5)
    2ca6:	89 8d       	ldd	r24, Y+25	; 0x19
    2ca8:	86 30       	cpi	r24, 0x06	; 6
    2caa:	88 f0       	brcs	.+34     	; 0x2cce <setUdpFunction+0xcc>
  {
    port = cmdlineGetArgInt(6, state);
    2cac:	be 01       	movw	r22, r28
    2cae:	86 e0       	ldi	r24, 0x06	; 6
    2cb0:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    udpSocket->dstPort = htons(port);
    2cb4:	c0 91 a2 0e 	lds	r28, 0x0EA2
    2cb8:	d0 91 a3 0e 	lds	r29, 0x0EA3
    2cbc:	cb 01       	movw	r24, r22
    2cbe:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    2cc2:	9b 83       	std	Y+3, r25	; 0x03
    2cc4:	8a 83       	std	Y+2, r24	; 0x02
    2cc6:	03 c0       	rjmp	.+6      	; 0x2cce <setUdpFunction+0xcc>
}

static cliExRes_t setUdpFunction(cmdState_t *state)
{
  if (state->argc < 5)
    return SYNTAX_ERROR;
    2cc8:	82 e0       	ldi	r24, 0x02	; 2
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	02 c0       	rjmp	.+4      	; 0x2cd2 <setUdpFunction+0xd0>
  udpSocket->dstIp = ip;

  uint16_t port = cmdlineGetArgInt(5, state);
  udpSocket->srcPort = htons(port);

  if (state->argc > 5)
    2cce:	80 e0       	ldi	r24, 0x00	; 0
    2cd0:	90 e0       	ldi	r25, 0x00	; 0
  {
    port = cmdlineGetArgInt(6, state);
    udpSocket->dstPort = htons(port);
  }
  return OK_SILENT;
}
    2cd2:	df 91       	pop	r29
    2cd4:	cf 91       	pop	r28
    2cd6:	ff 90       	pop	r15
    2cd8:	ef 90       	pop	r14
    2cda:	df 90       	pop	r13
    2cdc:	cf 90       	pop	r12
    2cde:	bf 90       	pop	r11
    2ce0:	af 90       	pop	r10
    2ce2:	9f 90       	pop	r9
    2ce4:	8f 90       	pop	r8
    2ce6:	08 95       	ret

00002ce8 <setIpGwFunction>:
  return OK_SILENT;
}


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
    2ce8:	8f 92       	push	r8
    2cea:	9f 92       	push	r9
    2cec:	af 92       	push	r10
    2cee:	bf 92       	push	r11
    2cf0:	cf 92       	push	r12
    2cf2:	df 92       	push	r13
    2cf4:	ef 92       	push	r14
    2cf6:	ff 92       	push	r15
    2cf8:	cf 93       	push	r28
    2cfa:	df 93       	push	r29
  if (state->argc < 4)
    2cfc:	fc 01       	movw	r30, r24
    2cfe:	21 8d       	ldd	r18, Z+25	; 0x19
    2d00:	24 30       	cpi	r18, 0x04	; 4
    2d02:	a0 f1       	brcs	.+104    	; 0x2d6c <setIpGwFunction+0x84>
    2d04:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  uint32_t gw = cmdlineGetArgInt(1, state) +
    2d06:	bc 01       	movw	r22, r24
    2d08:	81 e0       	ldi	r24, 0x01	; 1
    2d0a:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2d0e:	6b 01       	movw	r12, r22
    2d10:	7c 01       	movw	r14, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2d12:	be 01       	movw	r22, r28
    2d14:	82 e0       	ldi	r24, 0x02	; 2
    2d16:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2d1a:	4b 01       	movw	r8, r22
    2d1c:	5c 01       	movw	r10, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    2d1e:	be 01       	movw	r22, r28
    2d20:	83 e0       	ldi	r24, 0x03	; 3
    2d22:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
{
  if (state->argc < 4)
    return SYNTAX_ERROR;

  uint32_t gw = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2d26:	ba 2c       	mov	r11, r10
    2d28:	a9 2c       	mov	r10, r9
    2d2a:	98 2c       	mov	r9, r8
    2d2c:	88 24       	eor	r8, r8
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
    2d2e:	55 27       	eor	r21, r21
    2d30:	44 27       	eor	r20, r20
    2d32:	d5 01       	movw	r26, r10
    2d34:	c4 01       	movw	r24, r8
    2d36:	84 0f       	add	r24, r20
    2d38:	95 1f       	adc	r25, r21
    2d3a:	a6 1f       	adc	r26, r22
    2d3c:	b7 1f       	adc	r27, r23
{
  if (state->argc < 4)
    return SYNTAX_ERROR;

  uint32_t gw = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2d3e:	c8 0e       	add	r12, r24
    2d40:	d9 1e       	adc	r13, r25
    2d42:	ea 1e       	adc	r14, r26
    2d44:	fb 1e       	adc	r15, r27
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
    2d46:	be 01       	movw	r22, r28
    2d48:	84 e0       	ldi	r24, 0x04	; 4
    2d4a:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2d4e:	b6 2f       	mov	r27, r22
    2d50:	aa 27       	eor	r26, r26
    2d52:	99 27       	eor	r25, r25
    2d54:	88 27       	eor	r24, r24
static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;

  uint32_t gw = cmdlineGetArgInt(1, state) +
    2d56:	bc 01       	movw	r22, r24
    2d58:	cd 01       	movw	r24, r26
    2d5a:	6c 0d       	add	r22, r12
    2d5c:	7d 1d       	adc	r23, r13
    2d5e:	8e 1d       	adc	r24, r14
    2d60:	9f 1d       	adc	r25, r15
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
  ipSetConfigGw(gw);
    2d62:	0e 94 13 2e 	call	0x5c26	; 0x5c26 <ipSetConfigGw>
    2d66:	80 e0       	ldi	r24, 0x00	; 0
    2d68:	90 e0       	ldi	r25, 0x00	; 0
    2d6a:	02 c0       	rjmp	.+4      	; 0x2d70 <setIpGwFunction+0x88>


static cliExRes_t setIpGwFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    2d6c:	82 e0       	ldi	r24, 0x02	; 2
    2d6e:	90 e0       	ldi	r25, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
  ipSetConfigGw(gw);
  return OK_SILENT;
}
    2d70:	df 91       	pop	r29
    2d72:	cf 91       	pop	r28
    2d74:	ff 90       	pop	r15
    2d76:	ef 90       	pop	r14
    2d78:	df 90       	pop	r13
    2d7a:	cf 90       	pop	r12
    2d7c:	bf 90       	pop	r11
    2d7e:	af 90       	pop	r10
    2d80:	9f 90       	pop	r9
    2d82:	8f 90       	pop	r8
    2d84:	08 95       	ret

00002d86 <setIpMaskFunction>:
}


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
  if (state->argc < 1)
    2d86:	fc 01       	movw	r30, r24
    2d88:	21 8d       	ldd	r18, Z+25	; 0x19
    2d8a:	22 23       	and	r18, r18
    2d8c:	c9 f0       	breq	.+50     	; 0x2dc0 <setIpMaskFunction+0x3a>
    2d8e:	bc 01       	movw	r22, r24
    return SYNTAX_ERROR;

  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
    2d90:	81 e0       	ldi	r24, 0x01	; 1
    2d92:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2d96:	20 e2       	ldi	r18, 0x20	; 32
    2d98:	30 e0       	ldi	r19, 0x00	; 0
    2d9a:	26 1b       	sub	r18, r22
    2d9c:	37 0b       	sbc	r19, r23
    2d9e:	8f ef       	ldi	r24, 0xFF	; 255
    2da0:	9f ef       	ldi	r25, 0xFF	; 255
    2da2:	dc 01       	movw	r26, r24
    2da4:	bc 01       	movw	r22, r24
    2da6:	cd 01       	movw	r24, r26
    2da8:	04 c0       	rjmp	.+8      	; 0x2db2 <setIpMaskFunction+0x2c>
    2daa:	96 95       	lsr	r25
    2dac:	87 95       	ror	r24
    2dae:	77 95       	ror	r23
    2db0:	67 95       	ror	r22
    2db2:	2a 95       	dec	r18
    2db4:	d2 f7       	brpl	.-12     	; 0x2daa <setIpMaskFunction+0x24>

  ipSetConfigMask(mask);
    2db6:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <ipSetConfigMask>
    2dba:	80 e0       	ldi	r24, 0x00	; 0
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
    2dbe:	08 95       	ret


static cliExRes_t setIpMaskFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2dc0:	82 e0       	ldi	r24, 0x02	; 2
    2dc2:	90 e0       	ldi	r25, 0x00	; 0

  uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));

  ipSetConfigMask(mask);
  return OK_SILENT;
}
    2dc4:	08 95       	ret

00002dc6 <setIpFunction>:
  setTimeDecoded((timeDecoded_t *)(&czasRtc));
  return OK_SILENT;
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
    2dc6:	8f 92       	push	r8
    2dc8:	9f 92       	push	r9
    2dca:	af 92       	push	r10
    2dcc:	bf 92       	push	r11
    2dce:	cf 92       	push	r12
    2dd0:	df 92       	push	r13
    2dd2:	ef 92       	push	r14
    2dd4:	ff 92       	push	r15
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
  if (state->argc < 4)
    2dda:	fc 01       	movw	r30, r24
    2ddc:	21 8d       	ldd	r18, Z+25	; 0x19
    2dde:	24 30       	cpi	r18, 0x04	; 4
    2de0:	a0 f1       	brcs	.+104    	; 0x2e4a <setIpFunction+0x84>
    2de2:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
    2de4:	bc 01       	movw	r22, r24
    2de6:	81 e0       	ldi	r24, 0x01	; 1
    2de8:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2dec:	6b 01       	movw	r12, r22
    2dee:	7c 01       	movw	r14, r24
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2df0:	be 01       	movw	r22, r28
    2df2:	82 e0       	ldi	r24, 0x02	; 2
    2df4:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2df8:	4b 01       	movw	r8, r22
    2dfa:	5c 01       	movw	r10, r24
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
    2dfc:	be 01       	movw	r22, r28
    2dfe:	83 e0       	ldi	r24, 0x03	; 3
    2e00:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
{
  if (state->argc < 4)
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2e04:	ba 2c       	mov	r11, r10
    2e06:	a9 2c       	mov	r10, r9
    2e08:	98 2c       	mov	r9, r8
    2e0a:	88 24       	eor	r8, r8
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
    2e0c:	55 27       	eor	r21, r21
    2e0e:	44 27       	eor	r20, r20
    2e10:	d5 01       	movw	r26, r10
    2e12:	c4 01       	movw	r24, r8
    2e14:	84 0f       	add	r24, r20
    2e16:	95 1f       	adc	r25, r21
    2e18:	a6 1f       	adc	r26, r22
    2e1a:	b7 1f       	adc	r27, r23
{
  if (state->argc < 4)
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
    2e1c:	c8 0e       	add	r12, r24
    2e1e:	d9 1e       	adc	r13, r25
    2e20:	ea 1e       	adc	r14, r26
    2e22:	fb 1e       	adc	r15, r27
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
    2e24:	be 01       	movw	r22, r28
    2e26:	84 e0       	ldi	r24, 0x04	; 4
    2e28:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2e2c:	b6 2f       	mov	r27, r22
    2e2e:	aa 27       	eor	r26, r26
    2e30:	99 27       	eor	r25, r25
    2e32:	88 27       	eor	r24, r24
static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;

  uint32_t ip = cmdlineGetArgInt(1, state) +
    2e34:	bc 01       	movw	r22, r24
    2e36:	cd 01       	movw	r24, r26
    2e38:	6c 0d       	add	r22, r12
    2e3a:	7d 1d       	adc	r23, r13
    2e3c:	8e 1d       	adc	r24, r14
    2e3e:	9f 1d       	adc	r25, r15
                (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);

  ipSetConfigIp(ip);
    2e40:	0e 94 01 2e 	call	0x5c02	; 0x5c02 <ipSetConfigIp>
    2e44:	80 e0       	ldi	r24, 0x00	; 0
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	02 c0       	rjmp	.+4      	; 0x2e4e <setIpFunction+0x88>
}

static cliExRes_t setIpFunction(cmdState_t *state)
{
  if (state->argc < 4)
    return SYNTAX_ERROR;
    2e4a:	82 e0       	ldi	r24, 0x02	; 2
    2e4c:	90 e0       	ldi	r25, 0x00	; 0
                (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
                (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);

  ipSetConfigIp(ip);
  return OK_SILENT;
}
    2e4e:	df 91       	pop	r29
    2e50:	cf 91       	pop	r28
    2e52:	ff 90       	pop	r15
    2e54:	ef 90       	pop	r14
    2e56:	df 90       	pop	r13
    2e58:	cf 90       	pop	r12
    2e5a:	bf 90       	pop	r11
    2e5c:	af 90       	pop	r10
    2e5e:	9f 90       	pop	r9
    2e60:	8f 90       	pop	r8
    2e62:	08 95       	ret

00002e64 <VtyInit>:
  {cmd_disable,      cmd_help_disable,      disableFunction},
  {NULL, NULL, NULL}
};

void VtyInit(cmdState_t* state, FILE *stream)
{
    2e64:	ef 92       	push	r14
    2e66:	0f 93       	push	r16
    2e68:	1f 93       	push	r17
    2e6a:	9b 01       	movw	r18, r22
  cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR_NORMAL);
    2e6c:	e1 2c       	mov	r14, r1
    2e6e:	0a e7       	ldi	r16, 0x7A	; 122
    2e70:	12 e0       	ldi	r17, 0x02	; 2
    2e72:	40 e0       	ldi	r20, 0x00	; 0
    2e74:	51 e0       	ldi	r21, 0x01	; 1
    2e76:	60 e0       	ldi	r22, 0x00	; 0
    2e78:	78 e2       	ldi	r23, 0x28	; 40
    2e7a:	0e 94 1f 20 	call	0x403e	; 0x403e <cmdStateConfigure>
}
    2e7e:	1f 91       	pop	r17
    2e80:	0f 91       	pop	r16
    2e82:	ef 90       	pop	r14
    2e84:	08 95       	ret

00002e86 <printErrorInfo>:

void printErrorInfo(cmdState_t *state)
{
    2e86:	cf 93       	push	r28
    2e88:	df 93       	push	r29
    2e8a:	ec 01       	movw	r28, r24
  if (state->errno != 0)
    2e8c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    2e8e:	ee 23       	and	r30, r30
    2e90:	f1 f0       	breq	.+60     	; 0x2ece <printErrorInfo+0x48>
  {
    fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->err1, state->err2);
    2e92:	f0 e0       	ldi	r31, 0x00	; 0
    2e94:	ee 0f       	add	r30, r30
    2e96:	ff 1f       	adc	r31, r31
    2e98:	e0 55       	subi	r30, 0x50	; 80
    2e9a:	fd 4f       	sbci	r31, 0xFD	; 253
    2e9c:	85 91       	lpm	r24, Z+
    2e9e:	94 91       	lpm	r25, Z
    2ea0:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2ea2:	1f 92       	push	r1
    2ea4:	2f 93       	push	r18
    2ea6:	2e 8d       	ldd	r18, Y+30	; 0x1e
    2ea8:	2f 93       	push	r18
    2eaa:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2eac:	2f 93       	push	r18
    2eae:	9f 93       	push	r25
    2eb0:	8f 93       	push	r24
    2eb2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2eb4:	8f 93       	push	r24
    2eb6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2eb8:	8f 93       	push	r24
    2eba:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    2ebe:	8d b7       	in	r24, 0x3d	; 61
    2ec0:	9e b7       	in	r25, 0x3e	; 62
    2ec2:	08 96       	adiw	r24, 0x08	; 8
    2ec4:	0f b6       	in	r0, 0x3f	; 63
    2ec6:	f8 94       	cli
    2ec8:	9e bf       	out	0x3e, r25	; 62
    2eca:	0f be       	out	0x3f, r0	; 63
    2ecc:	8d bf       	out	0x3d, r24	; 61
  }
  state->errno = 0;
    2ece:	1c 8e       	std	Y+28, r1	; 0x1c
  state->err1 = 0;
    2ed0:	1e 8e       	std	Y+30, r1	; 0x1e
    2ed2:	1d 8e       	std	Y+29, r1	; 0x1d
  state->err2 = 0;
    2ed4:	1f 8e       	std	Y+31, r1	; 0x1f
}
    2ed6:	df 91       	pop	r29
    2ed8:	cf 91       	pop	r28
    2eda:	08 95       	ret

00002edc <rpingFunction>:

  return OK_SILENT;
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
    2edc:	0f 93       	push	r16
    2ede:	1f 93       	push	r17
    2ee0:	cf 93       	push	r28
    2ee2:	df 93       	push	r29
    2ee4:	1f 92       	push	r1
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
  if (state->argc < 1)
    2eea:	fc 01       	movw	r30, r24
    2eec:	21 8d       	ldd	r18, Z+25	; 0x19
    2eee:	22 23       	and	r18, r18
    2ef0:	c9 f0       	breq	.+50     	; 0x2f24 <rpingFunction+0x48>
    2ef2:	8c 01       	movw	r16, r24
    return SYNTAX_ERROR;

  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
    2ef4:	bc 01       	movw	r22, r24
    2ef6:	81 e0       	ldi	r24, 0x01	; 1
    2ef8:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    2efc:	86 2f       	mov	r24, r22
    2efe:	69 83       	std	Y+1, r22	; 0x01
    2f00:	0e 94 59 39 	call	0x72b2	; 0x72b2 <rs485ping>
    2f04:	f8 01       	movw	r30, r16
    2f06:	87 8f       	std	Z+31, r24	; 0x1f
    2f08:	69 81       	ldd	r22, Y+1	; 0x01
    2f0a:	88 23       	and	r24, r24
    2f0c:	71 f0       	breq	.+28     	; 0x2f2a <rpingFunction+0x4e>
    return OK_INFORM;

  state->errno = noRemoteDevice;
    2f0e:	89 e0       	ldi	r24, 0x09	; 9
    2f10:	84 8f       	std	Z+28, r24	; 0x1c
  state->err1 = nrSterownika;
    2f12:	70 e0       	ldi	r23, 0x00	; 0
    2f14:	76 8f       	std	Z+30, r23	; 0x1e
    2f16:	65 8f       	std	Z+29, r22	; 0x1d
  printErrorInfo(state);
    2f18:	c8 01       	movw	r24, r16
    2f1a:	0e 94 43 17 	call	0x2e86	; 0x2e86 <printErrorInfo>
  return OK_SILENT;
    2f1e:	80 e0       	ldi	r24, 0x00	; 0
    2f20:	90 e0       	ldi	r25, 0x00	; 0
    2f22:	05 c0       	rjmp	.+10     	; 0x2f2e <rpingFunction+0x52>
}

static cliExRes_t rpingFunction(cmdState_t *state)
{
  if (state->argc < 1)
    return SYNTAX_ERROR;
    2f24:	82 e0       	ldi	r24, 0x02	; 2
    2f26:	90 e0       	ldi	r25, 0x00	; 0
    2f28:	02 c0       	rjmp	.+4      	; 0x2f2e <rpingFunction+0x52>

  uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
  if ((state->err2 = rs485ping(nrSterownika)) == 0)
    return OK_INFORM;
    2f2a:	81 e0       	ldi	r24, 0x01	; 1
    2f2c:	90 e0       	ldi	r25, 0x00	; 0

  state->errno = noRemoteDevice;
  state->err1 = nrSterownika;
  printErrorInfo(state);
  return OK_SILENT;
}
    2f2e:	0f 90       	pop	r0
    2f30:	df 91       	pop	r29
    2f32:	cf 91       	pop	r28
    2f34:	1f 91       	pop	r17
    2f36:	0f 91       	pop	r16
    2f38:	08 95       	ret

00002f3a <eraseRamFileFunction>:
  ramDyskZamknijPlik(&fdVty);
  return OK_SILENT;
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
    2f3a:	cf 93       	push	r28
    2f3c:	df 93       	push	r29
    2f3e:	ec 01       	movw	r28, r24
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    2f40:	bc 01       	movw	r22, r24
    2f42:	81 e0       	ldi	r24, 0x01	; 1
    2f44:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2f48:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <ramDyskUsunPlik>
    2f4c:	88 23       	and	r24, r24
    2f4e:	31 f0       	breq	.+12     	; 0x2f5c <eraseRamFileFunction+0x22>
    return OK_INFORM;

  printErrorInfo(state);
    2f50:	ce 01       	movw	r24, r28
    2f52:	0e 94 43 17 	call	0x2e86	; 0x2e86 <printErrorInfo>
  return ERROR_INFORM;
    2f56:	84 e0       	ldi	r24, 0x04	; 4
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	02 c0       	rjmp	.+4      	; 0x2f60 <eraseRamFileFunction+0x26>
}

static cliExRes_t eraseRamFileFunction(cmdState_t *state)
{
  if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
    return OK_INFORM;
    2f5c:	81 e0       	ldi	r24, 0x01	; 1
    2f5e:	90 e0       	ldi	r25, 0x00	; 0

  printErrorInfo(state);
  return ERROR_INFORM;
}
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	08 95       	ret

00002f66 <dodajRamPlikFunction>:

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
    2f66:	cf 93       	push	r28
    2f68:	df 93       	push	r29
  if (state->argc != 1)
    2f6a:	fc 01       	movw	r30, r24
    2f6c:	21 8d       	ldd	r18, Z+25	; 0x19
    2f6e:	21 30       	cpi	r18, 0x01	; 1
    2f70:	79 f4       	brne	.+30     	; 0x2f90 <dodajRamPlikFunction+0x2a>
    2f72:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
    2f74:	bc 01       	movw	r22, r24
    2f76:	81 e0       	ldi	r24, 0x01	; 1
    2f78:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2f7c:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <ramDyskUtworzPlik>
    2f80:	88 23       	and	r24, r24
    2f82:	49 f0       	breq	.+18     	; 0x2f96 <dodajRamPlikFunction+0x30>
  {
    return OK_INFORM;
  }
  printErrorInfo(state);
    2f84:	ce 01       	movw	r24, r28
    2f86:	0e 94 43 17 	call	0x2e86	; 0x2e86 <printErrorInfo>
  return ERROR_INFORM;
    2f8a:	84 e0       	ldi	r24, 0x04	; 4
    2f8c:	90 e0       	ldi	r25, 0x00	; 0
    2f8e:	05 c0       	rjmp	.+10     	; 0x2f9a <dodajRamPlikFunction+0x34>
}

static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
{
  if (state->argc != 1)
    return SYNTAX_ERROR;
    2f90:	82 e0       	ldi	r24, 0x02	; 2
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	02 c0       	rjmp	.+4      	; 0x2f9a <dodajRamPlikFunction+0x34>

  if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
  {
    return OK_INFORM;
    2f96:	81 e0       	ldi	r24, 0x01	; 1
    2f98:	90 e0       	ldi	r25, 0x00	; 0
  }
  printErrorInfo(state);
  return ERROR_INFORM;
}
    2f9a:	df 91       	pop	r29
    2f9c:	cf 91       	pop	r28
    2f9e:	08 95       	ret

00002fa0 <flashExModuleFunction>:
  return OK_SILENT;
}


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
    2fa0:	ff 92       	push	r15
    2fa2:	0f 93       	push	r16
    2fa4:	1f 93       	push	r17
    2fa6:	cf 93       	push	r28
    2fa8:	df 93       	push	r29
  if (state->argc != 2)
    2faa:	fc 01       	movw	r30, r24
    2fac:	21 8d       	ldd	r18, Z+25	; 0x19
    2fae:	22 30       	cpi	r18, 0x02	; 2
    2fb0:	09 f0       	breq	.+2      	; 0x2fb4 <flashExModuleFunction+0x14>
    2fb2:	43 c0       	rjmp	.+134    	; 0x303a <flashExModuleFunction+0x9a>
    2fb4:	ec 01       	movw	r28, r24
    return SYNTAX_ERROR;

  uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
    2fb6:	bc 01       	movw	r22, r24
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	0e 94 07 24 	call	0x480e	; 0x480e <cmdlineGetArgInt>
    2fbe:	16 2f       	mov	r17, r22
  char *nazwaPliku      = cmdlineGetArgStr(2, state);
    2fc0:	be 01       	movw	r22, r28
    2fc2:	82 e0       	ldi	r24, 0x02	; 2
    2fc4:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    2fc8:	08 2f       	mov	r16, r24
    2fca:	f9 2e       	mov	r15, r25
  uint8_t  blad;

  // Sprawdzanie, czy moduł wykonawczy odpowiada
  if (rs485ping(nrUrzadzenia) != 0)
    2fcc:	81 2f       	mov	r24, r17
    2fce:	0e 94 59 39 	call	0x72b2	; 0x72b2 <rs485ping>
    2fd2:	88 23       	and	r24, r24
    2fd4:	31 f0       	breq	.+12     	; 0x2fe2 <flashExModuleFunction+0x42>
  {
    state->errno = noRemoteDevice;
    2fd6:	89 e0       	ldi	r24, 0x09	; 9
    2fd8:	8c 8f       	std	Y+28, r24	; 0x1c
    printErrorInfo(state);
    2fda:	ce 01       	movw	r24, r28
    2fdc:	0e 94 43 17 	call	0x2e86	; 0x2e86 <printErrorInfo>
    2fe0:	2f c0       	rjmp	.+94     	; 0x3040 <flashExModuleFunction+0xa0>
    return ERROR_INFORM;
  }

  //Sprawdzanie, czy istnieje odpowiedni plik z firmware
  if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
    2fe2:	62 e6       	ldi	r22, 0x62	; 98
    2fe4:	7f e0       	ldi	r23, 0x0F	; 15
    2fe6:	80 2f       	mov	r24, r16
    2fe8:	9f 2d       	mov	r25, r15
    2fea:	0e 94 bd 1b 	call	0x377a	; 0x377a <ramDyskOtworzPlik>
    2fee:	88 23       	and	r24, r24
    2ff0:	99 f0       	breq	.+38     	; 0x3018 <flashExModuleFunction+0x78>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
    2ff2:	ff 92       	push	r15
    2ff4:	0f 93       	push	r16
    2ff6:	8e ea       	ldi	r24, 0xAE	; 174
    2ff8:	9a e0       	ldi	r25, 0x0A	; 10
    2ffa:	9f 93       	push	r25
    2ffc:	8f 93       	push	r24
    2ffe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3000:	8f 93       	push	r24
    3002:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3004:	8f 93       	push	r24
    3006:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    300a:	0f 90       	pop	r0
    300c:	0f 90       	pop	r0
    300e:	0f 90       	pop	r0
    3010:	0f 90       	pop	r0
    3012:	0f 90       	pop	r0
    3014:	0f 90       	pop	r0
    3016:	14 c0       	rjmp	.+40     	; 0x3040 <flashExModuleFunction+0xa0>
    return ERROR_INFORM;
  }

  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
    3018:	4a 8d       	ldd	r20, Y+26	; 0x1a
    301a:	5b 8d       	ldd	r21, Y+27	; 0x1b
    301c:	61 2f       	mov	r22, r17
    301e:	82 e6       	ldi	r24, 0x62	; 98
    3020:	9f e0       	ldi	r25, 0x0F	; 15
    3022:	0e 94 6d 3b 	call	0x76da	; 0x76da <rs485xModemFlash>
    3026:	c8 2f       	mov	r28, r24

  ramDyskZamknijPlik(&fdVty);
    3028:	82 e6       	ldi	r24, 0x62	; 98
    302a:	9f e0       	ldi	r25, 0x0F	; 15
    302c:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <ramDyskZamknijPlik>

  if (blad != 0)
    3030:	c1 11       	cpse	r28, r1
    3032:	06 c0       	rjmp	.+12     	; 0x3040 <flashExModuleFunction+0xa0>
    return ERROR_INFORM;

  return OK_SILENT;
    3034:	80 e0       	ldi	r24, 0x00	; 0
    3036:	90 e0       	ldi	r25, 0x00	; 0
    3038:	05 c0       	rjmp	.+10     	; 0x3044 <flashExModuleFunction+0xa4>


static cliExRes_t flashExModuleFunction(cmdState_t *state)
{
  if (state->argc != 2)
    return SYNTAX_ERROR;
    303a:	82 e0       	ldi	r24, 0x02	; 2
    303c:	90 e0       	ldi	r25, 0x00	; 0
    303e:	02 c0       	rjmp	.+4      	; 0x3044 <flashExModuleFunction+0xa4>
  blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);

  ramDyskZamknijPlik(&fdVty);

  if (blad != 0)
    return ERROR_INFORM;
    3040:	84 e0       	ldi	r24, 0x04	; 4
    3042:	90 e0       	ldi	r25, 0x00	; 0

  return OK_SILENT;
}
    3044:	df 91       	pop	r29
    3046:	cf 91       	pop	r28
    3048:	1f 91       	pop	r17
    304a:	0f 91       	pop	r16
    304c:	ff 90       	pop	r15
    304e:	08 95       	ret

00003050 <printStatus>:
  return ERROR_OPERATION_NOT_ALLOWED;
}

// ************************** VTY API ***************************************************************************************
void printStatus(FILE *stream)
{
    3050:	cf 93       	push	r28
    3052:	df 93       	push	r29
    3054:	d8 2f       	mov	r29, r24
    3056:	c9 2f       	mov	r28, r25
  fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n"));
    3058:	84 ed       	ldi	r24, 0xD4	; 212
    305a:	90 e0       	ldi	r25, 0x00	; 0
    305c:	9f 93       	push	r25
    305e:	8f 93       	push	r24
    3060:	cf 93       	push	r28
    3062:	df 93       	push	r29
    3064:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  //Print system state
  fprintf_P(stream, systemStateStr);
    3068:	8e e9       	ldi	r24, 0x9E	; 158
    306a:	9a e0       	ldi	r25, 0x0A	; 10
    306c:	9f 93       	push	r25
    306e:	8f 93       	push	r24
    3070:	cf 93       	push	r28
    3072:	df 93       	push	r29
    3074:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
    3078:	0e 94 03 42 	call	0x8406	; 0x8406 <uxTaskGetNumberOfTasks>
    307c:	1f 92       	push	r1
    307e:	8f 93       	push	r24
    3080:	85 e8       	ldi	r24, 0x85	; 133
    3082:	9a e0       	ldi	r25, 0x0A	; 10
    3084:	9f 93       	push	r25
    3086:	8f 93       	push	r24
    3088:	cf 93       	push	r28
    308a:	df 93       	push	r29
    308c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
    3090:	0e 94 d5 4a 	call	0x95aa	; 0x95aa <xPortGetFreeHeapSize>
    3094:	2c e0       	ldi	r18, 0x0C	; 12
    3096:	2f 93       	push	r18
    3098:	2c e1       	ldi	r18, 0x1C	; 28
    309a:	2f 93       	push	r18
    309c:	9f 93       	push	r25
    309e:	8f 93       	push	r24
    30a0:	8b e5       	ldi	r24, 0x5B	; 91
    30a2:	9a e0       	ldi	r25, 0x0A	; 10
    30a4:	9f 93       	push	r25
    30a6:	8f 93       	push	r24
    30a8:	cf 93       	push	r28
    30aa:	df 93       	push	r29
    30ac:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
    30b0:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <xmallocAvailable>
    30b4:	27 e1       	ldi	r18, 0x17	; 23
    30b6:	2f 93       	push	r18
    30b8:	1f 92       	push	r1
    30ba:	9f 93       	push	r25
    30bc:	8f 93       	push	r24
    30be:	81 e3       	ldi	r24, 0x31	; 49
    30c0:	9a e0       	ldi	r25, 0x0A	; 10
    30c2:	9f 93       	push	r25
    30c4:	8f 93       	push	r24
    30c6:	cf 93       	push	r28
    30c8:	df 93       	push	r29
    30ca:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, statusTemperatureStr, temperature);
    30ce:	80 91 a4 0e 	lds	r24, 0x0EA4
    30d2:	1f 92       	push	r1
    30d4:	8f 93       	push	r24
    30d6:	89 ee       	ldi	r24, 0xE9	; 233
    30d8:	99 e0       	ldi	r25, 0x09	; 9
    30da:	9f 93       	push	r25
    30dc:	8f 93       	push	r24
    30de:	cf 93       	push	r28
    30e0:	df 93       	push	r29
    30e2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, statusVoltageStr, voltage);
    30e6:	80 91 ae 0e 	lds	r24, 0x0EAE
    30ea:	2d b7       	in	r18, 0x3d	; 61
    30ec:	3e b7       	in	r19, 0x3e	; 62
    30ee:	2c 5d       	subi	r18, 0xDC	; 220
    30f0:	3f 4f       	sbci	r19, 0xFF	; 255
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	3e bf       	out	0x3e, r19	; 62
    30f8:	0f be       	out	0x3f, r0	; 63
    30fa:	2d bf       	out	0x3d, r18	; 61
    30fc:	1f 92       	push	r1
    30fe:	8f 93       	push	r24
    3100:	8e ec       	ldi	r24, 0xCE	; 206
    3102:	99 e0       	ldi	r25, 0x09	; 9
    3104:	9f 93       	push	r25
    3106:	8f 93       	push	r24
    3108:	cf 93       	push	r28
    310a:	df 93       	push	r29
    310c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
    3110:	0e 94 48 1f 	call	0x3e90	; 0x3e90 <ramDyskLiczbaWolnychKlastrow>
  fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
    3114:	1f 92       	push	r1
    3116:	90 e8       	ldi	r25, 0x80	; 128
    3118:	9f 93       	push	r25
    311a:	1f 92       	push	r1
    311c:	8f 93       	push	r24
    311e:	84 e0       	ldi	r24, 0x04	; 4
    3120:	9a e0       	ldi	r25, 0x0A	; 10
    3122:	9f 93       	push	r25
    3124:	8f 93       	push	r24
    3126:	cf 93       	push	r28
    3128:	df 93       	push	r29
    312a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
//  printErrorInfo(state); //TODO fix and uncomment

  //Print system configuration
  fprintf_P(stream, systemRamConfigStr);
    312e:	8b eb       	ldi	r24, 0xBB	; 187
    3130:	99 e0       	ldi	r25, 0x09	; 9
    3132:	9f 93       	push	r25
    3134:	8f 93       	push	r24
    3136:	cf 93       	push	r28
    3138:	df 93       	push	r29
    313a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  fprintf_P(stream, statusMacStr);
    313e:	86 ea       	ldi	r24, 0xA6	; 166
    3140:	99 e0       	ldi	r25, 0x09	; 9
    3142:	9f 93       	push	r25
    3144:	8f 93       	push	r24
    3146:	cf 93       	push	r28
    3148:	df 93       	push	r29
    314a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    314e:	60 e8       	ldi	r22, 0x80	; 128
    3150:	7e e0       	ldi	r23, 0x0E	; 14
    3152:	8d 2f       	mov	r24, r29
    3154:	9c 2f       	mov	r25, r28
    3156:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
  fprintf_P(stream, PSTR("\r\n"));
    315a:	81 ed       	ldi	r24, 0xD1	; 209
    315c:	90 e0       	ldi	r25, 0x00	; 0
    315e:	9f 93       	push	r25
    3160:	8f 93       	push	r24
    3162:	cf 93       	push	r28
    3164:	df 93       	push	r29
    3166:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  fprintf_P(stream, statusIpStr);
    316a:	81 e9       	ldi	r24, 0x91	; 145
    316c:	99 e0       	ldi	r25, 0x09	; 9
    316e:	9f 93       	push	r25
    3170:	8f 93       	push	r24
    3172:	cf 93       	push	r28
    3174:	df 93       	push	r29
    3176:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->ip);
    317a:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <ipGetConfig>
    317e:	fc 01       	movw	r30, r24
    3180:	40 81       	ld	r20, Z
    3182:	51 81       	ldd	r21, Z+1	; 0x01
    3184:	62 81       	ldd	r22, Z+2	; 0x02
    3186:	73 81       	ldd	r23, Z+3	; 0x03
    3188:	8d 2f       	mov	r24, r29
    318a:	9c 2f       	mov	r25, r28
    318c:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    3190:	8e ec       	ldi	r24, 0xCE	; 206
    3192:	90 e0       	ldi	r25, 0x00	; 0
    3194:	9f 93       	push	r25
    3196:	8f 93       	push	r24
    3198:	cf 93       	push	r28
    319a:	df 93       	push	r29
    319c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  fprintf_P(stream, statusIpMaskStr);
    31a0:	2d b7       	in	r18, 0x3d	; 61
    31a2:	3e b7       	in	r19, 0x3e	; 62
    31a4:	2e 5d       	subi	r18, 0xDE	; 222
    31a6:	3f 4f       	sbci	r19, 0xFF	; 255
    31a8:	0f b6       	in	r0, 0x3f	; 63
    31aa:	f8 94       	cli
    31ac:	3e bf       	out	0x3e, r19	; 62
    31ae:	0f be       	out	0x3f, r0	; 63
    31b0:	2d bf       	out	0x3d, r18	; 61
    31b2:	8c e7       	ldi	r24, 0x7C	; 124
    31b4:	99 e0       	ldi	r25, 0x09	; 9
    31b6:	9f 93       	push	r25
    31b8:	8f 93       	push	r24
    31ba:	cf 93       	push	r28
    31bc:	df 93       	push	r29
    31be:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->netmask);
    31c2:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <ipGetConfig>
    31c6:	fc 01       	movw	r30, r24
    31c8:	44 81       	ldd	r20, Z+4	; 0x04
    31ca:	55 81       	ldd	r21, Z+5	; 0x05
    31cc:	66 81       	ldd	r22, Z+6	; 0x06
    31ce:	77 81       	ldd	r23, Z+7	; 0x07
    31d0:	8d 2f       	mov	r24, r29
    31d2:	9c 2f       	mov	r25, r28
    31d4:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    31d8:	8b ec       	ldi	r24, 0xCB	; 203
    31da:	90 e0       	ldi	r25, 0x00	; 0
    31dc:	9f 93       	push	r25
    31de:	8f 93       	push	r24
    31e0:	cf 93       	push	r28
    31e2:	df 93       	push	r29
    31e4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  fprintf_P(stream, statusIpGwStr);
    31e8:	87 e6       	ldi	r24, 0x67	; 103
    31ea:	99 e0       	ldi	r25, 0x09	; 9
    31ec:	9f 93       	push	r25
    31ee:	8f 93       	push	r24
    31f0:	cf 93       	push	r28
    31f2:	df 93       	push	r29
    31f4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintIPAddr(stream, ipGetConfig()->gateway);
    31f8:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <ipGetConfig>
    31fc:	fc 01       	movw	r30, r24
    31fe:	40 85       	ldd	r20, Z+8	; 0x08
    3200:	51 85       	ldd	r21, Z+9	; 0x09
    3202:	62 85       	ldd	r22, Z+10	; 0x0a
    3204:	73 85       	ldd	r23, Z+11	; 0x0b
    3206:	8d 2f       	mov	r24, r29
    3208:	9c 2f       	mov	r25, r28
    320a:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    320e:	88 ec       	ldi	r24, 0xC8	; 200
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	9f 93       	push	r25
    3214:	8f 93       	push	r24
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  //Print Rs485 Execitive modules
  fprintf_P(stream, statusRs485listStr);
    321e:	8c e4       	ldi	r24, 0x4C	; 76
    3220:	99 e0       	ldi	r25, 0x09	; 9
    3222:	9f 93       	push	r25
    3224:	8f 93       	push	r24
    3226:	cf 93       	push	r28
    3228:	df 93       	push	r29
    322a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
//  tmp = printRs485devices(stream);
//  if (tmp == 0)
//    fprintf_P(stream, statusNoRs485Dev);

  //Print locker sensors
  fprintf_P(stream, statusLockerSensorsStr);
    322e:	89 e1       	ldi	r24, 0x19	; 25
    3230:	99 e0       	ldi	r25, 0x09	; 9
    3232:	9f 93       	push	r25
    3234:	8f 93       	push	r24
    3236:	cf 93       	push	r28
    3238:	df 93       	push	r29
    323a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  tmp = printLockers(stream);
    323e:	8d 2f       	mov	r24, r29
    3240:	9c 2f       	mov	r25, r28
    3242:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <printLockers>
  if (tmp == 0)
    3246:	2d b7       	in	r18, 0x3d	; 61
    3248:	3e b7       	in	r19, 0x3e	; 62
    324a:	28 5e       	subi	r18, 0xE8	; 232
    324c:	3f 4f       	sbci	r19, 0xFF	; 255
    324e:	0f b6       	in	r0, 0x3f	; 63
    3250:	f8 94       	cli
    3252:	3e bf       	out	0x3e, r19	; 62
    3254:	0f be       	out	0x3f, r0	; 63
    3256:	2d bf       	out	0x3d, r18	; 61
    3258:	81 11       	cpse	r24, r1
    325a:	0c c0       	rjmp	.+24     	; 0x3274 <printStatus+0x224>
    fprintf_P(stream, statusLockerSensorsDisStr);
    325c:	8d ef       	ldi	r24, 0xFD	; 253
    325e:	98 e0       	ldi	r25, 0x08	; 8
    3260:	9f 93       	push	r25
    3262:	8f 93       	push	r24
    3264:	cf 93       	push	r28
    3266:	df 93       	push	r29
    3268:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    326c:	0f 90       	pop	r0
    326e:	0f 90       	pop	r0
    3270:	0f 90       	pop	r0
    3272:	0f 90       	pop	r0
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    3274:	8d 2f       	mov	r24, r29
    3276:	9c 2f       	mov	r25, r28
//  arpPrintTable(stream);
}
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
  uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
  uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
  uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
  fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/

  udpPrintStatus(stream);
    327c:	0c 94 70 38 	jmp	0x70e0	; 0x70e0 <udpPrintStatus>

00003280 <statusFunction>:


// ************************** CLI Functions *********************************************************************************

static cliExRes_t statusFunction(cmdState_t *state)
{
    3280:	0f 93       	push	r16
    3282:	1f 93       	push	r17
    3284:	cf 93       	push	r28
    3286:	df 93       	push	r29
    3288:	cd b7       	in	r28, 0x3d	; 61
    328a:	de b7       	in	r29, 0x3e	; 62
    328c:	2e 97       	sbiw	r28, 0x0e	; 14
    328e:	0f b6       	in	r0, 0x3f	; 63
    3290:	f8 94       	cli
    3292:	de bf       	out	0x3e, r29	; 62
    3294:	0f be       	out	0x3f, r0	; 63
    3296:	cd bf       	out	0x3d, r28	; 61
    3298:	8c 01       	movw	r16, r24
  if (state->argc < 1)
    329a:	fc 01       	movw	r30, r24
    329c:	81 8d       	ldd	r24, Z+25	; 0x19
    329e:	81 11       	cpse	r24, r1
    32a0:	05 c0       	rjmp	.+10     	; 0x32ac <statusFunction+0x2c>
  {
    printStatus(state->myStdInOut);
    32a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    32a4:	93 8d       	ldd	r25, Z+27	; 0x1b
    32a6:	0e 94 28 18 	call	0x3050	; 0x3050 <printStatus>
    32aa:	30 c0       	rjmp	.+96     	; 0x330c <statusFunction+0x8c>
    return OK_SILENT;
  }

  FILE stream;
  if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
    32ac:	b8 01       	movw	r22, r16
    32ae:	81 e0       	ldi	r24, 0x01	; 1
    32b0:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    32b4:	23 e0       	ldi	r18, 0x03	; 3
    32b6:	ae 01       	movw	r20, r28
    32b8:	4f 5f       	subi	r20, 0xFF	; 255
    32ba:	5f 4f       	sbci	r21, 0xFF	; 255
    32bc:	62 e6       	ldi	r22, 0x62	; 98
    32be:	7f e0       	ldi	r23, 0x0F	; 15
    32c0:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <ramDyskOtworzPlikStdIo>
    32c4:	88 23       	and	r24, r24
    32c6:	d1 f0       	breq	.+52     	; 0x32fc <statusFunction+0x7c>
  {
    fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
    32c8:	b8 01       	movw	r22, r16
    32ca:	81 e0       	ldi	r24, 0x01	; 1
    32cc:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    32d0:	9f 93       	push	r25
    32d2:	8f 93       	push	r24
    32d4:	8e ea       	ldi	r24, 0xAE	; 174
    32d6:	9a e0       	ldi	r25, 0x0A	; 10
    32d8:	9f 93       	push	r25
    32da:	8f 93       	push	r24
    32dc:	f8 01       	movw	r30, r16
    32de:	83 8d       	ldd	r24, Z+27	; 0x1b
    32e0:	8f 93       	push	r24
    32e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    32e4:	8f 93       	push	r24
    32e6:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    32ea:	0f 90       	pop	r0
    32ec:	0f 90       	pop	r0
    32ee:	0f 90       	pop	r0
    32f0:	0f 90       	pop	r0
    32f2:	0f 90       	pop	r0
    32f4:	0f 90       	pop	r0
    32f6:	84 e0       	ldi	r24, 0x04	; 4
    32f8:	90 e0       	ldi	r25, 0x00	; 0
    32fa:	0a c0       	rjmp	.+20     	; 0x3310 <statusFunction+0x90>
    return ERROR_INFORM;
  }

  printStatus(&stream);
    32fc:	ce 01       	movw	r24, r28
    32fe:	01 96       	adiw	r24, 0x01	; 1
    3300:	0e 94 28 18 	call	0x3050	; 0x3050 <printStatus>
  ramDyskZamknijPlikStdIo(&stream);
    3304:	ce 01       	movw	r24, r28
    3306:	01 96       	adiw	r24, 0x01	; 1
    3308:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <ramDyskZamknijPlikStdIo>
  return OK_SILENT;
    330c:	80 e0       	ldi	r24, 0x00	; 0
    330e:	90 e0       	ldi	r25, 0x00	; 0
}
    3310:	2e 96       	adiw	r28, 0x0e	; 14
    3312:	0f b6       	in	r0, 0x3f	; 63
    3314:	f8 94       	cli
    3316:	de bf       	out	0x3e, r29	; 62
    3318:	0f be       	out	0x3f, r0	; 63
    331a:	cd bf       	out	0x3d, r28	; 61
    331c:	df 91       	pop	r29
    331e:	cf 91       	pop	r28
    3320:	1f 91       	pop	r17
    3322:	0f 91       	pop	r16
    3324:	08 95       	ret

00003326 <encTask>:
//   return 0;
// }


void encTask ( void *pvParameters )
{
    3326:	ec 01       	movw	r28, r24
  FILE *netstackDebug = (FILE *) pvParameters;
  uint16_t plen;

  nicInit();
    3328:	0e 94 8f 2a 	call	0x551e	; 0x551e <nicInit>
  ipInit();
    332c:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <ipInit>
  arpInit();
    3330:	0e 94 78 30 	call	0x60f0	; 0x60f0 <arpInit>
  icmpInit();
    3334:	0e 94 51 2f 	call	0x5ea2	; 0x5ea2 <icmpInit>
    }
    else
    {
      if (netstackDebug != NULL)
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    3338:	0d e7       	ldi	r16, 0x7D	; 125
    333a:	1b e0       	ldi	r17, 0x0B	; 11
  //TODO    init_ip_arp_udp_tcp (mymac, ipGetConfig()->ip, MYWWWPORT);


  for ( ; ; )
  {
    vTaskDelay ( 0 );         //Zastąpić oczekiwaniem na zwolnienie semafora. Semafor zostaje zwolniony po odebrzeniu przerwania od ENC
    333c:	80 e0       	ldi	r24, 0x00	; 0
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>

    // get the next new packet:
    plen = nicPoll();
    3344:	0e 94 65 28 	call	0x50ca	; 0x50ca <nicPoll>
    /*plen will ne unequal to zero if there is a valid
    * packet (without crc error) */
    if ( plen==0 )
    3348:	89 2b       	or	r24, r25
    334a:	29 f4       	brne	.+10     	; 0x3356 <encTask+0x30>
    {
      flushUdpQueues();
    334c:	0e 94 1d 38 	call	0x703a	; 0x703a <flushUdpQueues>
      flushTcpQueues();
    3350:	0e 94 4d 36 	call	0x6c9a	; 0x6c9a <flushTcpQueues>
      //flush HTTP long file queue
      continue;
    3354:	f3 cf       	rjmp	.-26     	; 0x333c <encTask+0x16>
    }

    if(nicState.layer2.ethHeader->type == htons(ETHTYPE_IP))             // process an IP packet
    3356:	e0 91 86 0e 	lds	r30, 0x0E86
    335a:	f0 91 87 0e 	lds	r31, 0x0E87
    335e:	e4 84       	ldd	r14, Z+12	; 0x0c
    3360:	f5 84       	ldd	r15, Z+13	; 0x0d
    3362:	80 e0       	ldi	r24, 0x00	; 0
    3364:	98 e0       	ldi	r25, 0x08	; 8
    3366:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    336a:	e8 16       	cp	r14, r24
    336c:	f9 06       	cpc	r15, r25
    336e:	29 f4       	brne	.+10     	; 0x337a <encTask+0x54>
    {
      arpIpIn();
    3370:	0e 94 ae 30 	call	0x615c	; 0x615c <arpIpIn>
      netstackIPv4Process();
    3374:	0e 94 4f 2d 	call	0x5a9e	; 0x5a9e <netstackIPv4Process>
    3378:	e1 cf       	rjmp	.-62     	; 0x333c <encTask+0x16>
    }
    else if(nicState.layer2.ethHeader->type == htons(ETHTYPE_ARP))       // process an ARP packet
    337a:	e0 91 86 0e 	lds	r30, 0x0E86
    337e:	f0 91 87 0e 	lds	r31, 0x0E87
    3382:	e4 84       	ldd	r14, Z+12	; 0x0c
    3384:	f5 84       	ldd	r15, Z+13	; 0x0d
    3386:	86 e0       	ldi	r24, 0x06	; 6
    3388:	98 e0       	ldi	r25, 0x08	; 8
    338a:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    338e:	e8 16       	cp	r14, r24
    3390:	f9 06       	cpc	r15, r25
    3392:	19 f4       	brne	.+6      	; 0x339a <encTask+0x74>
    {
      arpArpIn();
    3394:	0e 94 5d 32 	call	0x64ba	; 0x64ba <arpArpIn>
    3398:	d1 cf       	rjmp	.-94     	; 0x333c <encTask+0x16>
    }
    else
    {
      if (netstackDebug != NULL)
    339a:	20 97       	sbiw	r28, 0x00	; 0
    339c:	79 f2       	breq	.-98     	; 0x333c <encTask+0x16>
      {
        fprintf_P(netstackDebug, PSTR("Unknown packet\r\n"));
    339e:	1f 93       	push	r17
    33a0:	0f 93       	push	r16
    33a2:	df 93       	push	r29
    33a4:	cf 93       	push	r28
    33a6:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    33aa:	0f 90       	pop	r0
    33ac:	0f 90       	pop	r0
    33ae:	0f 90       	pop	r0
    33b0:	0f 90       	pop	r0
    33b2:	c4 cf       	rjmp	.-120    	; 0x333c <encTask+0x16>

000033b4 <vTaskVTYusb>:
#include "cli_task.h"

void vTaskVTYusb(void *cliStatePtr)
{
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	1f 92       	push	r1
    33ba:	cd b7       	in	r28, 0x3d	; 61
    33bc:	de b7       	in	r29, 0x3e	; 62
    33be:	8c 01       	movw	r16, r24
  cmdState_t *state = (cmdState_t *)(cliStatePtr);
  fprintf_P(state->myStdInOut, PSTR("Restart\r\n"));
    33c0:	8e e8       	ldi	r24, 0x8E	; 142
    33c2:	9b e0       	ldi	r25, 0x0B	; 11
    33c4:	9f 93       	push	r25
    33c6:	8f 93       	push	r24
    33c8:	f8 01       	movw	r30, r16
    33ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    33cc:	8f 93       	push	r24
    33ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    33d0:	8f 93       	push	r24
    33d2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  cmdlineInputFunc('\r', state);
    33d6:	b8 01       	movw	r22, r16
    33d8:	8d e0       	ldi	r24, 0x0D	; 13
    33da:	0e 94 5c 20 	call	0x40b8	; 0x40b8 <cmdlineInputFunc>
    33de:	0f 90       	pop	r0
    33e0:	0f 90       	pop	r0
    33e2:	0f 90       	pop	r0
    33e4:	0f 90       	pop	r0
  
  char znak;
  for( ;; )
  {
    if( xQueueReceive(xVtyRec, &znak, portMAX_DELAY))
    33e6:	20 e0       	ldi	r18, 0x00	; 0
    33e8:	4f ef       	ldi	r20, 0xFF	; 255
    33ea:	5f ef       	ldi	r21, 0xFF	; 255
    33ec:	be 01       	movw	r22, r28
    33ee:	6f 5f       	subi	r22, 0xFF	; 255
    33f0:	7f 4f       	sbci	r23, 0xFF	; 255
    33f2:	80 91 ac 0e 	lds	r24, 0x0EAC
    33f6:	90 91 ad 0e 	lds	r25, 0x0EAD
    33fa:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    33fe:	88 23       	and	r24, r24
    3400:	91 f3       	breq	.-28     	; 0x33e6 <vTaskVTYusb+0x32>
    {
      cmdlineInputFunc((char)znak, state);
    3402:	b8 01       	movw	r22, r16
    3404:	89 81       	ldd	r24, Y+1	; 0x01
    3406:	0e 94 5c 20 	call	0x40b8	; 0x40b8 <cmdlineInputFunc>
      cmdlineMainLoop(state);
    340a:	c8 01       	movw	r24, r16
    340c:	0e 94 60 23 	call	0x46c0	; 0x46c0 <cmdlineMainLoop>
    3410:	ea cf       	rjmp	.-44     	; 0x33e6 <vTaskVTYusb+0x32>

00003412 <vTaskVTYsocket>:
    }  
  }
}

void vTaskVTYsocket(void *cliStatePtr)
{
    3412:	ec 01       	movw	r28, r24
  
  char znak;
  for( ;; )
  {
    znak = 0;
    znak = fgetc(state->myStdInOut);
    3414:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3416:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3418:	0e 94 cc 4f 	call	0x9f98	; 0x9f98 <fgetc>
    cmdlineInputFunc((char)znak, state);
    341c:	be 01       	movw	r22, r28
    341e:	0e 94 5c 20 	call	0x40b8	; 0x40b8 <cmdlineInputFunc>
    cmdlineMainLoop(state);
    3422:	ce 01       	movw	r24, r28
    3424:	0e 94 60 23 	call	0x46c0	; 0x46c0 <cmdlineMainLoop>
  }
    3428:	f5 cf       	rjmp	.-22     	; 0x3414 <vTaskVTYsocket+0x2>

0000342a <spiInit>:
#include "semphr.h"


void spiInit(void (*disableAllSpiDevicesFun)(void))
{
  disableAllSpiDevicesFun();
    342a:	fc 01       	movw	r30, r24
    342c:	09 95       	icall
  portENTER_CRITICAL();
    342e:	0f b6       	in	r0, 0x3f	; 63
    3430:	f8 94       	cli
    3432:	0f 92       	push	r0
  vSemaphoreCreateBinary(xSemaphoreSpiSS);
    3434:	60 e0       	ldi	r22, 0x00	; 0
    3436:	81 e0       	ldi	r24, 0x01	; 1
    3438:	0e 94 15 46 	call	0x8c2a	; 0x8c2a <xQueueCreate>
    343c:	90 93 bf 0e 	sts	0x0EBF, r25
    3440:	80 93 be 0e 	sts	0x0EBE, r24
    3444:	00 97       	sbiw	r24, 0x00	; 0
    3446:	39 f0       	breq	.+14     	; 0x3456 <spiInit+0x2c>
    3448:	20 e0       	ldi	r18, 0x00	; 0
    344a:	40 e0       	ldi	r20, 0x00	; 0
    344c:	50 e0       	ldi	r21, 0x00	; 0
    344e:	60 e0       	ldi	r22, 0x00	; 0
    3450:	70 e0       	ldi	r23, 0x00	; 0
    3452:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <xQueueGenericSend>

  SPCR  = (1<<SPE)|(1<<MSTR)|(1<<SPIE)|(1<<SPR0) ;  //TODO Adam: użyć odpowiednich nazw rejestrów
    3456:	81 ed       	ldi	r24, 0xD1	; 209
    3458:	8d b9       	out	0x0d, r24	; 13
  //SPSR |= (1<<SPI2X);

  portEXIT_CRITICAL();
    345a:	0f 90       	pop	r0
    345c:	0f be       	out	0x3f, r0	; 63
    345e:	08 95       	ret

00003460 <spiSetCPHA>:
  //mode 0,0
}

void spiSetCPHA(void)
{
  SPCR |= (1<<CPHA);
    3460:	6a 9a       	sbi	0x0d, 2	; 13
    3462:	08 95       	ret

00003464 <spiClearCPHA>:
}

void spiClearCPHA(void)
{
  SPCR &= ~(1<<CPHA);
    3464:	6a 98       	cbi	0x0d, 2	; 13
    3466:	08 95       	ret

00003468 <spiSetCPOL>:
}

void spiSetCPOL(void)
{
  SPCR |= (1<<CPOL);
    3468:	6b 9a       	sbi	0x0d, 3	; 13
    346a:	08 95       	ret

0000346c <spiClearCPOL>:
}

void spiClearCPOL(void)
{
  SPCR &= ~(1<<CPOL);
    346c:	6b 98       	cbi	0x0d, 3	; 13
    346e:	08 95       	ret

00003470 <spiTake>:
}

void spiTake(void)
{
  xSemaphoreTake(xSemaphoreSpiSS, portMAX_DELAY);
    3470:	20 e0       	ldi	r18, 0x00	; 0
    3472:	4f ef       	ldi	r20, 0xFF	; 255
    3474:	5f ef       	ldi	r21, 0xFF	; 255
    3476:	60 e0       	ldi	r22, 0x00	; 0
    3478:	70 e0       	ldi	r23, 0x00	; 0
    347a:	80 91 be 0e 	lds	r24, 0x0EBE
    347e:	90 91 bf 0e 	lds	r25, 0x0EBF
    3482:	0c 94 5e 47 	jmp	0x8ebc	; 0x8ebc <xQueueGenericReceive>

00003486 <spiGive>:
}

void spiGive(void)
{
  xSemaphoreGive(xSemaphoreSpiSS);
    3486:	20 e0       	ldi	r18, 0x00	; 0
    3488:	40 e0       	ldi	r20, 0x00	; 0
    348a:	50 e0       	ldi	r21, 0x00	; 0
    348c:	60 e0       	ldi	r22, 0x00	; 0
    348e:	70 e0       	ldi	r23, 0x00	; 0
    3490:	80 91 be 0e 	lds	r24, 0x0EBE
    3494:	90 91 bf 0e 	lds	r25, 0x0EBF
    3498:	0c 94 a2 46 	jmp	0x8d44	; 0x8d44 <xQueueGenericSend>
    349c:	80 e0       	ldi	r24, 0x00	; 0
    349e:	08 95       	ret
    34a0:	80 e0       	ldi	r24, 0x00	; 0
    34a2:	08 95       	ret

000034a4 <xmalloc>:

#ifdef HEAP_BEGIN
char *heapEnd =  (char *)HEAP_BEGIN;

void *xmalloc(size_t size)
{
    34a4:	cf 93       	push	r28
    34a6:	df 93       	push	r29
    34a8:	ec 01       	movw	r28, r24
  void *result = malloc(size);
    34aa:	0e 94 fe 4c 	call	0x99fc	; 0x99fc <malloc>

  heapEnd = (char *)(result);
  heapEnd += size;
    34ae:	c8 0f       	add	r28, r24
    34b0:	d9 1f       	adc	r29, r25
    34b2:	d0 93 03 01 	sts	0x0103, r29
    34b6:	c0 93 02 01 	sts	0x0102, r28
  return result;
}
    34ba:	df 91       	pop	r29
    34bc:	cf 91       	pop	r28
    34be:	08 95       	ret

000034c0 <xmallocAvailable>:

size_t xmallocAvailable(void)
{
  return __malloc_heap_end - heapEnd + 1;
    34c0:	80 91 05 01 	lds	r24, 0x0105
    34c4:	90 91 06 01 	lds	r25, 0x0106
    34c8:	20 91 02 01 	lds	r18, 0x0102
    34cc:	30 91 03 01 	lds	r19, 0x0103
    34d0:	82 1b       	sub	r24, r18
    34d2:	93 0b       	sbc	r25, r19
}
    34d4:	01 96       	adiw	r24, 0x01	; 1
    34d6:	08 95       	ret

000034d8 <uaktualnijRozmiarPliku>:

  return 1;
}

static void uaktualnijRozmiarPliku(struct ramPlikFd *fd)
{
    34d8:	fc 01       	movw	r30, r24
  if (fd->wpis->rozmiarHi == fd->IndHi)
    34da:	a4 81       	ldd	r26, Z+4	; 0x04
    34dc:	b5 81       	ldd	r27, Z+5	; 0x05
    34de:	12 96       	adiw	r26, 0x02	; 2
    34e0:	9c 91       	ld	r25, X
    34e2:	12 97       	sbiw	r26, 0x02	; 2
    34e4:	83 81       	ldd	r24, Z+3	; 0x03
    34e6:	98 13       	cpse	r25, r24
    34e8:	08 c0       	rjmp	.+16     	; 0x34fa <uaktualnijRozmiarPliku+0x22>
  {
    if (fd->wpis->rozmiarLo < fd->IndLo)
    34ea:	82 81       	ldd	r24, Z+2	; 0x02
    34ec:	11 96       	adiw	r26, 0x01	; 1
    34ee:	9c 91       	ld	r25, X
    34f0:	11 97       	sbiw	r26, 0x01	; 1
    34f2:	98 17       	cp	r25, r24
    34f4:	10 f4       	brcc	.+4      	; 0x34fa <uaktualnijRozmiarPliku+0x22>
      fd->wpis->rozmiarLo = fd->IndLo;
    34f6:	11 96       	adiw	r26, 0x01	; 1
    34f8:	8c 93       	st	X, r24
  }
  if (fd->wpis->rozmiarHi < fd->IndHi)
    34fa:	a4 81       	ldd	r26, Z+4	; 0x04
    34fc:	b5 81       	ldd	r27, Z+5	; 0x05
    34fe:	12 96       	adiw	r26, 0x02	; 2
    3500:	9c 91       	ld	r25, X
    3502:	12 97       	sbiw	r26, 0x02	; 2
    3504:	83 81       	ldd	r24, Z+3	; 0x03
    3506:	98 17       	cp	r25, r24
    3508:	40 f4       	brcc	.+16     	; 0x351a <uaktualnijRozmiarPliku+0x42>
  {
      fd->wpis->rozmiarLo = fd->IndLo;
    350a:	82 81       	ldd	r24, Z+2	; 0x02
    350c:	11 96       	adiw	r26, 0x01	; 1
    350e:	8c 93       	st	X, r24
      fd->wpis->rozmiarHi = fd->IndHi;
    3510:	a4 81       	ldd	r26, Z+4	; 0x04
    3512:	b5 81       	ldd	r27, Z+5	; 0x05
    3514:	83 81       	ldd	r24, Z+3	; 0x03
    3516:	12 96       	adiw	r26, 0x02	; 2
    3518:	8c 93       	st	X, r24
    351a:	08 95       	ret

0000351c <nastepnyKlaster>:
  }
  return 0;
}

static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
    351c:	98 2f       	mov	r25, r24
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
    351e:	e8 2f       	mov	r30, r24
    3520:	f0 e0       	ldi	r31, 0x00	; 0
    3522:	e7 53       	subi	r30, 0x37	; 55
    3524:	f1 4f       	sbci	r31, 0xF1	; 241
    3526:	80 81       	ld	r24, Z
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
    3528:	89 13       	cpse	r24, r25
    352a:	1d c0       	rjmp	.+58     	; 0x3566 <nastepnyKlaster+0x4a>
    352c:	aa ec       	ldi	r26, 0xCA	; 202
    352e:	be e0       	ldi	r27, 0x0E	; 14
    3530:	81 e0       	ldi	r24, 0x01	; 1
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    {                                      //Jeśli temp ma wartość 0 to oznacza, że nie ma wolnego klastra
      if (klastry[temp] == 0)              //Jeśli w tablicy klaster wskazuje na 0, to oznacza, że jest on pusty
    3532:	9d 91       	ld	r25, X+
    3534:	91 11       	cpse	r25, r1
    3536:	13 c0       	rjmp	.+38     	; 0x355e <nastepnyKlaster+0x42>
        break;                             //Wtedy można przerwać szukanie kolejnych klastrów dla klastra
    }                                      //Taka implementacja z założenia powoduje defragmentację.

    if (temp != 0)                         //Znaleziono jakiś wolny klaster
    {
      klastry[nrKlastra] = temp;           //Ustawienie łańcucha z klastrami, dodanie do pliku kolejnego klastra
    3538:	80 83       	st	Z, r24
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
    353a:	28 2f       	mov	r18, r24
    353c:	30 e0       	ldi	r19, 0x00	; 0
    353e:	f9 01       	movw	r30, r18
    3540:	e7 53       	subi	r30, 0x37	; 55
    3542:	f1 4f       	sbci	r31, 0xF1	; 241
    3544:	80 83       	st	Z, r24
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    3546:	e0 e0       	ldi	r30, 0x00	; 0
    3548:	f0 e8       	ldi	r31, 0x80	; 128
    354a:	f8 0f       	add	r31, r24
    354c:	20 e0       	ldi	r18, 0x00	; 0
    354e:	31 e0       	ldi	r19, 0x01	; 1
    3550:	df 01       	movw	r26, r30
    3552:	a9 01       	movw	r20, r18
    3554:	1d 92       	st	X+, r1
    3556:	41 50       	subi	r20, 0x01	; 1
    3558:	50 40       	sbci	r21, 0x00	; 0
    355a:	e1 f7       	brne	.-8      	; 0x3554 <nastepnyKlaster+0x38>
    355c:	08 95       	ret
static uint8_t nastepnyKlaster(uint8_t nrKlastra)
{
  uint8_t temp = klastry[nrKlastra];       //Temp oznacza na następny klaster.
  if (temp == nrKlastra)                   //Jeśli klaster wskazuje na samego siebie, co oznacza, że jest ostatni w pliku
  {                                        //Należy znaleźć jakiś wolny klaster i go dodać do łańcycha klastrów w pliku
    for (temp=1; temp <128; temp++)        //Przekglądamy wszystkie klastry za wyjątkiem klastra 0 (dla temp = 0 nie ma znaczenia instrukcja break)
    355e:	8f 5f       	subi	r24, 0xFF	; 255
    3560:	80 38       	cpi	r24, 0x80	; 128
    3562:	39 f7       	brne	.-50     	; 0x3532 <nastepnyKlaster+0x16>
    3564:	e9 cf       	rjmp	.-46     	; 0x3538 <nastepnyKlaster+0x1c>
      klastry[temp]=temp;                  //Oznaczenie klastra jako zajętego (ostatniego w danym pliku)
      czyscKlaster(temp);                  //Czyszczenie klastra
    }
  }
  return temp;
}
    3566:	08 95       	ret

00003568 <znajdzKlasterN>:

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
    3568:	1f 93       	push	r17
    356a:	cf 93       	push	r28
    356c:	df 93       	push	r29
    356e:	1f 92       	push	r1
    3570:	cd b7       	in	r28, 0x3d	; 61
    3572:	de b7       	in	r29, 0x3e	; 62
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3574:	10 e0       	ldi	r17, 0x00	; 0
    3576:	16 17       	cp	r17, r22
    3578:	41 f0       	breq	.+16     	; 0x358a <znajdzKlasterN+0x22>
  {
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    357a:	69 83       	std	Y+1, r22	; 0x01
    357c:	0e 94 8e 1a 	call	0x351c	; 0x351c <nastepnyKlaster>
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
    3580:	69 81       	ldd	r22, Y+1	; 0x01
    3582:	88 23       	and	r24, r24
    3584:	11 f0       	breq	.+4      	; 0x358a <znajdzKlasterN+0x22>

static uint8_t znajdzKlasterN(uint8_t nrPierwszegoKlastra, uint8_t lPrzeskokow)
{
  uint8_t ind;                             //PIerwszy klaster ma indeks 0
  uint8_t wynik = nrPierwszegoKlastra;
  for (ind=0; ind < lPrzeskokow; ind++)    //Należy wykonać klasterN przeskoków na kolejne klastry (IndHi określa ile trzeba zrobić przeskoków od pierwszego klastra)
    3586:	1f 5f       	subi	r17, 0xFF	; 255
    3588:	f6 cf       	rjmp	.-20     	; 0x3576 <znajdzKlasterN+0xe>
    wynik = nastepnyKlaster(wynik);        //Jeśli nie ma kolejnego klastra, to zostanie automatycznie dodany
    if (wynik == 0)                        //Sprawdzany, czy znalazł się kolejny klaster
      break;                               //Błąd, zwrócony zostanie klaster 0 - zarezerwowany na początek tablicy plików
  }
  return wynik;
}
    358a:	0f 90       	pop	r0
    358c:	df 91       	pop	r29
    358e:	cf 91       	pop	r28
    3590:	1f 91       	pop	r17
    3592:	08 95       	ret

00003594 <znajdzPlik>:
  return 0;
}
#endif

static struct ramPlik* znajdzPlik(const char *nazwa)
{
    3594:	8f 92       	push	r8
    3596:	9f 92       	push	r9
    3598:	bf 92       	push	r11
    359a:	cf 92       	push	r12
    359c:	df 92       	push	r13
    359e:	ef 92       	push	r14
    35a0:	ff 92       	push	r15
    35a2:	0f 93       	push	r16
    35a4:	1f 93       	push	r17
    35a6:	cf 93       	push	r28
    35a8:	df 93       	push	r29
    35aa:	7c 01       	movw	r14, r24
  uint8_t dlNazwy = strlen(nazwa);        //Skracanie podanej nazwy do 8 znaków
    35ac:	fc 01       	movw	r30, r24
    35ae:	01 90       	ld	r0, Z+
    35b0:	00 20       	and	r0, r0
    35b2:	e9 f7       	brne	.-6      	; 0x35ae <znajdzPlik+0x1a>
    35b4:	31 97       	sbiw	r30, 0x01	; 1
    35b6:	e8 1b       	sub	r30, r24
    35b8:	e9 30       	cpi	r30, 0x09	; 9
    35ba:	08 f0       	brcs	.+2      	; 0x35be <znajdzPlik+0x2a>
    35bc:	e8 e0       	ldi	r30, 0x08	; 8
  if (dlNazwy > 8)
    dlNazwy = 8;


  if (nazwa[dlNazwy-1] == 0)
    35be:	d7 01       	movw	r26, r14
    35c0:	ae 0f       	add	r26, r30
    35c2:	b1 1d       	adc	r27, r1
    35c4:	11 97       	sbiw	r26, 0x01	; 1
    35c6:	8c 91       	ld	r24, X
    35c8:	81 11       	cpse	r24, r1
    35ca:	01 c0       	rjmp	.+2      	; 0x35ce <znajdzPlik+0x3a>
    dlNazwy--;                            //Nie sprawdzamy czy string kończy się /0
    35cc:	e1 50       	subi	r30, 0x01	; 1
    35ce:	d7 01       	movw	r26, r14
    35d0:	11 96       	adiw	r26, 0x01	; 1
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    35d2:	81 e0       	ldi	r24, 0x01	; 1
    35d4:	8e 17       	cp	r24, r30
    35d6:	28 f4       	brcc	.+10     	; 0x35e2 <znajdzPlik+0x4e>
  {
    if (nazwa[temp] == ' ')               //Pozbycie sie spacji
    35d8:	9d 91       	ld	r25, X+
    35da:	90 32       	cpi	r25, 0x20	; 32
    35dc:	29 f0       	breq	.+10     	; 0x35e8 <znajdzPlik+0x54>
  struct ramPlik *plik;
  uint8_t temp;
  uint8_t tempKlaster=0;
  uint8_t tempKlaster2;

  for (temp=1; temp < dlNazwy; temp ++)
    35de:	8f 5f       	subi	r24, 0xFF	; 255
    35e0:	f9 cf       	rjmp	.-14     	; 0x35d4 <znajdzPlik+0x40>
    {
      dlNazwy = temp;
      break;
    }
  }
  if (dlNazwy == 0)
    35e2:	e1 11       	cpse	r30, r1
    35e4:	02 c0       	rjmp	.+4      	; 0x35ea <znajdzPlik+0x56>
    35e6:	23 c0       	rjmp	.+70     	; 0x362e <znajdzPlik+0x9a>
    35e8:	e8 2f       	mov	r30, r24
    35ea:	b1 2c       	mov	r11, r1
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    35ec:	ce 2f       	mov	r28, r30
    35ee:	d0 e0       	ldi	r29, 0x00	; 0
  if (dlNazwy == 0)
    return NULL;

  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    35f0:	cb 2c       	mov	r12, r11
    35f2:	d1 2c       	mov	r13, r1
    35f4:	86 01       	movw	r16, r12
    35f6:	00 58       	subi	r16, 0x80	; 128
    35f8:	1f 4f       	sbci	r17, 0xFF	; 255
    35fa:	10 2f       	mov	r17, r16
    35fc:	00 27       	eor	r16, r16
    35fe:	48 01       	movw	r8, r16
    3600:	93 94       	inc	r9
    for (temp=0; temp <16; temp++)
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
    3602:	ae 01       	movw	r20, r28
    3604:	b8 01       	movw	r22, r16
    3606:	6c 5f       	subi	r22, 0xFC	; 252
    3608:	7f 4f       	sbci	r23, 0xFF	; 255
    360a:	c7 01       	movw	r24, r14
    360c:	0e 94 98 4f 	call	0x9f30	; 0x9f30 <strncmp>
    3610:	89 2b       	or	r24, r25
    3612:	81 f0       	breq	.+32     	; 0x3634 <znajdzPlik+0xa0>
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    3614:	00 5f       	subi	r16, 0xF0	; 240
    3616:	1f 4f       	sbci	r17, 0xFF	; 255
    return NULL;

  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    3618:	08 15       	cp	r16, r8
    361a:	19 05       	cpc	r17, r9
    361c:	91 f7       	brne	.-28     	; 0x3602 <znajdzPlik+0x6e>
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    361e:	f6 01       	movw	r30, r12
    3620:	e7 53       	subi	r30, 0x37	; 55
    3622:	f1 4f       	sbci	r31, 0xF1	; 241
    3624:	80 81       	ld	r24, Z
  }
  while (tempKlaster2 != tempKlaster);
    3626:	b8 16       	cp	r11, r24
    3628:	11 f0       	breq	.+4      	; 0x362e <znajdzPlik+0x9a>
    362a:	b8 2e       	mov	r11, r24
    362c:	e1 cf       	rjmp	.-62     	; 0x35f0 <znajdzPlik+0x5c>
      dlNazwy = temp;
      break;
    }
  }
  if (dlNazwy == 0)
    return NULL;
    362e:	80 e0       	ldi	r24, 0x00	; 0
    3630:	90 e0       	ldi	r25, 0x00	; 0
    3632:	01 c0       	rjmp	.+2      	; 0x3636 <znajdzPlik+0xa2>
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    {
      if (strncmp(nazwa, plik->nazwa, dlNazwy) == 0)
	return plik;
    3634:	c8 01       	movw	r24, r16
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
  }
  while (tempKlaster2 != tempKlaster);
  return NULL;
}
    3636:	df 91       	pop	r29
    3638:	cf 91       	pop	r28
    363a:	1f 91       	pop	r17
    363c:	0f 91       	pop	r16
    363e:	ff 90       	pop	r15
    3640:	ef 90       	pop	r14
    3642:	df 90       	pop	r13
    3644:	cf 90       	pop	r12
    3646:	bf 90       	pop	r11
    3648:	9f 90       	pop	r9
    364a:	8f 90       	pop	r8
    364c:	08 95       	ret

0000364e <znajdzWolnyKlaster>:
}

static uint8_t znajdzWolnyKlaster(void)
{
  uint8_t i;
  for (i=1; i<L_KLASTROW; i++)             //Pomijamy klaster 0, tam jest wpis katalogowy. Jeśli ma wartość 0, to oznacza to, że na nim się kończy wpis katalogowy.
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	80 38       	cpi	r24, 0x80	; 128
    3654:	91 05       	cpc	r25, r1
    3656:	c1 f0       	breq	.+48     	; 0x3688 <znajdzWolnyKlaster+0x3a>
    3658:	9c 01       	movw	r18, r24
    365a:	2f 5f       	subi	r18, 0xFF	; 255
    365c:	3f 4f       	sbci	r19, 0xFF	; 255
    365e:	fc 01       	movw	r30, r24
    3660:	e7 53       	subi	r30, 0x37	; 55
    3662:	f1 4f       	sbci	r31, 0xF1	; 241
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    3664:	40 81       	ld	r20, Z
    3666:	41 11       	cpse	r20, r1
    3668:	0d c0       	rjmp	.+26     	; 0x3684 <znajdzWolnyKlaster+0x36>
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
    366a:	80 83       	st	Z, r24
static void            czyscKlaster(uint8_t nrKlastra);

static void            czyscKlaster(uint8_t nrKlastra)
{
  uint8_t *tmpPtr = dataPtr(nrKlastra, 0);
  memset (tmpPtr, 0, 256);
    366c:	e0 e0       	ldi	r30, 0x00	; 0
    366e:	f0 e8       	ldi	r31, 0x80	; 128
    3670:	f8 0f       	add	r31, r24
    3672:	20 e0       	ldi	r18, 0x00	; 0
    3674:	31 e0       	ldi	r19, 0x01	; 1
    3676:	df 01       	movw	r26, r30
    3678:	a9 01       	movw	r20, r18
    367a:	1d 92       	st	X+, r1
    367c:	41 50       	subi	r20, 0x01	; 1
    367e:	50 40       	sbci	r21, 0x00	; 0
    3680:	e1 f7       	brne	.-8      	; 0x367a <znajdzWolnyKlaster+0x2c>
  {                                        //Może być rozszerzony na inne klastry.
    if (klastry[i] == 0)                   //Sprawdzanie, czy klaster jest pusty.
    {
      klastry[i] = i;                      //Oznaczanie klastra jako ostatniego.
      czyscKlaster(i);                     //Czyszczenie zawartości klastra.
      return i;
    3682:	08 95       	ret
    3684:	c9 01       	movw	r24, r18
    3686:	e5 cf       	rjmp	.-54     	; 0x3652 <znajdzWolnyKlaster+0x4>
    }
  }
  return 0;
    3688:	80 e0       	ldi	r24, 0x00	; 0
}
    368a:	08 95       	ret

0000368c <ramDyskInit>:
}


void ramDyskInit(void)
{
  memset (klastry, 0, 128);              //Czyszczenie tablicy klastrów (wszystkie są puste)
    368c:	80 e8       	ldi	r24, 0x80	; 128
    368e:	e9 ec       	ldi	r30, 0xC9	; 201
    3690:	fe e0       	ldi	r31, 0x0E	; 14
    3692:	df 01       	movw	r26, r30
    3694:	1d 92       	st	X+, r1
    3696:	8a 95       	dec	r24
    3698:	e9 f7       	brne	.-6      	; 0x3694 <ramDyskInit+0x8>
  memset (dataPtr(0,0), 0, 256);         //Czyszczenie zerowego klastra z tablicą plików
    369a:	80 e0       	ldi	r24, 0x00	; 0
    369c:	91 e0       	ldi	r25, 0x01	; 1
    369e:	e0 e0       	ldi	r30, 0x00	; 0
    36a0:	f0 e8       	ldi	r31, 0x80	; 128
    36a2:	df 01       	movw	r26, r30
    36a4:	9c 01       	movw	r18, r24
    36a6:	1d 92       	st	X+, r1
    36a8:	21 50       	subi	r18, 0x01	; 1
    36aa:	30 40       	sbci	r19, 0x00	; 0
    36ac:	e1 f7       	brne	.-8      	; 0x36a6 <ramDyskInit+0x1a>
    36ae:	08 95       	ret

000036b0 <ramDyskUtworzPlik>:
}
uint8_t ramDyskUtworzPlik(const char *nazwa)
{                                        //Nowo utworzony plik nie zajmuje żadnego klastra
    36b0:	ff 92       	push	r15
    36b2:	0f 93       	push	r16
    36b4:	1f 93       	push	r17
    36b6:	cf 93       	push	r28
    36b8:	df 93       	push	r29
    36ba:	8c 01       	movw	r16, r24
  uint8_t dlNazwy = strlen(nazwa);
    36bc:	fc 01       	movw	r30, r24
    36be:	01 90       	ld	r0, Z+
    36c0:	00 20       	and	r0, r0
    36c2:	e9 f7       	brne	.-6      	; 0x36be <ramDyskUtworzPlik+0xe>
    36c4:	31 97       	sbiw	r30, 0x01	; 1
    36c6:	fe 2e       	mov	r15, r30
    36c8:	f8 1a       	sub	r15, r24
    36ca:	88 e0       	ldi	r24, 0x08	; 8
    36cc:	8f 15       	cp	r24, r15
    36ce:	10 f4       	brcc	.+4      	; 0x36d4 <ramDyskUtworzPlik+0x24>
    36d0:	58 e0       	ldi	r21, 0x08	; 8
    36d2:	f5 2e       	mov	r15, r21
    36d4:	90 2f       	mov	r25, r16
  uint8_t i;
  if (dlNazwy > 8)
    dlNazwy = 8;

  for (i=0; i<dlNazwy; i++)
    36d6:	f8 01       	movw	r30, r16
    36d8:	8e 2f       	mov	r24, r30
    36da:	89 1b       	sub	r24, r25
    36dc:	8f 15       	cp	r24, r15
    36de:	20 f4       	brcc	.+8      	; 0x36e8 <ramDyskUtworzPlik+0x38>
  {  if (nazwa[i] == ' ')
    36e0:	21 91       	ld	r18, Z+
    36e2:	20 32       	cpi	r18, 0x20	; 32
    36e4:	c9 f7       	brne	.-14     	; 0x36d8 <ramDyskUtworzPlik+0x28>
    36e6:	f8 2e       	mov	r15, r24
     {
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    36e8:	ff 20       	and	r15, r15
    36ea:	09 f4       	brne	.+2      	; 0x36ee <ramDyskUtworzPlik+0x3e>
    36ec:	3f c0       	rjmp	.+126    	; 0x376c <ramDyskUtworzPlik+0xbc>
    return 0;

  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    36ee:	c8 01       	movw	r24, r16
    36f0:	0e 94 ca 1a 	call	0x3594	; 0x3594 <znajdzPlik>
    36f4:	89 2b       	or	r24, r25
    36f6:	d1 f5       	brne	.+116    	; 0x376c <ramDyskUtworzPlik+0xbc>
    36f8:	50 e0       	ldi	r21, 0x00	; 0
  uint8_t temp;
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    36fa:	25 2f       	mov	r18, r21
    36fc:	30 e0       	ldi	r19, 0x00	; 0
    36fe:	c9 01       	movw	r24, r18
    3700:	80 58       	subi	r24, 0x80	; 128
    3702:	9f 4f       	sbci	r25, 0xFF	; 255
    3704:	98 2f       	mov	r25, r24
    3706:	88 27       	eor	r24, r24
    3708:	fc 01       	movw	r30, r24
    370a:	34 96       	adiw	r30, 0x04	; 4
    370c:	8c 5f       	subi	r24, 0xFC	; 252
    370e:	9e 4f       	sbci	r25, 0xFE	; 254
    3710:	ef 01       	movw	r28, r30
    3712:	24 97       	sbiw	r28, 0x04	; 4
    for (temp=0; temp <16; temp++)
    {
      if (plik->nazwa[0] == 0)
    3714:	40 81       	ld	r20, Z
    3716:	44 23       	and	r20, r20
    3718:	b9 f0       	breq	.+46     	; 0x3748 <ramDyskUtworzPlik+0x98>
    371a:	70 96       	adiw	r30, 0x10	; 16
  uint8_t tempKlaster=0;                                 //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  uint8_t tempKlaster2;                                  //Przeszukiwanie głównego wpisu katalogowego, jest on zapisany w klastrze 0
  do
  {
    plik = (struct ramPlik *)(dataPtr(tempKlaster, 0));  //Odczyt pierwszego nagłówka pliku w klastrze
    for (temp=0; temp <16; temp++)
    371c:	e8 17       	cp	r30, r24
    371e:	f9 07       	cpc	r31, r25
    3720:	b9 f7       	brne	.-18     	; 0x3710 <ramDyskUtworzPlik+0x60>
      if (plik->nazwa[0] == 0)
	return plik;
      plik++;                                            //Przejście do kolejnego wpisu (w tym samym klastrze)
    }
    tempKlaster2 = tempKlaster;
    tempKlaster = klastry[tempKlaster];
    3722:	e9 01       	movw	r28, r18
    3724:	c7 53       	subi	r28, 0x37	; 55
    3726:	d1 4f       	sbci	r29, 0xF1	; 241
    3728:	88 81       	ld	r24, Y
  }
  while (tempKlaster2 != tempKlaster);
    372a:	58 17       	cp	r21, r24
    372c:	11 f0       	breq	.+4      	; 0x3732 <ramDyskUtworzPlik+0x82>
    372e:	58 2f       	mov	r21, r24
    3730:	e4 cf       	rjmp	.-56     	; 0x36fa <ramDyskUtworzPlik+0x4a>

  klastry[tempKlaster] = znajdzWolnyKlaster();
    3732:	0e 94 27 1b 	call	0x364e	; 0x364e <znajdzWolnyKlaster>
    3736:	88 83       	st	Y, r24
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    3738:	81 11       	cpse	r24, r1
    373a:	02 c0       	rjmp	.+4      	; 0x3740 <ramDyskUtworzPlik+0x90>
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    return 0;
  }
  return 1;
    373c:	81 e0       	ldi	r24, 0x01	; 1
    373e:	17 c0       	rjmp	.+46     	; 0x376e <ramDyskUtworzPlik+0xbe>
  while (tempKlaster2 != tempKlaster);

  klastry[tempKlaster] = znajdzWolnyKlaster();
  plik = NULL;
  if (klastry[tempKlaster] != 0)
    plik = (struct ramPlik*) (dataPtr(klastry[tempKlaster], 0));
    3740:	90 e0       	ldi	r25, 0x00	; 0
    3742:	c9 2f       	mov	r28, r25
    3744:	d0 e8       	ldi	r29, 0x80	; 128
    3746:	d8 0f       	add	r29, r24
  if ((plik = znajdzPlik(nazwa)) != NULL)
  {
    return 0;
  }

  if ((plik = znajdzMiejsceNaWpis()) != NULL) //Szukanie pustego wpisu (nagłówka) po skasowanym pliku
    3748:	20 97       	sbiw	r28, 0x00	; 0
    374a:	c1 f3       	breq	.-16     	; 0x373c <ramDyskUtworzPlik+0x8c>
  {
    memset(plik, 0, 12);                      //Czyszczenie wpisu (pola: pierwszyKlaster, rozmiarLo, rozmiarHi, lAktOtw ustawione na wartość 0)
    374c:	8c e0       	ldi	r24, 0x0C	; 12
    374e:	fe 01       	movw	r30, r28
    3750:	11 92       	st	Z+, r1
    3752:	8a 95       	dec	r24
    3754:	e9 f7       	brne	.-6      	; 0x3750 <ramDyskUtworzPlik+0xa0>
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    3756:	4f 2d       	mov	r20, r15
    3758:	50 e0       	ldi	r21, 0x00	; 0
    375a:	b8 01       	movw	r22, r16
    375c:	ce 01       	movw	r24, r28
    375e:	04 96       	adiw	r24, 0x04	; 4
    3760:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <strncpy>
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    3764:	1c 86       	std	Y+12, r1	; 0x0c
    3766:	1d 86       	std	Y+13, r1	; 0x0d
    3768:	1e 86       	std	Y+14, r1	; 0x0e
    376a:	1f 86       	std	Y+15, r1	; 0x0f
       dlNazwy = i;
       break;
     }
  }
  if (dlNazwy == 0)
    return 0;
    376c:	80 e0       	ldi	r24, 0x00	; 0
    strncpy(plik->nazwa, nazwa, dlNazwy);     //Ustawianie odpowiedniej nazwy pliku
    plik -> dataMod = systemTime();           //Ustawianie czasu modyfikacji
    return 0;
  }
  return 1;
}
    376e:	df 91       	pop	r29
    3770:	cf 91       	pop	r28
    3772:	1f 91       	pop	r17
    3774:	0f 91       	pop	r16
    3776:	ff 90       	pop	r15
    3778:	08 95       	ret

0000377a <ramDyskOtworzPlik>:

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
    377a:	cf 93       	push	r28
    377c:	df 93       	push	r29
    377e:	eb 01       	movw	r28, r22
  uint8_t wynik = 1;
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) != NULL)
    3780:	0e 94 ca 1a 	call	0x3594	; 0x3594 <znajdzPlik>
    3784:	00 97       	sbiw	r24, 0x00	; 0
    3786:	59 f0       	breq	.+22     	; 0x379e <ramDyskOtworzPlik+0x24>
  {
    memset(fd, 0, 3);                                      //Zerowanie struktury deskryptora pliku
    3788:	18 82       	st	Y, r1
    378a:	19 82       	std	Y+1, r1	; 0x01
    378c:	1a 82       	std	Y+2, r1	; 0x02
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    378e:	9d 83       	std	Y+5, r25	; 0x05
    3790:	8c 83       	std	Y+4, r24	; 0x04
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    3792:	fc 01       	movw	r30, r24
    3794:	23 81       	ldd	r18, Z+3	; 0x03
    3796:	2f 5f       	subi	r18, 0xFF	; 255
    3798:	23 83       	std	Z+3, r18	; 0x03
    wynik = 0;
    379a:	80 e0       	ldi	r24, 0x00	; 0
    379c:	01 c0       	rjmp	.+2      	; 0x37a0 <ramDyskOtworzPlik+0x26>
  return 1;
}

uint8_t ramDyskOtworzPlik(const char *nazwa, struct ramPlikFd *fd)
{
  uint8_t wynik = 1;
    379e:	81 e0       	ldi	r24, 0x01	; 1
    fd->wpis = plik;                                       //Ustawianie w deskryptorze wskaźnika na wpis pliku do katalogu głównego
    plik->lAktOtw++;                                       //Uaktualnienie licznika otwarć plików
    wynik = 0;
  }
  return wynik;
}
    37a0:	df 91       	pop	r29
    37a2:	cf 91       	pop	r28
    37a4:	08 95       	ret

000037a6 <ramDyskUsunPlik>:

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    37a6:	0e 94 ca 1a 	call	0x3594	; 0x3594 <znajdzPlik>
    37aa:	fc 01       	movw	r30, r24
    37ac:	89 2b       	or	r24, r25
    37ae:	c1 f0       	breq	.+48     	; 0x37e0 <ramDyskUsunPlik+0x3a>
    return 1;                                              //Nie znaleziono pliku
  if (plik->lAktOtw != 0)
    37b0:	83 81       	ldd	r24, Z+3	; 0x03
    37b2:	81 11       	cpse	r24, r1
    37b4:	17 c0       	rjmp	.+46     	; 0x37e4 <ramDyskUsunPlik+0x3e>
    return 2;                                              //Plik jest otwarty

  uint8_t usuwanyKlaster;
  while(plik->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    37b6:	80 81       	ld	r24, Z
    37b8:	88 23       	and	r24, r24
    37ba:	61 f0       	breq	.+24     	; 0x37d4 <ramDyskUsunPlik+0x2e>
  {
    usuwanyKlaster = plik->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)         //Sprawdzanie, czy nie usuwamy ostatniego klastra
    37bc:	a8 2f       	mov	r26, r24
    37be:	b0 e0       	ldi	r27, 0x00	; 0
    37c0:	a7 53       	subi	r26, 0x37	; 55
    37c2:	b1 4f       	sbci	r27, 0xF1	; 241
    37c4:	9c 91       	ld	r25, X
    37c6:	98 13       	cpse	r25, r24
    37c8:	02 c0       	rjmp	.+4      	; 0x37ce <ramDyskUsunPlik+0x28>
      plik->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    37ca:	10 82       	st	Z, r1
    37cc:	01 c0       	rjmp	.+2      	; 0x37d0 <ramDyskUsunPlik+0x2a>
    else
      plik->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    37ce:	90 83       	st	Z, r25
    klastry[usuwanyKlaster] = 0;                           //Usunięcie klastra
    37d0:	1c 92       	st	X, r1
    37d2:	f1 cf       	rjmp	.-30     	; 0x37b6 <ramDyskUsunPlik+0x10>
  }

  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
    37d4:	90 e1       	ldi	r25, 0x10	; 16
    37d6:	df 01       	movw	r26, r30
    37d8:	1d 92       	st	X+, r1
    37da:	9a 95       	dec	r25
    37dc:	e9 f7       	brne	.-6      	; 0x37d8 <ramDyskUsunPlik+0x32>
//relokacjaTablicyWpisow()
  return 0;
    37de:	08 95       	ret

uint8_t ramDyskUsunPlik(const char *nazwa)
{
  struct ramPlik *plik;
  if ((plik = znajdzPlik(nazwa)) == NULL)
    return 1;                                              //Nie znaleziono pliku
    37e0:	81 e0       	ldi	r24, 0x01	; 1
    37e2:	08 95       	ret
  if (plik->lAktOtw != 0)
    return 2;                                              //Plik jest otwarty
    37e4:	82 e0       	ldi	r24, 0x02	; 2
  }

  memset (plik, 0, 16);                                    //Wpis katalogowy zostaje. Jest pusty. Inny plik może być tam wpisany
//relokacjaTablicyWpisow()
  return 0;
}
    37e6:	08 95       	ret

000037e8 <ramDyskZamknijPlik>:

void ramDyskZamknijPlik(struct ramPlikFd *fd)
{
    37e8:	fc 01       	movw	r30, r24
  if (fd -> wpis -> lAktOtw > 0)                           //Sprawdzanie, czy licznik otwarć jest poprawny
    37ea:	a4 81       	ldd	r26, Z+4	; 0x04
    37ec:	b5 81       	ldd	r27, Z+5	; 0x05
    37ee:	13 96       	adiw	r26, 0x03	; 3
    37f0:	9c 91       	ld	r25, X
    37f2:	13 97       	sbiw	r26, 0x03	; 3
    37f4:	99 23       	and	r25, r25
    37f6:	41 f0       	breq	.+16     	; 0x3808 <ramDyskZamknijPlik+0x20>
  {
    fd->wpis->lAktOtw--;                                   //Zmniejszanie licznika otwarć pliku
    37f8:	91 50       	subi	r25, 0x01	; 1
    37fa:	13 96       	adiw	r26, 0x03	; 3
    37fc:	9c 93       	st	X, r25
    memset(fd, 0, sizeof(struct ramPlikFd));               //CZyszczenie struktury deskryptora plików
    37fe:	86 e0       	ldi	r24, 0x06	; 6
    3800:	df 01       	movw	r26, r30
    3802:	1d 92       	st	X+, r1
    3804:	8a 95       	dec	r24
    3806:	e9 f7       	brne	.-6      	; 0x3802 <ramDyskZamknijPlik+0x1a>
    3808:	08 95       	ret

0000380a <ramDyskCzyscPlik>:
  }
}

uint8_t ramDyskCzyscPlik(struct ramPlikFd *fd)
{
    380a:	cf 93       	push	r28
    380c:	df 93       	push	r29
    380e:	fc 01       	movw	r30, r24
  uint8_t usuwanyKlaster;
  while(fd->wpis->pierwszyKlaster != 0)                        //Już na samym początku może się okazać, że plik nie miał klastrów
    3810:	a4 81       	ldd	r26, Z+4	; 0x04
    3812:	b5 81       	ldd	r27, Z+5	; 0x05
    3814:	8c 91       	ld	r24, X
    3816:	88 23       	and	r24, r24
    3818:	61 f0       	breq	.+24     	; 0x3832 <ramDyskCzyscPlik+0x28>
  {
    usuwanyKlaster = fd->wpis->pierwszyKlaster;
    if (klastry[usuwanyKlaster] == usuwanyKlaster)             //Sprawdzanie, czy nie usuwamy ostatniego klastra
    381a:	c8 2f       	mov	r28, r24
    381c:	d0 e0       	ldi	r29, 0x00	; 0
    381e:	c7 53       	subi	r28, 0x37	; 55
    3820:	d1 4f       	sbci	r29, 0xF1	; 241
    3822:	98 81       	ld	r25, Y
    3824:	98 13       	cpse	r25, r24
    3826:	02 c0       	rjmp	.+4      	; 0x382c <ramDyskCzyscPlik+0x22>
      fd->wpis->pierwszyKlaster = 0;                           //Ok można już zakończyć usuwanie pliku
    3828:	1c 92       	st	X, r1
    382a:	01 c0       	rjmp	.+2      	; 0x382e <ramDyskCzyscPlik+0x24>
    else
      fd->wpis->pierwszyKlaster = klastry[usuwanyKlaster];     //Przejście do następnego klastra
    382c:	9c 93       	st	X, r25
    klastry[usuwanyKlaster] = 0;                               //Usunięcie klastra
    382e:	18 82       	st	Y, r1
    3830:	ef cf       	rjmp	.-34     	; 0x3810 <ramDyskCzyscPlik+0x6>
  }
  fd->wpis->rozmiarLo       = 0;
    3832:	11 96       	adiw	r26, 0x01	; 1
    3834:	1c 92       	st	X, r1
  fd->wpis->rozmiarHi       = 0;
    3836:	a4 81       	ldd	r26, Z+4	; 0x04
    3838:	b5 81       	ldd	r27, Z+5	; 0x05
    383a:	12 96       	adiw	r26, 0x02	; 2
    383c:	1c 92       	st	X, r1
  fd->wpis->dataMod         = systemTime();
    383e:	a4 81       	ldd	r26, Z+4	; 0x04
    3840:	b5 81       	ldd	r27, Z+5	; 0x05
    3842:	1c 96       	adiw	r26, 0x0c	; 12
    3844:	1d 92       	st	X+, r1
    3846:	1d 92       	st	X+, r1
    3848:	1d 92       	st	X+, r1
    384a:	1c 92       	st	X, r1
    384c:	1f 97       	sbiw	r26, 0x0f	; 15
  memset (fd, 0, 4);
    384e:	10 82       	st	Z, r1
    3850:	11 82       	std	Z+1, r1	; 0x01
    3852:	12 82       	std	Z+2, r1	; 0x02
    3854:	13 82       	std	Z+3, r1	; 0x03
  return 0;
}
    3856:	df 91       	pop	r29
    3858:	cf 91       	pop	r28
    385a:	08 95       	ret

0000385c <ramDyskZapiszBajtDoPliku>:

uint8_t ramDyskZapiszBajtDoPliku(struct ramPlikFd *fd, uint8_t znak)
{
    385c:	1f 93       	push	r17
    385e:	cf 93       	push	r28
    3860:	df 93       	push	r29
    3862:	ec 01       	movw	r28, r24
    3864:	16 2f       	mov	r17, r22
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
    3866:	ec 81       	ldd	r30, Y+4	; 0x04
    3868:	fd 81       	ldd	r31, Y+5	; 0x05
    386a:	80 81       	ld	r24, Z
    386c:	81 11       	cpse	r24, r1
    386e:	07 c0       	rjmp	.+14     	; 0x387e <ramDyskZapiszBajtDoPliku+0x22>
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
    3870:	0e 94 27 1b 	call	0x364e	; 0x364e <znajdzWolnyKlaster>
    3874:	88 23       	and	r24, r24
    3876:	49 f1       	breq	.+82     	; 0x38ca <ramDyskZapiszBajtDoPliku+0x6e>
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    fd->wpis->pierwszyKlaster = tmpKlaster;
    3878:	ec 81       	ldd	r30, Y+4	; 0x04
    387a:	fd 81       	ldd	r31, Y+5	; 0x05
    387c:	80 83       	st	Z, r24
  }
  if (fd->IndLo == 0)
    387e:	8a 81       	ldd	r24, Y+2	; 0x02
    3880:	81 11       	cpse	r24, r1
    3882:	0d c0       	rjmp	.+26     	; 0x389e <ramDyskZapiszBajtDoPliku+0x42>
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    3884:	ec 81       	ldd	r30, Y+4	; 0x04
    3886:	fd 81       	ldd	r31, Y+5	; 0x05
    3888:	6b 81       	ldd	r22, Y+3	; 0x03
    388a:	80 81       	ld	r24, Z
    388c:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
    if (tmpKlaster == 0)
    3890:	88 23       	and	r24, r24
    3892:	e9 f0       	breq	.+58     	; 0x38ce <ramDyskZapiszBajtDoPliku+0x72>
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    }
    fd->Wsk = dataPtr(tmpKlaster, 0);                 //Ustawianie wskaźnika na początek nowego klastra
    3894:	90 e0       	ldi	r25, 0x00	; 0
    3896:	80 58       	subi	r24, 0x80	; 128
    3898:	9f 4f       	sbci	r25, 0xFF	; 255
    389a:	18 82       	st	Y, r1
    389c:	89 83       	std	Y+1, r24	; 0x01
  }

  *(fd->Wsk) = znak;                                  //Zapis bajtu do pliku
    389e:	e8 81       	ld	r30, Y
    38a0:	f9 81       	ldd	r31, Y+1	; 0x01
    38a2:	10 83       	st	Z, r17

  fd->IndLo++;                                        //Zwiększanie indeksu odczytu/zapisu
    38a4:	8a 81       	ldd	r24, Y+2	; 0x02
    38a6:	8f 5f       	subi	r24, 0xFF	; 255
    38a8:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Jeśli ma on wartość 0, to oznacza to, że czły klaster jest zapisany
    38aa:	81 11       	cpse	r24, r1
    38ac:	04 c0       	rjmp	.+8      	; 0x38b6 <ramDyskZapiszBajtDoPliku+0x5a>
    fd->IndHi++;                                      //Należy zwiększyć bardziej znaczący bajt indeksu. Nie utworzono nowego klastra, zatem nie uaktualniamy wskaźnika
    38ae:	8b 81       	ldd	r24, Y+3	; 0x03
    38b0:	8f 5f       	subi	r24, 0xFF	; 255
    38b2:	8b 83       	std	Y+3, r24	; 0x03
    38b4:	05 c0       	rjmp	.+10     	; 0x38c0 <ramDyskZapiszBajtDoPliku+0x64>
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik
    38b6:	88 81       	ld	r24, Y
    38b8:	99 81       	ldd	r25, Y+1	; 0x01
    38ba:	01 96       	adiw	r24, 0x01	; 1
    38bc:	99 83       	std	Y+1, r25	; 0x01
    38be:	88 83       	st	Y, r24

  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
    38c0:	ce 01       	movw	r24, r28
    38c2:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <uaktualnijRozmiarPliku>
  return 0;
    38c6:	80 e0       	ldi	r24, 0x00	; 0
    38c8:	03 c0       	rjmp	.+6      	; 0x38d0 <ramDyskZapiszBajtDoPliku+0x74>
{
  uint8_t tmpKlaster;
  if (fd->wpis->pierwszyKlaster == 0)
  {
    if ((tmpKlaster = znajdzWolnyKlaster()) == 0)
      return 1;                                         //Nie można było przydzielić pierwszego klastra do pliku
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	01 c0       	rjmp	.+2      	; 0x38d0 <ramDyskZapiszBajtDoPliku+0x74>
  if (fd->IndLo == 0)
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Wyszukanie lub dodanie następnego klastra. Na podstawie rozmiaru zostanie stwierdzone, czy klaster był dodany
    if (tmpKlaster == 0)
    {
      return 2;                                       //Nie można było przydzielić kolejnego klastra
    38ce:	82 e0       	ldi	r24, 0x02	; 2
  else                                                //Wziąż działamy na tym samym klastrze.
    fd->Wsk++;                                        //Można uaktualnić wskaźnik

  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}
    38d0:	df 91       	pop	r29
    38d2:	cf 91       	pop	r28
    38d4:	1f 91       	pop	r17
    38d6:	08 95       	ret

000038d8 <putSTD>:
    return wynik;
  return EOF;
}

static int putSTD(char c, FILE *stream)
{
    38d8:	fb 01       	movw	r30, r22
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);
    38da:	68 2f       	mov	r22, r24
    38dc:	84 85       	ldd	r24, Z+12	; 0x0c
    38de:	95 85       	ldd	r25, Z+13	; 0x0d
    38e0:	0e 94 2e 1c 	call	0x385c	; 0x385c <ramDyskZapiszBajtDoPliku>
}
    38e4:	90 e0       	ldi	r25, 0x00	; 0
    38e6:	08 95       	ret

000038e8 <ramDyskCzytajBajtZPliku>:
  uaktualnijRozmiarPliku(fd);                         //Uaktualnianie rozmiaru
  return 0;
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
    38e8:	0f 93       	push	r16
    38ea:	1f 93       	push	r17
    38ec:	cf 93       	push	r28
    38ee:	df 93       	push	r29
    38f0:	ec 01       	movw	r28, r24
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    38f2:	ec 81       	ldd	r30, Y+4	; 0x04
    38f4:	fd 81       	ldd	r31, Y+5	; 0x05
    38f6:	92 81       	ldd	r25, Z+2	; 0x02
    38f8:	8b 81       	ldd	r24, Y+3	; 0x03
    38fa:	89 17       	cp	r24, r25
    38fc:	40 f0       	brcs	.+16     	; 0x390e <ramDyskCzytajBajtZPliku+0x26>
    return 0;

  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    38fe:	98 13       	cpse	r25, r24
    3900:	04 c0       	rjmp	.+8      	; 0x390a <ramDyskCzytajBajtZPliku+0x22>
    3902:	21 81       	ldd	r18, Z+1	; 0x01
    3904:	9a 81       	ldd	r25, Y+2	; 0x02
    3906:	29 17       	cp	r18, r25
    3908:	10 f4       	brcc	.+4      	; 0x390e <ramDyskCzytajBajtZPliku+0x26>
}

uint8_t ramDyskCzytajBajtZPliku(struct ramPlikFd *fd, uint8_t *bajt)
{
  if (wObrebiePliku(fd) != 0)                         //Sprawdzanie, czy jesteśmy w obrębie pliku
    return 1;                                         //1 - eof
    390a:	81 e0       	ldi	r24, 0x01	; 1
    390c:	21 c0       	rjmp	.+66     	; 0x3950 <ramDyskCzytajBajtZPliku+0x68>
    390e:	8b 01       	movw	r16, r22

  if (fd->IndLo == 0)                                 //Sprawdzanie, czy działamy na początku nowego klastra
    3910:	9a 81       	ldd	r25, Y+2	; 0x02
    3912:	91 11       	cpse	r25, r1
    3914:	09 c0       	rjmp	.+18     	; 0x3928 <ramDyskCzytajBajtZPliku+0x40>
  {
    uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3916:	68 2f       	mov	r22, r24
    3918:	80 81       	ld	r24, Z
    391a:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
    fd->Wsk = dataPtr(nrKlastra, 0);                  //Ustawianie wskaźnika na początek nowego klastra
    391e:	90 e0       	ldi	r25, 0x00	; 0
    3920:	80 58       	subi	r24, 0x80	; 128
    3922:	9f 4f       	sbci	r25, 0xFF	; 255
    3924:	18 82       	st	Y, r1
    3926:	89 83       	std	Y+1, r24	; 0x01
  }

  *bajt = *(fd->Wsk);                                 //Odczyt z pliku
    3928:	e8 81       	ld	r30, Y
    392a:	f9 81       	ldd	r31, Y+1	; 0x01
    392c:	80 81       	ld	r24, Z
    392e:	f8 01       	movw	r30, r16
    3930:	80 83       	st	Z, r24
  fd->IndLo++;                                        //Zwiększenie indeksu o 1
    3932:	8a 81       	ldd	r24, Y+2	; 0x02
    3934:	8f 5f       	subi	r24, 0xFF	; 255
    3936:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                 //Sprawdzamy, czy przeszliśmy do nowego klastra
    3938:	81 11       	cpse	r24, r1
    393a:	04 c0       	rjmp	.+8      	; 0x3944 <ramDyskCzytajBajtZPliku+0x5c>
    fd->IndHi++;                                      //Tak: uaktualniamy liczbę przeskokół względem pierwszego klastra (bardziej znaczący bajt indeksu)
    393c:	9b 81       	ldd	r25, Y+3	; 0x03
    393e:	9f 5f       	subi	r25, 0xFF	; 255
    3940:	9b 83       	std	Y+3, r25	; 0x03
    3942:	06 c0       	rjmp	.+12     	; 0x3950 <ramDyskCzytajBajtZPliku+0x68>
  else                                                //Działamy na tym samym klastrze
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
    3944:	88 81       	ld	r24, Y
    3946:	99 81       	ldd	r25, Y+1	; 0x01
    3948:	01 96       	adiw	r24, 0x01	; 1
    394a:	99 83       	std	Y+1, r25	; 0x01
    394c:	88 83       	st	Y, r24
    394e:	80 e0       	ldi	r24, 0x00	; 0
  return 0;
}
    3950:	df 91       	pop	r29
    3952:	cf 91       	pop	r28
    3954:	1f 91       	pop	r17
    3956:	0f 91       	pop	r16
    3958:	08 95       	ret

0000395a <getSTD>:
  return wynik;
}


static int getSTD(FILE *stream)
{
    395a:	cf 93       	push	r28
    395c:	df 93       	push	r29
    395e:	1f 92       	push	r1
    3960:	cd b7       	in	r28, 0x3d	; 61
    3962:	de b7       	in	r29, 0x3e	; 62
  uint8_t wynik;
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));

  if (ramDyskCzytajBajtZPliku(fd, &wynik) == 0)
    3964:	be 01       	movw	r22, r28
    3966:	6f 5f       	subi	r22, 0xFF	; 255
    3968:	7f 4f       	sbci	r23, 0xFF	; 255
    396a:	fc 01       	movw	r30, r24
    396c:	84 85       	ldd	r24, Z+12	; 0x0c
    396e:	95 85       	ldd	r25, Z+13	; 0x0d
    3970:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <ramDyskCzytajBajtZPliku>
    3974:	81 11       	cpse	r24, r1
    3976:	03 c0       	rjmp	.+6      	; 0x397e <getSTD+0x24>
    return wynik;
    3978:	89 81       	ldd	r24, Y+1	; 0x01
    397a:	90 e0       	ldi	r25, 0x00	; 0
    397c:	02 c0       	rjmp	.+4      	; 0x3982 <getSTD+0x28>
  return EOF;
    397e:	8f ef       	ldi	r24, 0xFF	; 255
    3980:	9f ef       	ldi	r25, 0xFF	; 255
}
    3982:	0f 90       	pop	r0
    3984:	df 91       	pop	r29
    3986:	cf 91       	pop	r28
    3988:	08 95       	ret

0000398a <ramDyskZapiszBlokDoPliku>:
    fd->Wsk++;                                        //Uaktualniamy wskaźnik do tego klastra
  return 0;
}

uint8_t ramDyskZapiszBlokDoPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    398a:	8f 92       	push	r8
    398c:	9f 92       	push	r9
    398e:	af 92       	push	r10
    3990:	bf 92       	push	r11
    3992:	df 92       	push	r13
    3994:	ef 92       	push	r14
    3996:	ff 92       	push	r15
    3998:	0f 93       	push	r16
    399a:	1f 93       	push	r17
    399c:	cf 93       	push	r28
    399e:	df 93       	push	r29
    39a0:	ec 01       	movw	r28, r24
    39a2:	4b 01       	movw	r8, r22
    39a4:	5a 01       	movw	r10, r20
  if (fd->wpis->pierwszyKlaster == 0)
    39a6:	0c 81       	ldd	r16, Y+4	; 0x04
    39a8:	1d 81       	ldd	r17, Y+5	; 0x05
    39aa:	f8 01       	movw	r30, r16
    39ac:	80 81       	ld	r24, Z
    39ae:	81 11       	cpse	r24, r1
    39b0:	04 c0       	rjmp	.+8      	; 0x39ba <ramDyskZapiszBlokDoPliku+0x30>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    39b2:	0e 94 27 1b 	call	0x364e	; 0x364e <znajdzWolnyKlaster>
    39b6:	f8 01       	movw	r30, r16
    39b8:	80 83       	st	Z, r24

  uint16_t dlBloku = 256 - fd->IndLo;             //Obliczanie liczby bajtów, jaką da się zapisać w aktualnym klastrze
    39ba:	8a 81       	ldd	r24, Y+2	; 0x02
    39bc:	20 e0       	ldi	r18, 0x00	; 0
    39be:	31 e0       	ldi	r19, 0x01	; 1
    39c0:	79 01       	movw	r14, r18
    39c2:	e8 1a       	sub	r14, r24
    39c4:	f1 08       	sbc	r15, r1
  uint16_t doZapisu = *dlugosc;
    39c6:	f5 01       	movw	r30, r10
    39c8:	00 81       	ld	r16, Z
    39ca:	11 81       	ldd	r17, Z+1	; 0x01
  *dlugosc = 0;                                   //Jak do tąd jeszcze nic nie zapisano
    39cc:	11 82       	std	Z+1, r1	; 0x01
    39ce:	10 82       	st	Z, r1
  uint8_t tmpKlaster = 0;
    39d0:	d1 2c       	mov	r13, r1
  while (doZapisu > 0)
    39d2:	01 15       	cp	r16, r1
    39d4:	11 05       	cpc	r17, r1
    39d6:	09 f4       	brne	.+2      	; 0x39da <ramDyskZapiszBlokDoPliku+0x50>
    39d8:	50 c0       	rjmp	.+160    	; 0x3a7a <ramDyskZapiszBlokDoPliku+0xf0>
  {
    if (fd->IndLo == 0)                           //Jeśli indeks pokazuje na początek klastra, to należy odczytać jego numer oraz ustawić na niego wskaźnik
    39da:	8a 81       	ldd	r24, Y+2	; 0x02
    39dc:	81 11       	cpse	r24, r1
    39de:	15 c0       	rjmp	.+42     	; 0x3a0a <ramDyskZapiszBlokDoPliku+0x80>
    {
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
    39e0:	d1 10       	cpse	r13, r1
    39e2:	07 c0       	rjmp	.+14     	; 0x39f2 <ramDyskZapiszBlokDoPliku+0x68>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
    39e4:	ec 81       	ldd	r30, Y+4	; 0x04
    39e6:	fd 81       	ldd	r31, Y+5	; 0x05
    39e8:	6b 81       	ldd	r22, Y+3	; 0x03
    39ea:	80 81       	ld	r24, Z
    39ec:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
    39f0:	03 c0       	rjmp	.+6      	; 0x39f8 <ramDyskZapiszBlokDoPliku+0x6e>
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
    39f2:	8d 2d       	mov	r24, r13
    39f4:	0e 94 8e 1a 	call	0x351c	; 0x351c <nastepnyKlaster>
    39f8:	d8 2e       	mov	r13, r24
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
    39fa:	88 23       	and	r24, r24
    39fc:	09 f4       	brne	.+2      	; 0x3a00 <ramDyskZapiszBlokDoPliku+0x76>
    39fe:	42 c0       	rjmp	.+132    	; 0x3a84 <ramDyskZapiszBlokDoPliku+0xfa>
        return 1;                                 //1 - Brak wolnego klastra

      fd->Wsk = dataPtr(tmpKlaster, 0);           //Ustawianie wskaźnika na początek klastra. Teraz można do niego już pisać
    3a00:	90 e0       	ldi	r25, 0x00	; 0
    3a02:	80 58       	subi	r24, 0x80	; 128
    3a04:	9f 4f       	sbci	r25, 0xFF	; 255
    3a06:	18 82       	st	Y, r1
    3a08:	89 83       	std	Y+1, r24	; 0x01
    3a0a:	88 81       	ld	r24, Y
    3a0c:	99 81       	ldd	r25, Y+1	; 0x01
    }
    if (doZapisu > dlBloku)                       //Sprawdzanie, czy wszystko uda się zapisać w bieżącym klastrze
    3a0e:	e0 16       	cp	r14, r16
    3a10:	f1 06       	cpc	r15, r17
    3a12:	b8 f4       	brcc	.+46     	; 0x3a42 <ramDyskZapiszBlokDoPliku+0xb8>
    {                                             //Nie uda się, teraz zapiszemy cały klastr do końca
      memcpy(fd->Wsk, znaki, dlBloku);            //Zapis do końca aktualnego klastra
    3a14:	a7 01       	movw	r20, r14
    3a16:	b4 01       	movw	r22, r8
    3a18:	0e 94 76 4f 	call	0x9eec	; 0x9eec <memcpy>
      znaki +=dlBloku;
    3a1c:	8e 0c       	add	r8, r14
    3a1e:	9f 1c       	adc	r9, r15
      fd->IndLo = 0;                              //Mniej znaczący bajt odczytu wskazuje na początek nowego klastra. Kolejna iteracja go utworzy
    3a20:	1a 82       	std	Y+2, r1	; 0x02
      doZapisu -= dlBloku;                        //Uaktualnianie informacji o liczbie bajtów jaka pozostałą do zapisujemy
    3a22:	0e 19       	sub	r16, r14
    3a24:	1f 09       	sbc	r17, r15
      *dlugosc += dlBloku;                        //Uaktualnianie informacji o liczbie zapisanych danych
    3a26:	f5 01       	movw	r30, r10
    3a28:	80 81       	ld	r24, Z
    3a2a:	91 81       	ldd	r25, Z+1	; 0x01
    3a2c:	e8 0e       	add	r14, r24
    3a2e:	f9 1e       	adc	r15, r25
    3a30:	f1 82       	std	Z+1, r15	; 0x01
    3a32:	e0 82       	st	Z, r14
      fd->IndHi++;                                //Ustawienie bardziej znaczącego bajtu indeksu. Oznacza to przejście do kolejnego klastra
    3a34:	8b 81       	ldd	r24, Y+3	; 0x03
    3a36:	8f 5f       	subi	r24, 0xFF	; 255
    3a38:	8b 83       	std	Y+3, r24	; 0x03
      dlBloku = 256;                              //Do następnego klastra możemy zapisać do 256 bajtów
    3a3a:	e1 2c       	mov	r14, r1
    3a3c:	ff 24       	eor	r15, r15
    3a3e:	f3 94       	inc	r15
    3a40:	c8 cf       	rjmp	.-112    	; 0x39d2 <ramDyskZapiszBlokDoPliku+0x48>
    }
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
    3a42:	a8 01       	movw	r20, r16
    3a44:	b4 01       	movw	r22, r8
    3a46:	0e 94 76 4f 	call	0x9eec	; 0x9eec <memcpy>
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
    3a4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a4c:	80 0f       	add	r24, r16
    3a4e:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
    3a50:	f5 01       	movw	r30, r10
    3a52:	80 81       	ld	r24, Z
    3a54:	91 81       	ldd	r25, Z+1	; 0x01
    3a56:	08 0f       	add	r16, r24
    3a58:	19 1f       	adc	r17, r25
    3a5a:	11 83       	std	Z+1, r17	; 0x01
    3a5c:	00 83       	st	Z, r16
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    3a5e:	8d 2d       	mov	r24, r13
    3a60:	90 e0       	ldi	r25, 0x00	; 0
    3a62:	80 58       	subi	r24, 0x80	; 128
    3a64:	9f 4f       	sbci	r25, 0xFF	; 255
    3a66:	98 2f       	mov	r25, r24
    3a68:	88 27       	eor	r24, r24
    3a6a:	2a 81       	ldd	r18, Y+2	; 0x02
    3a6c:	82 0f       	add	r24, r18
    3a6e:	91 1d       	adc	r25, r1
    3a70:	99 83       	std	Y+1, r25	; 0x01
    3a72:	88 83       	st	Y, r24
    else                                          //Jest to ostatni zapis. Całe dane zostaną skopiowane
    {
      memcpy(fd->Wsk, znaki, doZapisu);           //Ostatnia operacja zapisu do klasrta.
      fd->IndLo += doZapisu;                      //Uaktualnianie indeksu (wystarczy uaktualnić mneij znaczący bajt).
      *dlugosc  += doZapisu;                      //Uaktualnianie informacji o liczbie zapisanych danych.
      doZapisu  =  0;                             //Równie dobrze można tutaj wstawić break;
    3a74:	00 e0       	ldi	r16, 0x00	; 0
    3a76:	10 e0       	ldi	r17, 0x00	; 0
    3a78:	ac cf       	rjmp	.-168    	; 0x39d2 <ramDyskZapiszBlokDoPliku+0x48>
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
    3a7a:	ce 01       	movw	r24, r28
    3a7c:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <uaktualnijRozmiarPliku>
  return 0;
    3a80:	80 e0       	ldi	r24, 0x00	; 0
    3a82:	01 c0       	rjmp	.+2      	; 0x3a86 <ramDyskZapiszBlokDoPliku+0xfc>
      if (tmpKlaster == 0)                        //Pierwsza operacja zapisu, nie odczytano jeszcze numeru klastra
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi); //Odczyt numeru klastra na podstawie informacji o liczbie przeskoków od pierwszego
      else                                        //Znamy poprzedni klaster
        tmpKlaster = nastepnyKlaster(tmpKlaster); //Wystarczy przejść do następnego
      if (tmpKlaster == 0)                        //Sprawdzanie, czy udało się znaleźć klaster
        return 1;                                 //1 - Brak wolnego klastra
    3a84:	81 e0       	ldi	r24, 0x01	; 1
      fd->Wsk = dataPtr(tmpKlaster, fd->IndLo);   //Ustawianie wskaźnika w odpowiednie miejsce klastra.
    }
  }
  uaktualnijRozmiarPliku(fd);                     //Uaktualnianie rozmiaru pliku
  return 0;
}
    3a86:	df 91       	pop	r29
    3a88:	cf 91       	pop	r28
    3a8a:	1f 91       	pop	r17
    3a8c:	0f 91       	pop	r16
    3a8e:	ff 90       	pop	r15
    3a90:	ef 90       	pop	r14
    3a92:	df 90       	pop	r13
    3a94:	bf 90       	pop	r11
    3a96:	af 90       	pop	r10
    3a98:	9f 90       	pop	r9
    3a9a:	8f 90       	pop	r8
    3a9c:	08 95       	ret

00003a9e <ramDyskCzytajBlokZPliku>:

uint8_t ramDyskCzytajBlokZPliku(struct ramPlikFd *fd, uint8_t *znaki, uint16_t *dlugosc)
{
    3a9e:	9f 92       	push	r9
    3aa0:	af 92       	push	r10
    3aa2:	bf 92       	push	r11
    3aa4:	cf 92       	push	r12
    3aa6:	df 92       	push	r13
    3aa8:	ef 92       	push	r14
    3aaa:	ff 92       	push	r15
    3aac:	0f 93       	push	r16
    3aae:	1f 93       	push	r17
    3ab0:	cf 93       	push	r28
    3ab2:	df 93       	push	r29
    3ab4:	ec 01       	movw	r28, r24
    3ab6:	6b 01       	movw	r12, r22
    3ab8:	7a 01       	movw	r14, r20
  if (fd->wpis->pierwszyKlaster == 0)
    3aba:	ac 81       	ldd	r26, Y+4	; 0x04
    3abc:	bd 81       	ldd	r27, Y+5	; 0x05
    3abe:	8c 91       	ld	r24, X
    3ac0:	81 11       	cpse	r24, r1
    3ac2:	05 c0       	rjmp	.+10     	; 0x3ace <ramDyskCzytajBlokZPliku+0x30>
  {
    *dlugosc = 0;
    3ac4:	fa 01       	movw	r30, r20
    3ac6:	11 82       	std	Z+1, r1	; 0x01
    3ac8:	10 82       	st	Z, r1
    return 1;                         //1 - Plik jest pusty
    3aca:	81 e0       	ldi	r24, 0x01	; 1
    3acc:	81 c0       	rjmp	.+258    	; 0x3bd0 <ramDyskCzytajBlokZPliku+0x132>
  memset (tmpPtr, 0, 256);
}

static uint8_t  wObrebiePliku(struct ramPlikFd *fd)
{
  if (fd->wpis->rozmiarHi > fd->IndHi)
    3ace:	12 96       	adiw	r26, 0x02	; 2
    3ad0:	2c 91       	ld	r18, X
    3ad2:	12 97       	sbiw	r26, 0x02	; 2
    3ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad6:	82 17       	cp	r24, r18
    3ad8:	68 f0       	brcs	.+26     	; 0x3af4 <ramDyskCzytajBlokZPliku+0x56>
    return 0;

  if ((fd->wpis->rozmiarHi == fd->IndHi) && (fd->wpis->rozmiarLo >= fd->IndLo))
    3ada:	28 13       	cpse	r18, r24
    3adc:	06 c0       	rjmp	.+12     	; 0x3aea <ramDyskCzytajBlokZPliku+0x4c>
    3ade:	11 96       	adiw	r26, 0x01	; 1
    3ae0:	3c 91       	ld	r19, X
    3ae2:	11 97       	sbiw	r26, 0x01	; 1
    3ae4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae6:	39 17       	cp	r19, r25
    3ae8:	28 f4       	brcc	.+10     	; 0x3af4 <ramDyskCzytajBlokZPliku+0x56>
    *dlugosc = 0;
    return 1;                         //1 - Plik jest pusty
  }
  if (wObrebiePliku(fd) != 0)
  {
    *dlugosc = 0;
    3aea:	f7 01       	movw	r30, r14
    3aec:	11 82       	std	Z+1, r1	; 0x01
    3aee:	10 82       	st	Z, r1
    return 2;                         //2 - Źle ustawiony indeks odczytu/zapisu (poza obszarem pliku)
    3af0:	82 e0       	ldi	r24, 0x02	; 2
    3af2:	6e c0       	rjmp	.+220    	; 0x3bd0 <ramDyskCzytajBlokZPliku+0x132>
  }

  uint16_t lDanych = (fd->wpis->rozmiarHi - fd->IndHi);
    3af4:	30 e0       	ldi	r19, 0x00	; 0
    3af6:	f9 01       	movw	r30, r18
    3af8:	e8 1b       	sub	r30, r24
    3afa:	f1 09       	sbc	r31, r1
  lDanych +=fd->wpis->rozmiarLo;      //Obliczanie liczby bajtów jaka zostałą zapisana jeszcze za wskaźnikiem.
    3afc:	11 96       	adiw	r26, 0x01	; 1
    3afe:	2c 91       	ld	r18, X
    3b00:	30 e0       	ldi	r19, 0x00	; 0
  lDanych -=fd->IndLo;                //Na podstawie wcześniej sprawdzonych warunków jest to zawsze liczba dodatnia
    3b02:	8a 81       	ldd	r24, Y+2	; 0x02
    3b04:	28 1b       	sub	r18, r24
    3b06:	31 09       	sbc	r19, r1
    3b08:	2e 0f       	add	r18, r30
    3b0a:	3f 1f       	adc	r19, r31

  uint16_t doOdczytania = (lDanych < *dlugosc)?  //Sprawdzenie liczby zapisanych bajtół w pliku i określenie ile bajtów zdoła się odczytać
    3b0c:	f7 01       	movw	r30, r14
    3b0e:	00 81       	ld	r16, Z
    3b10:	11 81       	ldd	r17, Z+1	; 0x01
    3b12:	20 17       	cp	r18, r16
    3b14:	31 07       	cpc	r19, r17
    3b16:	08 f4       	brcc	.+2      	; 0x3b1a <ramDyskCzytajBlokZPliku+0x7c>
    3b18:	89 01       	movw	r16, r18
    lDanych :                          //W pliku jest mniej bajtów do odczytu niż chcemy odczytać
    *dlugosc;                          //W pliku jest więcej bajtów niż chcemy odczytać
  *dlugosc = 0;                        //Jak do tąd odczytano 0 bajtów
    3b1a:	f7 01       	movw	r30, r14
    3b1c:	11 82       	std	Z+1, r1	; 0x01
    3b1e:	10 82       	st	Z, r1
  uint16_t dlBloku = 256 - fd->IndLo;  //Określanie liczby bajtół jaka zostałą do końca aktualnego klastra`
    3b20:	8a 81       	ldd	r24, Y+2	; 0x02
    3b22:	20 e0       	ldi	r18, 0x00	; 0
    3b24:	31 e0       	ldi	r19, 0x01	; 1
    3b26:	59 01       	movw	r10, r18
    3b28:	a8 1a       	sub	r10, r24
    3b2a:	b1 08       	sbc	r11, r1
  uint8_t tmpKlaster = 0;
    3b2c:	91 2c       	mov	r9, r1
  while (doOdczytania > 0)
    3b2e:	01 15       	cp	r16, r1
    3b30:	11 05       	cpc	r17, r1
    3b32:	09 f4       	brne	.+2      	; 0x3b36 <ramDyskCzytajBlokZPliku+0x98>
    3b34:	4a c0       	rjmp	.+148    	; 0x3bca <ramDyskCzytajBlokZPliku+0x12c>
  {
    if (fd->IndLo == 0)                //Indeks odczytu wskazuje na początek klastra. Oznacza to, że wskaźnik nie jest jeszcze ustawiony
    3b36:	8a 81       	ldd	r24, Y+2	; 0x02
    3b38:	81 11       	cpse	r24, r1
    3b3a:	14 c0       	rjmp	.+40     	; 0x3b64 <ramDyskCzytajBlokZPliku+0xc6>
    {                                  //Bardziej znaczący bajt indeksu określa o ile klastrów (od początkowego) należy się przesunąć do przodu
      if (tmpKlaster == 0)
    3b3c:	91 10       	cpse	r9, r1
    3b3e:	07 c0       	rjmp	.+14     	; 0x3b4e <ramDyskCzytajBlokZPliku+0xb0>
        tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->IndHi);
    3b40:	ec 81       	ldd	r30, Y+4	; 0x04
    3b42:	fd 81       	ldd	r31, Y+5	; 0x05
    3b44:	6b 81       	ldd	r22, Y+3	; 0x03
    3b46:	80 81       	ld	r24, Z
    3b48:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
    3b4c:	03 c0       	rjmp	.+6      	; 0x3b54 <ramDyskCzytajBlokZPliku+0xb6>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
    3b4e:	89 2d       	mov	r24, r9
    3b50:	0e 94 8e 1a 	call	0x351c	; 0x351c <nastepnyKlaster>
    3b54:	98 2e       	mov	r9, r24
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
    3b56:	88 23       	and	r24, r24
    3b58:	d1 f1       	breq	.+116    	; 0x3bce <ramDyskCzytajBlokZPliku+0x130>
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
    3b5c:	80 58       	subi	r24, 0x80	; 128
    3b5e:	9f 4f       	sbci	r25, 0xFF	; 255
    3b60:	18 82       	st	Y, r1
    3b62:	89 83       	std	Y+1, r24	; 0x01
    3b64:	68 81       	ld	r22, Y
    3b66:	79 81       	ldd	r23, Y+1	; 0x01
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    }

    if (doOdczytania > dlBloku)        //Odczyt do końca zawartości klastra
    3b68:	a0 16       	cp	r10, r16
    3b6a:	b1 06       	cpc	r11, r17
    3b6c:	b8 f4       	brcc	.+46     	; 0x3b9c <ramDyskCzytajBlokZPliku+0xfe>
    {                                  //dlBloku określa ile zostało jeszcze bajtów do końca klasrta
      memcpy(znaki, fd->Wsk, dlBloku); //Odczyt zawartości Klastra
    3b6e:	a5 01       	movw	r20, r10
    3b70:	c6 01       	movw	r24, r12
    3b72:	0e 94 76 4f 	call	0x9eec	; 0x9eec <memcpy>
      znaki +=dlBloku;                 //Przestawienie wskaźnika do tablicy, w której zapisujemy odczytane bajty
    3b76:	ca 0c       	add	r12, r10
    3b78:	db 1c       	adc	r13, r11
      fd->IndLo = 0;                   //Indeks wskazuje na początek nowego klastra
    3b7a:	1a 82       	std	Y+2, r1	; 0x02
      fd->IndHi++;                     //Bardziej znaczący bajt określa zmianę klastra. Teraz nie ma potrzeby ustawienia wskaźnika odczytu na jego początek
    3b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b7e:	8f 5f       	subi	r24, 0xFF	; 255
    3b80:	8b 83       	std	Y+3, r24	; 0x03
      doOdczytania -= dlBloku;         //Uaktualnienie liczby bajtół jaką należy odczytać
    3b82:	0a 19       	sub	r16, r10
    3b84:	1b 09       	sbc	r17, r11
      *dlugosc += dlBloku;             //Uaktualnienie
    3b86:	f7 01       	movw	r30, r14
    3b88:	80 81       	ld	r24, Z
    3b8a:	91 81       	ldd	r25, Z+1	; 0x01
    3b8c:	a8 0e       	add	r10, r24
    3b8e:	b9 1e       	adc	r11, r25
    3b90:	b1 82       	std	Z+1, r11	; 0x01
    3b92:	a0 82       	st	Z, r10
      dlBloku = 256;                   //Kolejny dostępny blok do odczytania, to długość całego klastra.
    3b94:	a1 2c       	mov	r10, r1
    3b96:	bb 24       	eor	r11, r11
    3b98:	b3 94       	inc	r11
    3b9a:	c9 cf       	rjmp	.-110    	; 0x3b2e <ramDyskCzytajBlokZPliku+0x90>
    }
    else                               //Ostatnia operacja odczytu
    {
      memcpy(znaki, fd->Wsk, doOdczytania);
    3b9c:	a8 01       	movw	r20, r16
    3b9e:	c6 01       	movw	r24, r12
    3ba0:	0e 94 76 4f 	call	0x9eec	; 0x9eec <memcpy>
      fd->Wsk   += doOdczytania;       //Po zakończeniu operacji odczytu nadal działamy w tym samym klastrze, zatem trzeba teraz uaktualnić wzkaźnik
    3ba4:	88 81       	ld	r24, Y
    3ba6:	99 81       	ldd	r25, Y+1	; 0x01
    3ba8:	80 0f       	add	r24, r16
    3baa:	91 1f       	adc	r25, r17
    3bac:	99 83       	std	Y+1, r25	; 0x01
    3bae:	88 83       	st	Y, r24
      fd->IndLo += doOdczytania;       //Uaktualnianie indeksu. Jesteśmy w tym samym klastrze, zatem nie trzeba zmieniać IndHi
    3bb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3bb2:	80 0f       	add	r24, r16
    3bb4:	8a 83       	std	Y+2, r24	; 0x02
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów
    3bb6:	f7 01       	movw	r30, r14
    3bb8:	80 81       	ld	r24, Z
    3bba:	91 81       	ldd	r25, Z+1	; 0x01
    3bbc:	08 0f       	add	r16, r24
    3bbe:	19 1f       	adc	r17, r25
    3bc0:	11 83       	std	Z+1, r17	; 0x01
    3bc2:	00 83       	st	Z, r16
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    3bc4:	00 e0       	ldi	r16, 0x00	; 0
    3bc6:	10 e0       	ldi	r17, 0x00	; 0
    3bc8:	b2 cf       	rjmp	.-156    	; 0x3b2e <ramDyskCzytajBlokZPliku+0x90>
    }
  }
  return 0;
    3bca:	80 e0       	ldi	r24, 0x00	; 0
    3bcc:	01 c0       	rjmp	.+2      	; 0x3bd0 <ramDyskCzytajBlokZPliku+0x132>
      else
        tmpKlaster = nastepnyKlaster(tmpKlaster);
      if (tmpKlaster != 0)             //Jeśli znaleziono odpowiedni klaster, to
        fd->Wsk = dataPtr(tmpKlaster, 0); //przestaw wskaźnik na początek tego klastra
      else
        return 3;                      //3 - Nie udało się znaleźć odpowiedniego klastra
    3bce:	83 e0       	ldi	r24, 0x03	; 3
      *dlugosc  += doOdczytania;       //Uaktualnianie liczby odczytanych bajtów
      doOdczytania = 0;                //Tutaj równie dobrze może być brake
    }
  }
  return 0;
}
    3bd0:	df 91       	pop	r29
    3bd2:	cf 91       	pop	r28
    3bd4:	1f 91       	pop	r17
    3bd6:	0f 91       	pop	r16
    3bd8:	ff 90       	pop	r15
    3bda:	ef 90       	pop	r14
    3bdc:	df 90       	pop	r13
    3bde:	cf 90       	pop	r12
    3be0:	bf 90       	pop	r11
    3be2:	af 90       	pop	r10
    3be4:	9f 90       	pop	r9
    3be6:	08 95       	ret

00003be8 <ramDyskUstawWskaznik>:

uint8_t ramDyskUstawWskaznik(struct ramPlikFd *fd, uint16_t indeks)
{
    3be8:	ef 92       	push	r14
    3bea:	ff 92       	push	r15
    3bec:	0f 93       	push	r16
    3bee:	1f 93       	push	r17
    3bf0:	cf 93       	push	r28
    3bf2:	df 93       	push	r29
    3bf4:	ec 01       	movw	r28, r24
  if (indeks == 0)                                        //Sprawdzanie, czy wskaźnik nie pokazuje na początek pliku.
    3bf6:	61 15       	cp	r22, r1
    3bf8:	71 05       	cpc	r23, r1
    3bfa:	19 f4       	brne	.+6      	; 0x3c02 <ramDyskUstawWskaznik+0x1a>
  {                                                       //Jeśli tak, to nie ma potzeby tworzenia klastrów. Plik może nadal nei mieć żadnego klastra.
    fd->IndLo = 0;                                        //Ustawianie na 0 indeksów (mniej i bardziej znaczącego bajtu)
    3bfc:	1a 82       	std	Y+2, r1	; 0x02
    fd->IndHi = 0;
    3bfe:	1b 82       	std	Y+3, r1	; 0x03
    3c00:	2f c0       	rjmp	.+94     	; 0x3c60 <ramDyskUstawWskaznik+0x78>
    return 0;
  }
  indeks--;                                               //Zmniejszamy indeks o 1, by odpowiednio ustawić rozmair pliku.
    3c02:	8b 01       	movw	r16, r22
    3c04:	01 50       	subi	r16, 0x01	; 1
    3c06:	11 09       	sbc	r17, r1
                                                          //Jeśli indeks jest większy niż rozmiar pliku, to plik zostanie rozciągnięty do zadanej wartości indeksu -1

  if (fd->wpis->pierwszyKlaster == 0)                     //Sprawdzanie, czy plik ma już przydzielony pierwszy klaster
    3c08:	ec 80       	ldd	r14, Y+4	; 0x04
    3c0a:	fd 80       	ldd	r15, Y+5	; 0x05
    3c0c:	f7 01       	movw	r30, r14
    3c0e:	80 81       	ld	r24, Z
    3c10:	81 11       	cpse	r24, r1
    3c12:	04 c0       	rjmp	.+8      	; 0x3c1c <ramDyskUstawWskaznik+0x34>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();     //Przydzielanie pierwszego klastra dla pliku. Jest to konieczne, ponieważ klaster ma wartość niezerową
    3c14:	0e 94 27 1b 	call	0x364e	; 0x364e <znajdzWolnyKlaster>
    3c18:	f7 01       	movw	r30, r14
    3c1a:	80 83       	st	Z, r24

  uint8_t klasterN = indeks >> 8;                         //Obliczanie liczby klastrów, jaką należy dodać do pierwszego klastra`

  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
    3c1c:	0a 83       	std	Y+2, r16	; 0x02
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.
    3c1e:	1b 83       	std	Y+3, r17	; 0x03

  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
    3c20:	ec 81       	ldd	r30, Y+4	; 0x04
    3c22:	fd 81       	ldd	r31, Y+5	; 0x05
    3c24:	61 2f       	mov	r22, r17
    3c26:	80 81       	ld	r24, Z
    3c28:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
    3c2c:	18 2f       	mov	r17, r24
  if (nrKlastra == 0)
    3c2e:	88 23       	and	r24, r24
    3c30:	c9 f0       	breq	.+50     	; 0x3c64 <ramDyskUstawWskaznik+0x7c>
    return 1;                                             //Brak klastrów

  uaktualnijRozmiarPliku(fd);                             //Uaktualnianie rozmiaru pliku
    3c32:	ce 01       	movw	r24, r28
    3c34:	0e 94 6c 1a 	call	0x34d8	; 0x34d8 <uaktualnijRozmiarPliku>

  fd->IndLo++;                                            //Powrót do zadanej wartości indeksu
    3c38:	8a 81       	ldd	r24, Y+2	; 0x02
    3c3a:	8f 5f       	subi	r24, 0xFF	; 255
    3c3c:	8a 83       	std	Y+2, r24	; 0x02
  if (fd->IndLo == 0)                                     //Jeśli jesteśmy na początku klastra, to jeszcze on nie iestnieje
    3c3e:	81 11       	cpse	r24, r1
    3c40:	04 c0       	rjmp	.+8      	; 0x3c4a <ramDyskUstawWskaznik+0x62>
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
    3c42:	9b 81       	ldd	r25, Y+3	; 0x03
    3c44:	9f 5f       	subi	r25, 0xFF	; 255
    3c46:	9b 83       	std	Y+3, r25	; 0x03
    3c48:	0e c0       	rjmp	.+28     	; 0x3c66 <ramDyskUstawWskaznik+0x7e>
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra
    3c4a:	21 2f       	mov	r18, r17
    3c4c:	30 e0       	ldi	r19, 0x00	; 0
    3c4e:	20 58       	subi	r18, 0x80	; 128
    3c50:	3f 4f       	sbci	r19, 0xFF	; 255
    3c52:	32 2f       	mov	r19, r18
    3c54:	22 27       	eor	r18, r18
    3c56:	a9 01       	movw	r20, r18
    3c58:	48 0f       	add	r20, r24
    3c5a:	51 1d       	adc	r21, r1
    3c5c:	59 83       	std	Y+1, r21	; 0x01
    3c5e:	48 83       	st	Y, r20

  return 0;
    3c60:	80 e0       	ldi	r24, 0x00	; 0
    3c62:	01 c0       	rjmp	.+2      	; 0x3c66 <ramDyskUstawWskaznik+0x7e>
  fd->IndLo = indeks & 0xFF;                              //Obliczanie na podstawie wartości 16 mniej znaczącego bajtu indeksu pomniejszonej o 1
  fd->IndHi = klasterN;                                   //oraz bardziej znaczącego bajtu indeksu w deskryptorze.

  uint8_t nrKlastra = znajdzKlasterN(fd->wpis->pierwszyKlaster, klasterN);
  if (nrKlastra == 0)
    return 1;                                             //Brak klastrów
    3c64:	81 e0       	ldi	r24, 0x01	; 1
    fd->IndHi++;                                          //Uaktualniamy tylko bardziej znaczący bajt indeksu
  else                                                    //Jesteśmy w obszarze utworzonego klastra, można uaktualnić wskaźnik
    fd->Wsk=dataPtr(nrKlastra, fd->IndLo);                //ustawić wskaźnik na odpowiednie miejsce klastra

  return 0;
}
    3c66:	df 91       	pop	r29
    3c68:	cf 91       	pop	r28
    3c6a:	1f 91       	pop	r17
    3c6c:	0f 91       	pop	r16
    3c6e:	ff 90       	pop	r15
    3c70:	ef 90       	pop	r14
    3c72:	08 95       	ret

00003c74 <ramDyskUstawWskaznikNaKoniec>:

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
    3c74:	cf 93       	push	r28
    3c76:	df 93       	push	r29
    3c78:	fc 01       	movw	r30, r24
  if (fd == NULL)
    3c7a:	89 2b       	or	r24, r25
    3c7c:	01 f1       	breq	.+64     	; 0x3cbe <ramDyskUstawWskaznikNaKoniec+0x4a>
    return 1;
  fd->IndLo = fd->wpis->rozmiarLo;
    3c7e:	a4 81       	ldd	r26, Z+4	; 0x04
    3c80:	b5 81       	ldd	r27, Z+5	; 0x05
    3c82:	11 96       	adiw	r26, 0x01	; 1
    3c84:	8c 91       	ld	r24, X
    3c86:	11 97       	sbiw	r26, 0x01	; 1
    3c88:	82 83       	std	Z+2, r24	; 0x02
  fd->IndHi = fd->wpis->rozmiarHi;
    3c8a:	12 96       	adiw	r26, 0x02	; 2
    3c8c:	9c 91       	ld	r25, X
    3c8e:	12 97       	sbiw	r26, 0x02	; 2
    3c90:	93 83       	std	Z+3, r25	; 0x03
//  fd->IndLo++;
  uint8_t tmpKlaster = 0;
  if (fd->IndLo != 0)
    3c92:	88 23       	and	r24, r24
    3c94:	a9 f0       	breq	.+42     	; 0x3cc0 <ramDyskUstawWskaznikNaKoniec+0x4c>
    3c96:	ef 01       	movw	r28, r30
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    3c98:	12 96       	adiw	r26, 0x02	; 2
    3c9a:	6c 91       	ld	r22, X
    3c9c:	12 97       	sbiw	r26, 0x02	; 2
    3c9e:	8c 91       	ld	r24, X
    3ca0:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
    3ca4:	28 2f       	mov	r18, r24
    3ca6:	30 e0       	ldi	r19, 0x00	; 0
    3ca8:	20 58       	subi	r18, 0x80	; 128
    3caa:	3f 4f       	sbci	r19, 0xFF	; 255
    3cac:	32 2f       	mov	r19, r18
    3cae:	22 27       	eor	r18, r18
    3cb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3cb2:	28 0f       	add	r18, r24
    3cb4:	31 1d       	adc	r19, r1
    3cb6:	39 83       	std	Y+1, r19	; 0x01
    3cb8:	28 83       	st	Y, r18
  }
  return 0;
    3cba:	80 e0       	ldi	r24, 0x00	; 0
    3cbc:	01 c0       	rjmp	.+2      	; 0x3cc0 <ramDyskUstawWskaznikNaKoniec+0x4c>
}

uint8_t ramDyskUstawWskaznikNaKoniec(struct ramPlikFd *fd)
{
  if (fd == NULL)
    return 1;
    3cbe:	81 e0       	ldi	r24, 0x01	; 1
  {
    tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster, fd->wpis->rozmiarHi);
    fd->Wsk=dataPtr(tmpKlaster, fd->IndLo);
  }
  return 0;
}
    3cc0:	df 91       	pop	r29
    3cc2:	cf 91       	pop	r28
    3cc4:	08 95       	ret

00003cc6 <ramDyskDodajBlokXmodem>:

uint8_t* ramDyskDodajBlokXmodem(struct ramPlikFd *fd, uint16_t nrBloku)
{
    3cc6:	af 92       	push	r10
    3cc8:	bf 92       	push	r11
    3cca:	cf 92       	push	r12
    3ccc:	df 92       	push	r13
    3cce:	ef 92       	push	r14
    3cd0:	ff 92       	push	r15
    3cd2:	1f 93       	push	r17
    3cd4:	cf 93       	push	r28
    3cd6:	df 93       	push	r29
  if (nrBloku == 0)
    3cd8:	61 15       	cp	r22, r1
    3cda:	71 05       	cpc	r23, r1
    3cdc:	19 f4       	brne	.+6      	; 0x3ce4 <ramDyskDodajBlokXmodem+0x1e>
    return NULL;
    3cde:	80 e0       	ldi	r24, 0x00	; 0
    3ce0:	90 e0       	ldi	r25, 0x00	; 0
    3ce2:	42 c0       	rjmp	.+132    	; 0x3d68 <ramDyskDodajBlokXmodem+0xa2>
    3ce4:	ec 01       	movw	r28, r24
  nrBloku --;
    3ce6:	6b 01       	movw	r12, r22
    3ce8:	81 e0       	ldi	r24, 0x01	; 1
    3cea:	c8 1a       	sub	r12, r24
    3cec:	d1 08       	sbc	r13, r1

  uint8_t indHi = (uint8_t)(nrBloku / 2);
    3cee:	76 01       	movw	r14, r12
    3cf0:	f6 94       	lsr	r15
    3cf2:	e7 94       	ror	r14
    3cf4:	1e 2d       	mov	r17, r14
  //uint8_t indLo = 0;
  uint8_t *wynik;

  if (fd->wpis->pierwszyKlaster == 0)
    3cf6:	ac 80       	ldd	r10, Y+4	; 0x04
    3cf8:	bd 80       	ldd	r11, Y+5	; 0x05
    3cfa:	f5 01       	movw	r30, r10
    3cfc:	80 81       	ld	r24, Z
    3cfe:	81 11       	cpse	r24, r1
    3d00:	04 c0       	rjmp	.+8      	; 0x3d0a <ramDyskDodajBlokXmodem+0x44>
    fd->wpis->pierwszyKlaster = znajdzWolnyKlaster();
    3d02:	0e 94 27 1b 	call	0x364e	; 0x364e <znajdzWolnyKlaster>
    3d06:	f5 01       	movw	r30, r10
    3d08:	80 83       	st	Z, r24
  if (fd->wpis->pierwszyKlaster == 0)
    3d0a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d0c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d0e:	80 81       	ld	r24, Z
    3d10:	88 23       	and	r24, r24
    3d12:	29 f3       	breq	.-54     	; 0x3cde <ramDyskDodajBlokXmodem+0x18>
    return NULL;

  uint8_t tmpKlaster = znajdzKlasterN(fd->wpis->pierwszyKlaster , indHi);
    3d14:	6e 2d       	mov	r22, r14
    3d16:	0e 94 b4 1a 	call	0x3568	; 0x3568 <znajdzKlasterN>
  if (tmpKlaster == 0)
    3d1a:	88 23       	and	r24, r24
    3d1c:	01 f3       	breq	.-64     	; 0x3cde <ramDyskDodajBlokXmodem+0x18>
    3d1e:	ec 81       	ldd	r30, Y+4	; 0x04
    3d20:	fd 81       	ldd	r31, Y+5	; 0x05
    3d22:	28 2f       	mov	r18, r24
    3d24:	30 e0       	ldi	r19, 0x00	; 0
    return NULL;
  if ((nrBloku & 0x0001) == 0x0001)           // Druga część klastra
    3d26:	c0 fe       	sbrs	r12, 0
    3d28:	0e c0       	rjmp	.+28     	; 0x3d46 <ramDyskDodajBlokXmodem+0x80>
  {
    //indLo = 128;
    if (fd->wpis->rozmiarHi <= indHi)
    3d2a:	82 81       	ldd	r24, Z+2	; 0x02
    3d2c:	18 17       	cp	r17, r24
    3d2e:	28 f0       	brcs	.+10     	; 0x3d3a <ramDyskDodajBlokXmodem+0x74>
    {
      fd->wpis->rozmiarHi = indHi+1;
    3d30:	e3 94       	inc	r14
    3d32:	e2 82       	std	Z+2, r14	; 0x02
      fd->wpis->rozmiarLo = 0;
    3d34:	ec 81       	ldd	r30, Y+4	; 0x04
    3d36:	fd 81       	ldd	r31, Y+5	; 0x05
    3d38:	11 82       	std	Z+1, r1	; 0x01
    }
    wynik=dataPtr(tmpKlaster, 128);
    3d3a:	32 2f       	mov	r19, r18
    3d3c:	22 27       	eor	r18, r18
    3d3e:	20 58       	subi	r18, 0x80	; 128
    3d40:	3f 47       	sbci	r19, 0x7F	; 127
    3d42:	c9 01       	movw	r24, r18
    3d44:	11 c0       	rjmp	.+34     	; 0x3d68 <ramDyskDodajBlokXmodem+0xa2>
  }
  else
  {
    if (fd->wpis->rozmiarHi < indHi)
    3d46:	92 81       	ldd	r25, Z+2	; 0x02
    3d48:	91 17       	cp	r25, r17
    3d4a:	20 f4       	brcc	.+8      	; 0x3d54 <ramDyskDodajBlokXmodem+0x8e>
    {
      fd->wpis->rozmiarHi = indHi;
    3d4c:	e2 82       	std	Z+2, r14	; 0x02
      fd->wpis->rozmiarLo = 128;
    3d4e:	ec 81       	ldd	r30, Y+4	; 0x04
    3d50:	fd 81       	ldd	r31, Y+5	; 0x05
    3d52:	05 c0       	rjmp	.+10     	; 0x3d5e <ramDyskDodajBlokXmodem+0x98>
    }
    else if ((fd->wpis->rozmiarHi == indHi) && (fd->wpis->rozmiarLo < 128))
    3d54:	91 13       	cpse	r25, r17
    3d56:	05 c0       	rjmp	.+10     	; 0x3d62 <ramDyskDodajBlokXmodem+0x9c>
    3d58:	81 81       	ldd	r24, Z+1	; 0x01
    3d5a:	87 fd       	sbrc	r24, 7
    3d5c:	02 c0       	rjmp	.+4      	; 0x3d62 <ramDyskDodajBlokXmodem+0x9c>
      fd->wpis->rozmiarLo = 128;
    3d5e:	80 e8       	ldi	r24, 0x80	; 128
    3d60:	81 83       	std	Z+1, r24	; 0x01

    wynik=dataPtr(tmpKlaster, 0);
    3d62:	80 e0       	ldi	r24, 0x00	; 0
    3d64:	90 e8       	ldi	r25, 0x80	; 128
    3d66:	92 0f       	add	r25, r18
  }
  return wynik;
}
    3d68:	df 91       	pop	r29
    3d6a:	cf 91       	pop	r28
    3d6c:	1f 91       	pop	r17
    3d6e:	ff 90       	pop	r15
    3d70:	ef 90       	pop	r14
    3d72:	df 90       	pop	r13
    3d74:	cf 90       	pop	r12
    3d76:	bf 90       	pop	r11
    3d78:	af 90       	pop	r10
    3d7a:	08 95       	ret

00003d7c <ramDyskDir>:

void ramDyskDir(FILE *ostream)
{
    3d7c:	5f 92       	push	r5
    3d7e:	6f 92       	push	r6
    3d80:	7f 92       	push	r7
    3d82:	8f 92       	push	r8
    3d84:	9f 92       	push	r9
    3d86:	af 92       	push	r10
    3d88:	bf 92       	push	r11
    3d8a:	cf 92       	push	r12
    3d8c:	df 92       	push	r13
    3d8e:	ef 92       	push	r14
    3d90:	ff 92       	push	r15
    3d92:	0f 93       	push	r16
    3d94:	1f 93       	push	r17
    3d96:	cf 93       	push	r28
    3d98:	df 93       	push	r29
    3d9a:	b8 2e       	mov	r11, r24
    3d9c:	a9 2e       	mov	r10, r25
  fprintf(ostream, "nazwa\t\trozmiar\totwarty\r\n");
    3d9e:	68 2f       	mov	r22, r24
    3da0:	79 2f       	mov	r23, r25
    3da2:	8b e0       	ldi	r24, 0x0B	; 11
    3da4:	91 e0       	ldi	r25, 0x01	; 1
    3da6:	0e 94 6f 50 	call	0xa0de	; 0xa0de <fputs>
  struct ramPlik *plik;
  uint8_t tmpKlaster = 0;
    3daa:	71 2c       	mov	r7, r1
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    3dac:	34 e2       	ldi	r19, 0x24	; 36
    3dae:	c3 2e       	mov	r12, r19
    3db0:	31 e0       	ldi	r19, 0x01	; 1
    3db2:	d3 2e       	mov	r13, r19
  uint8_t tmpKlaster = 0;
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    3db4:	e7 2c       	mov	r14, r7
    3db6:	f1 2c       	mov	r15, r1
    3db8:	87 01       	movw	r16, r14
    3dba:	00 58       	subi	r16, 0x80	; 128
    3dbc:	1f 4f       	sbci	r17, 0xFF	; 255
    3dbe:	10 2f       	mov	r17, r16
    3dc0:	00 27       	eor	r16, r16
    3dc2:	e8 01       	movw	r28, r16
    3dc4:	25 96       	adiw	r28, 0x05	; 5
    3dc6:	0b 5f       	subi	r16, 0xFB	; 251
    3dc8:	1e 4f       	sbci	r17, 0xFE	; 254
    3dca:	fe 01       	movw	r30, r28
    3dcc:	31 97       	sbiw	r30, 0x01	; 1
    for (tmp=0; tmp<16; tmp++)
    {
      tmp3=plik->nazwa[0];
    3dce:	60 80       	ld	r6, Z
      if (tmp3 == 0)
    3dd0:	61 10       	cpse	r6, r1
    3dd2:	09 c0       	rjmp	.+18     	; 0x3de6 <ramDyskDir+0x6a>
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
      plik++;
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
    3dd4:	f7 01       	movw	r30, r14
    3dd6:	e7 53       	subi	r30, 0x37	; 55
    3dd8:	f1 4f       	sbci	r31, 0xF1	; 241
    3dda:	80 81       	ld	r24, Z
  }
  while (tmpKlaster != tmpKlaster2);
    3ddc:	87 15       	cp	r24, r7
    3dde:	09 f4       	brne	.+2      	; 0x3de2 <ramDyskDir+0x66>
    3de0:	47 c0       	rjmp	.+142    	; 0x3e70 <ramDyskDir+0xf4>
    3de2:	78 2e       	mov	r7, r24
    3de4:	e7 cf       	rjmp	.-50     	; 0x3db4 <ramDyskDir+0x38>
    for (tmp=0; tmp<16; tmp++)
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
    3de6:	6b 2d       	mov	r22, r11
    3de8:	7a 2d       	mov	r23, r10
    3dea:	86 2d       	mov	r24, r6
    3dec:	90 e0       	ldi	r25, 0x00	; 0
    3dee:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3df2:	4e 01       	movw	r8, r28
    3df4:	97 e0       	ldi	r25, 0x07	; 7
    3df6:	59 2e       	mov	r5, r25
      {
        if (tmp3 != 0)
          tmp3=plik->nazwa[tmp2];

        if (tmp3 != 0)
          fputc(tmp3     , ostream);
    3df8:	6b 2d       	mov	r22, r11
    3dfa:	7a 2d       	mov	r23, r10
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
      {
        if (tmp3 != 0)
    3dfc:	66 20       	and	r6, r6
    3dfe:	49 f0       	breq	.+18     	; 0x3e12 <ramDyskDir+0x96>
          tmp3=plik->nazwa[tmp2];
    3e00:	f4 01       	movw	r30, r8
    3e02:	60 80       	ld	r6, Z

        if (tmp3 != 0)
    3e04:	66 20       	and	r6, r6
    3e06:	29 f0       	breq	.+10     	; 0x3e12 <ramDyskDir+0x96>
          fputc(tmp3     , ostream);
    3e08:	86 2d       	mov	r24, r6
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3e10:	05 c0       	rjmp	.+10     	; 0x3e1c <ramDyskDir+0xa0>
        else
          fputc(' '      , ostream);
    3e12:	80 e2       	ldi	r24, 0x20	; 32
    3e14:	90 e0       	ldi	r25, 0x00	; 0
    3e16:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3e1a:	61 2c       	mov	r6, r1
    3e1c:	5a 94       	dec	r5
    3e1e:	ff ef       	ldi	r31, 0xFF	; 255
    3e20:	8f 1a       	sub	r8, r31
    3e22:	9f 0a       	sbc	r9, r31
    {
      tmp3=plik->nazwa[0];
      if (tmp3 == 0)
        break;                                            //Ten wpis jest pusty.
      fputc(tmp3         , ostream);
      for (tmp2=1; tmp2<8; tmp2++)
    3e24:	51 10       	cpse	r5, r1
    3e26:	e8 cf       	rjmp	.-48     	; 0x3df8 <ramDyskDir+0x7c>
    3e28:	fe 01       	movw	r30, r28
    3e2a:	32 97       	sbiw	r30, 0x02	; 2
        if (tmp3 != 0)
          fputc(tmp3     , ostream);
        else
          fputc(' '      , ostream);
      }
      fprintf(ostream, "\t%d\t%d\r\n", 256*plik->rozmiarHi+plik->rozmiarLo,  plik->lAktOtw);
    3e2c:	80 81       	ld	r24, Z
    3e2e:	1f 92       	push	r1
    3e30:	8f 93       	push	r24
    3e32:	31 97       	sbiw	r30, 0x01	; 1
    3e34:	20 81       	ld	r18, Z
    3e36:	30 e0       	ldi	r19, 0x00	; 0
    3e38:	32 2f       	mov	r19, r18
    3e3a:	22 27       	eor	r18, r18
    3e3c:	31 97       	sbiw	r30, 0x01	; 1
    3e3e:	80 81       	ld	r24, Z
    3e40:	28 0f       	add	r18, r24
    3e42:	31 1d       	adc	r19, r1
    3e44:	3f 93       	push	r19
    3e46:	2f 93       	push	r18
    3e48:	df 92       	push	r13
    3e4a:	cf 92       	push	r12
    3e4c:	af 92       	push	r10
    3e4e:	bf 92       	push	r11
    3e50:	0e 94 0a 50 	call	0xa014	; 0xa014 <fprintf>
    3e54:	60 96       	adiw	r28, 0x10	; 16
  uint8_t tmpKlaster2;
  uint8_t tmp, tmp2, tmp3;
  do
  {
    plik = (struct ramPlik *)(dataPtr(tmpKlaster, 0));
    for (tmp=0; tmp<16; tmp++)
    3e56:	8d b7       	in	r24, 0x3d	; 61
    3e58:	9e b7       	in	r25, 0x3e	; 62
    3e5a:	08 96       	adiw	r24, 0x08	; 8
    3e5c:	0f b6       	in	r0, 0x3f	; 63
    3e5e:	f8 94       	cli
    3e60:	9e bf       	out	0x3e, r25	; 62
    3e62:	0f be       	out	0x3f, r0	; 63
    3e64:	8d bf       	out	0x3d, r24	; 61
    3e66:	c0 17       	cp	r28, r16
    3e68:	d1 07       	cpc	r29, r17
    3e6a:	09 f0       	breq	.+2      	; 0x3e6e <ramDyskDir+0xf2>
    3e6c:	ae cf       	rjmp	.-164    	; 0x3dca <ramDyskDir+0x4e>
    3e6e:	b2 cf       	rjmp	.-156    	; 0x3dd4 <ramDyskDir+0x58>
    }
    tmpKlaster2 = tmpKlaster;
    tmpKlaster = klastry[tmpKlaster];
  }
  while (tmpKlaster != tmpKlaster2);
}
    3e70:	df 91       	pop	r29
    3e72:	cf 91       	pop	r28
    3e74:	1f 91       	pop	r17
    3e76:	0f 91       	pop	r16
    3e78:	ff 90       	pop	r15
    3e7a:	ef 90       	pop	r14
    3e7c:	df 90       	pop	r13
    3e7e:	cf 90       	pop	r12
    3e80:	bf 90       	pop	r11
    3e82:	af 90       	pop	r10
    3e84:	9f 90       	pop	r9
    3e86:	8f 90       	pop	r8
    3e88:	7f 90       	pop	r7
    3e8a:	6f 90       	pop	r6
    3e8c:	5f 90       	pop	r5
    3e8e:	08 95       	ret

00003e90 <ramDyskLiczbaWolnychKlastrow>:

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
    3e90:	29 e4       	ldi	r18, 0x49	; 73
    3e92:	3f e0       	ldi	r19, 0x0F	; 15
    3e94:	f9 01       	movw	r30, r18
  uint8_t wynik=0;
    3e96:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    if (klastry[temp] == 0)
    3e98:	92 91       	ld	r25, -Z
    3e9a:	91 11       	cpse	r25, r1
    3e9c:	01 c0       	rjmp	.+2      	; 0x3ea0 <ramDyskLiczbaWolnychKlastrow+0x10>
      wynik++;
    3e9e:	8f 5f       	subi	r24, 0xFF	; 255
    3ea0:	9f e7       	ldi	r25, 0x7F	; 127
    3ea2:	9e 0f       	add	r25, r30

uint8_t ramDyskLiczbaWolnychKlastrow(void)
{
  uint8_t wynik=0;
  uint8_t temp;
  for (temp = L_KLASTROW-1; temp > 0; temp--)
    3ea4:	92 13       	cpse	r25, r18
    3ea6:	f8 cf       	rjmp	.-16     	; 0x3e98 <ramDyskLiczbaWolnychKlastrow+0x8>
    if (klastry[temp] == 0)
      wynik++;
  return wynik;
}
    3ea8:	08 95       	ret

00003eaa <ramDyskOtworzPlikStdIo>:
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
  return ramDyskZapiszBajtDoPliku(fd, c);
}

uint8_t ramDyskOtworzPlikStdIo(const char *nazwa, struct ramPlikFd *fd, FILE *stream, uint8_t flags)
{
    3eaa:	ef 92       	push	r14
    3eac:	ff 92       	push	r15
    3eae:	0f 93       	push	r16
    3eb0:	1f 93       	push	r17
    3eb2:	cf 93       	push	r28
    3eb4:	df 93       	push	r29
    3eb6:	1f 92       	push	r1
    3eb8:	cd b7       	in	r28, 0x3d	; 61
    3eba:	de b7       	in	r29, 0x3e	; 62
    3ebc:	8b 01       	movw	r16, r22
    3ebe:	7a 01       	movw	r14, r20
  uint8_t wynik = ramDyskOtworzPlik(nazwa, fd);
    3ec0:	29 83       	std	Y+1, r18	; 0x01
    3ec2:	0e 94 bd 1b 	call	0x377a	; 0x377a <ramDyskOtworzPlik>
  if (wynik != 0)
    3ec6:	29 81       	ldd	r18, Y+1	; 0x01
    3ec8:	81 11       	cpse	r24, r1
    3eca:	0c c0       	rjmp	.+24     	; 0x3ee4 <ramDyskOtworzPlikStdIo+0x3a>
    return wynik;

  fdev_setup_stream(stream, putSTD, getSTD, flags);
    3ecc:	4c e6       	ldi	r20, 0x6C	; 108
    3ece:	5c e1       	ldi	r21, 0x1C	; 28
    3ed0:	f7 01       	movw	r30, r14
    3ed2:	51 87       	std	Z+9, r21	; 0x09
    3ed4:	40 87       	std	Z+8, r20	; 0x08
    3ed6:	4d ea       	ldi	r20, 0xAD	; 173
    3ed8:	5c e1       	ldi	r21, 0x1C	; 28
    3eda:	53 87       	std	Z+11, r21	; 0x0b
    3edc:	42 87       	std	Z+10, r20	; 0x0a
    3ede:	23 83       	std	Z+3, r18	; 0x03
  fdev_set_udata(stream, fd);
    3ee0:	15 87       	std	Z+13, r17	; 0x0d
    3ee2:	04 87       	std	Z+12, r16	; 0x0c
  return 0;
}
    3ee4:	0f 90       	pop	r0
    3ee6:	df 91       	pop	r29
    3ee8:	cf 91       	pop	r28
    3eea:	1f 91       	pop	r17
    3eec:	0f 91       	pop	r16
    3eee:	ff 90       	pop	r15
    3ef0:	ef 90       	pop	r14
    3ef2:	08 95       	ret

00003ef4 <ramDyskZamknijPlikStdIo>:

uint8_t ramDyskZamknijPlikStdIo(FILE *stream)
{
    3ef4:	0f 93       	push	r16
    3ef6:	1f 93       	push	r17
    3ef8:	cf 93       	push	r28
    3efa:	df 93       	push	r29
    3efc:	8c 01       	movw	r16, r24
  struct ramPlikFd *fd = (struct ramPlikFd *)(fdev_get_udata(stream));
    3efe:	fc 01       	movw	r30, r24
    3f00:	c4 85       	ldd	r28, Z+12	; 0x0c
    3f02:	d5 85       	ldd	r29, Z+13	; 0x0d
  ramDyskZamknijPlik(fd);
    3f04:	ce 01       	movw	r24, r28
    3f06:	0e 94 f4 1b 	call	0x37e8	; 0x37e8 <ramDyskZamknijPlik>
  fclose(stream);
    3f0a:	c8 01       	movw	r24, r16
    3f0c:	0e 94 b5 4f 	call	0x9f6a	; 0x9f6a <fclose>
  return fd->wpis->lAktOtw;
    3f10:	ec 81       	ldd	r30, Y+4	; 0x04
    3f12:	fd 81       	ldd	r31, Y+5	; 0x05
}
    3f14:	83 81       	ldd	r24, Z+3	; 0x03
    3f16:	df 91       	pop	r29
    3f18:	cf 91       	pop	r28
    3f1a:	1f 91       	pop	r17
    3f1c:	0f 91       	pop	r16
    3f1e:	08 95       	ret

00003f20 <cmdlinePrintPrompt>:
    cmdlinePrintPrompt(state);                  // output new prompt
  }
}

void cmdlinePrintPrompt(cmdState_t *state)
{
    3f20:	0f 93       	push	r16
    3f22:	1f 93       	push	r17
    3f24:	cf 93       	push	r28
    3f26:	df 93       	push	r29
    3f28:	8c 01       	movw	r16, r24
  const char* ptr;
  // print a new command prompt
  switch (state->cliMode)
    3f2a:	fc 01       	movw	r30, r24
    3f2c:	80 a1       	ldd	r24, Z+32	; 0x20
    3f2e:	81 30       	cpi	r24, 0x01	; 1
    3f30:	29 f0       	breq	.+10     	; 0x3f3c <cmdlinePrintPrompt+0x1c>
    3f32:	82 30       	cpi	r24, 0x02	; 2
    3f34:	31 f0       	breq	.+12     	; 0x3f42 <cmdlinePrintPrompt+0x22>
  {
    case NR_NORMAL:
      ptr = CmdlinePromptNormal;
    3f36:	c3 e0       	ldi	r28, 0x03	; 3
    3f38:	dc e0       	ldi	r29, 0x0C	; 12
    3f3a:	05 c0       	rjmp	.+10     	; 0x3f46 <cmdlinePrintPrompt+0x26>
      break;
    case NR_ENABLE:
      ptr = CmdlinePromptEnable;
    3f3c:	cc ef       	ldi	r28, 0xFC	; 252
    3f3e:	db e0       	ldi	r29, 0x0B	; 11
    3f40:	02 c0       	rjmp	.+4      	; 0x3f46 <cmdlinePrintPrompt+0x26>
      break;
    case NR_CONFIGURE:
      ptr = CmdlinePromptConfigure;
    3f42:	c5 ef       	ldi	r28, 0xF5	; 245
    3f44:	db e0       	ldi	r29, 0x0B	; 11
      break;
    default:
      ptr = CmdlinePromptNormal;
      break;
  }
  while(pgm_read_byte(ptr))
    3f46:	9e 01       	movw	r18, r28
    3f48:	fe 01       	movw	r30, r28
    3f4a:	84 91       	lpm	r24, Z
    3f4c:	88 23       	and	r24, r24
    3f4e:	51 f0       	breq	.+20     	; 0x3f64 <cmdlinePrintPrompt+0x44>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    3f50:	21 96       	adiw	r28, 0x01	; 1
    3f52:	f9 01       	movw	r30, r18
    3f54:	84 91       	lpm	r24, Z
    3f56:	f8 01       	movw	r30, r16
    3f58:	62 8d       	ldd	r22, Z+26	; 0x1a
    3f5a:	73 8d       	ldd	r23, Z+27	; 0x1b
    3f5c:	90 e0       	ldi	r25, 0x00	; 0
    3f5e:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3f62:	f1 cf       	rjmp	.-30     	; 0x3f46 <cmdlinePrintPrompt+0x26>
}
    3f64:	df 91       	pop	r29
    3f66:	cf 91       	pop	r28
    3f68:	1f 91       	pop	r17
    3f6a:	0f 91       	pop	r16
    3f6c:	08 95       	ret

00003f6e <cmdlineRepaint>:
    state->CmdlineInputVT100State = 1;
  }
}

void cmdlineRepaint(cmdState_t *state, char *buf)
{
    3f6e:	ef 92       	push	r14
    3f70:	ff 92       	push	r15
    3f72:	0f 93       	push	r16
    3f74:	1f 93       	push	r17
    3f76:	cf 93       	push	r28
    3f78:	df 93       	push	r29
    3f7a:	ec 01       	movw	r28, r24
    3f7c:	f6 2e       	mov	r15, r22
    3f7e:	e7 2e       	mov	r14, r23
  uint8_t i;

  // carriage return
  fputc(ASCII_CR         , state->myStdInOut);
    3f80:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3f82:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3f84:	8d e0       	ldi	r24, 0x0D	; 13
    3f86:	90 e0       	ldi	r25, 0x00	; 0
    3f88:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
  // print fresh prompt
  cmdlinePrintPrompt(state);
    3f8c:	ce 01       	movw	r24, r28
    3f8e:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <cmdlinePrintPrompt>
  // print the new command line buffer
  i = state->CmdlineBufferLength;
    3f92:	8d 85       	ldd	r24, Y+13	; 0x0d
  while(i--)
    3f94:	0f 2d       	mov	r16, r15
    3f96:	1e 2d       	mov	r17, r14
    3f98:	f8 0e       	add	r15, r24
    3f9a:	f0 16       	cp	r15, r16
    3f9c:	59 f0       	breq	.+22     	; 0x3fb4 <cmdlineRepaint+0x46>
    fputc(*buf++         , state->myStdInOut);
    3f9e:	f8 01       	movw	r30, r16
    3fa0:	81 91       	ld	r24, Z+
    3fa2:	8f 01       	movw	r16, r30
    3fa4:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3fa6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3fa8:	08 2e       	mov	r0, r24
    3faa:	00 0c       	add	r0, r0
    3fac:	99 0b       	sbc	r25, r25
    3fae:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3fb2:	f3 cf       	rjmp	.-26     	; 0x3f9a <cmdlineRepaint+0x2c>
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    3fb4:	1c 85       	ldd	r17, Y+12	; 0x0c
    3fb6:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fb8:	18 1b       	sub	r17, r24
  while (i--)
    3fba:	11 23       	and	r17, r17
    3fbc:	41 f0       	breq	.+16     	; 0x3fce <cmdlineRepaint+0x60>
    fputc(' ', state->myStdInOut);
    3fbe:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3fc0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3fc2:	80 e2       	ldi	r24, 0x20	; 32
    3fc4:	90 e0       	ldi	r25, 0x00	; 0
    3fc6:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3fca:	11 50       	subi	r17, 0x01	; 1
    3fcc:	f6 cf       	rjmp	.-20     	; 0x3fba <cmdlineRepaint+0x4c>
  i = state->bufferMaxSize - state->CmdlineBufferLength;
    3fce:	1c 85       	ldd	r17, Y+12	; 0x0c
    3fd0:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fd2:	18 1b       	sub	r17, r24
  while (i--)
    3fd4:	11 23       	and	r17, r17
    3fd6:	41 f0       	breq	.+16     	; 0x3fe8 <cmdlineRepaint+0x7a>
    fputc(ASCII_BS,  state->myStdInOut);
    3fd8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3fda:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3fdc:	88 e0       	ldi	r24, 0x08	; 8
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    3fe4:	11 50       	subi	r17, 0x01	; 1
    3fe6:	f6 cf       	rjmp	.-20     	; 0x3fd4 <cmdlineRepaint+0x66>
}
    3fe8:	df 91       	pop	r29
    3fea:	cf 91       	pop	r28
    3fec:	1f 91       	pop	r17
    3fee:	0f 91       	pop	r16
    3ff0:	ff 90       	pop	r15
    3ff2:	ef 90       	pop	r14
    3ff4:	08 95       	ret

00003ff6 <cmdHistoryCopy>:

void cmdHistoryCopy(cmdState_t *state)
{
    3ff6:	1f 93       	push	r17
    3ff8:	cf 93       	push	r28
    3ffa:	df 93       	push	r29
    3ffc:	ec 01       	movw	r28, r24
  if (state->historyDepthIdx != 0)
    3ffe:	88 89       	ldd	r24, Y+16	; 0x10
    4000:	88 23       	and	r24, r24
    4002:	b1 f0       	breq	.+44     	; 0x4030 <cmdHistoryCopy+0x3a>
  {
    uint8_t historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    4004:	1f 85       	ldd	r17, Y+15	; 0x0f
    4006:	18 1b       	sub	r17, r24
    4008:	13 70       	andi	r17, 0x03	; 3
    memset(state->CmdlineBuffer, 0, state->bufferMaxSize);
    400a:	4c 85       	ldd	r20, Y+12	; 0x0c
    400c:	50 e0       	ldi	r21, 0x00	; 0
    400e:	60 e0       	ldi	r22, 0x00	; 0
    4010:	70 e0       	ldi	r23, 0x00	; 0
    4012:	88 81       	ld	r24, Y
    4014:	99 81       	ldd	r25, Y+1	; 0x01
    4016:	0e 94 7f 4f 	call	0x9efe	; 0x9efe <memset>
    strcpy(state->CmdlineBuffer, state->CmdlineHistory[historyReadIdx]);
    401a:	fe 01       	movw	r30, r28
    401c:	e1 0f       	add	r30, r17
    401e:	f1 1d       	adc	r31, r1
    4020:	e1 0f       	add	r30, r17
    4022:	f1 1d       	adc	r31, r1
    4024:	64 81       	ldd	r22, Z+4	; 0x04
    4026:	75 81       	ldd	r23, Z+5	; 0x05
    4028:	88 81       	ld	r24, Y
    402a:	99 81       	ldd	r25, Y+1	; 0x01
    402c:	0e 94 91 4f 	call	0x9f22	; 0x9f22 <strcpy>
  }

  state->historyDepthIdx = 0;
    4030:	18 8a       	std	Y+16, r1	; 0x10
  state->bufferHistoryState = COPIED;
    4032:	81 e0       	ldi	r24, 0x01	; 1
    4034:	89 8b       	std	Y+17, r24	; 0x11
}
    4036:	df 91       	pop	r29
    4038:	cf 91       	pop	r28
    403a:	1f 91       	pop	r17
    403c:	08 95       	ret

0000403e <cmdStateConfigure>:
static void cmdHistoryCopy            (cmdState_t *state);
static void cmdHistoryMove            (cmdState_t *state);


void cmdStateConfigure(cmdState_t * state, char *buffPtr, uint16_t bufferTotalSize, FILE *stream, const command_t *commands, enum cliModeState mode)
{
    403e:	8f 92       	push	r8
    4040:	9f 92       	push	r9
    4042:	af 92       	push	r10
    4044:	bf 92       	push	r11
    4046:	cf 92       	push	r12
    4048:	df 92       	push	r13
    404a:	ef 92       	push	r14
    404c:	0f 93       	push	r16
    404e:	1f 93       	push	r17
    4050:	cf 93       	push	r28
    4052:	df 93       	push	r29
    4054:	ec 01       	movw	r28, r24
    4056:	5b 01       	movw	r10, r22
    4058:	6a 01       	movw	r12, r20
    405a:	49 01       	movw	r8, r18
  memset(state, 0, sizeof(cmdState_t));
    405c:	83 e2       	ldi	r24, 0x23	; 35
    405e:	fe 01       	movw	r30, r28
    4060:	11 92       	st	Z+, r1
    4062:	8a 95       	dec	r24
    4064:	e9 f7       	brne	.-6      	; 0x4060 <cmdStateConfigure+0x22>
  memset(buffPtr, 0, bufferTotalSize);
    4066:	60 e0       	ldi	r22, 0x00	; 0
    4068:	70 e0       	ldi	r23, 0x00	; 0
    406a:	c5 01       	movw	r24, r10
    406c:	0e 94 7f 4f 	call	0x9efe	; 0x9efe <memset>

  state->CmdlineBuffer = buffPtr;
    4070:	b9 82       	std	Y+1, r11	; 0x01
    4072:	a8 82       	st	Y, r10
  state->bufferMaxSize    = (uint8_t)(bufferTotalSize / CMD_STATE_HISTORY);
    4074:	d6 94       	lsr	r13
    4076:	c7 94       	ror	r12
    4078:	d6 94       	lsr	r13
    407a:	c7 94       	ror	r12
    407c:	cc 86       	std	Y+12, r12	; 0x0c

  state->cliMode = mode;
    407e:	e8 a2       	std	Y+32, r14	; 0x20
  state->cmdList = commands;
    4080:	1a a3       	std	Y+34, r17	; 0x22
    4082:	09 a3       	std	Y+33, r16	; 0x21
    4084:	fe 01       	movw	r30, r28
    4086:	34 96       	adiw	r30, 0x04	; 4
    4088:	ce 01       	movw	r24, r28
    408a:	0c 96       	adiw	r24, 0x0c	; 12
  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    tmpPtr += state->bufferMaxSize;
    408c:	dd 24       	eor	r13, r13

  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
  {
    state->CmdlineHistory[i] = tmpPtr;
    408e:	a1 92       	st	Z+, r10
    4090:	b1 92       	st	Z+, r11
    tmpPtr += state->bufferMaxSize;
    4092:	ac 0c       	add	r10, r12
    4094:	bd 1c       	adc	r11, r13
  state->cliMode = mode;
  state->cmdList = commands;

  uint8_t i;
  char *tmpPtr = buffPtr;
  for (i=0; i < CMD_STATE_HISTORY; i++)
    4096:	e8 17       	cp	r30, r24
    4098:	f9 07       	cpc	r31, r25
    409a:	c9 f7       	brne	.-14     	; 0x408e <cmdStateConfigure+0x50>
  {
    state->CmdlineHistory[i] = tmpPtr;
    tmpPtr += state->bufferMaxSize;
  }
  state->myStdInOut = stream;
    409c:	9b 8e       	std	Y+27, r9	; 0x1b
    409e:	8a 8e       	std	Y+26, r8	; 0x1a
}
    40a0:	df 91       	pop	r29
    40a2:	cf 91       	pop	r28
    40a4:	1f 91       	pop	r17
    40a6:	0f 91       	pop	r16
    40a8:	ef 90       	pop	r14
    40aa:	df 90       	pop	r13
    40ac:	cf 90       	pop	r12
    40ae:	bf 90       	pop	r11
    40b0:	af 90       	pop	r10
    40b2:	9f 90       	pop	r9
    40b4:	8f 90       	pop	r8
    40b6:	08 95       	ret

000040b8 <cmdlineInputFunc>:
  // initialize executing function
  state->CmdlineExecFunction = 0;
}*/

void cmdlineInputFunc(char c, cmdState_t *state)
{
    40b8:	af 92       	push	r10
    40ba:	bf 92       	push	r11
    40bc:	cf 92       	push	r12
    40be:	df 92       	push	r13
    40c0:	ef 92       	push	r14
    40c2:	ff 92       	push	r15
    40c4:	0f 93       	push	r16
    40c6:	1f 93       	push	r17
    40c8:	cf 93       	push	r28
    40ca:	df 93       	push	r29
    40cc:	cd b7       	in	r28, 0x3d	; 61
    40ce:	de b7       	in	r29, 0x3e	; 62
    40d0:	27 97       	sbiw	r28, 0x07	; 7
    40d2:	0f b6       	in	r0, 0x3f	; 63
    40d4:	f8 94       	cli
    40d6:	de bf       	out	0x3e, r29	; 62
    40d8:	0f be       	out	0x3f, r0	; 63
    40da:	cd bf       	out	0x3d, r28	; 61
    40dc:	28 2f       	mov	r18, r24
    40de:	8b 01       	movw	r16, r22
  uint8_t i;
  // process the received character

  // VT100 handling
  // are we processing a VT100 command?
  if(state->CmdlineInputVT100State == 2)
    40e0:	db 01       	movw	r26, r22
    40e2:	52 96       	adiw	r26, 0x12	; 18
    40e4:	8c 91       	ld	r24, X
    40e6:	82 30       	cpi	r24, 0x02	; 2
    40e8:	09 f0       	breq	.+2      	; 0x40ec <cmdlineInputFunc+0x34>
    40ea:	92 c0       	rjmp	.+292    	; 0x4210 <cmdlineInputFunc+0x158>
  {
    // we have already received ESC and [
    // now process the vt100 codeCmdlineExcBuffer
    switch(c)
    40ec:	22 34       	cpi	r18, 0x42	; 66
    40ee:	21 f1       	breq	.+72     	; 0x4138 <cmdlineInputFunc+0x80>
    40f0:	1c f4       	brge	.+6      	; 0x40f8 <cmdlineInputFunc+0x40>
    40f2:	21 34       	cpi	r18, 0x41	; 65
    40f4:	41 f0       	breq	.+16     	; 0x4106 <cmdlineInputFunc+0x4e>
    40f6:	89 c0       	rjmp	.+274    	; 0x420a <cmdlineInputFunc+0x152>
    40f8:	23 34       	cpi	r18, 0x43	; 67
    40fa:	09 f4       	brne	.+2      	; 0x40fe <cmdlineInputFunc+0x46>
    40fc:	41 c0       	rjmp	.+130    	; 0x4180 <cmdlineInputFunc+0xc8>
    40fe:	24 34       	cpi	r18, 0x44	; 68
    4100:	09 f4       	brne	.+2      	; 0x4104 <cmdlineInputFunc+0x4c>
    4102:	68 c0       	rjmp	.+208    	; 0x41d4 <cmdlineInputFunc+0x11c>
    4104:	82 c0       	rjmp	.+260    	; 0x420a <cmdlineInputFunc+0x152>

      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    }
    break;
  case CMDLINE_HISTORY_PREV:
    if (state->historyDepthIdx == CMD_STATE_HISTORY - 1)
    4106:	fb 01       	movw	r30, r22
    4108:	90 89       	ldd	r25, Z+16	; 0x10
    410a:	93 30       	cpi	r25, 0x03	; 3
    410c:	09 f4       	brne	.+2      	; 0x4110 <cmdlineInputFunc+0x58>
    410e:	7d c0       	rjmp	.+250    	; 0x420a <cmdlineInputFunc+0x152>
    4110:	87 85       	ldd	r24, Z+15	; 0x0f
    4112:	81 50       	subi	r24, 0x01	; 1
      break;                                               //We are on the end of the history list

    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx - 1) & CMD_STATE_HISTORY_MASK;
    4114:	89 1b       	sub	r24, r25
    4116:	83 70       	andi	r24, 0x03	; 3

    if (state->CmdlineHistory[historyReadIdx][0] == 0)
    4118:	e8 0f       	add	r30, r24
    411a:	f1 1d       	adc	r31, r1
    411c:	e8 0f       	add	r30, r24
    411e:	f1 1d       	adc	r31, r1
    4120:	64 81       	ldd	r22, Z+4	; 0x04
    4122:	75 81       	ldd	r23, Z+5	; 0x05
    4124:	db 01       	movw	r26, r22
    4126:	8c 91       	ld	r24, X
    4128:	88 23       	and	r24, r24
    412a:	09 f4       	brne	.+2      	; 0x412e <cmdlineInputFunc+0x76>
    412c:	6e c0       	rjmp	.+220    	; 0x420a <cmdlineInputFunc+0x152>
      break;

    state->historyDepthIdx++;
    412e:	9f 5f       	subi	r25, 0xFF	; 255
    state->historyDepthIdx &= CMD_STATE_HISTORY_MASK;
    4130:	93 70       	andi	r25, 0x03	; 3
    4132:	f8 01       	movw	r30, r16
    4134:	90 8b       	std	Z+16, r25	; 0x10
    4136:	10 c0       	rjmp	.+32     	; 0x4158 <cmdlineInputFunc+0xa0>
    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);

    break;
  case CMDLINE_HISTORY_NEXT:
    if (state->historyDepthIdx == 0)
    4138:	fb 01       	movw	r30, r22
    413a:	90 89       	ldd	r25, Z+16	; 0x10
    413c:	99 23       	and	r25, r25
    413e:	09 f4       	brne	.+2      	; 0x4142 <cmdlineInputFunc+0x8a>
    4140:	64 c0       	rjmp	.+200    	; 0x420a <cmdlineInputFunc+0x152>
      break;                                               //We are on the begining of the history list

    state->historyDepthIdx --;
    4142:	91 50       	subi	r25, 0x01	; 1
    4144:	90 8b       	std	Z+16, r25	; 0x10
    historyReadIdx = (state->historyWrIdx - state->historyDepthIdx) & CMD_STATE_HISTORY_MASK;
    4146:	87 85       	ldd	r24, Z+15	; 0x0f
    4148:	89 1b       	sub	r24, r25
    414a:	83 70       	andi	r24, 0x03	; 3

    // set the buffer position to the end of the line
    state->CmdlineBufferLength = strlen(state->CmdlineHistory[historyReadIdx]);
    414c:	e8 0f       	add	r30, r24
    414e:	f1 1d       	adc	r31, r1
    4150:	e8 0f       	add	r30, r24
    4152:	f1 1d       	adc	r31, r1
    4154:	64 81       	ldd	r22, Z+4	; 0x04
    4156:	75 81       	ldd	r23, Z+5	; 0x05
    4158:	fb 01       	movw	r30, r22
    415a:	01 90       	ld	r0, Z+
    415c:	00 20       	and	r0, r0
    415e:	e9 f7       	brne	.-6      	; 0x415a <cmdlineInputFunc+0xa2>
    4160:	31 97       	sbiw	r30, 0x01	; 1
    4162:	e6 1b       	sub	r30, r22
    4164:	f7 0b       	sbc	r31, r23
    4166:	d8 01       	movw	r26, r16
    4168:	1d 96       	adiw	r26, 0x0d	; 13
    416a:	ec 93       	st	X, r30
    416c:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = state->CmdlineBufferLength;
    416e:	1e 96       	adiw	r26, 0x0e	; 14
    4170:	ec 93       	st	X, r30
    4172:	1e 97       	sbiw	r26, 0x0e	; 14

    state->bufferHistoryState = NOT_COPIED;
    4174:	51 96       	adiw	r26, 0x11	; 17
    4176:	1c 92       	st	X, r1

    // "re-paint" line
    cmdlineRepaint(state, state->CmdlineHistory[historyReadIdx]);
    4178:	c8 01       	movw	r24, r16
    417a:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <cmdlineRepaint>
    417e:	45 c0       	rjmp	.+138    	; 0x420a <cmdlineInputFunc+0x152>
      break;
    case VT100_ARROWDOWN:
      cmdlineDoHistory(CMDLINE_HISTORY_NEXT, state);
      break;
    case VT100_ARROWRIGHT:
      if (state->bufferHistoryState == NOT_COPIED)
    4180:	fb 01       	movw	r30, r22
    4182:	81 89       	ldd	r24, Z+17	; 0x11
    4184:	81 11       	cpse	r24, r1
    4186:	03 c0       	rjmp	.+6      	; 0x418e <cmdlineInputFunc+0xd6>
        cmdHistoryCopy(state);
    4188:	cb 01       	movw	r24, r22
    418a:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <cmdHistoryCopy>
      // if the edit position less than current string length
      if(state->CmdlineBufferEditPos < state->CmdlineBufferLength)
    418e:	d8 01       	movw	r26, r16
    4190:	1e 96       	adiw	r26, 0x0e	; 14
    4192:	8c 91       	ld	r24, X
    4194:	1e 97       	sbiw	r26, 0x0e	; 14
    4196:	1d 96       	adiw	r26, 0x0d	; 13
    4198:	9c 91       	ld	r25, X
    419a:	1d 97       	sbiw	r26, 0x0d	; 13
    419c:	5a 96       	adiw	r26, 0x1a	; 26
    419e:	6d 91       	ld	r22, X+
    41a0:	7c 91       	ld	r23, X
    41a2:	5b 97       	sbiw	r26, 0x1b	; 27
    41a4:	89 17       	cp	r24, r25
    41a6:	68 f5       	brcc	.+90     	; 0x4202 <cmdlineInputFunc+0x14a>
      {
        // increment the edit position
        state->CmdlineBufferEditPos++;
    41a8:	8f 5f       	subi	r24, 0xFF	; 255
    41aa:	1e 96       	adiw	r26, 0x0e	; 14
    41ac:	8c 93       	st	X, r24
        // move cursor forward one space (no erase)
        fputc(ASCII_ESC        , state->myStdInOut);
    41ae:	8b e1       	ldi	r24, 0x1B	; 27
    41b0:	90 e0       	ldi	r25, 0x00	; 0
    41b2:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        fputc('['              , state->myStdInOut);
    41b6:	f8 01       	movw	r30, r16
    41b8:	62 8d       	ldd	r22, Z+26	; 0x1a
    41ba:	73 8d       	ldd	r23, Z+27	; 0x1b
    41bc:	8b e5       	ldi	r24, 0x5B	; 91
    41be:	90 e0       	ldi	r25, 0x00	; 0
    41c0:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        fputc(VT100_ARROWRIGHT , state->myStdInOut);
    41c4:	d8 01       	movw	r26, r16
    41c6:	5a 96       	adiw	r26, 0x1a	; 26
    41c8:	6d 91       	ld	r22, X+
    41ca:	7c 91       	ld	r23, X
    41cc:	5b 97       	sbiw	r26, 0x1b	; 27
    41ce:	83 e4       	ldi	r24, 0x43	; 67
    41d0:	90 e0       	ldi	r25, 0x00	; 0
    41d2:	19 c0       	rjmp	.+50     	; 0x4206 <cmdlineInputFunc+0x14e>
        fputc(ASCII_BEL        , state->myStdInOut);
      }
      break;
    case VT100_ARROWLEFT:
      // if the edit position is non-zero
      if (state->bufferHistoryState == NOT_COPIED)
    41d4:	fb 01       	movw	r30, r22
    41d6:	81 89       	ldd	r24, Z+17	; 0x11
    41d8:	81 11       	cpse	r24, r1
    41da:	03 c0       	rjmp	.+6      	; 0x41e2 <cmdlineInputFunc+0x12a>
        cmdHistoryCopy(state);
    41dc:	cb 01       	movw	r24, r22
    41de:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <cmdHistoryCopy>

      if(state->CmdlineBufferEditPos)
    41e2:	d8 01       	movw	r26, r16
    41e4:	1e 96       	adiw	r26, 0x0e	; 14
    41e6:	8c 91       	ld	r24, X
    41e8:	1e 97       	sbiw	r26, 0x0e	; 14
    41ea:	5a 96       	adiw	r26, 0x1a	; 26
    41ec:	6d 91       	ld	r22, X+
    41ee:	7c 91       	ld	r23, X
    41f0:	5b 97       	sbiw	r26, 0x1b	; 27
    41f2:	88 23       	and	r24, r24
    41f4:	31 f0       	breq	.+12     	; 0x4202 <cmdlineInputFunc+0x14a>
      {
        // decrement the edit position
        state->CmdlineBufferEditPos--;
    41f6:	81 50       	subi	r24, 0x01	; 1
    41f8:	1e 96       	adiw	r26, 0x0e	; 14
    41fa:	8c 93       	st	X, r24
        // move cursor back one space (no erase)
        fputc(ASCII_BS         , state->myStdInOut);
    41fc:	88 e0       	ldi	r24, 0x08	; 8
    41fe:	90 e0       	ldi	r25, 0x00	; 0
    4200:	02 c0       	rjmp	.+4      	; 0x4206 <cmdlineInputFunc+0x14e>
      }
      else
      {
        // else, ring the bell
        fputc(ASCII_BEL        , state->myStdInOut);
    4202:	87 e0       	ldi	r24, 0x07	; 7
    4204:	90 e0       	ldi	r25, 0x00	; 0
    4206:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
      break;
    default:
      break;
    }
    // done, reset state
    state->CmdlineInputVT100State = 0;
    420a:	f8 01       	movw	r30, r16
    420c:	12 8a       	std	Z+18, r1	; 0x12
    return;
    420e:	32 c2       	rjmp	.+1124   	; 0x4674 <cmdlineInputFunc+0x5bc>
  }
  else if(state->CmdlineInputVT100State == 1)
    4210:	81 30       	cpi	r24, 0x01	; 1
    4212:	21 f4       	brne	.+8      	; 0x421c <cmdlineInputFunc+0x164>
  {
    // we last received [ESC]
    if(c == '[')
    4214:	2b 35       	cpi	r18, 0x5B	; 91
    4216:	11 f4       	brne	.+4      	; 0x421c <cmdlineInputFunc+0x164>
    {
      state->CmdlineInputVT100State = 2;
    4218:	82 e0       	ldi	r24, 0x02	; 2
    421a:	29 c2       	rjmp	.+1106   	; 0x466e <cmdlineInputFunc+0x5b6>
      return;
    }
    else
      state->CmdlineInputVT100State = 0;
    421c:	f8 01       	movw	r30, r16
    421e:	12 8a       	std	Z+18, r1	; 0x12
    state->CmdlineInputVT100State = 0;
  }

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
    4220:	85 85       	ldd	r24, Z+13	; 0x0d
    4222:	94 85       	ldd	r25, Z+12	; 0x0c
    4224:	89 17       	cp	r24, r25
    4226:	29 f0       	breq	.+10     	; 0x4232 <cmdlineInputFunc+0x17a>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    }
  }

  if( (c >= 0x20) && (c < 0x7F) )
    4228:	80 ee       	ldi	r24, 0xE0	; 224
    422a:	82 0f       	add	r24, r18
    422c:	8f 35       	cpi	r24, 0x5F	; 95
    422e:	90 f0       	brcs	.+36     	; 0x4254 <cmdlineInputFunc+0x19c>
    4230:	75 c0       	rjmp	.+234    	; 0x431c <cmdlineInputFunc+0x264>

  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    4232:	81 50       	subi	r24, 0x01	; 1
    4234:	85 87       	std	Z+13, r24	; 0x0d
    for (i=1; i < state->bufferMaxSize; i++)
    4236:	81 e0       	ldi	r24, 0x01	; 1
    4238:	f8 01       	movw	r30, r16
    423a:	94 85       	ldd	r25, Z+12	; 0x0c
    423c:	89 17       	cp	r24, r25
    423e:	a0 f7       	brcc	.-24     	; 0x4228 <cmdlineInputFunc+0x170>
    {
      state->CmdlineBuffer[i-1] = state->CmdlineBuffer[i];
    4240:	d8 01       	movw	r26, r16
    4242:	ed 91       	ld	r30, X+
    4244:	fc 91       	ld	r31, X
    4246:	e8 0f       	add	r30, r24
    4248:	f1 1d       	adc	r31, r1
    424a:	90 81       	ld	r25, Z
    424c:	31 97       	sbiw	r30, 0x01	; 1
    424e:	90 83       	st	Z, r25
  // Regular handling
  //Protection against buffer Overflow
  if (state->CmdlineBufferLength == state->bufferMaxSize)
  {
    state->CmdlineBufferLength--;
    for (i=1; i < state->bufferMaxSize; i++)
    4250:	8f 5f       	subi	r24, 0xFF	; 255
    4252:	f2 cf       	rjmp	.-28     	; 0x4238 <cmdlineInputFunc+0x180>
    }
  }

  if( (c >= 0x20) && (c < 0x7F) )
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4254:	d8 01       	movw	r26, r16
    4256:	51 96       	adiw	r26, 0x11	; 17
    4258:	8c 91       	ld	r24, X
    425a:	81 11       	cpse	r24, r1
    425c:	05 c0       	rjmp	.+10     	; 0x4268 <cmdlineInputFunc+0x1b0>
      cmdHistoryCopy(state);
    425e:	c8 01       	movw	r24, r16
    4260:	2f 83       	std	Y+7, r18	; 0x07
    4262:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <cmdHistoryCopy>
    4266:	2f 81       	ldd	r18, Y+7	; 0x07
    // character is printable
    // is this a simple append
    if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    4268:	f8 01       	movw	r30, r16
    426a:	85 85       	ldd	r24, Z+13	; 0x0d
    426c:	96 85       	ldd	r25, Z+14	; 0x0e
    426e:	98 13       	cpse	r25, r24
    4270:	20 c0       	rjmp	.+64     	; 0x42b2 <cmdlineInputFunc+0x1fa>
    {
      // echo character to the output
      fputc(c                , state->myStdInOut);
    4272:	62 8d       	ldd	r22, Z+26	; 0x1a
    4274:	73 8d       	ldd	r23, Z+27	; 0x1b
    4276:	82 2f       	mov	r24, r18
    4278:	02 2e       	mov	r0, r18
    427a:	00 0c       	add	r0, r0
    427c:	99 0b       	sbc	r25, r25
    427e:	2f 83       	std	Y+7, r18	; 0x07
    4280:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
      // add it to the command line buffer
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    4284:	d8 01       	movw	r26, r16
    4286:	ed 91       	ld	r30, X+
    4288:	fc 91       	ld	r31, X
    428a:	11 97       	sbiw	r26, 0x01	; 1
    428c:	1e 96       	adiw	r26, 0x0e	; 14
    428e:	8c 91       	ld	r24, X
    4290:	1e 97       	sbiw	r26, 0x0e	; 14
    4292:	91 e0       	ldi	r25, 0x01	; 1
    4294:	98 0f       	add	r25, r24
    4296:	1e 96       	adiw	r26, 0x0e	; 14
    4298:	9c 93       	st	X, r25
    429a:	1e 97       	sbiw	r26, 0x0e	; 14
    429c:	e8 0f       	add	r30, r24
    429e:	f1 1d       	adc	r31, r1
    42a0:	2f 81       	ldd	r18, Y+7	; 0x07
    42a2:	20 83       	st	Z, r18
      // update buffer length
      state->CmdlineBufferLength++;
    42a4:	1d 96       	adiw	r26, 0x0d	; 13
    42a6:	8c 91       	ld	r24, X
    42a8:	1d 97       	sbiw	r26, 0x0d	; 13
    42aa:	8f 5f       	subi	r24, 0xFF	; 255
    42ac:	1d 96       	adiw	r26, 0x0d	; 13
    42ae:	8c 93       	st	X, r24
    42b0:	e1 c1       	rjmp	.+962    	; 0x4674 <cmdlineInputFunc+0x5bc>
    else
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
    42b2:	8f 5f       	subi	r24, 0xFF	; 255
    42b4:	f8 01       	movw	r30, r16
    42b6:	85 87       	std	Z+13, r24	; 0x0d
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    42b8:	d8 01       	movw	r26, r16
    42ba:	1e 96       	adiw	r26, 0x0e	; 14
    42bc:	9c 91       	ld	r25, X
    42be:	1e 97       	sbiw	r26, 0x0e	; 14
    42c0:	4d 91       	ld	r20, X+
    42c2:	5c 91       	ld	r21, X
    42c4:	11 97       	sbiw	r26, 0x01	; 1
    42c6:	98 17       	cp	r25, r24
    42c8:	48 f4       	brcc	.+18     	; 0x42dc <cmdlineInputFunc+0x224>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
    42ca:	da 01       	movw	r26, r20
    42cc:	a8 0f       	add	r26, r24
    42ce:	b1 1d       	adc	r27, r1
    42d0:	fd 01       	movw	r30, r26
    42d2:	31 97       	sbiw	r30, 0x01	; 1
    42d4:	90 81       	ld	r25, Z
    42d6:	9c 93       	st	X, r25
    {
      // edit/cursor position != end of buffer
      // we're inserting characters at a mid-line edit position
      // make room at the insert point
      state->CmdlineBufferLength++;
      for(i=state->CmdlineBufferLength; i>state->CmdlineBufferEditPos; i--)
    42d8:	81 50       	subi	r24, 0x01	; 1
    42da:	ee cf       	rjmp	.-36     	; 0x42b8 <cmdlineInputFunc+0x200>
        state->CmdlineBuffer[i] = state->CmdlineBuffer[i-1];
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
    42dc:	81 e0       	ldi	r24, 0x01	; 1
    42de:	89 0f       	add	r24, r25
    42e0:	1e 96       	adiw	r26, 0x0e	; 14
    42e2:	8c 93       	st	X, r24
    42e4:	1e 97       	sbiw	r26, 0x0e	; 14
    42e6:	fa 01       	movw	r30, r20
    42e8:	e9 0f       	add	r30, r25
    42ea:	f1 1d       	adc	r31, r1
    42ec:	20 83       	st	Z, r18
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
    42ee:	6d 91       	ld	r22, X+
    42f0:	7c 91       	ld	r23, X
    42f2:	c8 01       	movw	r24, r16
    42f4:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <cmdlineRepaint>
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    42f8:	f8 01       	movw	r30, r16
    42fa:	f6 84       	ldd	r15, Z+14	; 0x0e
    42fc:	f8 01       	movw	r30, r16
    42fe:	85 85       	ldd	r24, Z+13	; 0x0d
    4300:	f8 16       	cp	r15, r24
    4302:	08 f0       	brcs	.+2      	; 0x4306 <cmdlineInputFunc+0x24e>
    4304:	b7 c1       	rjmp	.+878    	; 0x4674 <cmdlineInputFunc+0x5bc>
        fputc(ASCII_BS         , state->myStdInOut);
    4306:	d8 01       	movw	r26, r16
    4308:	5a 96       	adiw	r26, 0x1a	; 26
    430a:	6d 91       	ld	r22, X+
    430c:	7c 91       	ld	r23, X
    430e:	5b 97       	sbiw	r26, 0x1b	; 27
    4310:	88 e0       	ldi	r24, 0x08	; 8
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
      // insert character
      state->CmdlineBuffer[state->CmdlineBufferEditPos++] = c;
      // repaint
      cmdlineRepaint(state, state->CmdlineBuffer);
      // reposition cursor
      for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4318:	f3 94       	inc	r15
    431a:	f0 cf       	rjmp	.-32     	; 0x42fc <cmdlineInputFunc+0x244>
        fputc(ASCII_BS         , state->myStdInOut);
    }
  }
  // handle special characters
  else if(c == ASCII_CR)
    431c:	2d 30       	cpi	r18, 0x0D	; 13
    431e:	09 f0       	breq	.+2      	; 0x4322 <cmdlineInputFunc+0x26a>
    4320:	38 c1       	rjmp	.+624    	; 0x4592 <cmdlineInputFunc+0x4da>
  {
    if (state->bufferHistoryState == NOT_COPIED)
    4322:	d8 01       	movw	r26, r16
    4324:	51 96       	adiw	r26, 0x11	; 17
    4326:	8c 91       	ld	r24, X
    4328:	51 97       	sbiw	r26, 0x11	; 17
    432a:	81 11       	cpse	r24, r1
    432c:	46 c0       	rjmp	.+140    	; 0x43ba <cmdlineInputFunc+0x302>
  state->bufferHistoryState = COPIED;
}

void cmdHistoryMove(cmdState_t *state)
{
  uint8_t i=state->historyDepthIdx;
    432e:	50 96       	adiw	r26, 0x10	; 16
    4330:	4c 91       	ld	r20, X
    4332:	50 97       	sbiw	r26, 0x10	; 16
    4334:	1f 96       	adiw	r26, 0x0f	; 15
    4336:	5c 91       	ld	r21, X

  if (state->historyDepthIdx != 0)
    4338:	41 11       	cpse	r20, r1
    433a:	12 c0       	rjmp	.+36     	; 0x4360 <cmdlineInputFunc+0x2a8>
    for ( ; i<CMD_STATE_HISTORY; i++)
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    }
  }
  state->CmdlineHistory[state->historyWrIdx] = state->CmdlineBuffer;
    433c:	f8 01       	movw	r30, r16
    433e:	e5 0f       	add	r30, r21
    4340:	f1 1d       	adc	r31, r1
    4342:	e5 0f       	add	r30, r21
    4344:	f1 1d       	adc	r31, r1
    4346:	d8 01       	movw	r26, r16
    4348:	8d 91       	ld	r24, X+
    434a:	9c 91       	ld	r25, X
    434c:	11 97       	sbiw	r26, 0x01	; 1
    434e:	95 83       	std	Z+5, r25	; 0x05
    4350:	84 83       	std	Z+4, r24	; 0x04

  state->historyDepthIdx = 0;
    4352:	50 96       	adiw	r26, 0x10	; 16
    4354:	1c 92       	st	X, r1
    4356:	50 97       	sbiw	r26, 0x10	; 16
  state->bufferHistoryState = COPIED;
    4358:	81 e0       	ldi	r24, 0x01	; 1
    435a:	51 96       	adiw	r26, 0x11	; 17
    435c:	8c 93       	st	X, r24
    435e:	2d c0       	rjmp	.+90     	; 0x43ba <cmdlineInputFunc+0x302>
{
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    4360:	25 2f       	mov	r18, r21
    4362:	30 e0       	ldi	r19, 0x00	; 0
    4364:	f9 01       	movw	r30, r18
    4366:	e4 1b       	sub	r30, r20
    4368:	f1 09       	sbc	r31, r1
    436a:	e3 70       	andi	r30, 0x03	; 3
    436c:	ff 27       	eor	r31, r31
    436e:	32 96       	adiw	r30, 0x02	; 2
    4370:	ee 0f       	add	r30, r30
    4372:	ff 1f       	adc	r31, r31
    4374:	e0 0f       	add	r30, r16
    4376:	f1 1f       	adc	r31, r17
    4378:	80 81       	ld	r24, Z
    437a:	91 81       	ldd	r25, Z+1	; 0x01
    437c:	f8 01       	movw	r30, r16
    437e:	91 83       	std	Z+1, r25	; 0x01
    4380:	80 83       	st	Z, r24
    for ( ; i<CMD_STATE_HISTORY; i++)
    4382:	44 30       	cpi	r20, 0x04	; 4
    4384:	d8 f6       	brcc	.-74     	; 0x433c <cmdlineInputFunc+0x284>
    {
      state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK] = state->CmdlineHistory[(state->historyWrIdx-i-1) & CMD_STATE_HISTORY_MASK];
    4386:	c9 01       	movw	r24, r18
    4388:	84 1b       	sub	r24, r20
    438a:	91 09       	sbc	r25, r1
    438c:	fc 01       	movw	r30, r24
    438e:	31 97       	sbiw	r30, 0x01	; 1
    4390:	e3 70       	andi	r30, 0x03	; 3
    4392:	ff 27       	eor	r31, r31
    4394:	32 96       	adiw	r30, 0x02	; 2
    4396:	ee 0f       	add	r30, r30
    4398:	ff 1f       	adc	r31, r31
    439a:	e0 0f       	add	r30, r16
    439c:	f1 1f       	adc	r31, r17
    439e:	60 81       	ld	r22, Z
    43a0:	71 81       	ldd	r23, Z+1	; 0x01
    43a2:	fc 01       	movw	r30, r24
    43a4:	e3 70       	andi	r30, 0x03	; 3
    43a6:	ff 27       	eor	r31, r31
    43a8:	32 96       	adiw	r30, 0x02	; 2
    43aa:	ee 0f       	add	r30, r30
    43ac:	ff 1f       	adc	r31, r31
    43ae:	e0 0f       	add	r30, r16
    43b0:	f1 1f       	adc	r31, r17
    43b2:	71 83       	std	Z+1, r23	; 0x01
    43b4:	60 83       	st	Z, r22
  uint8_t i=state->historyDepthIdx;

  if (state->historyDepthIdx != 0)
  {
    state->CmdlineBuffer = state->CmdlineHistory[(state->historyWrIdx-i) & CMD_STATE_HISTORY_MASK];
    for ( ; i<CMD_STATE_HISTORY; i++)
    43b6:	4f 5f       	subi	r20, 0xFF	; 255
    43b8:	e4 cf       	rjmp	.-56     	; 0x4382 <cmdlineInputFunc+0x2ca>
    if (state->bufferHistoryState == NOT_COPIED)
      cmdHistoryMove(state);

    // user pressed [ENTER]
    // echo CR and LF to terminal
    fputc(ASCII_CR         , state->myStdInOut);
    43ba:	d8 01       	movw	r26, r16
    43bc:	5a 96       	adiw	r26, 0x1a	; 26
    43be:	6d 91       	ld	r22, X+
    43c0:	7c 91       	ld	r23, X
    43c2:	5b 97       	sbiw	r26, 0x1b	; 27
    43c4:	8d e0       	ldi	r24, 0x0D	; 13
    43c6:	90 e0       	ldi	r25, 0x00	; 0
    43c8:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    fputc(ASCII_LF         , state->myStdInOut);
    43cc:	f8 01       	movw	r30, r16
    43ce:	62 8d       	ldd	r22, Z+26	; 0x1a
    43d0:	73 8d       	ldd	r23, Z+27	; 0x1b
    43d2:	8a e0       	ldi	r24, 0x0A	; 10
    43d4:	90 e0       	ldi	r25, 0x00	; 0
    43d6:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    // add null termination to command
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    43da:	d8 01       	movw	r26, r16
    43dc:	ed 91       	ld	r30, X+
    43de:	fc 91       	ld	r31, X
    43e0:	11 97       	sbiw	r26, 0x01	; 1
    43e2:	1d 96       	adiw	r26, 0x0d	; 13
    43e4:	8c 91       	ld	r24, X
    43e6:	1d 97       	sbiw	r26, 0x0d	; 13
    43e8:	91 e0       	ldi	r25, 0x01	; 1
    43ea:	98 0f       	add	r25, r24
    43ec:	1d 96       	adiw	r26, 0x0d	; 13
    43ee:	9c 93       	st	X, r25
    43f0:	1d 97       	sbiw	r26, 0x0d	; 13
    43f2:	e8 0f       	add	r30, r24
    43f4:	f1 1d       	adc	r31, r1
    43f6:	10 82       	st	Z, r1
    state->CmdlineBufferEditPos++;
    43f8:	1e 96       	adiw	r26, 0x0e	; 14
    43fa:	8c 91       	ld	r24, X
    43fc:	1e 97       	sbiw	r26, 0x0e	; 14
    43fe:	8f 5f       	subi	r24, 0xFF	; 255
    4400:	1e 96       	adiw	r26, 0x0e	; 14
    4402:	8c 93       	st	X, r24
    4404:	1e 97       	sbiw	r26, 0x0e	; 14
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments
    4406:	2d 91       	ld	r18, X+
    4408:	3c 91       	ld	r19, X
    440a:	11 97       	sbiw	r26, 0x01	; 1
    440c:	13 96       	adiw	r26, 0x03	; 3
    440e:	3c 93       	st	X, r19
    4410:	2e 93       	st	-X, r18
    4412:	12 97       	sbiw	r26, 0x02	; 2
  }
}

void cmdlineProcessInputString(cmdState_t *state)
{
  uint8_t i=0;
    4414:	80 e0       	ldi	r24, 0x00	; 0
  state->CmdlineExcBuffer = state->CmdlineBuffer;                     // We will use exec buffer later to read the arguments

  while( !((state->CmdlineExcBuffer[i] == ' ')                        // find the end of the command (excluding arguments)
    4416:	c8 2e       	mov	r12, r24
    4418:	d1 2c       	mov	r13, r1
    441a:	f9 01       	movw	r30, r18
    441c:	ec 0d       	add	r30, r12
    441e:	fd 1d       	adc	r31, r13
    4420:	90 81       	ld	r25, Z
    4422:	9f 7d       	andi	r25, 0xDF	; 223
    4424:	11 f0       	breq	.+4      	; 0x442a <cmdlineInputFunc+0x372>
    || (state->CmdlineExcBuffer[i] == 0)) )                           // find first whitespace character in CmdlineBuffer
    i++;                                                              // i determines the cammand length
    4426:	8f 5f       	subi	r24, 0xFF	; 255
    4428:	f6 cf       	rjmp	.-20     	; 0x4416 <cmdlineInputFunc+0x35e>

  if(!i)                                                              // command was null or empty
    442a:	88 23       	and	r24, r24
    442c:	09 f4       	brne	.+2      	; 0x4430 <cmdlineInputFunc+0x378>
    442e:	a7 c0       	rjmp	.+334    	; 0x457e <cmdlineInputFunc+0x4c6>
  {
    cmdlinePrintPrompt(state);                                        // output a new prompt
    return;
  }

  const command_t *tmpPtr = state->cmdList;                           // Set list of commands. The list depends of the cli mode
    4430:	f8 01       	movw	r30, r16
    4432:	e1 a0       	ldd	r14, Z+33	; 0x21
    4434:	f2 a0       	ldd	r15, Z+34	; 0x22
  command_t  tmp;                                                     // We need to create this object. We can't directly
  memcpy_P(&tmp, tmpPtr, sizeof(command_t));                          // read from flash. We need to copy it before.
    4436:	46 e0       	ldi	r20, 0x06	; 6
    4438:	50 e0       	ldi	r21, 0x00	; 0
    443a:	b7 01       	movw	r22, r14
    443c:	ce 01       	movw	r24, r28
    443e:	01 96       	adiw	r24, 0x01	; 1
    4440:	0e 94 5f 4f 	call	0x9ebe	; 0x9ebe <memcpy_P>

  do                                                                  // search command list for match with entered command
  {
    if( !strncmp_P(state->CmdlineExcBuffer, tmp.commandStr, i) )      // user-entered command matched a command in the list
    4444:	a9 80       	ldd	r10, Y+1	; 0x01
    4446:	ba 80       	ldd	r11, Y+2	; 0x02
    4448:	a6 01       	movw	r20, r12
    444a:	b5 01       	movw	r22, r10
    444c:	d8 01       	movw	r26, r16
    444e:	12 96       	adiw	r26, 0x02	; 2
    4450:	8d 91       	ld	r24, X+
    4452:	9c 91       	ld	r25, X
    4454:	13 97       	sbiw	r26, 0x03	; 3
    4456:	0e 94 68 4f 	call	0x9ed0	; 0x9ed0 <strncmp_P>
    445a:	89 2b       	or	r24, r25
    445c:	41 f5       	brne	.+80     	; 0x44ae <cmdlineInputFunc+0x3f6>
    {                                                                 //
      state->CmdlineExecFunction = tmp.commandFun;                    // set function pointer
    445e:	8d 81       	ldd	r24, Y+5	; 0x05
    4460:	9e 81       	ldd	r25, Y+6	; 0x06
    4462:	f8 01       	movw	r30, r16
    4464:	90 8f       	std	Z+24, r25	; 0x18
    4466:	87 8b       	std	Z+23, r24	; 0x17
      state->command_str         = tmp.commandStr;
    4468:	b4 8a       	std	Z+20, r11	; 0x14
    446a:	a3 8a       	std	Z+19, r10	; 0x13
      state->command_help_str    = tmp.commandHelpStr;
    446c:	8b 81       	ldd	r24, Y+3	; 0x03
    446e:	9c 81       	ldd	r25, Y+4	; 0x04
    4470:	96 8b       	std	Z+22, r25	; 0x16
    4472:	85 8b       	std	Z+21, r24	; 0x15
  uint8_t historyReadIdx;
  switch(action)
  {
  case CMDLINE_HISTORY_SAVE:
    // copy CmdlineBuffer to history if not null string
    state->CmdlineBufferLength  = 0;
    4474:	15 86       	std	Z+13, r1	; 0x0d
    state->CmdlineBufferEditPos = 0;
    4476:	16 86       	std	Z+14, r1	; 0x0e
    state->bufferHistoryState   = NOT_COPIED;
    4478:	11 8a       	std	Z+17, r1	; 0x11

    if( strlen(state->CmdlineBuffer) )
    447a:	01 90       	ld	r0, Z+
    447c:	f0 81       	ld	r31, Z
    447e:	e0 2d       	mov	r30, r0
    4480:	80 81       	ld	r24, Z
    4482:	88 23       	and	r24, r24
    4484:	09 f4       	brne	.+2      	; 0x4488 <cmdlineInputFunc+0x3d0>
    4486:	7e c0       	rjmp	.+252    	; 0x4584 <cmdlineInputFunc+0x4cc>
    {
      state->historyWrIdx++;
    4488:	d8 01       	movw	r26, r16
    448a:	1f 96       	adiw	r26, 0x0f	; 15
    448c:	8c 91       	ld	r24, X
    448e:	1f 97       	sbiw	r26, 0x0f	; 15
    4490:	8f 5f       	subi	r24, 0xFF	; 255
      state->historyWrIdx &= CMD_STATE_HISTORY_MASK;
    4492:	83 70       	andi	r24, 0x03	; 3
    4494:	1f 96       	adiw	r26, 0x0f	; 15
    4496:	8c 93       	st	X, r24

      state->CmdlineBuffer = state->CmdlineHistory[state->historyWrIdx];
    4498:	f8 01       	movw	r30, r16
    449a:	e8 0f       	add	r30, r24
    449c:	f1 1d       	adc	r31, r1
    449e:	e8 0f       	add	r30, r24
    44a0:	f1 1d       	adc	r31, r1
    44a2:	84 81       	ldd	r24, Z+4	; 0x04
    44a4:	95 81       	ldd	r25, Z+5	; 0x05
    44a6:	f8 01       	movw	r30, r16
    44a8:	91 83       	std	Z+1, r25	; 0x01
    44aa:	80 83       	st	Z, r24
    44ac:	6b c0       	rjmp	.+214    	; 0x4584 <cmdlineInputFunc+0x4cc>
      state->command_str         = tmp.commandStr;
      state->command_help_str    = tmp.commandHelpStr;
      cmdlineDoHistory(CMDLINE_HISTORY_SAVE, state);                  // save command in history
      return;
    }
    tmpPtr++;                                                         // Next command
    44ae:	f6 e0       	ldi	r31, 0x06	; 6
    44b0:	ef 0e       	add	r14, r31
    44b2:	f1 1c       	adc	r15, r1
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));                        // Copy this command from flash to ram
    44b4:	46 e0       	ldi	r20, 0x06	; 6
    44b6:	50 e0       	ldi	r21, 0x00	; 0
    44b8:	b7 01       	movw	r22, r14
    44ba:	ce 01       	movw	r24, r28
    44bc:	01 96       	adiw	r24, 0x01	; 1
    44be:	0e 94 5f 4f 	call	0x9ebe	; 0x9ebe <memcpy_P>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!
    44c2:	89 81       	ldd	r24, Y+1	; 0x01
    44c4:	9a 81       	ldd	r25, Y+2	; 0x02
    44c6:	89 2b       	or	r24, r25
    44c8:	09 f0       	breq	.+2      	; 0x44cc <cmdlineInputFunc+0x414>
    44ca:	bc cf       	rjmp	.-136    	; 0x4444 <cmdlineInputFunc+0x38c>
    44cc:	9b ee       	ldi	r25, 0xEB	; 235
    44ce:	e9 2e       	mov	r14, r25
    44d0:	9b e0       	ldi	r25, 0x0B	; 11
    44d2:	f9 2e       	mov	r15, r25
  char * ptr;

  // print a notice header
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineNotice;
  while(pgm_read_byte(ptr))
    44d4:	c7 01       	movw	r24, r14
    44d6:	f7 01       	movw	r30, r14
    44d8:	24 91       	lpm	r18, Z
    44da:	22 23       	and	r18, r18
    44dc:	71 f0       	breq	.+28     	; 0x44fa <cmdlineInputFunc+0x442>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    44de:	2f ef       	ldi	r18, 0xFF	; 255
    44e0:	e2 1a       	sub	r14, r18
    44e2:	f2 0a       	sbc	r15, r18
    44e4:	fc 01       	movw	r30, r24
    44e6:	84 91       	lpm	r24, Z
    44e8:	d8 01       	movw	r26, r16
    44ea:	5a 96       	adiw	r26, 0x1a	; 26
    44ec:	6d 91       	ld	r22, X+
    44ee:	7c 91       	ld	r23, X
    44f0:	5b 97       	sbiw	r26, 0x1b	; 27
    44f2:	90 e0       	ldi	r25, 0x00	; 0
    44f4:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    44f8:	ed cf       	rjmp	.-38     	; 0x44d4 <cmdlineInputFunc+0x41c>
    44fa:	d8 01       	movw	r26, r16
    44fc:	ed 90       	ld	r14, X+
    44fe:	fc 90       	ld	r15, X

  // print the offending command
  ptr = state->CmdlineBuffer;
  while((*ptr) && (*ptr != ' '))
    4500:	f7 01       	movw	r30, r14
    4502:	81 91       	ld	r24, Z+
    4504:	7f 01       	movw	r14, r30
    4506:	98 2f       	mov	r25, r24
    4508:	9f 7d       	andi	r25, 0xDF	; 223
    450a:	d8 01       	movw	r26, r16
    450c:	5a 96       	adiw	r26, 0x1a	; 26
    450e:	6d 91       	ld	r22, X+
    4510:	7c 91       	ld	r23, X
    4512:	5b 97       	sbiw	r26, 0x1b	; 27
    4514:	99 23       	and	r25, r25
    4516:	31 f0       	breq	.+12     	; 0x4524 <cmdlineInputFunc+0x46c>
    fputc(*ptr++    , state->myStdInOut);
    4518:	08 2e       	mov	r0, r24
    451a:	00 0c       	add	r0, r0
    451c:	99 0b       	sbc	r25, r25
    451e:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    4522:	ee cf       	rjmp	.-36     	; 0x4500 <cmdlineInputFunc+0x448>

  fputc(':'         , state->myStdInOut);
    4524:	8a e3       	ldi	r24, 0x3A	; 58
    4526:	90 e0       	ldi	r25, 0x00	; 0
    4528:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
  fputc(' '         , state->myStdInOut);
    452c:	f8 01       	movw	r30, r16
    452e:	62 8d       	ldd	r22, Z+26	; 0x1a
    4530:	73 8d       	ldd	r23, Z+27	; 0x1b
    4532:	80 e2       	ldi	r24, 0x20	; 32
    4534:	90 e0       	ldi	r25, 0x00	; 0
    4536:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>

  // print the not-found message
  // (uint8_t*) cast used to avoid compiler warning
  ptr = (char*)CmdlineCmdNotFound;
    453a:	86 ee       	ldi	r24, 0xE6	; 230
    453c:	e8 2e       	mov	r14, r24
    453e:	8b e0       	ldi	r24, 0x0B	; 11
    4540:	f8 2e       	mov	r15, r24
  while(pgm_read_byte(ptr))
    4542:	97 01       	movw	r18, r14
    4544:	f7 01       	movw	r30, r14
    4546:	94 91       	lpm	r25, Z
    4548:	d8 01       	movw	r26, r16
    454a:	5a 96       	adiw	r26, 0x1a	; 26
    454c:	6d 91       	ld	r22, X+
    454e:	7c 91       	ld	r23, X
    4550:	5b 97       	sbiw	r26, 0x1b	; 27
    4552:	99 23       	and	r25, r25
    4554:	49 f0       	breq	.+18     	; 0x4568 <cmdlineInputFunc+0x4b0>
    fputc(pgm_read_byte(ptr++)    , state->myStdInOut);
    4556:	ff ef       	ldi	r31, 0xFF	; 255
    4558:	ef 1a       	sub	r14, r31
    455a:	ff 0a       	sbc	r15, r31
    455c:	f9 01       	movw	r30, r18
    455e:	84 91       	lpm	r24, Z
    4560:	90 e0       	ldi	r25, 0x00	; 0
    4562:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    4566:	ed cf       	rjmp	.-38     	; 0x4542 <cmdlineInputFunc+0x48a>

  fputc('\r'        , state->myStdInOut);
    4568:	8d e0       	ldi	r24, 0x0D	; 13
    456a:	90 e0       	ldi	r25, 0x00	; 0
    456c:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
  fputc('\n'        , state->myStdInOut);
    4570:	f8 01       	movw	r30, r16
    4572:	62 8d       	ldd	r22, Z+26	; 0x1a
    4574:	73 8d       	ldd	r23, Z+27	; 0x1b
    4576:	8a e0       	ldi	r24, 0x0A	; 10
    4578:	90 e0       	ldi	r25, 0x00	; 0
    457a:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
  }
  while (tmp.commandStr != NULL);                                     // Last command on the list is NULL. It is required !!!

  // if we did not get a match
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
    457e:	c8 01       	movw	r24, r16
    4580:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <cmdlinePrintPrompt>
    state->CmdlineBuffer[state->CmdlineBufferLength++] = 0;
    state->CmdlineBufferEditPos++;
    // command is complete, process it
    cmdlineProcessInputString(state);
    // reset buffer
    state->CmdlineBufferLength = 0;
    4584:	d8 01       	movw	r26, r16
    4586:	1d 96       	adiw	r26, 0x0d	; 13
    4588:	1c 92       	st	X, r1
    458a:	1d 97       	sbiw	r26, 0x0d	; 13
    state->CmdlineBufferEditPos = 0;
    458c:	1e 96       	adiw	r26, 0x0e	; 14
    458e:	1c 92       	st	X, r1
    4590:	71 c0       	rjmp	.+226    	; 0x4674 <cmdlineInputFunc+0x5bc>
  }
  else if(c == ASCII_BS)
    4592:	28 30       	cpi	r18, 0x08	; 8
    4594:	09 f0       	breq	.+2      	; 0x4598 <cmdlineInputFunc+0x4e0>
    4596:	68 c0       	rjmp	.+208    	; 0x4668 <cmdlineInputFunc+0x5b0>
  {
    if(state->CmdlineBufferEditPos)
    4598:	f8 01       	movw	r30, r16
    459a:	86 85       	ldd	r24, Z+14	; 0x0e
    459c:	88 23       	and	r24, r24
    459e:	09 f4       	brne	.+2      	; 0x45a2 <cmdlineInputFunc+0x4ea>
    45a0:	5b c0       	rjmp	.+182    	; 0x4658 <cmdlineInputFunc+0x5a0>
    {
      // is this a simple delete (off the end of the line)
      if(state->CmdlineBufferEditPos == state->CmdlineBufferLength)
    45a2:	95 85       	ldd	r25, Z+13	; 0x0d
    45a4:	89 13       	cpse	r24, r25
    45a6:	25 c0       	rjmp	.+74     	; 0x45f2 <cmdlineInputFunc+0x53a>
      {
        // destructive backspace
        // echo backspace-space-backspace
        fputc(ASCII_BS         , state->myStdInOut);
    45a8:	62 8d       	ldd	r22, Z+26	; 0x1a
    45aa:	73 8d       	ldd	r23, Z+27	; 0x1b
    45ac:	88 e0       	ldi	r24, 0x08	; 8
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    45b0:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        fputc(' '              , state->myStdInOut);
    45b4:	d8 01       	movw	r26, r16
    45b6:	5a 96       	adiw	r26, 0x1a	; 26
    45b8:	6d 91       	ld	r22, X+
    45ba:	7c 91       	ld	r23, X
    45bc:	5b 97       	sbiw	r26, 0x1b	; 27
    45be:	80 e2       	ldi	r24, 0x20	; 32
    45c0:	90 e0       	ldi	r25, 0x00	; 0
    45c2:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        fputc(ASCII_BS         , state->myStdInOut);
    45c6:	f8 01       	movw	r30, r16
    45c8:	62 8d       	ldd	r22, Z+26	; 0x1a
    45ca:	73 8d       	ldd	r23, Z+27	; 0x1b
    45cc:	88 e0       	ldi	r24, 0x08	; 8
    45ce:	90 e0       	ldi	r25, 0x00	; 0
    45d0:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        // decrement our buffer length and edit position
        state->CmdlineBufferLength--;
    45d4:	d8 01       	movw	r26, r16
    45d6:	1d 96       	adiw	r26, 0x0d	; 13
    45d8:	8c 91       	ld	r24, X
    45da:	1d 97       	sbiw	r26, 0x0d	; 13
    45dc:	81 50       	subi	r24, 0x01	; 1
    45de:	1d 96       	adiw	r26, 0x0d	; 13
    45e0:	8c 93       	st	X, r24
    45e2:	1d 97       	sbiw	r26, 0x0d	; 13
        state->CmdlineBufferEditPos--;
    45e4:	1e 96       	adiw	r26, 0x0e	; 14
    45e6:	8c 91       	ld	r24, X
    45e8:	1e 97       	sbiw	r26, 0x0e	; 14
    45ea:	81 50       	subi	r24, 0x01	; 1
    45ec:	1e 96       	adiw	r26, 0x0e	; 14
    45ee:	8c 93       	st	X, r24
    45f0:	41 c0       	rjmp	.+130    	; 0x4674 <cmdlineInputFunc+0x5bc>
      else
      {
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
    45f2:	91 50       	subi	r25, 0x01	; 1
    45f4:	f8 01       	movw	r30, r16
    45f6:	95 87       	std	Z+13, r25	; 0x0d
        state->CmdlineBufferEditPos--;
    45f8:	81 50       	subi	r24, 0x01	; 1
    45fa:	86 87       	std	Z+14, r24	; 0x0e
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    45fc:	d8 01       	movw	r26, r16
    45fe:	1d 96       	adiw	r26, 0x0d	; 13
    4600:	9c 91       	ld	r25, X
    4602:	1d 97       	sbiw	r26, 0x0d	; 13
    4604:	6d 91       	ld	r22, X+
    4606:	7c 91       	ld	r23, X
    4608:	89 17       	cp	r24, r25
    460a:	38 f4       	brcc	.+14     	; 0x461a <cmdlineInputFunc+0x562>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
    460c:	fb 01       	movw	r30, r22
    460e:	e8 0f       	add	r30, r24
    4610:	f1 1d       	adc	r31, r1
    4612:	91 81       	ldd	r25, Z+1	; 0x01
    4614:	90 83       	st	Z, r25
        // edit/cursor position != end of buffer
        // we're deleting characters at a mid-line edit position
        // shift characters down, effectively deleting
        state->CmdlineBufferLength--;
        state->CmdlineBufferEditPos--;
        for(i=state->CmdlineBufferEditPos; i<state->CmdlineBufferLength; i++)
    4616:	8f 5f       	subi	r24, 0xFF	; 255
    4618:	f1 cf       	rjmp	.-30     	; 0x45fc <cmdlineInputFunc+0x544>
          state->CmdlineBuffer[i] = state->CmdlineBuffer[i+1];
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
    461a:	c8 01       	movw	r24, r16
    461c:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <cmdlineRepaint>
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
    4620:	f8 01       	movw	r30, r16
    4622:	62 8d       	ldd	r22, Z+26	; 0x1a
    4624:	73 8d       	ldd	r23, Z+27	; 0x1b
    4626:	80 e2       	ldi	r24, 0x20	; 32
    4628:	90 e0       	ldi	r25, 0x00	; 0
    462a:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    462e:	d8 01       	movw	r26, r16
    4630:	1e 96       	adiw	r26, 0x0e	; 14
    4632:	fc 90       	ld	r15, X
    4634:	d8 01       	movw	r26, r16
    4636:	1d 96       	adiw	r26, 0x0d	; 13
    4638:	8c 91       	ld	r24, X
    463a:	90 e0       	ldi	r25, 0x00	; 0
    463c:	2f 2d       	mov	r18, r15
    463e:	30 e0       	ldi	r19, 0x00	; 0
    4640:	82 17       	cp	r24, r18
    4642:	93 07       	cpc	r25, r19
    4644:	bc f0       	brlt	.+46     	; 0x4674 <cmdlineInputFunc+0x5bc>
          fputc(ASCII_BS       , state->myStdInOut);
    4646:	f8 01       	movw	r30, r16
    4648:	62 8d       	ldd	r22, Z+26	; 0x1a
    464a:	73 8d       	ldd	r23, Z+27	; 0x1b
    464c:	88 e0       	ldi	r24, 0x08	; 8
    464e:	90 e0       	ldi	r25, 0x00	; 0
    4650:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
        // repaint
        cmdlineRepaint(state, state->CmdlineBuffer);
        // add space to clear leftover characters
        fputc(' '              , state->myStdInOut);
        // reposition cursor
        for(i=state->CmdlineBufferEditPos; i<(state->CmdlineBufferLength+1); i++)
    4654:	f3 94       	inc	r15
    4656:	ee cf       	rjmp	.-36     	; 0x4634 <cmdlineInputFunc+0x57c>
      }
    }
    else
    {
      // else, ring the bell
      fputc(ASCII_BEL          , state->myStdInOut);
    4658:	f8 01       	movw	r30, r16
    465a:	62 8d       	ldd	r22, Z+26	; 0x1a
    465c:	73 8d       	ldd	r23, Z+27	; 0x1b
    465e:	87 e0       	ldi	r24, 0x07	; 7
    4660:	90 e0       	ldi	r25, 0x00	; 0
    4662:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    4666:	06 c0       	rjmp	.+12     	; 0x4674 <cmdlineInputFunc+0x5bc>
  }
  else if(c == ASCII_DEL)
  {
    // not yet handled
  }
  else if(c == ASCII_ESC)
    4668:	2b 31       	cpi	r18, 0x1B	; 27
    466a:	21 f4       	brne	.+8      	; 0x4674 <cmdlineInputFunc+0x5bc>
  {
    state->CmdlineInputVT100State = 1;
    466c:	81 e0       	ldi	r24, 0x01	; 1
    466e:	d8 01       	movw	r26, r16
    4670:	52 96       	adiw	r26, 0x12	; 18
    4672:	8c 93       	st	X, r24
  }
}
    4674:	27 96       	adiw	r28, 0x07	; 7
    4676:	0f b6       	in	r0, 0x3f	; 63
    4678:	f8 94       	cli
    467a:	de bf       	out	0x3e, r29	; 62
    467c:	0f be       	out	0x3f, r0	; 63
    467e:	cd bf       	out	0x3d, r28	; 61
    4680:	df 91       	pop	r29
    4682:	cf 91       	pop	r28
    4684:	1f 91       	pop	r17
    4686:	0f 91       	pop	r16
    4688:	ff 90       	pop	r15
    468a:	ef 90       	pop	r14
    468c:	df 90       	pop	r13
    468e:	cf 90       	pop	r12
    4690:	bf 90       	pop	r11
    4692:	af 90       	pop	r10
    4694:	08 95       	ret

00004696 <cmdLineGetLastArgIdx>:
  fputc('\n'        , state->myStdInOut);
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
    4696:	dc 01       	movw	r26, r24
    4698:	12 96       	adiw	r26, 0x02	; 2
    469a:	ed 91       	ld	r30, X+
    469c:	fc 91       	ld	r31, X
    469e:	13 97       	sbiw	r26, 0x03	; 3
  uint8_t result = 0;
  uint8_t lastWhite = 1;
    46a0:	91 e0       	ldi	r25, 0x01	; 1
}


uint8_t cmdLineGetLastArgIdx(cmdState_t *state)
{
  uint8_t result = 0;
    46a2:	80 e0       	ldi	r24, 0x00	; 0
  uint8_t lastWhite = 1;
  char *str = state->CmdlineExcBuffer;
  while(*str != 0)
    46a4:	21 91       	ld	r18, Z+
    46a6:	22 23       	and	r18, r18
    46a8:	51 f0       	breq	.+20     	; 0x46be <cmdLineGetLastArgIdx+0x28>
  {
    if (*str == ' ')
    46aa:	20 32       	cpi	r18, 0x20	; 32
    46ac:	21 f4       	brne	.+8      	; 0x46b6 <cmdLineGetLastArgIdx+0x20>
    {
      if (lastWhite == 0)
    46ae:	91 11       	cpse	r25, r1
    46b0:	04 c0       	rjmp	.+8      	; 0x46ba <cmdLineGetLastArgIdx+0x24>
        result++;
    46b2:	8f 5f       	subi	r24, 0xFF	; 255
    46b4:	02 c0       	rjmp	.+4      	; 0x46ba <cmdLineGetLastArgIdx+0x24>
      lastWhite = 1;
    }
    else
      lastWhite = 0;
    46b6:	90 e0       	ldi	r25, 0x00	; 0
    46b8:	f5 cf       	rjmp	.-22     	; 0x46a4 <cmdLineGetLastArgIdx+0xe>
  {
    if (*str == ' ')
    {
      if (lastWhite == 0)
        result++;
      lastWhite = 1;
    46ba:	91 e0       	ldi	r25, 0x01	; 1
    46bc:	f3 cf       	rjmp	.-26     	; 0x46a4 <cmdLineGetLastArgIdx+0xe>
    else
      lastWhite = 0;
    str++;
  }
  return result;
}
    46be:	08 95       	ret

000046c0 <cmdlineMainLoop>:
  cmdlinePrintError(state);                                           // output an error message
  cmdlinePrintPrompt(state);                                          // output a new prompt
}

void cmdlineMainLoop(cmdState_t *state)
{
    46c0:	0f 93       	push	r16
    46c2:	1f 93       	push	r17
    46c4:	cf 93       	push	r28
    46c6:	df 93       	push	r29
  cliExRes_t result;
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
    46c8:	fc 01       	movw	r30, r24
    46ca:	07 89       	ldd	r16, Z+23	; 0x17
    46cc:	10 8d       	ldd	r17, Z+24	; 0x18
    46ce:	01 15       	cp	r16, r1
    46d0:	11 05       	cpc	r17, r1
    46d2:	09 f4       	brne	.+2      	; 0x46d6 <cmdlineMainLoop+0x16>
    46d4:	71 c0       	rjmp	.+226    	; 0x47b8 <cmdlineMainLoop+0xf8>
    46d6:	ec 01       	movw	r28, r24
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    46d8:	0e 94 4b 23 	call	0x4696	; 0x4696 <cmdLineGetLastArgIdx>
    46dc:	89 8f       	std	Y+25, r24	; 0x19
    result = state->CmdlineExecFunction(state); // run it
    46de:	ce 01       	movw	r24, r28
    46e0:	f8 01       	movw	r30, r16
    46e2:	09 95       	icall

    switch(result)
    46e4:	82 30       	cpi	r24, 0x02	; 2
    46e6:	91 05       	cpc	r25, r1
    46e8:	89 f0       	breq	.+34     	; 0x470c <cmdlineMainLoop+0x4c>
    46ea:	30 f4       	brcc	.+12     	; 0x46f8 <cmdlineMainLoop+0x38>
    46ec:	01 97       	sbiw	r24, 0x01	; 1
    46ee:	09 f0       	breq	.+2      	; 0x46f2 <cmdlineMainLoop+0x32>
    46f0:	56 c0       	rjmp	.+172    	; 0x479e <cmdlineMainLoop+0xde>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
    46f2:	81 ee       	ldi	r24, 0xE1	; 225
    46f4:	9b e0       	ldi	r25, 0x0B	; 11
    46f6:	47 c0       	rjmp	.+142    	; 0x4786 <cmdlineMainLoop+0xc6>
  if(state->CmdlineExecFunction)                // do we have a command/function to be executed
  {
    state->argc = cmdLineGetLastArgIdx(state);  // get number of arguments
    result = state->CmdlineExecFunction(state); // run it

    switch(result)
    46f8:	84 30       	cpi	r24, 0x04	; 4
    46fa:	91 05       	cpc	r25, r1
    46fc:	09 f4       	brne	.+2      	; 0x4700 <cmdlineMainLoop+0x40>
    46fe:	41 c0       	rjmp	.+130    	; 0x4782 <cmdlineMainLoop+0xc2>
    4700:	05 97       	sbiw	r24, 0x05	; 5
    4702:	09 f0       	breq	.+2      	; 0x4706 <cmdlineMainLoop+0x46>
    4704:	4c c0       	rjmp	.+152    	; 0x479e <cmdlineMainLoop+0xde>
        break;
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    4706:	8d e9       	ldi	r24, 0x9D	; 157
    4708:	9b e0       	ldi	r25, 0x0B	; 11
    470a:	3d c0       	rjmp	.+122    	; 0x4786 <cmdlineMainLoop+0xc6>
    {
      case OK_INFORM:
        fprintf_P(state->myStdInOut, PSTR("OK\r\n"));
        break;
      case SYNTAX_ERROR:
        fprintf_P(state->myStdInOut, PSTR("Syntax Error. Use: "));
    470c:	8d ec       	ldi	r24, 0xCD	; 205
    470e:	9b e0       	ldi	r25, 0x0B	; 11
    4710:	9f 93       	push	r25
    4712:	8f 93       	push	r24
    4714:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4716:	8f 93       	push	r24
    4718:	8a 8d       	ldd	r24, Y+26	; 0x1a
    471a:	8f 93       	push	r24
    471c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_str);
    4720:	8c 89       	ldd	r24, Y+20	; 0x14
    4722:	8f 93       	push	r24
    4724:	8b 89       	ldd	r24, Y+19	; 0x13
    4726:	8f 93       	push	r24
    4728:	8b 8d       	ldd	r24, Y+27	; 0x1b
    472a:	8f 93       	push	r24
    472c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    472e:	8f 93       	push	r24
    4730:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR(" "));
    4734:	8b ec       	ldi	r24, 0xCB	; 203
    4736:	9b e0       	ldi	r25, 0x0B	; 11
    4738:	9f 93       	push	r25
    473a:	8f 93       	push	r24
    473c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    473e:	8f 93       	push	r24
    4740:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4742:	8f 93       	push	r24
    4744:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
        fprintf_P(state->myStdInOut, state->command_help_str);
    4748:	8e 89       	ldd	r24, Y+22	; 0x16
    474a:	8f 93       	push	r24
    474c:	8d 89       	ldd	r24, Y+21	; 0x15
    474e:	8f 93       	push	r24
    4750:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4752:	8f 93       	push	r24
    4754:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4756:	8f 93       	push	r24
    4758:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
        fprintf_P(state->myStdInOut, PSTR("\r\n"));
    475c:	88 ec       	ldi	r24, 0xC8	; 200
    475e:	9b e0       	ldi	r25, 0x0B	; 11
    4760:	9f 93       	push	r25
    4762:	8f 93       	push	r24
    4764:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4766:	8f 93       	push	r24
    4768:	8a 8d       	ldd	r24, Y+26	; 0x1a
    476a:	8f 93       	push	r24
    476c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
        break;
    4770:	8d b7       	in	r24, 0x3d	; 61
    4772:	9e b7       	in	r25, 0x3e	; 62
    4774:	44 96       	adiw	r24, 0x14	; 20
    4776:	0f b6       	in	r0, 0x3f	; 63
    4778:	f8 94       	cli
    477a:	9e bf       	out	0x3e, r25	; 62
    477c:	0f be       	out	0x3f, r0	; 63
    477e:	8d bf       	out	0x3d, r24	; 61
    4780:	0e c0       	rjmp	.+28     	; 0x479e <cmdlineMainLoop+0xde>
      case ERROR_INFORM:
        fprintf_P(state->myStdInOut, PSTR("Operation failed\r\n"));
    4782:	85 eb       	ldi	r24, 0xB5	; 181
    4784:	9b e0       	ldi	r25, 0x0B	; 11
        break;
      case ERROR_OPERATION_NOT_ALLOWED:
        fprintf_P(state->myStdInOut, PSTR("Operation not allowed\r\n"));
    4786:	9f 93       	push	r25
    4788:	8f 93       	push	r24
    478a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    478c:	8f 93       	push	r24
    478e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4790:	8f 93       	push	r24
    4792:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
        break;
    4796:	0f 90       	pop	r0
    4798:	0f 90       	pop	r0
    479a:	0f 90       	pop	r0
    479c:	0f 90       	pop	r0
      default:
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    479e:	18 8e       	std	Y+24, r1	; 0x18
    47a0:	1f 8a       	std	Y+23, r1	; 0x17
    state->command_str         = NULL;
    47a2:	1c 8a       	std	Y+20, r1	; 0x14
    47a4:	1b 8a       	std	Y+19, r1	; 0x13
    state->command_help_str    = NULL;
    47a6:	1e 8a       	std	Y+22, r1	; 0x16
    47a8:	1d 8a       	std	Y+21, r1	; 0x15
    cmdlinePrintPrompt(state);                  // output new prompt
    47aa:	ce 01       	movw	r24, r28
  }
}
    47ac:	df 91       	pop	r29
    47ae:	cf 91       	pop	r28
    47b0:	1f 91       	pop	r17
    47b2:	0f 91       	pop	r16
        break;
    }
    state->CmdlineExecFunction = NULL;          // reset
    state->command_str         = NULL;
    state->command_help_str    = NULL;
    cmdlinePrintPrompt(state);                  // output new prompt
    47b4:	0c 94 90 1f 	jmp	0x3f20	; 0x3f20 <cmdlinePrintPrompt>
  }
}
    47b8:	df 91       	pop	r29
    47ba:	cf 91       	pop	r28
    47bc:	1f 91       	pop	r17
    47be:	0f 91       	pop	r16
    47c0:	08 95       	ret

000047c2 <cmdlineGetArgStr>:
  // find the offset of argument number [argnum]
  uint8_t idx=0;
  uint8_t arg;

  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    47c2:	fb 01       	movw	r30, r22
    47c4:	22 81       	ldd	r18, Z+2	; 0x02
    47c6:	33 81       	ldd	r19, Z+3	; 0x03
}

char* cmdlineGetArgStr(uint8_t argnum, cmdState_t *state)
{
  // find the offset of argument number [argnum]
  uint8_t idx=0;
    47c8:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t arg;

  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    47ca:	f9 01       	movw	r30, r18
    47cc:	e9 0f       	add	r30, r25
    47ce:	f1 1d       	adc	r31, r1
    47d0:	40 81       	ld	r20, Z
    47d2:	40 32       	cpi	r20, 0x20	; 32
    47d4:	11 f4       	brne	.+4      	; 0x47da <cmdlineGetArgStr+0x18>
    47d6:	9f 5f       	subi	r25, 0xFF	; 255
    47d8:	f8 cf       	rjmp	.-16     	; 0x47ca <cmdlineGetArgStr+0x8>
    47da:	40 e0       	ldi	r20, 0x00	; 0

  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    47dc:	48 17       	cp	r20, r24
    47de:	91 f0       	breq	.+36     	; 0x4804 <cmdlineGetArgStr+0x42>
  {
    // find the next whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] != ' ')) idx++;
    47e0:	f9 01       	movw	r30, r18
    47e2:	e9 0f       	add	r30, r25
    47e4:	f1 1d       	adc	r31, r1
    47e6:	50 81       	ld	r21, Z
    47e8:	5f 7d       	andi	r21, 0xDF	; 223
    47ea:	11 f0       	breq	.+4      	; 0x47f0 <cmdlineGetArgStr+0x2e>
    47ec:	9f 5f       	subi	r25, 0xFF	; 255
    47ee:	f8 cf       	rjmp	.-16     	; 0x47e0 <cmdlineGetArgStr+0x1e>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
    47f0:	f9 01       	movw	r30, r18
    47f2:	e9 0f       	add	r30, r25
    47f4:	f1 1d       	adc	r31, r1
    47f6:	50 81       	ld	r21, Z
    47f8:	50 32       	cpi	r21, 0x20	; 32
    47fa:	11 f4       	brne	.+4      	; 0x4800 <cmdlineGetArgStr+0x3e>
    47fc:	9f 5f       	subi	r25, 0xFF	; 255
    47fe:	f8 cf       	rjmp	.-16     	; 0x47f0 <cmdlineGetArgStr+0x2e>

  // find the first non-whitespace character
  while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;

  // we are at the first argument
  for(arg=0; arg<argnum; arg++)
    4800:	4f 5f       	subi	r20, 0xFF	; 255
    4802:	ec cf       	rjmp	.-40     	; 0x47dc <cmdlineGetArgStr+0x1a>
    // find the first non-whitespace character
    while( (state->CmdlineExcBuffer[idx] != 0) && (state->CmdlineExcBuffer[idx] == ' ')) idx++;
  }
  // we are at the requested argument or the end of the buffer
  return &state->CmdlineExcBuffer[idx];
}
    4804:	a9 01       	movw	r20, r18
    4806:	49 0f       	add	r20, r25
    4808:	51 1d       	adc	r21, r1
    480a:	ca 01       	movw	r24, r20
    480c:	08 95       	ret

0000480e <cmdlineGetArgInt>:

// return argument [argnum] interpreted as a decimal integer
long cmdlineGetArgInt(uint8_t argnum, cmdState_t *state)
{
    480e:	cf 93       	push	r28
    4810:	df 93       	push	r29
    4812:	00 d0       	rcall	.+0      	; 0x4814 <cmdlineGetArgInt+0x6>
    4814:	cd b7       	in	r28, 0x3d	; 61
    4816:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 10);
    4818:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    481c:	4a e0       	ldi	r20, 0x0A	; 10
    481e:	50 e0       	ldi	r21, 0x00	; 0
    4820:	be 01       	movw	r22, r28
    4822:	6f 5f       	subi	r22, 0xFF	; 255
    4824:	7f 4f       	sbci	r23, 0xFF	; 255
    4826:	0e 94 2b 4e 	call	0x9c56	; 0x9c56 <strtol>
}
    482a:	0f 90       	pop	r0
    482c:	0f 90       	pop	r0
    482e:	df 91       	pop	r29
    4830:	cf 91       	pop	r28
    4832:	08 95       	ret

00004834 <cmdlineGetArgHex>:

// return argument [argnum] interpreted as a hex integer
long cmdlineGetArgHex(uint8_t argnum, cmdState_t *state)
{
    4834:	cf 93       	push	r28
    4836:	df 93       	push	r29
    4838:	00 d0       	rcall	.+0      	; 0x483a <cmdlineGetArgHex+0x6>
    483a:	cd b7       	in	r28, 0x3d	; 61
    483c:	de b7       	in	r29, 0x3e	; 62
  char* endptr;
  return strtol(cmdlineGetArgStr(argnum, state), &endptr, 16);
    483e:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <cmdlineGetArgStr>
    4842:	40 e1       	ldi	r20, 0x10	; 16
    4844:	50 e0       	ldi	r21, 0x00	; 0
    4846:	be 01       	movw	r22, r28
    4848:	6f 5f       	subi	r22, 0xFF	; 255
    484a:	7f 4f       	sbci	r23, 0xFF	; 255
    484c:	0e 94 2b 4e 	call	0x9c56	; 0x9c56 <strtol>
}
    4850:	0f 90       	pop	r0
    4852:	0f 90       	pop	r0
    4854:	df 91       	pop	r29
    4856:	cf 91       	pop	r28
    4858:	08 95       	ret

0000485a <cmdPrintHelp>:

void cmdPrintHelp(cmdState_t *state)
{
    485a:	af 92       	push	r10
    485c:	bf 92       	push	r11
    485e:	cf 92       	push	r12
    4860:	df 92       	push	r13
    4862:	ef 92       	push	r14
    4864:	ff 92       	push	r15
    4866:	0f 93       	push	r16
    4868:	1f 93       	push	r17
    486a:	cf 93       	push	r28
    486c:	df 93       	push	r29
    486e:	00 d0       	rcall	.+0      	; 0x4870 <cmdPrintHelp+0x16>
    4870:	00 d0       	rcall	.+0      	; 0x4872 <cmdPrintHelp+0x18>
    4872:	00 d0       	rcall	.+0      	; 0x4874 <cmdPrintHelp+0x1a>
    4874:	cd b7       	in	r28, 0x3d	; 61
    4876:	de b7       	in	r29, 0x3e	; 62
    4878:	8c 01       	movw	r16, r24
  command_t  tmp;
  const command_t *tmpPtr = state->cmdList;
    487a:	fc 01       	movw	r30, r24
    487c:	e1 a0       	ldd	r14, Z+33	; 0x21
    487e:	f2 a0       	ldd	r15, Z+34	; 0x22

  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    4880:	46 e0       	ldi	r20, 0x06	; 6
    4882:	50 e0       	ldi	r21, 0x00	; 0
    4884:	b7 01       	movw	r22, r14
    4886:	ce 01       	movw	r24, r28
    4888:	01 96       	adiw	r24, 0x01	; 1
    488a:	0e 94 5f 4f 	call	0x9ebe	; 0x9ebe <memcpy_P>
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    fprintf_P(state->myStdInOut, PSTR("\t"));
    488e:	8b e9       	ldi	r24, 0x9B	; 155
    4890:	a8 2e       	mov	r10, r24
    4892:	8b e0       	ldi	r24, 0x0B	; 11
    4894:	b8 2e       	mov	r11, r24
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    4896:	98 e9       	ldi	r25, 0x98	; 152
    4898:	c9 2e       	mov	r12, r25
    489a:	9b e0       	ldi	r25, 0x0B	; 11
    489c:	d9 2e       	mov	r13, r25
  const command_t *tmpPtr = state->cmdList;

  memcpy_P(&tmp, tmpPtr, sizeof(command_t));
  do
  {
    fprintf_P(state->myStdInOut, tmp.commandStr);
    489e:	8a 81       	ldd	r24, Y+2	; 0x02
    48a0:	8f 93       	push	r24
    48a2:	89 81       	ldd	r24, Y+1	; 0x01
    48a4:	8f 93       	push	r24
    48a6:	f8 01       	movw	r30, r16
    48a8:	83 8d       	ldd	r24, Z+27	; 0x1b
    48aa:	8f 93       	push	r24
    48ac:	82 8d       	ldd	r24, Z+26	; 0x1a
    48ae:	8f 93       	push	r24
    48b0:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\t"));
    48b4:	bf 92       	push	r11
    48b6:	af 92       	push	r10
    48b8:	f8 01       	movw	r30, r16
    48ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    48bc:	8f 93       	push	r24
    48be:	82 8d       	ldd	r24, Z+26	; 0x1a
    48c0:	8f 93       	push	r24
    48c2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    fprintf_P(state->myStdInOut, tmp.commandHelpStr);
    48c6:	8c 81       	ldd	r24, Y+4	; 0x04
    48c8:	8f 93       	push	r24
    48ca:	8b 81       	ldd	r24, Y+3	; 0x03
    48cc:	8f 93       	push	r24
    48ce:	f8 01       	movw	r30, r16
    48d0:	83 8d       	ldd	r24, Z+27	; 0x1b
    48d2:	8f 93       	push	r24
    48d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    48d6:	8f 93       	push	r24
    48d8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    fprintf_P(state->myStdInOut, PSTR("\r\n"));
    48dc:	df 92       	push	r13
    48de:	cf 92       	push	r12
    48e0:	f8 01       	movw	r30, r16
    48e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    48e4:	8f 93       	push	r24
    48e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    48e8:	8f 93       	push	r24
    48ea:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

    tmpPtr++;
    48ee:	f6 e0       	ldi	r31, 0x06	; 6
    48f0:	ef 0e       	add	r14, r31
    48f2:	f1 1c       	adc	r15, r1
    memcpy_P(&tmp, tmpPtr, sizeof(command_t));
    48f4:	46 e0       	ldi	r20, 0x06	; 6
    48f6:	50 e0       	ldi	r21, 0x00	; 0
    48f8:	b7 01       	movw	r22, r14
    48fa:	ce 01       	movw	r24, r28
    48fc:	01 96       	adiw	r24, 0x01	; 1
    48fe:	0e 94 5f 4f 	call	0x9ebe	; 0x9ebe <memcpy_P>
  }
  while (tmp.commandFun != NULL);
    4902:	0f b6       	in	r0, 0x3f	; 63
    4904:	f8 94       	cli
    4906:	de bf       	out	0x3e, r29	; 62
    4908:	0f be       	out	0x3f, r0	; 63
    490a:	cd bf       	out	0x3d, r28	; 61
    490c:	8d 81       	ldd	r24, Y+5	; 0x05
    490e:	9e 81       	ldd	r25, Y+6	; 0x06
    4910:	89 2b       	or	r24, r25
    4912:	29 f6       	brne	.-118    	; 0x489e <cmdPrintHelp+0x44>
}
    4914:	26 96       	adiw	r28, 0x06	; 6
    4916:	0f b6       	in	r0, 0x3f	; 63
    4918:	f8 94       	cli
    491a:	de bf       	out	0x3e, r29	; 62
    491c:	0f be       	out	0x3f, r0	; 63
    491e:	cd bf       	out	0x3d, r28	; 61
    4920:	df 91       	pop	r29
    4922:	cf 91       	pop	r28
    4924:	1f 91       	pop	r17
    4926:	0f 91       	pop	r16
    4928:	ff 90       	pop	r15
    492a:	ef 90       	pop	r14
    492c:	df 90       	pop	r13
    492e:	cf 90       	pop	r12
    4930:	bf 90       	pop	r11
    4932:	af 90       	pop	r10
    4934:	08 95       	ret

00004936 <vt100Init>:
void vt100Init(cmdState_t *state)
{
  // initializes terminal to "power-on" settings
  // ESC c

 fprintf_P(state->myStdInOut, "\x1B\x63");
    4936:	2d e2       	ldi	r18, 0x2D	; 45
    4938:	31 e0       	ldi	r19, 0x01	; 1
    493a:	3f 93       	push	r19
    493c:	2f 93       	push	r18
    493e:	fc 01       	movw	r30, r24
    4940:	23 8d       	ldd	r18, Z+27	; 0x1b
    4942:	2f 93       	push	r18
    4944:	82 8d       	ldd	r24, Z+26	; 0x1a
    4946:	8f 93       	push	r24
    4948:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    494c:	0f 90       	pop	r0
    494e:	0f 90       	pop	r0
    4950:	0f 90       	pop	r0
    4952:	0f 90       	pop	r0
    4954:	08 95       	ret

00004956 <vt100ClearScreen>:
}

void vt100ClearScreen(cmdState_t *state)
{
  // ESC [ 2 J
  fprintf_P(state->myStdInOut, "\x1B[2J");
    4956:	20 e3       	ldi	r18, 0x30	; 48
    4958:	31 e0       	ldi	r19, 0x01	; 1
    495a:	3f 93       	push	r19
    495c:	2f 93       	push	r18
    495e:	fc 01       	movw	r30, r24
    4960:	23 8d       	ldd	r18, Z+27	; 0x1b
    4962:	2f 93       	push	r18
    4964:	82 8d       	ldd	r24, Z+26	; 0x1a
    4966:	8f 93       	push	r24
    4968:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    496c:	0f 90       	pop	r0
    496e:	0f 90       	pop	r0
    4970:	0f 90       	pop	r0
    4972:	0f 90       	pop	r0
    4974:	08 95       	ret

00004976 <vt100SetAttr>:
}

void vt100SetAttr(uint8_t attr, cmdState_t *state)
{
  // ESC [ Ps m
  fprintf_P(state->myStdInOut, "\x1B[%dm",attr);
    4976:	1f 92       	push	r1
    4978:	8f 93       	push	r24
    497a:	85 e3       	ldi	r24, 0x35	; 53
    497c:	91 e0       	ldi	r25, 0x01	; 1
    497e:	9f 93       	push	r25
    4980:	8f 93       	push	r24
    4982:	fb 01       	movw	r30, r22
    4984:	83 8d       	ldd	r24, Z+27	; 0x1b
    4986:	8f 93       	push	r24
    4988:	82 8d       	ldd	r24, Z+26	; 0x1a
    498a:	8f 93       	push	r24
    498c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    4990:	0f 90       	pop	r0
    4992:	0f 90       	pop	r0
    4994:	0f 90       	pop	r0
    4996:	0f 90       	pop	r0
    4998:	0f 90       	pop	r0
    499a:	0f 90       	pop	r0
    499c:	08 95       	ret

0000499e <vt100SetCursorMode>:
}

void vt100SetCursorMode(uint8_t visible, cmdState_t *state)
{
    499e:	fb 01       	movw	r30, r22
    49a0:	23 8d       	ldd	r18, Z+27	; 0x1b
    49a2:	92 8d       	ldd	r25, Z+26	; 0x1a
  if(visible)
    49a4:	88 23       	and	r24, r24
    49a6:	19 f0       	breq	.+6      	; 0x49ae <vt100SetCursorMode+0x10>
  // ESC [ ? 25 h
    fprintf_P(state->myStdInOut, "\x1B[?25h");
    49a8:	4b e3       	ldi	r20, 0x3B	; 59
    49aa:	51 e0       	ldi	r21, 0x01	; 1
    49ac:	02 c0       	rjmp	.+4      	; 0x49b2 <vt100SetCursorMode+0x14>
  else
  // ESC [ ? 25 l
    fprintf_P(state->myStdInOut, "\x1B[?25l");
    49ae:	42 e4       	ldi	r20, 0x42	; 66
    49b0:	51 e0       	ldi	r21, 0x01	; 1
    49b2:	5f 93       	push	r21
    49b4:	4f 93       	push	r20
    49b6:	2f 93       	push	r18
    49b8:	9f 93       	push	r25
    49ba:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    49be:	0f 90       	pop	r0
    49c0:	0f 90       	pop	r0
    49c2:	0f 90       	pop	r0
    49c4:	0f 90       	pop	r0
    49c6:	08 95       	ret

000049c8 <vt100SetCursorPos>:
}

void vt100SetCursorPos(uint8_t line, uint8_t col, cmdState_t *state)
{
  // ESC [ Pl ; Pc H
  fprintf_P(state->myStdInOut, "\x1B[%d;%dH",line,col);
    49c8:	1f 92       	push	r1
    49ca:	6f 93       	push	r22
    49cc:	1f 92       	push	r1
    49ce:	8f 93       	push	r24
    49d0:	89 e4       	ldi	r24, 0x49	; 73
    49d2:	91 e0       	ldi	r25, 0x01	; 1
    49d4:	9f 93       	push	r25
    49d6:	8f 93       	push	r24
    49d8:	fa 01       	movw	r30, r20
    49da:	83 8d       	ldd	r24, Z+27	; 0x1b
    49dc:	8f 93       	push	r24
    49de:	82 8d       	ldd	r24, Z+26	; 0x1a
    49e0:	8f 93       	push	r24
    49e2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    49e6:	8d b7       	in	r24, 0x3d	; 61
    49e8:	9e b7       	in	r25, 0x3e	; 62
    49ea:	08 96       	adiw	r24, 0x08	; 8
    49ec:	0f b6       	in	r0, 0x3f	; 63
    49ee:	f8 94       	cli
    49f0:	9e bf       	out	0x3e, r25	; 62
    49f2:	0f be       	out	0x3f, r0	; 63
    49f4:	8d bf       	out	0x3d, r24	; 61
    49f6:	08 95       	ret
    49f8:	08 95       	ret
    49fa:	08 95       	ret

000049fc <readTimeBCD>:
void spiEnableDS1305(void)  {};
void spiDisableDS1305(void) {};


void readTimeBCD(timeBCD_t *time)
{
    49fc:	0f 93       	push	r16
    49fe:	1f 93       	push	r17
    4a00:	cf 93       	push	r28
    4a02:	8c 01       	movw	r16, r24
  spiTake();
    4a04:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  spiEnableDS1305();
    4a08:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);
    4a0c:	80 e0       	ldi	r24, 0x00	; 0
    4a0e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>

  for (i=0; i<sizeof(timeBCD_t); i++)
    4a12:	c0 e0       	ldi	r28, 0x00	; 0
  {
    *ptr = spiSend(i);
    4a14:	8c 2f       	mov	r24, r28
    4a16:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4a1a:	f8 01       	movw	r30, r16
    4a1c:	81 93       	st	Z+, r24
    4a1e:	8f 01       	movw	r16, r30
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  
  spiSend(0x00);

  for (i=0; i<sizeof(timeBCD_t); i++)
    4a20:	cf 5f       	subi	r28, 0xFF	; 255
    4a22:	c7 30       	cpi	r28, 0x07	; 7
    4a24:	b9 f7       	brne	.-18     	; 0x4a14 <readTimeBCD+0x18>
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
    4a26:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <spiDisableDS1305>
  spiGive();
}
    4a2a:	cf 91       	pop	r28
    4a2c:	1f 91       	pop	r17
    4a2e:	0f 91       	pop	r16
  {
    *ptr = spiSend(i);
    ptr++;
  }  
  spiDisableDS1305();  
  spiGive();
    4a30:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004a34 <readTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void readTimeDecoded(timeDecoded_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4a34:	0c 94 fe 24 	jmp	0x49fc	; 0x49fc <readTimeBCD>

00004a38 <readTime>:
}
void readTime (time_t *time)
{
  readTimeBCD((timeBCD_t *)(time));
    4a38:	0c 94 fe 24 	jmp	0x49fc	; 0x49fc <readTimeBCD>

00004a3c <setTimeBCD>:
}
#endif /* USE_DECODED_TIME_STRUCT */


void setTimeBCD(timeBCD_t *time)
{
    4a3c:	0f 93       	push	r16
    4a3e:	1f 93       	push	r17
    4a40:	cf 93       	push	r28
    4a42:	df 93       	push	r29
    4a44:	ec 01       	movw	r28, r24
  spiTake();
    4a46:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  spiEnableDS1305();
    4a4a:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <spiEnableDS1305>
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
    4a4e:	80 e8       	ldi	r24, 0x80	; 128
    4a50:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4a54:	8e 01       	movw	r16, r28
    4a56:	09 5f       	subi	r16, 0xF9	; 249
    4a58:	1f 4f       	sbci	r17, 0xFF	; 255
  for (i=0; i<sizeof(timeBCD_t); i++)
  {
    spiSend(*ptr);
    4a5a:	89 91       	ld	r24, Y+
    4a5c:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiEnableDS1305();
  
  uint8_t *ptr = (uint8_t *)(time);
  uint8_t i;
  spiSend(0x80);
  for (i=0; i<sizeof(timeBCD_t); i++)
    4a60:	c0 17       	cp	r28, r16
    4a62:	d1 07       	cpc	r29, r17
    4a64:	d1 f7       	brne	.-12     	; 0x4a5a <setTimeBCD+0x1e>
  {
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
    4a66:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <spiDisableDS1305>
  spiGive();
}
    4a6a:	df 91       	pop	r29
    4a6c:	cf 91       	pop	r28
    4a6e:	1f 91       	pop	r17
    4a70:	0f 91       	pop	r16
    spiSend(*ptr);
    ptr++;
  }  
  
  spiDisableDS1305();  
  spiGive();
    4a72:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004a76 <setTimeDecoded>:
}

#if USE_DECODED_TIME_STRUCT
void setTimeDecoded(timeDecoded_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    4a76:	0c 94 1e 25 	jmp	0x4a3c	; 0x4a3c <setTimeBCD>

00004a7a <setTime>:
}
void setTime(time_t *time)
{
  setTimeBCD((timeBCD_t *)(time));
    4a7a:	0c 94 1e 25 	jmp	0x4a3c	; 0x4a3c <setTimeBCD>

00004a7e <ds1305start>:
}
#endif /* USE_DECODED_TIME_STRUCT */

void ds1305start(void)
{  
  spiTake();
    4a7e:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  spiEnableDS1305();
    4a82:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <spiEnableDS1305>

  spiSend(0x8F);
    4a86:	8f e8       	ldi	r24, 0x8F	; 143
    4a88:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(0x00);
    4a8c:	80 e0       	ldi	r24, 0x00	; 0
    4a8e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  
  spiDisableDS1305();  
    4a92:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <spiDisableDS1305>
  spiGive();
    4a96:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004a9a <ds1305writeMem>:
  return;
}


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
    4a9a:	ff 92       	push	r15
    4a9c:	0f 93       	push	r16
    4a9e:	1f 93       	push	r17
    4aa0:	cf 93       	push	r28
    4aa2:	df 93       	push	r29
    4aa4:	1f 92       	push	r1
    4aa6:	cd b7       	in	r28, 0x3d	; 61
    4aa8:	de b7       	in	r29, 0x3e	; 62
    4aaa:	f6 2e       	mov	r15, r22
    4aac:	8a 01       	movw	r16, r20
  if (addr > 95)
    4aae:	80 36       	cpi	r24, 0x60	; 96
    4ab0:	f8 f4       	brcc	.+62     	; 0x4af0 <ds1305writeMem+0x56>
    return 1;
  if (addr + length > 95)
    4ab2:	26 2f       	mov	r18, r22
    4ab4:	30 e0       	ldi	r19, 0x00	; 0
    4ab6:	28 0f       	add	r18, r24
    4ab8:	31 1d       	adc	r19, r1
    4aba:	20 36       	cpi	r18, 0x60	; 96
    4abc:	31 05       	cpc	r19, r1
    4abe:	d4 f4       	brge	.+52     	; 0x4af4 <ds1305writeMem+0x5a>
    return 2;

  addr += 0xA0;
  
  spiTake();
    4ac0:	89 83       	std	Y+1, r24	; 0x01
    4ac2:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  spiEnableDS1305();
    4ac6:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <spiEnableDS1305>

  spiSend(addr);
    4aca:	89 81       	ldd	r24, Y+1	; 0x01
    4acc:	80 56       	subi	r24, 0x60	; 96
    4ace:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  while (length > 0)
    4ad2:	ff 20       	and	r15, r15
    4ad4:	39 f0       	breq	.+14     	; 0x4ae4 <ds1305writeMem+0x4a>
  {
    spiSend(*data);
    4ad6:	f8 01       	movw	r30, r16
    4ad8:	81 91       	ld	r24, Z+
    4ada:	8f 01       	movw	r16, r30
    4adc:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    data++;
    length--;
    4ae0:	fa 94       	dec	r15
    4ae2:	f7 cf       	rjmp	.-18     	; 0x4ad2 <ds1305writeMem+0x38>
  }
  
  spiDisableDS1305();  
    4ae4:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <spiDisableDS1305>
  spiGive();
    4ae8:	0e 94 43 1a 	call	0x3486	; 0x3486 <spiGive>
  return 0;
    4aec:	80 e0       	ldi	r24, 0x00	; 0
    4aee:	03 c0       	rjmp	.+6      	; 0x4af6 <ds1305writeMem+0x5c>


uint8_t ds1305writeMem      (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr > 95)
    return 1;
    4af0:	81 e0       	ldi	r24, 0x01	; 1
    4af2:	01 c0       	rjmp	.+2      	; 0x4af6 <ds1305writeMem+0x5c>
  if (addr + length > 95)
    return 2;
    4af4:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    4af6:	0f 90       	pop	r0
    4af8:	df 91       	pop	r29
    4afa:	cf 91       	pop	r28
    4afc:	1f 91       	pop	r17
    4afe:	0f 91       	pop	r16
    4b00:	ff 90       	pop	r15
    4b02:	08 95       	ret

00004b04 <ds1305readMem>:
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
    4b04:	ff 92       	push	r15
    4b06:	0f 93       	push	r16
    4b08:	1f 93       	push	r17
    4b0a:	cf 93       	push	r28
    4b0c:	df 93       	push	r29
    4b0e:	1f 92       	push	r1
    4b10:	cd b7       	in	r28, 0x3d	; 61
    4b12:	de b7       	in	r29, 0x3e	; 62
    4b14:	f6 2e       	mov	r15, r22
    4b16:	8a 01       	movw	r16, r20
  if (addr >95)
    4b18:	80 36       	cpi	r24, 0x60	; 96
    4b1a:	00 f5       	brcc	.+64     	; 0x4b5c <ds1305readMem+0x58>
    return 1;
  if (addr + length > 95)
    4b1c:	26 2f       	mov	r18, r22
    4b1e:	30 e0       	ldi	r19, 0x00	; 0
    4b20:	28 0f       	add	r18, r24
    4b22:	31 1d       	adc	r19, r1
    4b24:	20 36       	cpi	r18, 0x60	; 96
    4b26:	31 05       	cpc	r19, r1
    4b28:	dc f4       	brge	.+54     	; 0x4b60 <ds1305readMem+0x5c>
    return 2;
  
  addr += 0x20;
  
  spiTake();
    4b2a:	89 83       	std	Y+1, r24	; 0x01
    4b2c:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  spiEnableDS1305();
    4b30:	0e 94 53 0f 	call	0x1ea6	; 0x1ea6 <spiEnableDS1305>

  spiSend(addr);
    4b34:	89 81       	ldd	r24, Y+1	; 0x01
    4b36:	80 5e       	subi	r24, 0xE0	; 224
    4b38:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  while (length > 0)
    4b3c:	ff 20       	and	r15, r15
    4b3e:	41 f0       	breq	.+16     	; 0x4b50 <ds1305readMem+0x4c>
  {
    *data = spiSend(0);
    4b40:	80 e0       	ldi	r24, 0x00	; 0
    4b42:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4b46:	f8 01       	movw	r30, r16
    4b48:	81 93       	st	Z+, r24
    4b4a:	8f 01       	movw	r16, r30
    data++;
    length--;
    4b4c:	fa 94       	dec	r15
    4b4e:	f6 cf       	rjmp	.-20     	; 0x4b3c <ds1305readMem+0x38>
  }
  
  spiDisableDS1305();  
    4b50:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <spiDisableDS1305>
  spiGive();
    4b54:	0e 94 43 1a 	call	0x3486	; 0x3486 <spiGive>
  return 0;
    4b58:	80 e0       	ldi	r24, 0x00	; 0
    4b5a:	03 c0       	rjmp	.+6      	; 0x4b62 <ds1305readMem+0x5e>
  return 0;
}
uint8_t ds1305readMem       (uint8_t addr, uint8_t length, uint8_t *data)
{
  if (addr >95)
    return 1;
    4b5c:	81 e0       	ldi	r24, 0x01	; 1
    4b5e:	01 c0       	rjmp	.+2      	; 0x4b62 <ds1305readMem+0x5e>
  if (addr + length > 95)
    return 2;
    4b60:	82 e0       	ldi	r24, 0x02	; 2
  }
  
  spiDisableDS1305();  
  spiGive();
  return 0;
}
    4b62:	0f 90       	pop	r0
    4b64:	df 91       	pop	r29
    4b66:	cf 91       	pop	r28
    4b68:	1f 91       	pop	r17
    4b6a:	0f 91       	pop	r16
    4b6c:	ff 90       	pop	r15
    4b6e:	08 95       	ret
    4b70:	08 95       	ret
    4b72:	08 95       	ret

00004b74 <MPC23s17SetDirA>:
void enableSpiMPC23S17(void)  {}
void disableSpiMPC23S17(void) {}


void MPC23s17SetDirA(uint8_t portAdir, uint8_t addr)
{
    4b74:	cf 93       	push	r28
    4b76:	df 93       	push	r29
    4b78:	d8 2f       	mov	r29, r24
  addr = addr<<1;
    4b7a:	c6 2f       	mov	r28, r22
    4b7c:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4b7e:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    4b80:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17(); 
    4b84:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  spiSend(addr);
    4b88:	8c 2f       	mov	r24, r28
    4b8a:	80 64       	ori	r24, 0x40	; 64
    4b8c:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_IODIRA);
    4b90:	80 e0       	ldi	r24, 0x00	; 0
    4b92:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portAdir);  
    4b96:	8d 2f       	mov	r24, r29
    4b98:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  
  disableSpiMPC23S17();
    4b9c:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4ba0:	df 91       	pop	r29
    4ba2:	cf 91       	pop	r28
  spiSend(addr);
  spiSend(B0_IODIRA);
  spiSend(portAdir);  
  
  disableSpiMPC23S17();
  spiGive();
    4ba4:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004ba8 <MPC23s17SetDirB>:
}

void MPC23s17SetDirB(uint8_t portBdir, uint8_t addr)
{
    4ba8:	cf 93       	push	r28
    4baa:	df 93       	push	r29
    4bac:	d8 2f       	mov	r29, r24
  addr = addr<<1;
    4bae:	c6 2f       	mov	r28, r22
    4bb0:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4bb2:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    4bb4:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4bb8:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  
  spiSend(addr);
    4bbc:	8c 2f       	mov	r24, r28
    4bbe:	80 64       	ori	r24, 0x40	; 64
    4bc0:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_IODIRB);
    4bc4:	81 e0       	ldi	r24, 0x01	; 1
    4bc6:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portBdir);  
    4bca:	8d 2f       	mov	r24, r29
    4bcc:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  
  disableSpiMPC23S17();
    4bd0:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4bd4:	df 91       	pop	r29
    4bd6:	cf 91       	pop	r28
  spiSend(addr);
  spiSend(B0_IODIRB);
  spiSend(portBdir);  
  
  disableSpiMPC23S17();
  spiGive();
    4bd8:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004bdc <MPC23s17SetPortA>:
}

void MPC23s17SetPortA(uint8_t portAout, uint8_t addr)
{
    4bdc:	1f 93       	push	r17
    4bde:	cf 93       	push	r28
    4be0:	df 93       	push	r29
    4be2:	1f 92       	push	r1
    4be4:	cd b7       	in	r28, 0x3d	; 61
    4be6:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    4be8:	66 0f       	add	r22, r22
  addr &= 0x0E;
    4bea:	16 2f       	mov	r17, r22
    4bec:	1e 70       	andi	r17, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  spiTake();
    4bee:	89 83       	std	Y+1, r24	; 0x01
    4bf0:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4bf4:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  portA = portAout;  
    4bf8:	89 81       	ldd	r24, Y+1	; 0x01
    4bfa:	80 93 c2 0e 	sts	0x0EC2, r24
  spiSend(addr);
    4bfe:	81 2f       	mov	r24, r17
    4c00:	80 64       	ori	r24, 0x40	; 64
    4c02:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_OLATA);
    4c06:	84 e1       	ldi	r24, 0x14	; 20
    4c08:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portA);  
    4c0c:	80 91 c2 0e 	lds	r24, 0x0EC2
    4c10:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>

  disableSpiMPC23S17();
    4c14:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4c18:	0f 90       	pop	r0
    4c1a:	df 91       	pop	r29
    4c1c:	cf 91       	pop	r28
    4c1e:	1f 91       	pop	r17
  spiSend(addr);
  spiSend(B0_OLATA);
  spiSend(portA);  

  disableSpiMPC23S17();
  spiGive();
    4c20:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004c24 <MPC23s17SetBitsOnPortA>:
}

void MPC23s17SetBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    4c24:	cf 93       	push	r28
  addr = addr<<1;
    4c26:	c6 2f       	mov	r28, r22
    4c28:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4c2a:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA |= portAout;  
    4c2c:	90 91 c2 0e 	lds	r25, 0x0EC2
    4c30:	89 2b       	or	r24, r25
    4c32:	80 93 c2 0e 	sts	0x0EC2, r24

  spiTake();
    4c36:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4c3a:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  spiSend(addr);
    4c3e:	8c 2f       	mov	r24, r28
    4c40:	80 64       	ori	r24, 0x40	; 64
    4c42:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_OLATA);
    4c46:	84 e1       	ldi	r24, 0x14	; 20
    4c48:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portA);  
    4c4c:	80 91 c2 0e 	lds	r24, 0x0EC2
    4c50:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  disableSpiMPC23S17();
    4c54:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4c58:	cf 91       	pop	r28
  enableSpiMPC23S17();
  spiSend(addr);
  spiSend(B0_OLATA);
  spiSend(portA);  
  disableSpiMPC23S17();
  spiGive();
    4c5a:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004c5e <MPC23s17ClearBitsOnPortA>:
}

void MPC23s17ClearBitsOnPortA(uint8_t portAout, uint8_t addr)
{
    4c5e:	cf 93       	push	r28
  addr = addr<<1;
    4c60:	c6 2f       	mov	r28, r22
    4c62:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4c64:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portA &= (~portAout);
    4c66:	90 91 c2 0e 	lds	r25, 0x0EC2
    4c6a:	80 95       	com	r24
    4c6c:	98 23       	and	r25, r24
    4c6e:	90 93 c2 0e 	sts	0x0EC2, r25

  spiTake();
    4c72:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4c76:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  spiSend(addr);
    4c7a:	8c 2f       	mov	r24, r28
    4c7c:	80 64       	ori	r24, 0x40	; 64
    4c7e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_OLATA);
    4c82:	84 e1       	ldi	r24, 0x14	; 20
    4c84:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portA);  
    4c88:	80 91 c2 0e 	lds	r24, 0x0EC2
    4c8c:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  disableSpiMPC23S17();
    4c90:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4c94:	cf 91       	pop	r28
  enableSpiMPC23S17();
  spiSend(addr);
  spiSend(B0_OLATA);
  spiSend(portA);  
  disableSpiMPC23S17();
  spiGive();
    4c96:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004c9a <MPC23s17SetPortB>:
}

void MPC23s17SetPortB(uint8_t portBout, uint8_t addr)
{
    4c9a:	cf 93       	push	r28
  addr = addr<<1;
    4c9c:	c6 2f       	mov	r28, r22
    4c9e:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4ca0:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB = portBout;
    4ca2:	80 93 79 0e 	sts	0x0E79, r24

  spiTake();
    4ca6:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4caa:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  spiSend(addr);
    4cae:	8c 2f       	mov	r24, r28
    4cb0:	80 64       	ori	r24, 0x40	; 64
    4cb2:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_OLATB);
    4cb6:	85 e1       	ldi	r24, 0x15	; 21
    4cb8:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portB);  
    4cbc:	80 91 79 0e 	lds	r24, 0x0E79
    4cc0:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  disableSpiMPC23S17();
    4cc4:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4cc8:	cf 91       	pop	r28
  enableSpiMPC23S17();
  spiSend(addr);
  spiSend(B0_OLATB);
  spiSend(portB);  
  disableSpiMPC23S17();
  spiGive();
    4cca:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004cce <MPC23s17SetBitsOnPortB>:
}

void MPC23s17SetBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    4cce:	cf 93       	push	r28
  addr = addr<<1;
    4cd0:	c6 2f       	mov	r28, r22
    4cd2:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4cd4:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB |= portBout;
    4cd6:	90 91 79 0e 	lds	r25, 0x0E79
    4cda:	89 2b       	or	r24, r25
    4cdc:	80 93 79 0e 	sts	0x0E79, r24

  spiTake();
    4ce0:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4ce4:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  spiSend(addr);
    4ce8:	8c 2f       	mov	r24, r28
    4cea:	80 64       	ori	r24, 0x40	; 64
    4cec:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_OLATB);
    4cf0:	85 e1       	ldi	r24, 0x15	; 21
    4cf2:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portB);  
    4cf6:	80 91 79 0e 	lds	r24, 0x0E79
    4cfa:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  disableSpiMPC23S17();
    4cfe:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4d02:	cf 91       	pop	r28
  enableSpiMPC23S17();
  spiSend(addr);
  spiSend(B0_OLATB);
  spiSend(portB);  
  disableSpiMPC23S17();
  spiGive();
    4d04:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004d08 <MPC23s17ClearBitsOnPortB>:
}

void MPC23s17ClearBitsOnPortB(uint8_t portBout, uint8_t addr)
{
    4d08:	cf 93       	push	r28
  addr = addr<<1;
    4d0a:	c6 2f       	mov	r28, r22
    4d0c:	cc 0f       	add	r28, r28
  addr &= 0x0E;
    4d0e:	ce 70       	andi	r28, 0x0E	; 14
  addr |= 0x40;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 

  portB &= (~portBout);
    4d10:	90 91 79 0e 	lds	r25, 0x0E79
    4d14:	80 95       	com	r24
    4d16:	98 23       	and	r25, r24
    4d18:	90 93 79 0e 	sts	0x0E79, r25

  spiTake();
    4d1c:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4d20:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>
  spiSend(addr);
    4d24:	8c 2f       	mov	r24, r28
    4d26:	80 64       	ori	r24, 0x40	; 64
    4d28:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_OLATB);
    4d2c:	85 e1       	ldi	r24, 0x15	; 21
    4d2e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(portB);  
    4d32:	80 91 79 0e 	lds	r24, 0x0E79
    4d36:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>

  disableSpiMPC23S17();
    4d3a:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
}
    4d3e:	cf 91       	pop	r28
  spiSend(addr);
  spiSend(B0_OLATB);
  spiSend(portB);  

  disableSpiMPC23S17();
  spiGive();
    4d40:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>

00004d44 <MPC23s17ReadPortA>:
}

uint8_t MPC23s17ReadPortA(uint8_t addr)
{
    4d44:	1f 93       	push	r17
    4d46:	cf 93       	push	r28
    4d48:	df 93       	push	r29
    4d4a:	1f 92       	push	r1
    4d4c:	cd b7       	in	r28, 0x3d	; 61
    4d4e:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    4d50:	88 0f       	add	r24, r24
  addr &= 0x0E;
    4d52:	8e 70       	andi	r24, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    4d54:	18 2f       	mov	r17, r24
    4d56:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    4d58:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4d5c:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>

  spiSend(addr);
    4d60:	81 2f       	mov	r24, r17
    4d62:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_GPIOA);
    4d66:	82 e1       	ldi	r24, 0x12	; 18
    4d68:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  uint8_t result = spiSend(addr);  
    4d6c:	81 2f       	mov	r24, r17
    4d6e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>

  disableSpiMPC23S17();
    4d72:	89 83       	std	Y+1, r24	; 0x01
    4d74:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
    4d78:	0e 94 43 1a 	call	0x3486	; 0x3486 <spiGive>

  return result; 
}
    4d7c:	89 81       	ldd	r24, Y+1	; 0x01
    4d7e:	0f 90       	pop	r0
    4d80:	df 91       	pop	r29
    4d82:	cf 91       	pop	r28
    4d84:	1f 91       	pop	r17
    4d86:	08 95       	ret

00004d88 <MPC23s17ReadPortB>:

uint8_t MPC23s17ReadPortB(uint8_t addr)
{
    4d88:	1f 93       	push	r17
    4d8a:	cf 93       	push	r28
    4d8c:	df 93       	push	r29
    4d8e:	1f 92       	push	r1
    4d90:	cd b7       	in	r28, 0x3d	; 61
    4d92:	de b7       	in	r29, 0x3e	; 62
  addr = addr<<1;
    4d94:	88 0f       	add	r24, r24
  addr &= 0x0E;
    4d96:	8e 70       	andi	r24, 0x0E	; 14
  addr |= 0x41;        //OPCODE 0100 AAA 0 bit0: 0 - zapis, 1 - odczyt 
    4d98:	18 2f       	mov	r17, r24
    4d9a:	11 64       	ori	r17, 0x41	; 65

  spiTake();
    4d9c:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMPC23S17();
    4da0:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <enableSpiMPC23S17>

  spiSend(addr);
    4da4:	81 2f       	mov	r24, r17
    4da6:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(B0_GPIOB);
    4daa:	83 e1       	ldi	r24, 0x13	; 19
    4dac:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  uint8_t result = spiSend(addr);  
    4db0:	81 2f       	mov	r24, r17
    4db2:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>

  disableSpiMPC23S17();
    4db6:	89 83       	std	Y+1, r24	; 0x01
    4db8:	0e 94 3d 0f 	call	0x1e7a	; 0x1e7a <disableSpiMPC23S17>
  spiGive();
    4dbc:	0e 94 43 1a 	call	0x3486	; 0x3486 <spiGive>

  return result; 
}
    4dc0:	89 81       	ldd	r24, Y+1	; 0x01
    4dc2:	0f 90       	pop	r0
    4dc4:	df 91       	pop	r29
    4dc6:	cf 91       	pop	r28
    4dc8:	1f 91       	pop	r17
    4dca:	08 95       	ret
    4dcc:	08 95       	ret
    4dce:	08 95       	ret

00004dd0 <MCP3008_getSampleDiff>:
void enableSpiMCP3008(void)   {};
void disableSpiMCP3008(void)  {};


uint16_t MCP3008_getSampleDiff(uint8_t inputNo)
{
    4dd0:	cf 93       	push	r28
    4dd2:	df 93       	push	r29
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    4dd4:	c8 2f       	mov	r28, r24
    4dd6:	c2 95       	swap	r28
    4dd8:	c0 7f       	andi	r28, 0xF0	; 240
  inputNo &= 0x70;
  
  spiTake();
    4dda:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMCP3008();
    4dde:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <enableSpiMCP3008>
  
  spiSend(0x01);                               //Start
    4de2:	81 e0       	ldi	r24, 0x01	; 1
    4de4:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    4de8:	8c 2f       	mov	r24, r28
    4dea:	80 77       	andi	r24, 0x70	; 112
    4dec:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4df0:	d8 2f       	mov	r29, r24
  resultLo = spiSend(0);        //X X X X X X X X
    4df2:	80 e0       	ldi	r24, 0x00	; 0
    4df4:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4df8:	c8 2f       	mov	r28, r24
  
  disableSpiMCP3008(); 
    4dfa:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <disableSpiMCP3008>
  spiGive();
    4dfe:	0e 94 43 1a 	call	0x3486	; 0x3486 <spiGive>
  
  resultHi &= 0x03;
    4e02:	d3 70       	andi	r29, 0x03	; 3
  return resultHi << 8 | resultLo;
    4e04:	8c 2f       	mov	r24, r28
    4e06:	90 e0       	ldi	r25, 0x00	; 0
}
    4e08:	9d 2b       	or	r25, r29
    4e0a:	df 91       	pop	r29
    4e0c:	cf 91       	pop	r28
    4e0e:	08 95       	ret

00004e10 <MCP3008_getSampleSingle>:

uint16_t MCP3008_getSampleSingle(uint8_t inputNo)
{
    4e10:	cf 93       	push	r28
    4e12:	df 93       	push	r29
  uint8_t resultLo;
  uint8_t resultHi;
  inputNo = inputNo << 4;
    4e14:	82 95       	swap	r24
    4e16:	80 7f       	andi	r24, 0xF0	; 240
  inputNo &= 0x70;
    4e18:	c8 2f       	mov	r28, r24
    4e1a:	c0 77       	andi	r28, 0x70	; 112
  inputNo |= 0x80;
  
  spiTake();
    4e1c:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMCP3008();
    4e20:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <enableSpiMCP3008>
  
  spiSend(0x01);                //Start
    4e24:	81 e0       	ldi	r24, 0x01	; 1
    4e26:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  resultHi = spiSend(inputNo);  //DIFF/!SGL A2 A1 A0 X X X X
    4e2a:	8c 2f       	mov	r24, r28
    4e2c:	80 68       	ori	r24, 0x80	; 128
    4e2e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4e32:	d8 2f       	mov	r29, r24
  resultLo = spiSend(0);        //X X X X X X X X
    4e34:	80 e0       	ldi	r24, 0x00	; 0
    4e36:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
    4e3a:	c8 2f       	mov	r28, r24
  
  disableSpiMCP3008(); 
    4e3c:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <disableSpiMCP3008>
  spiGive();
    4e40:	0e 94 43 1a 	call	0x3486	; 0x3486 <spiGive>
  
  resultHi &= 0x03;
    4e44:	d3 70       	andi	r29, 0x03	; 3
  return resultHi << 8 | resultLo;
    4e46:	8c 2f       	mov	r24, r28
    4e48:	90 e0       	ldi	r25, 0x00	; 0
}
    4e4a:	9d 2b       	or	r25, r29
    4e4c:	df 91       	pop	r29
    4e4e:	cf 91       	pop	r28
    4e50:	08 95       	ret
    4e52:	08 95       	ret
    4e54:	08 95       	ret

00004e56 <MCP4150_setValue>:
/**
 * Ustawia wartość rezystancji
 * @param inputNo - WARTOŚĆ OD 0 DO 255.
 */
void MCP4150_setValue(uint8_t value)
{  
    4e56:	cf 93       	push	r28
    4e58:	c8 2f       	mov	r28, r24
  spiTake();
    4e5a:	0e 94 38 1a 	call	0x3470	; 0x3470 <spiTake>
  enableSpiMCP4150();
    4e5e:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <enableSpiMCP4150>
  
  spiSend(0x11);  
    4e62:	81 e1       	ldi	r24, 0x11	; 17
    4e64:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  spiSend(value);
    4e68:	8c 2f       	mov	r24, r28
    4e6a:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <spiSend>
  
  disableSpiMCP4150(); 
    4e6e:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <disableSpiMCP4150>
  spiGive();
}
    4e72:	cf 91       	pop	r28
  
  spiSend(0x11);  
  spiSend(value);
  
  disableSpiMCP4150(); 
  spiGive();
    4e74:	0c 94 43 1a 	jmp	0x3486	; 0x3486 <spiGive>
    4e78:	08 95       	ret
    4e7a:	08 95       	ret

00004e7c <enc28j60WriteOp>:
 // spiGive();
  return result;
}

void enc28j60WriteOp(uint8_t op, uint8_t address, uint8_t data)
{
    4e7c:	cf 93       	push	r28
    4e7e:	df 93       	push	r29
    4e80:	00 d0       	rcall	.+0      	; 0x4e82 <enc28j60WriteOp+0x6>
    4e82:	1f 92       	push	r1
    4e84:	cd b7       	in	r28, 0x3d	; 61
    4e86:	de b7       	in	r29, 0x3e	; 62
 // spiTake();
  spiEnableEnc28j60();
    4e88:	4b 83       	std	Y+3, r20	; 0x03
    4e8a:	6a 83       	std	Y+2, r22	; 0x02
    4e8c:	89 83       	std	Y+1, r24	; 0x01
    4e8e:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <spiEnableEnc28j60>
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSendENC(op | (address & ADDR_MASK));
    4e92:	6a 81       	ldd	r22, Y+2	; 0x02
    4e94:	6f 71       	andi	r22, 0x1F	; 31
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    4e98:	86 2b       	or	r24, r22
    4e9a:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
  spiSendENC(data);
    4e9e:	4b 81       	ldd	r20, Y+3	; 0x03
    4ea0:	84 2f       	mov	r24, r20
    4ea2:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
  spiDisableEnc28j60();
 // spiGive();
}
    4ea6:	0f 90       	pop	r0
    4ea8:	0f 90       	pop	r0
    4eaa:	0f 90       	pop	r0
    4eac:	df 91       	pop	r29
    4eae:	cf 91       	pop	r28
  spiEnableEnc28j60();
  // issue write command
  //spiSend(op | (address & ADDR_MASK));
  spiSendENC(op | (address & ADDR_MASK));
  spiSendENC(data);
  spiDisableEnc28j60();
    4eb0:	0c 94 2d 0f 	jmp	0x1e5a	; 0x1e5a <spiDisableEnc28j60>

00004eb4 <enc28j60SetBank>:
//   spiGive();
// }


void enc28j60SetBank(uint8_t address)
{
    4eb4:	1f 93       	push	r17
    4eb6:	cf 93       	push	r28
    4eb8:	df 93       	push	r29
  // set the bank (if needed)
  if((address & BANK_MASK) != Enc28j60Bank)
    4eba:	18 2f       	mov	r17, r24
    4ebc:	10 76       	andi	r17, 0x60	; 96
    4ebe:	c1 2f       	mov	r28, r17
    4ec0:	d0 e0       	ldi	r29, 0x00	; 0
    4ec2:	20 91 92 01 	lds	r18, 0x0192
    4ec6:	30 e0       	ldi	r19, 0x00	; 0
    4ec8:	c2 17       	cp	r28, r18
    4eca:	d3 07       	cpc	r29, r19
    4ecc:	89 f0       	breq	.+34     	; 0x4ef0 <enc28j60SetBank+0x3c>
  {
    // set the bank
    enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    4ece:	43 e0       	ldi	r20, 0x03	; 3
    4ed0:	6f e1       	ldi	r22, 0x1F	; 31
    4ed2:	80 ea       	ldi	r24, 0xA0	; 160
    4ed4:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
    enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    4ed8:	ae 01       	movw	r20, r28
    4eda:	85 e0       	ldi	r24, 0x05	; 5
    4edc:	55 95       	asr	r21
    4ede:	47 95       	ror	r20
    4ee0:	8a 95       	dec	r24
    4ee2:	e1 f7       	brne	.-8      	; 0x4edc <enc28j60SetBank+0x28>
    4ee4:	6f e1       	ldi	r22, 0x1F	; 31
    4ee6:	80 e8       	ldi	r24, 0x80	; 128
    4ee8:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
    Enc28j60Bank = (address & BANK_MASK);
    4eec:	10 93 92 01 	sts	0x0192, r17
  }
}
    4ef0:	df 91       	pop	r29
    4ef2:	cf 91       	pop	r28
    4ef4:	1f 91       	pop	r17
    4ef6:	08 95       	ret

00004ef8 <enc28j60Write>:

  return (enc28j60Read(MIRDH));
}

void enc28j60Write(uint8_t address, uint8_t data)
{
    4ef8:	1f 93       	push	r17
    4efa:	cf 93       	push	r28
    4efc:	df 93       	push	r29
    4efe:	1f 92       	push	r1
    4f00:	cd b7       	in	r28, 0x3d	; 61
    4f02:	de b7       	in	r29, 0x3e	; 62
    4f04:	18 2f       	mov	r17, r24
  // set the bank
  enc28j60SetBank(address);
    4f06:	69 83       	std	Y+1, r22	; 0x01
    4f08:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <enc28j60SetBank>
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    4f0c:	49 81       	ldd	r20, Y+1	; 0x01
    4f0e:	61 2f       	mov	r22, r17
    4f10:	80 e4       	ldi	r24, 0x40	; 64
}
    4f12:	0f 90       	pop	r0
    4f14:	df 91       	pop	r29
    4f16:	cf 91       	pop	r28
    4f18:	1f 91       	pop	r17
void enc28j60Write(uint8_t address, uint8_t data)
{
  // set the bank
  enc28j60SetBank(address);
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    4f1a:	0c 94 3e 27 	jmp	0x4e7c	; 0x4e7c <enc28j60WriteOp>

00004f1e <enc28j60ReadOp>:
    enc28j60PhyWrite    (PHLCON, 0x476);
    vTaskDelay          (2);
}

uint8_t enc28j60ReadOp(uint8_t op, uint8_t address)
{
    4f1e:	1f 93       	push	r17
    4f20:	cf 93       	push	r28
    4f22:	df 93       	push	r29
    4f24:	1f 92       	push	r1
    4f26:	cd b7       	in	r28, 0x3d	; 61
    4f28:	de b7       	in	r29, 0x3e	; 62
    4f2a:	16 2f       	mov	r17, r22
  uint8_t result;
  //spiTake();
  spiEnableEnc28j60();
    4f2c:	89 83       	std	Y+1, r24	; 0x01
    4f2e:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <spiEnableEnc28j60>

  // issue read command
  spiSendENC(op | (address & ADDR_MASK));
    4f32:	91 2f       	mov	r25, r17
    4f34:	9f 71       	andi	r25, 0x1F	; 31
    4f36:	89 81       	ldd	r24, Y+1	; 0x01
    4f38:	89 2b       	or	r24, r25
    4f3a:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>

  // read data
  result = spiSendENC(0x00);
    4f3e:	80 e0       	ldi	r24, 0x00	; 0
    4f40:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>

  // do dummy read if needed (for mac and mii, see datasheet page 29)
  if(address & 0x80)
    4f44:	17 ff       	sbrs	r17, 7
    4f46:	03 c0       	rjmp	.+6      	; 0x4f4e <enc28j60ReadOp+0x30>
  {
    result = spiSendENC(0x00);
    4f48:	80 e0       	ldi	r24, 0x00	; 0
    4f4a:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
  }

  spiDisableEnc28j60();
    4f4e:	89 83       	std	Y+1, r24	; 0x01
    4f50:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <spiDisableEnc28j60>
 // spiGive();
  return result;
}
    4f54:	89 81       	ldd	r24, Y+1	; 0x01
    4f56:	0f 90       	pop	r0
    4f58:	df 91       	pop	r29
    4f5a:	cf 91       	pop	r28
    4f5c:	1f 91       	pop	r17
    4f5e:	08 95       	ret

00004f60 <enc28j60Read>:
    Enc28j60Bank = (address & BANK_MASK);
  }
}

uint8_t enc28j60Read(uint8_t address)
{
    4f60:	cf 93       	push	r28
    4f62:	df 93       	push	r29
    4f64:	1f 92       	push	r1
    4f66:	cd b7       	in	r28, 0x3d	; 61
    4f68:	de b7       	in	r29, 0x3e	; 62
    4f6a:	68 2f       	mov	r22, r24
  // set the bank
  enc28j60SetBank(address);
    4f6c:	69 83       	std	Y+1, r22	; 0x01
    4f6e:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <enc28j60SetBank>
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    4f72:	69 81       	ldd	r22, Y+1	; 0x01
    4f74:	80 e0       	ldi	r24, 0x00	; 0
  return result;
}
    4f76:	0f 90       	pop	r0
    4f78:	df 91       	pop	r29
    4f7a:	cf 91       	pop	r28
uint8_t enc28j60Read(uint8_t address)
{
  // set the bank
  enc28j60SetBank(address);
  // do the read
  uint8_t result = enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    4f7c:	0c 94 8f 27 	jmp	0x4f1e	; 0x4f1e <enc28j60ReadOp>

00004f80 <enc28j60PhyWrite>:
  // do the write
  enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
}

void enc28j60PhyWrite(uint8_t address, uint16_t data)
{
    4f80:	1f 93       	push	r17
    4f82:	cf 93       	push	r28
    4f84:	df 93       	push	r29
    4f86:	1f 92       	push	r1
    4f88:	cd b7       	in	r28, 0x3d	; 61
    4f8a:	de b7       	in	r29, 0x3e	; 62
    4f8c:	16 2f       	mov	r17, r22
  // set the PHY register address
  enc28j60Write(MIREGADR, address);
    4f8e:	68 2f       	mov	r22, r24
    4f90:	84 ed       	ldi	r24, 0xD4	; 212
    4f92:	79 83       	std	Y+1, r23	; 0x01
    4f94:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // write the PHY data
  enc28j60Write(MIWRL, data);
    4f98:	61 2f       	mov	r22, r17
    4f9a:	86 ed       	ldi	r24, 0xD6	; 214
    4f9c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MIWRH, data>>8);
    4fa0:	79 81       	ldd	r23, Y+1	; 0x01
    4fa2:	67 2f       	mov	r22, r23
    4fa4:	87 ed       	ldi	r24, 0xD7	; 215
    4fa6:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // wait until the PHY write completes

  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    4faa:	8a ee       	ldi	r24, 0xEA	; 234
    4fac:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    4fb0:	80 ff       	sbrs	r24, 0
    4fb2:	05 c0       	rjmp	.+10     	; 0x4fbe <enc28j60PhyWrite+0x3e>
  {
    vTaskDelay ( 0 );         //FIXME być może tutaj następuje zakleszczenie
    4fb4:	80 e0       	ldi	r24, 0x00	; 0
    4fb6:	90 e0       	ldi	r25, 0x00	; 0
    4fb8:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    4fbc:	f6 cf       	rjmp	.-20     	; 0x4faa <enc28j60PhyWrite+0x2a>
  }
}
    4fbe:	0f 90       	pop	r0
    4fc0:	df 91       	pop	r29
    4fc2:	cf 91       	pop	r28
    4fc4:	1f 91       	pop	r17
    4fc6:	08 95       	ret

00004fc8 <enc28j60getrev>:
}

// read the revision of the chip:
uint8_t enc28j60getrev(void)
{
  return(enc28j60Read(EREVID));
    4fc8:	82 e7       	ldi	r24, 0x72	; 114
    4fca:	0c 94 b0 27 	jmp	0x4f60	; 0x4f60 <enc28j60Read>

00004fce <enc28j60hasRxPkt>:
}

// just probe if there might be a packet
uint8_t enc28j60hasRxPkt(void)
{
  if( enc28j60Read(EPKTCNT) ==0 )
    4fce:	89 e3       	ldi	r24, 0x39	; 57
    4fd0:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    4fd4:	91 e0       	ldi	r25, 0x01	; 1
    4fd6:	81 11       	cpse	r24, r1
    4fd8:	01 c0       	rjmp	.+2      	; 0x4fdc <enc28j60hasRxPkt+0xe>
    4fda:	90 e0       	ldi	r25, 0x00	; 0
  {
    return(0);
  }
  return(1);
}
    4fdc:	89 2f       	mov	r24, r25
    4fde:	08 95       	ret

00004fe0 <enc28j60linkup>:

// read upper 8 bits
uint16_t enc28j60PhyReadH(uint8_t address)
{
  // Set the right address and start the register read operation
  enc28j60Write(MIREGADR, address);
    4fe0:	61 e1       	ldi	r22, 0x11	; 17
    4fe2:	84 ed       	ldi	r24, 0xD4	; 212
    4fe4:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MICMD, MICMD_MIIRD);
    4fe8:	61 e0       	ldi	r22, 0x01	; 1
    4fea:	82 ed       	ldi	r24, 0xD2	; 210
    4fec:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>

  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie
    4ff0:	80 e0       	ldi	r24, 0x00	; 0
    4ff2:	90 e0       	ldi	r25, 0x00	; 0
    4ff4:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
  enc28j60Write(MICMD, MICMD_MIIRD);

  vTaskDelay(0);

  // wait until the PHY read completes
  while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    4ff8:	8a ee       	ldi	r24, 0xEA	; 234
    4ffa:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    4ffe:	80 fd       	sbrc	r24, 0
    5000:	f7 cf       	rjmp	.-18     	; 0x4ff0 <enc28j60linkup+0x10>
   vTaskDelay ( 0 ); //FIXME być może tutaj następuje zawieszenie

  // reset reading bit
  enc28j60Write(MICMD, 0x00);
    5002:	60 e0       	ldi	r22, 0x00	; 0
    5004:	82 ed       	ldi	r24, 0xD2	; 210
    5006:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>

  return (enc28j60Read(MIRDH));
    500a:	89 ed       	ldi	r24, 0xD9	; 217
    500c:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>

// link status
uint8_t enc28j60linkup(void)
{
  // bit 10 (= bit 3 in upper reg)
  return(enc28j60PhyReadH(PHSTAT2) && 4);
    5010:	91 e0       	ldi	r25, 0x01	; 1
    5012:	81 11       	cpse	r24, r1
    5014:	01 c0       	rjmp	.+2      	; 0x5018 <enc28j60linkup+0x38>
    5016:	90 e0       	ldi	r25, 0x00	; 0
}
    5018:	89 2f       	mov	r24, r25
    501a:	08 95       	ret

0000501c <nicSend>:

void nicSend(uint16_t len)
{
    501c:	0f 93       	push	r16
    501e:	1f 93       	push	r17
    5020:	cf 93       	push	r28
    5022:	df 93       	push	r29
    5024:	ec 01       	movw	r28, r24
  // Check no transmit in progress
  while (enc28j60ReadOp(ENC28J60_READ_CTRL_REG, ECON1) & ECON1_TXRTS)
    5026:	6f e1       	ldi	r22, 0x1F	; 31
    5028:	80 e0       	ldi	r24, 0x00	; 0
    502a:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
    502e:	83 ff       	sbrs	r24, 3
    5030:	14 c0       	rjmp	.+40     	; 0x505a <nicSend+0x3e>
  {
    // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
    if( (enc28j60Read(EIR) & EIR_TXERIF) )
    5032:	8c e1       	ldi	r24, 0x1C	; 28
    5034:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    5038:	81 ff       	sbrs	r24, 1
    503a:	0a c0       	rjmp	.+20     	; 0x5050 <nicSend+0x34>
    {
      enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRST);
    503c:	40 e8       	ldi	r20, 0x80	; 128
    503e:	6f e1       	ldi	r22, 0x1F	; 31
    5040:	80 e8       	ldi	r24, 0x80	; 128
    5042:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
      enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRST);
    5046:	40 e8       	ldi	r20, 0x80	; 128
    5048:	6f e1       	ldi	r22, 0x1F	; 31
    504a:	80 ea       	ldi	r24, 0xA0	; 160
    504c:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
    }
    vTaskDelay ( 0 ); //FIXME być może tutaj następuje zakleszczenie
    5050:	80 e0       	ldi	r24, 0x00	; 0
    5052:	90 e0       	ldi	r25, 0x00	; 0
    5054:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    5058:	e6 cf       	rjmp	.-52     	; 0x5026 <nicSend+0xa>
  }
  // Set the write pointer to start of transmit buffer area
  enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
    505a:	6f ef       	ldi	r22, 0xFF	; 255
    505c:	82 e0       	ldi	r24, 0x02	; 2
    505e:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    5062:	69 e1       	ldi	r22, 0x19	; 25
    5064:	83 e0       	ldi	r24, 0x03	; 3
    5066:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // Set the TXND pointer to correspond to the packet size given
  enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
    506a:	6c 2f       	mov	r22, r28
    506c:	61 50       	subi	r22, 0x01	; 1
    506e:	86 e0       	ldi	r24, 0x06	; 6
    5070:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    5074:	ce 01       	movw	r24, r28
    5076:	81 50       	subi	r24, 0x01	; 1
    5078:	96 4e       	sbci	r25, 0xE6	; 230
    507a:	69 2f       	mov	r22, r25
    507c:	87 e0       	ldi	r24, 0x07	; 7
    507e:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // write per-packet control byte (0x00 means use macon3 settings)
  enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    5082:	40 e0       	ldi	r20, 0x00	; 0
    5084:	60 e0       	ldi	r22, 0x00	; 0
    5086:	8a e7       	ldi	r24, 0x7A	; 122
    5088:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
  // copy the packet into the transmit buffer
  enc28j60WriteBuffer(len, nicState.layer2.buf);
    508c:	00 91 86 0e 	lds	r16, 0x0E86
    5090:	10 91 87 0e 	lds	r17, 0x0E87
}

void enc28j60WriteBuffer(uint16_t len, uint8_t* data)
{
  //spiTake();
  spiEnableEnc28j60();
    5094:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <spiEnableEnc28j60>
  // issue write command
  //spiSend(ENC28J60_WRITE_BUF_MEM);      //
  spiSendENC(ENC28J60_WRITE_BUF_MEM);
    5098:	8a e7       	ldi	r24, 0x7A	; 122
    509a:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
    509e:	c0 0f       	add	r28, r16
    50a0:	d1 1f       	adc	r29, r17
  while(len)
    50a2:	0c 17       	cp	r16, r28
    50a4:	1d 07       	cpc	r17, r29
    50a6:	31 f0       	breq	.+12     	; 0x50b4 <nicSend+0x98>
  {
    len--;
    spiSendENC(*data);       // write data
    50a8:	f8 01       	movw	r30, r16
    50aa:	81 91       	ld	r24, Z+
    50ac:	8f 01       	movw	r16, r30
    50ae:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
    50b2:	f7 cf       	rjmp	.-18     	; 0x50a2 <nicSend+0x86>
    data++;
  }
  spiDisableEnc28j60();
    50b4:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <spiDisableEnc28j60>
  // write per-packet control byte (0x00 means use macon3 settings)
  enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
  // copy the packet into the transmit buffer
  enc28j60WriteBuffer(len, nicState.layer2.buf);
  // send the contents of the transmit buffer onto the network
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    50b8:	48 e0       	ldi	r20, 0x08	; 8
    50ba:	6f e1       	ldi	r22, 0x1F	; 31
    50bc:	80 e8       	ldi	r24, 0x80	; 128
}
    50be:	df 91       	pop	r29
    50c0:	cf 91       	pop	r28
    50c2:	1f 91       	pop	r17
    50c4:	0f 91       	pop	r16
  // write per-packet control byte (0x00 means use macon3 settings)
  enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
  // copy the packet into the transmit buffer
  enc28j60WriteBuffer(len, nicState.layer2.buf);
  // send the contents of the transmit buffer onto the network
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    50c6:	0c 94 3e 27 	jmp	0x4e7c	; 0x4e7c <enc28j60WriteOp>

000050ca <nicPoll>:
  }
  return(1);
}

uint16_t nicPoll(void)
{
    50ca:	ef 92       	push	r14
    50cc:	ff 92       	push	r15
    50ce:	0f 93       	push	r16
    50d0:	1f 93       	push	r17
    50d2:	cf 93       	push	r28
    50d4:	df 93       	push	r29
  uint16_t rxstat;
  uint16_t len;
  // check if a packet has been received and buffered
  //if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
  // The above does not work. See Rev. B4 Silicon Errata point 6.
  if( enc28j60Read(EPKTCNT) == 0 )
    50d6:	89 e3       	ldi	r24, 0x39	; 57
    50d8:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    50dc:	88 23       	and	r24, r24
    50de:	09 f4       	brne	.+2      	; 0x50e2 <nicPoll+0x18>
    50e0:	7f c0       	rjmp	.+254    	; 0x51e0 <nicPoll+0x116>
  {
    return(0);
  }

  // Set the read pointer to the start of the received packet
  enc28j60Write(ERDPTL, (gNextPacketPtr &0xFF));
    50e2:	60 91 90 01 	lds	r22, 0x0190
    50e6:	80 e0       	ldi	r24, 0x00	; 0
    50e8:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ERDPTH, (gNextPacketPtr)>>8);
    50ec:	60 91 91 01 	lds	r22, 0x0191
    50f0:	81 e0       	ldi	r24, 0x01	; 1
    50f2:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // read the next packet pointer
  gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    50f6:	60 e0       	ldi	r22, 0x00	; 0
    50f8:	8a e3       	ldi	r24, 0x3A	; 58
    50fa:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
    50fe:	90 e0       	ldi	r25, 0x00	; 0
    5100:	90 93 91 01 	sts	0x0191, r25
    5104:	80 93 90 01 	sts	0x0190, r24
  gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    5108:	60 e0       	ldi	r22, 0x00	; 0
    510a:	8a e3       	ldi	r24, 0x3A	; 58
    510c:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
    5110:	20 91 90 01 	lds	r18, 0x0190
    5114:	30 91 91 01 	lds	r19, 0x0191
    5118:	38 2b       	or	r19, r24
    511a:	30 93 91 01 	sts	0x0191, r19
    511e:	20 93 90 01 	sts	0x0190, r18
  // read the packet length (see datasheet page 43)
  len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    5122:	60 e0       	ldi	r22, 0x00	; 0
    5124:	8a e3       	ldi	r24, 0x3A	; 58
    5126:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
    512a:	c8 2f       	mov	r28, r24
  len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    512c:	60 e0       	ldi	r22, 0x00	; 0
    512e:	8a e3       	ldi	r24, 0x3A	; 58
    5130:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
    5134:	f8 2e       	mov	r15, r24
  len-=4; //remove the CRC count
  // read the receive status (see datasheet page 43)
  rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    5136:	60 e0       	ldi	r22, 0x00	; 0
    5138:	8a e3       	ldi	r24, 0x3A	; 58
    513a:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
    513e:	08 2f       	mov	r16, r24
  rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
    5140:	60 e0       	ldi	r22, 0x00	; 0
    5142:	8a e3       	ldi	r24, 0x3A	; 58
    5144:	0e 94 8f 27 	call	0x4f1e	; 0x4f1e <enc28j60ReadOp>
  // limit retrieve length
  if (len> nicState.bufferSize -1)
    5148:	20 91 7e 0e 	lds	r18, 0x0E7E
    514c:	30 91 7f 0e 	lds	r19, 0x0E7F
  }
  // check CRC and symbol errors (see datasheet page 44, table 7-3):
  // The ERXFCON.CRCEN is set by default. Normally we should not
  // need to check this.

  if ((rxstat & 0x80)==0)
    5150:	07 ff       	sbrs	r16, 7
    5152:	24 c0       	rjmp	.+72     	; 0x519c <nicPoll+0xd2>
  len-=4; //remove the CRC count
  // read the receive status (see datasheet page 43)
  rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
  rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
  // limit retrieve length
  if (len> nicState.bufferSize -1)
    5154:	21 50       	subi	r18, 0x01	; 1
    5156:	31 09       	sbc	r19, r1
  // read the next packet pointer
  gNextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
  gNextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
  // read the packet length (see datasheet page 43)
  len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
  len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    5158:	d0 e0       	ldi	r29, 0x00	; 0
    515a:	df 29       	or	r29, r15
    515c:	24 97       	sbiw	r28, 0x04	; 4
    515e:	2c 17       	cp	r18, r28
    5160:	3d 07       	cpc	r19, r29
    5162:	08 f4       	brcc	.+2      	; 0x5166 <nicPoll+0x9c>
    5164:	e9 01       	movw	r28, r18
    len=0;
  }
  else
  {
    // copy the packet from the receive buffer
    enc28j60ReadBuffer(len, nicState.layer2.buf);
    5166:	00 91 86 0e 	lds	r16, 0x0E86
    516a:	10 91 87 0e 	lds	r17, 0x0E87
}

void enc28j60ReadBuffer(uint16_t len, uint8_t* data)
{
 // spiTake();
  spiEnableEnc28j60();
    516e:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <spiEnableEnc28j60>
  spiSendENC(ENC28J60_READ_BUF_MEM);
    5172:	8a e3       	ldi	r24, 0x3A	; 58
    5174:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
    5178:	78 01       	movw	r14, r16
    517a:	ec 0e       	add	r14, r28
    517c:	fd 1e       	adc	r15, r29
  while(len)
    517e:	0e 15       	cp	r16, r14
    5180:	1f 05       	cpc	r17, r15
    5182:	39 f0       	breq	.+14     	; 0x5192 <nicPoll+0xc8>
  {
    len--;
    *data = spiSendENC(0x00);
    5184:	80 e0       	ldi	r24, 0x00	; 0
    5186:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <spiSendENC>
    518a:	f8 01       	movw	r30, r16
    518c:	81 93       	st	Z+, r24
    518e:	8f 01       	movw	r16, r30
    5190:	f6 cf       	rjmp	.-20     	; 0x517e <nicPoll+0xb4>
    data++;
  }
  *data='\0';
    5192:	f8 01       	movw	r30, r16
    5194:	10 82       	st	Z, r1
  spiDisableEnc28j60();
    5196:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <spiDisableEnc28j60>
    519a:	02 c0       	rjmp	.+4      	; 0x51a0 <nicPoll+0xd6>
  // need to check this.

  if ((rxstat & 0x80)==0)
  {
    // invalid
    len=0;
    519c:	c0 e0       	ldi	r28, 0x00	; 0
    519e:	d0 e0       	ldi	r29, 0x00	; 0
    // copy the packet from the receive buffer
    enc28j60ReadBuffer(len, nicState.layer2.buf);
  }
  // Move the RX read pointer to the start of the next received packet
  // This frees the memory we just read out
  enc28j60Write(ERXRDPTL, (gNextPacketPtr &0xFF));
    51a0:	60 91 90 01 	lds	r22, 0x0190
    51a4:	8c e0       	ldi	r24, 0x0C	; 12
    51a6:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ERXRDPTH, (gNextPacketPtr)>>8);
    51aa:	60 91 91 01 	lds	r22, 0x0191
    51ae:	8d e0       	ldi	r24, 0x0D	; 13
    51b0:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
    enc28j60Write(ERXRDPTH, (RXSTOP_INIT)>>8);
  }
  else
  {
#endif
    enc28j60Write(ERXRDPTL, (gNextPacketPtr-1)&0xFF);
    51b4:	60 91 90 01 	lds	r22, 0x0190
    51b8:	61 50       	subi	r22, 0x01	; 1
    51ba:	8c e0       	ldi	r24, 0x0C	; 12
    51bc:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
    enc28j60Write(ERXRDPTH, (gNextPacketPtr-1)>>8);
    51c0:	80 91 90 01 	lds	r24, 0x0190
    51c4:	90 91 91 01 	lds	r25, 0x0191
    51c8:	01 97       	sbiw	r24, 0x01	; 1
    51ca:	69 2f       	mov	r22, r25
    51cc:	8d e0       	ldi	r24, 0x0D	; 13
    51ce:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
#if RXSTART_INIT > 0
  }
#endif
  // decrement the packet counter indicate we are done with this packet
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    51d2:	40 e4       	ldi	r20, 0x40	; 64
    51d4:	6e e1       	ldi	r22, 0x1E	; 30
    51d6:	80 e8       	ldi	r24, 0x80	; 128
    51d8:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
  return(len);
    51dc:	ce 01       	movw	r24, r28
    51de:	02 c0       	rjmp	.+4      	; 0x51e4 <nicPoll+0x11a>
  // check if a packet has been received and buffered
  //if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
  // The above does not work. See Rev. B4 Silicon Errata point 6.
  if( enc28j60Read(EPKTCNT) == 0 )
  {
    return(0);
    51e0:	80 e0       	ldi	r24, 0x00	; 0
    51e2:	90 e0       	ldi	r25, 0x00	; 0
  }
#endif
  // decrement the packet counter indicate we are done with this packet
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
  return(len);
}
    51e4:	df 91       	pop	r29
    51e6:	cf 91       	pop	r28
    51e8:	1f 91       	pop	r17
    51ea:	0f 91       	pop	r16
    51ec:	ff 90       	pop	r15
    51ee:	ef 90       	pop	r14
    51f0:	08 95       	ret

000051f2 <nicSetMacAddress>:

void spiEnableEnc28j60(void)  {};
void spiDisableEnc28j60(void) {};

void     nicSetMacAddress(uint8_t* macaddr)
{
    51f2:	cf 93       	push	r28
    51f4:	df 93       	push	r29
    51f6:	ec 01       	movw	r28, r24
//NOTE: MAC address in ENC28J60 is byte-backward
  enc28j60Write(MAADR5, macaddr[0]);
    51f8:	68 81       	ld	r22, Y
    51fa:	84 ee       	ldi	r24, 0xE4	; 228
    51fc:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAADR4, macaddr[1]);
    5200:	69 81       	ldd	r22, Y+1	; 0x01
    5202:	85 ee       	ldi	r24, 0xE5	; 229
    5204:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAADR3, macaddr[2]);
    5208:	6a 81       	ldd	r22, Y+2	; 0x02
    520a:	82 ee       	ldi	r24, 0xE2	; 226
    520c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAADR2, macaddr[3]);
    5210:	6b 81       	ldd	r22, Y+3	; 0x03
    5212:	83 ee       	ldi	r24, 0xE3	; 227
    5214:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAADR1, macaddr[4]);
    5218:	6c 81       	ldd	r22, Y+4	; 0x04
    521a:	80 ee       	ldi	r24, 0xE0	; 224
    521c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAADR0, macaddr[5]);
    5220:	6d 81       	ldd	r22, Y+5	; 0x05
    5222:	81 ee       	ldi	r24, 0xE1	; 225
  //strncpy((void *)(nicState.mac.addr), (void *)(macaddr), 6);
}
    5224:	df 91       	pop	r29
    5226:	cf 91       	pop	r28
  enc28j60Write(MAADR5, macaddr[0]);
  enc28j60Write(MAADR4, macaddr[1]);
  enc28j60Write(MAADR3, macaddr[2]);
  enc28j60Write(MAADR2, macaddr[3]);
  enc28j60Write(MAADR1, macaddr[4]);
  enc28j60Write(MAADR0, macaddr[5]);
    5228:	0c 94 7c 27 	jmp	0x4ef8	; 0x4ef8 <enc28j60Write>

0000522c <nicMacInit>:
uint8_t  enc28j60getrev(void);
uint8_t  enc28j60linkup(void);

void nicMacInit(void)
{
    vTaskDelay          (5);
    522c:	85 e0       	ldi	r24, 0x05	; 5
    522e:	90 e0       	ldi	r25, 0x00	; 0
    5230:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
void enc28j60Init(uint8_t* macaddr)
{
  // perform system reset

  //ENC28j60 reset is on PE2 TODO add in hardware.c macros for that.
  ENC_RST_ON;   // PORTE &= ~0x04;
    5234:	1a 98       	cbi	0x03, 2	; 3
  vTaskDelay(5); // 50ms
    5236:	85 e0       	ldi	r24, 0x05	; 5
    5238:	90 e0       	ldi	r25, 0x00	; 0
    523a:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
  ENC_RST_OFF;  //PORTE |= 0x04;
    523e:	1a 9a       	sbi	0x03, 2	; 3
  vTaskDelay(5); // 50ms
    5240:	85 e0       	ldi	r24, 0x05	; 5
    5242:	90 e0       	ldi	r25, 0x00	; 0
    5244:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
  //while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
  // do bank 0 stuff
  // initialize receive buffer
  // 16-bit transfers, must write low byte first
  // set receive buffer start address
  gNextPacketPtr = RXSTART_INIT;
    5248:	10 92 91 01 	sts	0x0191, r1
    524c:	10 92 90 01 	sts	0x0190, r1
  // Rx start
  enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
    5250:	60 e0       	ldi	r22, 0x00	; 0
    5252:	88 e0       	ldi	r24, 0x08	; 8
    5254:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ERXSTH, RXSTART_INIT>>8);
    5258:	60 e0       	ldi	r22, 0x00	; 0
    525a:	89 e0       	ldi	r24, 0x09	; 9
    525c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // set receive pointer address
  enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
    5260:	60 e0       	ldi	r22, 0x00	; 0
    5262:	8c e0       	ldi	r24, 0x0C	; 12
    5264:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
    5268:	60 e0       	ldi	r22, 0x00	; 0
    526a:	8d e0       	ldi	r24, 0x0D	; 13
    526c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // RX end
  enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
    5270:	6e ef       	ldi	r22, 0xFE	; 254
    5272:	8a e0       	ldi	r24, 0x0A	; 10
    5274:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
    5278:	69 e1       	ldi	r22, 0x19	; 25
    527a:	8b e0       	ldi	r24, 0x0B	; 11
    527c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // TX start
  enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
    5280:	6f ef       	ldi	r22, 0xFF	; 255
    5282:	84 e0       	ldi	r24, 0x04	; 4
    5284:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ETXSTH, TXSTART_INIT>>8);
    5288:	69 e1       	ldi	r22, 0x19	; 25
    528a:	85 e0       	ldi	r24, 0x05	; 5
    528c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // TX end
  enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
    5290:	6f ef       	ldi	r22, 0xFF	; 255
    5292:	86 e0       	ldi	r24, 0x06	; 6
    5294:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
    5298:	6f e1       	ldi	r22, 0x1F	; 31
    529a:	87 e0       	ldi	r24, 0x07	; 7
    529c:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // ARP      BROADCAST
  // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
  // in binary these poitions are:11 0000 0011 1111
  // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
  //enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);  //Bez wejsca dla broadcastu (jak opis powyzej, wpusci tylko arp - na zasadzie checksumy zgodnej z pakietem)
  enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN|ERXFCON_MCEN); //Z wejsciem dla calego broadcastu
    52a0:	62 eb       	ldi	r22, 0xB2	; 178
    52a2:	88 e3       	ldi	r24, 0x38	; 56
    52a4:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(EPMM0, 0x3f);
    52a8:	6f e3       	ldi	r22, 0x3F	; 63
    52aa:	88 e2       	ldi	r24, 0x28	; 40
    52ac:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(EPMM1, 0x30);
    52b0:	60 e3       	ldi	r22, 0x30	; 48
    52b2:	89 e2       	ldi	r24, 0x29	; 41
    52b4:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(EPMCSL, 0xf9);
    52b8:	69 ef       	ldi	r22, 0xF9	; 249
    52ba:	80 e3       	ldi	r24, 0x30	; 48
    52bc:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(EPMCSH, 0xf7);
    52c0:	67 ef       	ldi	r22, 0xF7	; 247
    52c2:	81 e3       	ldi	r24, 0x31	; 49
    52c4:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  //
  //
  // do bank 2 stuff
  // enable MAC receive
  enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
    52c8:	6d e0       	ldi	r22, 0x0D	; 13
    52ca:	80 ec       	ldi	r24, 0xC0	; 192
    52cc:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // bring MAC out of reset
  enc28j60Write(MACON2, 0x00);
    52d0:	60 e0       	ldi	r22, 0x00	; 0
    52d2:	81 ec       	ldi	r24, 0xC1	; 193
    52d4:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // enable automatic padding to 60bytes and CRC operations
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
    52d8:	42 e3       	ldi	r20, 0x32	; 50
    52da:	62 ec       	ldi	r22, 0xC2	; 194
    52dc:	80 e8       	ldi	r24, 0x80	; 128
    52de:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
  // set inter-frame gap (non-back-to-back)
  enc28j60Write(MAIPGL, 0x12);
    52e2:	62 e1       	ldi	r22, 0x12	; 18
    52e4:	86 ec       	ldi	r24, 0xC6	; 198
    52e6:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAIPGH, 0x0C);
    52ea:	6c e0       	ldi	r22, 0x0C	; 12
    52ec:	87 ec       	ldi	r24, 0xC7	; 199
    52ee:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // set inter-frame gap (back-to-back)
  enc28j60Write(MABBIPG, 0x12);
    52f2:	62 e1       	ldi	r22, 0x12	; 18
    52f4:	84 ec       	ldi	r24, 0xC4	; 196
    52f6:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  // Set the maximum packet size which the controller will accept
  // Do not send packets longer than MAX_FRAMELEN:
  enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);
    52fa:	6c ed       	ldi	r22, 0xDC	; 220
    52fc:	8a ec       	ldi	r24, 0xCA	; 202
    52fe:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>
  enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
    5302:	65 e0       	ldi	r22, 0x05	; 5
    5304:	8b ec       	ldi	r24, 0xCB	; 203
    5306:	0e 94 7c 27 	call	0x4ef8	; 0x4ef8 <enc28j60Write>

  // do bank 3 stuff
  // write MAC address

  nicSetMacAddress(macaddr);
    530a:	80 e8       	ldi	r24, 0x80	; 128
    530c:	9e e0       	ldi	r25, 0x0E	; 14
    530e:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <nicSetMacAddress>

  // no loopback of transmitted frames
  enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
    5312:	60 e0       	ldi	r22, 0x00	; 0
    5314:	71 e0       	ldi	r23, 0x01	; 1
    5316:	80 e1       	ldi	r24, 0x10	; 16
    5318:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <enc28j60PhyWrite>

  enc28j60SetBank(ECON1);                             // switch to bank 0
    531c:	8f e1       	ldi	r24, 0x1F	; 31
    531e:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <enc28j60SetBank>
  // enable interrutps
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
    5322:	40 ec       	ldi	r20, 0xC0	; 192
    5324:	6b e1       	ldi	r22, 0x1B	; 27
    5326:	80 e8       	ldi	r24, 0x80	; 128
    5328:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
  // enable packet reception
  enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    532c:	44 e0       	ldi	r20, 0x04	; 4
    532e:	6f e1       	ldi	r22, 0x1F	; 31
    5330:	80 e8       	ldi	r24, 0x80	; 128
    5332:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <enc28j60WriteOp>
void nicMacInit(void)
{
    vTaskDelay          (5);
    enc28j60Init        (nicState.mac.addr);
//  enc28j60clkout      (2);     // change clkout from 6.25MHz to 12.5MHz
    vTaskDelay          (5);
    5336:	85 e0       	ldi	r24, 0x05	; 5
    5338:	90 e0       	ldi	r25, 0x00	; 0
    533a:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    enc28j60PhyWrite    (PHLCON, 0x476);
    533e:	66 e7       	ldi	r22, 0x76	; 118
    5340:	74 e0       	ldi	r23, 0x04	; 4
    5342:	84 e1       	ldi	r24, 0x14	; 20
    5344:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <enc28j60PhyWrite>
    vTaskDelay          (2);
    5348:	82 e0       	ldi	r24, 0x02	; 2
    534a:	90 e0       	ldi	r25, 0x00	; 0
    534c:	0c 94 81 43 	jmp	0x8702	; 0x8702 <vTaskDelay>

00005350 <nicGetMacAddress>:
  enc28j60Write(MAADR0, macaddr[5]);
  //strncpy((void *)(nicState.mac.addr), (void *)(macaddr), 6);
}

void     nicGetMacAddress(uint8_t* macaddr)
{
    5350:	cf 93       	push	r28
    5352:	df 93       	push	r29
    5354:	ec 01       	movw	r28, r24
  macaddr[5] = enc28j60Read(MAADR0);
    5356:	81 ee       	ldi	r24, 0xE1	; 225
    5358:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    535c:	8d 83       	std	Y+5, r24	; 0x05
  macaddr[4] = enc28j60Read(MAADR1);
    535e:	80 ee       	ldi	r24, 0xE0	; 224
    5360:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    5364:	8c 83       	std	Y+4, r24	; 0x04
  macaddr[3] = enc28j60Read(MAADR2);
    5366:	83 ee       	ldi	r24, 0xE3	; 227
    5368:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    536c:	8b 83       	std	Y+3, r24	; 0x03
  macaddr[2] = enc28j60Read(MAADR3);
    536e:	82 ee       	ldi	r24, 0xE2	; 226
    5370:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    5374:	8a 83       	std	Y+2, r24	; 0x02
  macaddr[1] = enc28j60Read(MAADR4);
    5376:	85 ee       	ldi	r24, 0xE5	; 229
    5378:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    537c:	89 83       	std	Y+1, r24	; 0x01
  macaddr[0] = enc28j60Read(MAADR5);
    537e:	84 ee       	ldi	r24, 0xE4	; 228
    5380:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    5384:	88 83       	st	Y, r24
  //strncpy((void *)(nicState.mac.addr), (void *)(macaddr), 6);
}
    5386:	df 91       	pop	r29
    5388:	cf 91       	pop	r28
    538a:	08 95       	ret

0000538c <nicRegDump>:

void     nicRegDump(FILE *stream)
{
    538c:	cf 93       	push	r28
    538e:	df 93       	push	r29
    5390:	ec 01       	movw	r28, r24
  uint8_t temp;
  fprintf_P(stream, PSTR("ENC28j60 stan rejestrow:\r\n"));
    5392:	84 e6       	ldi	r24, 0x64	; 100
    5394:	9c e0       	ldi	r25, 0x0C	; 12
    5396:	9f 93       	push	r25
    5398:	8f 93       	push	r24
    539a:	df 93       	push	r29
    539c:	cf 93       	push	r28
    539e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

  temp = enc28j60Read(MAADR0); fprintf_P(stream, PSTR("\tMAADR0 0x%x\r\n"), temp);
    53a2:	81 ee       	ldi	r24, 0xE1	; 225
    53a4:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    53a8:	1f 92       	push	r1
    53aa:	8f 93       	push	r24
    53ac:	85 e5       	ldi	r24, 0x55	; 85
    53ae:	9c e0       	ldi	r25, 0x0C	; 12
    53b0:	9f 93       	push	r25
    53b2:	8f 93       	push	r24
    53b4:	df 93       	push	r29
    53b6:	cf 93       	push	r28
    53b8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  temp = enc28j60Read(MAADR1); fprintf_P(stream, PSTR("\tMAADR1 0x%x\r\n"), temp);
    53bc:	80 ee       	ldi	r24, 0xE0	; 224
    53be:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    53c2:	1f 92       	push	r1
    53c4:	8f 93       	push	r24
    53c6:	86 e4       	ldi	r24, 0x46	; 70
    53c8:	9c e0       	ldi	r25, 0x0C	; 12
    53ca:	9f 93       	push	r25
    53cc:	8f 93       	push	r24
    53ce:	df 93       	push	r29
    53d0:	cf 93       	push	r28
    53d2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  temp = enc28j60Read(MAADR2); fprintf_P(stream, PSTR("\tMAADR2 0x%x\r\n"), temp);
    53d6:	83 ee       	ldi	r24, 0xE3	; 227
    53d8:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    53dc:	1f 92       	push	r1
    53de:	8f 93       	push	r24
    53e0:	87 e3       	ldi	r24, 0x37	; 55
    53e2:	9c e0       	ldi	r25, 0x0C	; 12
    53e4:	9f 93       	push	r25
    53e6:	8f 93       	push	r24
    53e8:	df 93       	push	r29
    53ea:	cf 93       	push	r28
    53ec:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  temp = enc28j60Read(MAADR3); fprintf_P(stream, PSTR("\tMAADR3 0x%x\r\n"), temp);
    53f0:	82 ee       	ldi	r24, 0xE2	; 226
    53f2:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    53f6:	1f 92       	push	r1
    53f8:	8f 93       	push	r24
    53fa:	88 e2       	ldi	r24, 0x28	; 40
    53fc:	9c e0       	ldi	r25, 0x0C	; 12
    53fe:	9f 93       	push	r25
    5400:	8f 93       	push	r24
    5402:	df 93       	push	r29
    5404:	cf 93       	push	r28
    5406:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  temp = enc28j60Read(MAADR4); fprintf_P(stream, PSTR("\tMAADR4 0x%x\r\n"), temp);
    540a:	85 ee       	ldi	r24, 0xE5	; 229
    540c:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    5410:	1f 92       	push	r1
    5412:	8f 93       	push	r24
    5414:	89 e1       	ldi	r24, 0x19	; 25
    5416:	9c e0       	ldi	r25, 0x0C	; 12
    5418:	9f 93       	push	r25
    541a:	8f 93       	push	r24
    541c:	df 93       	push	r29
    541e:	cf 93       	push	r28
    5420:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  temp = enc28j60Read(MAADR5); fprintf_P(stream, PSTR("\tMAADR5 0x%x\r\n"), temp);
    5424:	8d b7       	in	r24, 0x3d	; 61
    5426:	9e b7       	in	r25, 0x3e	; 62
    5428:	82 96       	adiw	r24, 0x22	; 34
    542a:	0f b6       	in	r0, 0x3f	; 63
    542c:	f8 94       	cli
    542e:	9e bf       	out	0x3e, r25	; 62
    5430:	0f be       	out	0x3f, r0	; 63
    5432:	8d bf       	out	0x3d, r24	; 61
    5434:	84 ee       	ldi	r24, 0xE4	; 228
    5436:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <enc28j60Read>
    543a:	1f 92       	push	r1
    543c:	8f 93       	push	r24
    543e:	8a e0       	ldi	r24, 0x0A	; 10
    5440:	9c e0       	ldi	r25, 0x0C	; 12
    5442:	9f 93       	push	r25
    5444:	8f 93       	push	r24
    5446:	df 93       	push	r29
    5448:	cf 93       	push	r28
    544a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    544e:	0f 90       	pop	r0
    5450:	0f 90       	pop	r0
    5452:	0f 90       	pop	r0
    5454:	0f 90       	pop	r0
    5456:	0f 90       	pop	r0
    5458:	0f 90       	pop	r0
}
    545a:	df 91       	pop	r29
    545c:	cf 91       	pop	r28
    545e:	08 95       	ret

00005460 <streamQueueInputFun>:
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
  return 0;
}

static int streamQueueInputFun(FILE *istream)
{
    5460:	cf 93       	push	r28
    5462:	df 93       	push	r29
    5464:	1f 92       	push	r1
    5466:	cd b7       	in	r28, 0x3d	; 61
    5468:	de b7       	in	r29, 0x3e	; 62
  char c;
  streamBuffers_t *strBuf = (streamBuffers_t *) istream->udata;
  xQueueReceive(strBuf->Rx, &c, portMAX_DELAY);
    546a:	dc 01       	movw	r26, r24
    546c:	1c 96       	adiw	r26, 0x0c	; 12
    546e:	ed 91       	ld	r30, X+
    5470:	fc 91       	ld	r31, X
    5472:	1d 97       	sbiw	r26, 0x0d	; 13
    5474:	20 e0       	ldi	r18, 0x00	; 0
    5476:	4f ef       	ldi	r20, 0xFF	; 255
    5478:	5f ef       	ldi	r21, 0xFF	; 255
    547a:	be 01       	movw	r22, r28
    547c:	6f 5f       	subi	r22, 0xFF	; 255
    547e:	7f 4f       	sbci	r23, 0xFF	; 255
    5480:	80 81       	ld	r24, Z
    5482:	91 81       	ldd	r25, Z+1	; 0x01
    5484:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
  return c;
    5488:	89 81       	ldd	r24, Y+1	; 0x01
}
    548a:	08 2e       	mov	r0, r24
    548c:	00 0c       	add	r0, r0
    548e:	99 0b       	sbc	r25, r25
    5490:	0f 90       	pop	r0
    5492:	df 91       	pop	r29
    5494:	cf 91       	pop	r28
    5496:	08 95       	ret

00005498 <streamQueueOutputFun>:
  buffer->Tx = Tx;
  return;
}

static int streamQueueOutputFun(char c, FILE *ostream)
{
    5498:	cf 93       	push	r28
    549a:	df 93       	push	r29
    549c:	1f 92       	push	r1
    549e:	cd b7       	in	r28, 0x3d	; 61
    54a0:	de b7       	in	r29, 0x3e	; 62
    54a2:	89 83       	std	Y+1, r24	; 0x01
/*  if (xQueueSend( strBuf->Tx, &c, strBuf->tx_timeout))
  {
    return EOF;
  }
  else*/
  xQueueSend( strBuf->Tx, &c, portMAX_DELAY);
    54a4:	db 01       	movw	r26, r22
    54a6:	1c 96       	adiw	r26, 0x0c	; 12
    54a8:	ed 91       	ld	r30, X+
    54aa:	fc 91       	ld	r31, X
    54ac:	1d 97       	sbiw	r26, 0x0d	; 13
    54ae:	20 e0       	ldi	r18, 0x00	; 0
    54b0:	4f ef       	ldi	r20, 0xFF	; 255
    54b2:	5f ef       	ldi	r21, 0xFF	; 255
    54b4:	be 01       	movw	r22, r28
    54b6:	6f 5f       	subi	r22, 0xFF	; 255
    54b8:	7f 4f       	sbci	r23, 0xFF	; 255
    54ba:	82 81       	ldd	r24, Z+2	; 0x02
    54bc:	93 81       	ldd	r25, Z+3	; 0x03
    54be:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <xQueueGenericSend>
  return 0;
}
    54c2:	80 e0       	ldi	r24, 0x00	; 0
    54c4:	90 e0       	ldi	r25, 0x00	; 0
    54c6:	0f 90       	pop	r0
    54c8:	df 91       	pop	r29
    54ca:	cf 91       	pop	r28
    54cc:	08 95       	ret

000054ce <initQueueStream>:

static int streamQueueOutputFun(char c, FILE *ostream);
static int streamQueueInputFun(FILE *istream);

void initQueueStream(FILE *stream, streamBuffers_t *buffer, xQueueHandle Rx, xQueueHandle Tx)
{
    54ce:	fc 01       	movw	r30, r24
  fdev_setup_stream(stream, streamQueueOutputFun, streamQueueInputFun, _FDEV_SETUP_RW);
    54d0:	8c e4       	ldi	r24, 0x4C	; 76
    54d2:	9a e2       	ldi	r25, 0x2A	; 42
    54d4:	91 87       	std	Z+9, r25	; 0x09
    54d6:	80 87       	std	Z+8, r24	; 0x08
    54d8:	80 e3       	ldi	r24, 0x30	; 48
    54da:	9a e2       	ldi	r25, 0x2A	; 42
    54dc:	93 87       	std	Z+11, r25	; 0x0b
    54de:	82 87       	std	Z+10, r24	; 0x0a
    54e0:	83 e0       	ldi	r24, 0x03	; 3
    54e2:	83 83       	std	Z+3, r24	; 0x03
  fdev_set_udata(stream, (void *)buffer);
    54e4:	75 87       	std	Z+13, r23	; 0x0d
    54e6:	64 87       	std	Z+12, r22	; 0x0c
  buffer->Rx = Rx;
    54e8:	fb 01       	movw	r30, r22
    54ea:	51 83       	std	Z+1, r21	; 0x01
    54ec:	40 83       	st	Z, r20
  buffer->Tx = Tx;
    54ee:	33 83       	std	Z+3, r19	; 0x03
    54f0:	22 83       	std	Z+2, r18	; 0x02
    54f2:	08 95       	ret
    54f4:	08 95       	ret
    54f6:	08 95       	ret
    54f8:	80 e0       	ldi	r24, 0x00	; 0
    54fa:	90 e0       	ldi	r25, 0x00	; 0
    54fc:	08 95       	ret

000054fe <nicLoadConfig>:
  nicLoadConfig();
}

void nicLoadConfig(void)
{
  eeprom_read_block(&nicState.mac.addr, mymac_eep, 6);
    54fe:	46 e0       	ldi	r20, 0x06	; 6
    5500:	50 e0       	ldi	r21, 0x00	; 0
    5502:	60 e2       	ldi	r22, 0x20	; 32
    5504:	70 e0       	ldi	r23, 0x00	; 0
    5506:	80 e8       	ldi	r24, 0x80	; 128
    5508:	9e e0       	ldi	r25, 0x0E	; 14
    550a:	0c 94 3d 53 	jmp	0xa67a	; 0xa67a <eeprom_read_block>

0000550e <nicSaveConfig>:
}

void nicSaveConfig(void)
{
  eeprom_update_block(&nicState.mac.addr, mymac_eep, 6);
    550e:	46 e0       	ldi	r20, 0x06	; 6
    5510:	50 e0       	ldi	r21, 0x00	; 0
    5512:	60 e2       	ldi	r22, 0x20	; 32
    5514:	70 e0       	ldi	r23, 0x00	; 0
    5516:	80 e8       	ldi	r24, 0x80	; 128
    5518:	9e e0       	ldi	r25, 0x0E	; 14
    551a:	0c 94 59 53 	jmp	0xa6b2	; 0xa6b2 <eeprom_update_block>

0000551e <nicInit>:



static void nicBufferInit(void)
{
  nicState.bufferSize  = NETWORK_STACK_BUF_SIZE;
    551e:	ee e7       	ldi	r30, 0x7E	; 126
    5520:	fe e0       	ldi	r31, 0x0E	; 14
    5522:	80 e0       	ldi	r24, 0x00	; 0
    5524:	96 e0       	ldi	r25, 0x06	; 6
    5526:	91 83       	std	Z+1, r25	; 0x01
    5528:	80 83       	st	Z, r24
  nicState.layer2.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR);
    552a:	a0 e0       	ldi	r26, 0x00	; 0
    552c:	ba e7       	ldi	r27, 0x7A	; 122
    552e:	b1 87       	std	Z+9, r27	; 0x09
    5530:	a0 87       	std	Z+8, r26	; 0x08
  nicState.layer3.ip   = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
    5532:	2e e0       	ldi	r18, 0x0E	; 14
    5534:	3a e7       	ldi	r19, 0x7A	; 122
    5536:	33 87       	std	Z+11, r19	; 0x0b
    5538:	22 87       	std	Z+10, r18	; 0x0a
  nicState.layer4.icmp = (struct  netIcmpHeader *)(NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN + IP_HEADER_LEN);
    553a:	22 e2       	ldi	r18, 0x22	; 34
    553c:	3a e7       	ldi	r19, 0x7A	; 122
    553e:	35 87       	std	Z+13, r19	; 0x0d
    5540:	24 87       	std	Z+12, r18	; 0x0c
  #if IPV6_SUPPORT
  nicState.layer3.ipv6 = (struct netIpHeader *)   (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN);
  nicState.layer3.buf  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN);
  //nicState.layer4.icmpv6  = (uint8_t *)              (NETWORK_STACK_BUF_ADDR + ETH_HEADER_LEN); //Te wartosci beda ustawiane w czasie analizy pakietu
  #endif /*IPV6_SUPPORT*/
  memset(nicState.layer2.buf, 0, nicState.bufferSize);
    5542:	fd 01       	movw	r30, r26
    5544:	9c 01       	movw	r18, r24
    5546:	11 92       	st	Z+, r1
    5548:	21 50       	subi	r18, 0x01	; 1
    554a:	30 40       	sbci	r19, 0x00	; 0
    554c:	e1 f7       	brne	.-8      	; 0x5546 <nicInit+0x28>
  nicLoadConfig();
    554e:	0e 94 7f 2a 	call	0x54fe	; 0x54fe <nicLoadConfig>
}

void nicInit()
{
  nicBufferInit();
  nicMacInit();
    5552:	0c 94 16 29 	jmp	0x522c	; 0x522c <nicMacInit>
    5556:	46 e0       	ldi	r20, 0x06	; 6
    5558:	50 e0       	ldi	r21, 0x00	; 0
    555a:	60 e8       	ldi	r22, 0x80	; 128
    555c:	7e e0       	ldi	r23, 0x0E	; 14
    555e:	0c 94 a6 4f 	jmp	0x9f4c	; 0x9f4c <strncpy>
    5562:	46 e0       	ldi	r20, 0x06	; 6
    5564:	50 e0       	ldi	r21, 0x00	; 0
    5566:	bc 01       	movw	r22, r24
    5568:	80 e8       	ldi	r24, 0x80	; 128
    556a:	9e e0       	ldi	r25, 0x0E	; 14
    556c:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <strncpy>
    5570:	0c 94 16 29 	jmp	0x522c	; 0x522c <nicMacInit>
    5574:	2f e7       	ldi	r18, 0x7F	; 127
    5576:	3c e0       	ldi	r19, 0x0C	; 12
    5578:	3f 93       	push	r19
    557a:	2f 93       	push	r18
    557c:	9f 93       	push	r25
    557e:	8f 93       	push	r24
    5580:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5584:	0f 90       	pop	r0
    5586:	0f 90       	pop	r0
    5588:	0f 90       	pop	r0
    558a:	0f 90       	pop	r0
    558c:	08 95       	ret

0000558e <ntohs>:


uint16_t ntohs(uint16_t val)
{
  return (val<<8) | (val>>8);
}
    558e:	98 27       	eor	r25, r24
    5590:	89 27       	eor	r24, r25
    5592:	98 27       	eor	r25, r24
    5594:	08 95       	ret

00005596 <htons>:

uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
}
    5596:	98 27       	eor	r25, r24
    5598:	89 27       	eor	r24, r25
    559a:	98 27       	eor	r25, r24
    559c:	08 95       	ret

0000559e <htonl>:

uint32_t htonl(uint32_t val)
{
    559e:	0e 94 f7 4c 	call	0x99ee	; 0x99ee <__bswapsi2>
  return (htons(val>>16) | (uint32_t)htons(val&0x0000FFFF)<<16);
}
    55a2:	08 95       	ret

000055a4 <ntohl>:

uint32_t ntohl(uint32_t val)
{
    55a4:	0e 94 f7 4c 	call	0x99ee	; 0x99ee <__bswapsi2>
  return (ntohs(val>>16) | (uint32_t)ntohs(val&0x0000FFFF)<<16);
}
    55a8:	08 95       	ret

000055aa <netChecksum>:


uint16_t netChecksum(uint8_t *data, uint16_t len)
{
    55aa:	cf 93       	push	r28
    55ac:	df 93       	push	r29
    55ae:	db 01       	movw	r26, r22
    55b0:	9b 01       	movw	r18, r22
    55b2:	fc 01       	movw	r30, r24
  register uint32_t sum = 0;
    55b4:	40 e0       	ldi	r20, 0x00	; 0
    55b6:	50 e0       	ldi	r21, 0x00	; 0
    55b8:	ba 01       	movw	r22, r20

  for (;;)
  {
    if (len < 2)
    55ba:	22 30       	cpi	r18, 0x02	; 2
    55bc:	31 05       	cpc	r19, r1
    55be:	48 f0       	brcs	.+18     	; 0x55d2 <netChecksum+0x28>
      break;
//sum += *((uint16_t *)data)++;
    sum += *((uint16_t *)data);
    55c0:	c1 91       	ld	r28, Z+
    55c2:	d1 91       	ld	r29, Z+
    55c4:	4c 0f       	add	r20, r28
    55c6:	5d 1f       	adc	r21, r29
    55c8:	61 1d       	adc	r22, r1
    55ca:	71 1d       	adc	r23, r1
    data+=2;
    len -= 2;
    55cc:	22 50       	subi	r18, 0x02	; 2
    55ce:	31 09       	sbc	r19, r1
  }
    55d0:	f4 cf       	rjmp	.-24     	; 0x55ba <netChecksum+0x10>
    55d2:	9d 01       	movw	r18, r26
    55d4:	2e 7f       	andi	r18, 0xFE	; 254
    55d6:	fc 01       	movw	r30, r24
    55d8:	e2 0f       	add	r30, r18
    55da:	f3 1f       	adc	r31, r19
  if (len)
    55dc:	a0 ff       	sbrs	r26, 0
    55de:	05 c0       	rjmp	.+10     	; 0x55ea <netChecksum+0x40>
    sum += *(uint8_t *) data;
    55e0:	80 81       	ld	r24, Z
    55e2:	48 0f       	add	r20, r24
    55e4:	51 1d       	adc	r21, r1
    55e6:	61 1d       	adc	r22, r1
    55e8:	71 1d       	adc	r23, r1

  while ((len = (uint16_t) (sum >> 16)) != 0)
    55ea:	cb 01       	movw	r24, r22
    55ec:	aa 27       	eor	r26, r26
    55ee:	bb 27       	eor	r27, r27
    55f0:	00 97       	sbiw	r24, 0x00	; 0
    55f2:	29 f0       	breq	.+10     	; 0x55fe <netChecksum+0x54>
    sum = (uint16_t) sum + len;
    55f4:	48 0f       	add	r20, r24
    55f6:	59 1f       	adc	r21, r25
    55f8:	60 e0       	ldi	r22, 0x00	; 0
    55fa:	70 e0       	ldi	r23, 0x00	; 0
    55fc:	f6 cf       	rjmp	.-20     	; 0x55ea <netChecksum+0x40>

  return (uint16_t) sum ^ 0xFFFF;
    55fe:	ca 01       	movw	r24, r20
    5600:	80 95       	com	r24
    5602:	90 95       	com	r25
}
    5604:	df 91       	pop	r29
    5606:	cf 91       	pop	r28
    5608:	08 95       	ret

0000560a <netPrintEthAddr>:

void netPrintEthAddr(FILE *stream, struct netEthAddr* ethaddr)
{
    560a:	fb 01       	movw	r30, r22
  fprintf_P(stream, PSTR("%02x:%02x:%02x:%02x:%02x:%02x"), ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2], ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]);
    560c:	25 81       	ldd	r18, Z+5	; 0x05
    560e:	1f 92       	push	r1
    5610:	2f 93       	push	r18
    5612:	24 81       	ldd	r18, Z+4	; 0x04
    5614:	1f 92       	push	r1
    5616:	2f 93       	push	r18
    5618:	23 81       	ldd	r18, Z+3	; 0x03
    561a:	1f 92       	push	r1
    561c:	2f 93       	push	r18
    561e:	22 81       	ldd	r18, Z+2	; 0x02
    5620:	1f 92       	push	r1
    5622:	2f 93       	push	r18
    5624:	21 81       	ldd	r18, Z+1	; 0x01
    5626:	1f 92       	push	r1
    5628:	2f 93       	push	r18
    562a:	20 81       	ld	r18, Z
    562c:	1f 92       	push	r1
    562e:	2f 93       	push	r18
    5630:	2a ec       	ldi	r18, 0xCA	; 202
    5632:	3d e0       	ldi	r19, 0x0D	; 13
    5634:	3f 93       	push	r19
    5636:	2f 93       	push	r18
    5638:	9f 93       	push	r25
    563a:	8f 93       	push	r24
    563c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5640:	8d b7       	in	r24, 0x3d	; 61
    5642:	9e b7       	in	r25, 0x3e	; 62
    5644:	40 96       	adiw	r24, 0x10	; 16
    5646:	0f b6       	in	r0, 0x3f	; 63
    5648:	f8 94       	cli
    564a:	9e bf       	out	0x3e, r25	; 62
    564c:	0f be       	out	0x3f, r0	; 63
    564e:	8d bf       	out	0x3d, r24	; 61
    5650:	08 95       	ret

00005652 <netPrintIPAddr>:
}

void netPrintIPAddr(FILE *stream, uint32_t ipaddr)
{
    5652:	cf 93       	push	r28
    5654:	df 93       	push	r29
    5656:	00 d0       	rcall	.+0      	; 0x5658 <netPrintIPAddr+0x6>
    5658:	00 d0       	rcall	.+0      	; 0x565a <netPrintIPAddr+0x8>
    565a:	cd b7       	in	r28, 0x3d	; 61
    565c:	de b7       	in	r29, 0x3e	; 62
    565e:	49 83       	std	Y+1, r20	; 0x01
    5660:	5a 83       	std	Y+2, r21	; 0x02
    5662:	6b 83       	std	Y+3, r22	; 0x03
    5664:	7c 83       	std	Y+4, r23	; 0x04
  fprintf_P(stream, PSTR("%d.%d.%d.%d"), ((unsigned char*)&ipaddr)[0], ((unsigned char*)&ipaddr)[1], ((unsigned char*)&ipaddr)[2], ((unsigned char*)&ipaddr)[3]);
    5666:	2c 81       	ldd	r18, Y+4	; 0x04
    5668:	1f 92       	push	r1
    566a:	2f 93       	push	r18
    566c:	2b 81       	ldd	r18, Y+3	; 0x03
    566e:	1f 92       	push	r1
    5670:	2f 93       	push	r18
    5672:	2a 81       	ldd	r18, Y+2	; 0x02
    5674:	1f 92       	push	r1
    5676:	2f 93       	push	r18
    5678:	29 81       	ldd	r18, Y+1	; 0x01
    567a:	1f 92       	push	r1
    567c:	2f 93       	push	r18
    567e:	2e eb       	ldi	r18, 0xBE	; 190
    5680:	3d e0       	ldi	r19, 0x0D	; 13
    5682:	3f 93       	push	r19
    5684:	2f 93       	push	r18
    5686:	9f 93       	push	r25
    5688:	8f 93       	push	r24
    568a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    568e:	0f b6       	in	r0, 0x3f	; 63
    5690:	f8 94       	cli
    5692:	de bf       	out	0x3e, r29	; 62
    5694:	0f be       	out	0x3f, r0	; 63
    5696:	cd bf       	out	0x3d, r28	; 61
}
    5698:	0f 90       	pop	r0
    569a:	0f 90       	pop	r0
    569c:	0f 90       	pop	r0
    569e:	0f 90       	pop	r0
    56a0:	df 91       	pop	r29
    56a2:	cf 91       	pop	r28
    56a4:	08 95       	ret

000056a6 <netPrintEthHeader>:

void netPrintEthHeader(FILE *stream, struct netEthHeader* eth_hdr)
{
    56a6:	0f 93       	push	r16
    56a8:	1f 93       	push	r17
    56aa:	cf 93       	push	r28
    56ac:	df 93       	push	r29
    56ae:	d8 2f       	mov	r29, r24
    56b0:	c9 2f       	mov	r28, r25
    56b2:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
    56b4:	fb 01       	movw	r30, r22
    56b6:	85 85       	ldd	r24, Z+13	; 0x0d
    56b8:	8f 93       	push	r24
    56ba:	84 85       	ldd	r24, Z+12	; 0x0c
    56bc:	8f 93       	push	r24
    56be:	88 ea       	ldi	r24, 0xA8	; 168
    56c0:	9d e0       	ldi	r25, 0x0D	; 13
    56c2:	9f 93       	push	r25
    56c4:	8f 93       	push	r24
    56c6:	cf 93       	push	r28
    56c8:	df 93       	push	r29
    56ca:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR(" SRC:"));
    56ce:	82 ea       	ldi	r24, 0xA2	; 162
    56d0:	9d e0       	ldi	r25, 0x0D	; 13
    56d2:	9f 93       	push	r25
    56d4:	8f 93       	push	r24
    56d6:	cf 93       	push	r28
    56d8:	df 93       	push	r29
    56da:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->src);
    56de:	b8 01       	movw	r22, r16
    56e0:	6a 5f       	subi	r22, 0xFA	; 250
    56e2:	7f 4f       	sbci	r23, 0xFF	; 255
    56e4:	8d 2f       	mov	r24, r29
    56e6:	9c 2f       	mov	r25, r28
    56e8:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
  fprintf_P(stream, PSTR("->DST:"));
    56ec:	8b e9       	ldi	r24, 0x9B	; 155
    56ee:	9d e0       	ldi	r25, 0x0D	; 13
    56f0:	9f 93       	push	r25
    56f2:	8f 93       	push	r24
    56f4:	cf 93       	push	r28
    56f6:	df 93       	push	r29
    56f8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintEthAddr(stream, &eth_hdr->dest);
    56fc:	8d b7       	in	r24, 0x3d	; 61
    56fe:	9e b7       	in	r25, 0x3e	; 62
    5700:	0e 96       	adiw	r24, 0x0e	; 14
    5702:	0f b6       	in	r0, 0x3f	; 63
    5704:	f8 94       	cli
    5706:	9e bf       	out	0x3e, r25	; 62
    5708:	0f be       	out	0x3f, r0	; 63
    570a:	8d bf       	out	0x3d, r24	; 61
    570c:	b8 01       	movw	r22, r16
    570e:	8d 2f       	mov	r24, r29
    5710:	9c 2f       	mov	r25, r28
}
    5712:	df 91       	pop	r29
    5714:	cf 91       	pop	r28
    5716:	1f 91       	pop	r17
    5718:	0f 91       	pop	r16
{
  fprintf_P(stream, PSTR("Eth Packet Type: 0x%x"), eth_hdr->type);
  fprintf_P(stream, PSTR(" SRC:"));
  netPrintEthAddr(stream, &eth_hdr->src);
  fprintf_P(stream, PSTR("->DST:"));
  netPrintEthAddr(stream, &eth_hdr->dest);
    571a:	0c 94 05 2b 	jmp	0x560a	; 0x560a <netPrintEthAddr>

0000571e <netPrintIpHeader>:
}

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
    571e:	0f 93       	push	r16
    5720:	1f 93       	push	r17
    5722:	cf 93       	push	r28
    5724:	df 93       	push	r29
    5726:	ec 01       	movw	r28, r24
    5728:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Header\r\n"));
    572a:	8f e8       	ldi	r24, 0x8F	; 143
    572c:	9d e0       	ldi	r25, 0x0D	; 13
    572e:	9f 93       	push	r25
    5730:	8f 93       	push	r24
    5732:	df 93       	push	r29
    5734:	cf 93       	push	r28
    5736:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
    573a:	f8 01       	movw	r30, r16
    573c:	80 81       	ld	r24, Z
    573e:	82 95       	swap	r24
    5740:	8f 70       	andi	r24, 0x0F	; 15
    5742:	1f 92       	push	r1
    5744:	8f 93       	push	r24
    5746:	80 e8       	ldi	r24, 0x80	; 128
    5748:	9d e0       	ldi	r25, 0x0D	; 13
    574a:	9f 93       	push	r25
    574c:	8f 93       	push	r24
    574e:	df 93       	push	r29
    5750:	cf 93       	push	r28
    5752:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  return (val<<8) | (val>>8);
}

uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5756:	f8 01       	movw	r30, r16
    5758:	82 81       	ldd	r24, Z+2	; 0x02
    575a:	93 81       	ldd	r25, Z+3	; 0x03
    575c:	98 27       	eor	r25, r24
    575e:	89 27       	eor	r24, r25
    5760:	98 27       	eor	r25, r24

void netPrintIpHeader(FILE *stream, struct netIpHeader* ipheader)
{
  fprintf_P(stream, PSTR("IP Header\r\n"));
  fprintf_P(stream, PSTR("Ver     : %d\r\n"), (ipheader->vhl)>>4);
  fprintf_P(stream, PSTR("Length  : %d\r\n"), htons(ipheader->len));
    5762:	9f 93       	push	r25
    5764:	8f 93       	push	r24
    5766:	81 e7       	ldi	r24, 0x71	; 113
    5768:	9d e0       	ldi	r25, 0x0D	; 13
    576a:	9f 93       	push	r25
    576c:	8f 93       	push	r24
    576e:	df 93       	push	r29
    5770:	cf 93       	push	r28
    5772:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if(ipheader->proto == IP_PROTO_ICMP)
    5776:	f8 01       	movw	r30, r16
    5778:	81 85       	ldd	r24, Z+9	; 0x09
    577a:	2d b7       	in	r18, 0x3d	; 61
    577c:	3e b7       	in	r19, 0x3e	; 62
    577e:	20 5f       	subi	r18, 0xF0	; 240
    5780:	3f 4f       	sbci	r19, 0xFF	; 255
    5782:	0f b6       	in	r0, 0x3f	; 63
    5784:	f8 94       	cli
    5786:	3e bf       	out	0x3e, r19	; 62
    5788:	0f be       	out	0x3f, r0	; 63
    578a:	2d bf       	out	0x3d, r18	; 61
    578c:	81 30       	cpi	r24, 0x01	; 1
    578e:	19 f4       	brne	.+6      	; 0x5796 <netPrintIpHeader+0x78>
    fprintf_P(stream, PSTR("Protocol: ICMP\r\n"));
    5790:	80 e6       	ldi	r24, 0x60	; 96
    5792:	9d e0       	ldi	r25, 0x0D	; 13
    5794:	04 c0       	rjmp	.+8      	; 0x579e <netPrintIpHeader+0x80>
  else if(ipheader->proto == IP_PROTO_TCP)
    5796:	86 30       	cpi	r24, 0x06	; 6
    5798:	69 f4       	brne	.+26     	; 0x57b4 <netPrintIpHeader+0x96>
    fprintf_P(stream, PSTR("Protocol: TCP\r\n"));
    579a:	80 e5       	ldi	r24, 0x50	; 80
    579c:	9d e0       	ldi	r25, 0x0D	; 13
    579e:	9f 93       	push	r25
    57a0:	8f 93       	push	r24
    57a2:	df 93       	push	r29
    57a4:	cf 93       	push	r28
    57a6:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    57aa:	0f 90       	pop	r0
    57ac:	0f 90       	pop	r0
    57ae:	0f 90       	pop	r0
    57b0:	0f 90       	pop	r0
    57b2:	15 c0       	rjmp	.+42     	; 0x57de <netPrintIpHeader+0xc0>
  else if(ipheader->proto == IP_PROTO_UDP)
    57b4:	81 31       	cpi	r24, 0x11	; 17
    57b6:	19 f4       	brne	.+6      	; 0x57be <netPrintIpHeader+0xa0>
    fprintf_P(stream, PSTR("Protocol: UDP\r\n"));
    57b8:	80 e4       	ldi	r24, 0x40	; 64
    57ba:	9d e0       	ldi	r25, 0x0D	; 13
    57bc:	f0 cf       	rjmp	.-32     	; 0x579e <netPrintIpHeader+0x80>
  else
    fprintf_P(stream, PSTR("Protocol: %d\r\n"), ipheader->proto);
    57be:	1f 92       	push	r1
    57c0:	8f 93       	push	r24
    57c2:	81 e3       	ldi	r24, 0x31	; 49
    57c4:	9d e0       	ldi	r25, 0x0D	; 13
    57c6:	9f 93       	push	r25
    57c8:	8f 93       	push	r24
    57ca:	df 93       	push	r29
    57cc:	cf 93       	push	r28
    57ce:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    57d2:	0f 90       	pop	r0
    57d4:	0f 90       	pop	r0
    57d6:	0f 90       	pop	r0
    57d8:	0f 90       	pop	r0
    57da:	0f 90       	pop	r0
    57dc:	0f 90       	pop	r0

  fprintf_P(stream, PSTR("SourceIP: ")); netPrintIPAddr(stream, htonl(ipheader->srcipaddr));   fprintf_P(stream, PSTR("\r\n"));
    57de:	86 e2       	ldi	r24, 0x26	; 38
    57e0:	9d e0       	ldi	r25, 0x0D	; 13
    57e2:	9f 93       	push	r25
    57e4:	8f 93       	push	r24
    57e6:	df 93       	push	r29
    57e8:	cf 93       	push	r28
    57ea:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    57ee:	f8 01       	movw	r30, r16
    57f0:	64 85       	ldd	r22, Z+12	; 0x0c
    57f2:	75 85       	ldd	r23, Z+13	; 0x0d
    57f4:	86 85       	ldd	r24, Z+14	; 0x0e
    57f6:	97 85       	ldd	r25, Z+15	; 0x0f
    57f8:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    57fc:	ab 01       	movw	r20, r22
    57fe:	bc 01       	movw	r22, r24
    5800:	ce 01       	movw	r24, r28
    5802:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    5806:	83 e2       	ldi	r24, 0x23	; 35
    5808:	9d e0       	ldi	r25, 0x0D	; 13
    580a:	9f 93       	push	r25
    580c:	8f 93       	push	r24
    580e:	df 93       	push	r29
    5810:	cf 93       	push	r28
    5812:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Dest  IP: ")); netPrintIPAddr(stream, htonl(ipheader->destipaddr));  fprintf_P(stream, PSTR("\r\n"));
    5816:	88 e1       	ldi	r24, 0x18	; 24
    5818:	9d e0       	ldi	r25, 0x0D	; 13
    581a:	9f 93       	push	r25
    581c:	8f 93       	push	r24
    581e:	df 93       	push	r29
    5820:	cf 93       	push	r28
    5822:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5826:	f8 01       	movw	r30, r16
    5828:	60 89       	ldd	r22, Z+16	; 0x10
    582a:	71 89       	ldd	r23, Z+17	; 0x11
    582c:	82 89       	ldd	r24, Z+18	; 0x12
    582e:	93 89       	ldd	r25, Z+19	; 0x13
    5830:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    5834:	ab 01       	movw	r20, r22
    5836:	bc 01       	movw	r22, r24
    5838:	ce 01       	movw	r24, r28
    583a:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    583e:	85 e1       	ldi	r24, 0x15	; 21
    5840:	9d e0       	ldi	r25, 0x0D	; 13
    5842:	9f 93       	push	r25
    5844:	8f 93       	push	r24
    5846:	df 93       	push	r29
    5848:	cf 93       	push	r28
    584a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    584e:	2d b7       	in	r18, 0x3d	; 61
    5850:	3e b7       	in	r19, 0x3e	; 62
    5852:	20 5f       	subi	r18, 0xF0	; 240
    5854:	3f 4f       	sbci	r19, 0xFF	; 255
    5856:	0f b6       	in	r0, 0x3f	; 63
    5858:	f8 94       	cli
    585a:	3e bf       	out	0x3e, r19	; 62
    585c:	0f be       	out	0x3f, r0	; 63
    585e:	2d bf       	out	0x3d, r18	; 61
}
    5860:	df 91       	pop	r29
    5862:	cf 91       	pop	r28
    5864:	1f 91       	pop	r17
    5866:	0f 91       	pop	r16
    5868:	08 95       	ret

0000586a <netPrintTcpHeader>:

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
    586a:	0f 93       	push	r16
    586c:	1f 93       	push	r17
    586e:	cf 93       	push	r28
    5870:	df 93       	push	r29
    5872:	ec 01       	movw	r28, r24
    5874:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("TCP Header\r\n"));
    5876:	88 e0       	ldi	r24, 0x08	; 8
    5878:	9d e0       	ldi	r25, 0x0D	; 13
    587a:	9f 93       	push	r25
    587c:	8f 93       	push	r24
    587e:	df 93       	push	r29
    5880:	cf 93       	push	r28
    5882:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  return (val<<8) | (val>>8);
}

uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    5886:	f8 01       	movw	r30, r16
    5888:	80 81       	ld	r24, Z
    588a:	91 81       	ldd	r25, Z+1	; 0x01
    588c:	98 27       	eor	r25, r24
    588e:	89 27       	eor	r24, r25
    5890:	98 27       	eor	r25, r24
}

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
    5892:	9f 93       	push	r25
    5894:	8f 93       	push	r24
    5896:	89 ef       	ldi	r24, 0xF9	; 249
    5898:	9c e0       	ldi	r25, 0x0C	; 12
    589a:	9f 93       	push	r25
    589c:	8f 93       	push	r24
    589e:	df 93       	push	r29
    58a0:	cf 93       	push	r28
    58a2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  return (val<<8) | (val>>8);
}

uint16_t htons(uint16_t val)
{
  return (val<<8) | (val>>8);
    58a6:	f8 01       	movw	r30, r16
    58a8:	82 81       	ldd	r24, Z+2	; 0x02
    58aa:	93 81       	ldd	r25, Z+3	; 0x03
    58ac:	98 27       	eor	r25, r24
    58ae:	89 27       	eor	r24, r25
    58b0:	98 27       	eor	r25, r24

void netPrintTcpHeader(FILE *stream, struct netTcpHeader* tcpheader)
{
  fprintf_P(stream, PSTR("TCP Header\r\n"));
  fprintf_P(stream, PSTR("Src Port: %d\r\n"), htons(tcpheader->srcport));
  fprintf_P(stream, PSTR("Dst Port: %d\r\n"), htons(tcpheader->destport));
    58b2:	9f 93       	push	r25
    58b4:	8f 93       	push	r24
    58b6:	8a ee       	ldi	r24, 0xEA	; 234
    58b8:	9c e0       	ldi	r25, 0x0C	; 12
    58ba:	9f 93       	push	r25
    58bc:	8f 93       	push	r24
    58be:	df 93       	push	r29
    58c0:	cf 93       	push	r28
    58c2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Seq Num : 0x%x"), htonl(tcpheader->seqno));
    58c6:	f8 01       	movw	r30, r16
    58c8:	64 81       	ldd	r22, Z+4	; 0x04
    58ca:	75 81       	ldd	r23, Z+5	; 0x05
    58cc:	86 81       	ldd	r24, Z+6	; 0x06
    58ce:	97 81       	ldd	r25, Z+7	; 0x07
    58d0:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    58d4:	9f 93       	push	r25
    58d6:	8f 93       	push	r24
    58d8:	7f 93       	push	r23
    58da:	6f 93       	push	r22
    58dc:	8b ed       	ldi	r24, 0xDB	; 219
    58de:	9c e0       	ldi	r25, 0x0C	; 12
    58e0:	9f 93       	push	r25
    58e2:	8f 93       	push	r24
    58e4:	df 93       	push	r29
    58e6:	cf 93       	push	r28
    58e8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Ack Num : 0x%x\r\n"), htonl(tcpheader->ackno));
    58ec:	f8 01       	movw	r30, r16
    58ee:	60 85       	ldd	r22, Z+8	; 0x08
    58f0:	71 85       	ldd	r23, Z+9	; 0x09
    58f2:	82 85       	ldd	r24, Z+10	; 0x0a
    58f4:	93 85       	ldd	r25, Z+11	; 0x0b
    58f6:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    58fa:	9f 93       	push	r25
    58fc:	8f 93       	push	r24
    58fe:	7f 93       	push	r23
    5900:	6f 93       	push	r22
    5902:	8a ec       	ldi	r24, 0xCA	; 202
    5904:	9c e0       	ldi	r25, 0x0C	; 12
    5906:	9f 93       	push	r25
    5908:	8f 93       	push	r24
    590a:	df 93       	push	r29
    590c:	cf 93       	push	r28
    590e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Flags   : "));
    5912:	8d b7       	in	r24, 0x3d	; 61
    5914:	9e b7       	in	r25, 0x3e	; 62
    5916:	80 96       	adiw	r24, 0x20	; 32
    5918:	0f b6       	in	r0, 0x3f	; 63
    591a:	f8 94       	cli
    591c:	9e bf       	out	0x3e, r25	; 62
    591e:	0f be       	out	0x3f, r0	; 63
    5920:	8d bf       	out	0x3d, r24	; 61
    5922:	8f eb       	ldi	r24, 0xBF	; 191
    5924:	9c e0       	ldi	r25, 0x0C	; 12
    5926:	9f 93       	push	r25
    5928:	8f 93       	push	r24
    592a:	df 93       	push	r29
    592c:	cf 93       	push	r28
    592e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if(tcpheader->flags & TCP_FLAGS_FIN)
    5932:	f8 01       	movw	r30, r16
    5934:	85 85       	ldd	r24, Z+13	; 0x0d
    5936:	0f 90       	pop	r0
    5938:	0f 90       	pop	r0
    593a:	0f 90       	pop	r0
    593c:	0f 90       	pop	r0
    593e:	80 ff       	sbrs	r24, 0
    5940:	0c c0       	rjmp	.+24     	; 0x595a <netPrintTcpHeader+0xf0>
    fprintf_P(stream, PSTR("FIN "));
    5942:	8a eb       	ldi	r24, 0xBA	; 186
    5944:	9c e0       	ldi	r25, 0x0C	; 12
    5946:	9f 93       	push	r25
    5948:	8f 93       	push	r24
    594a:	df 93       	push	r29
    594c:	cf 93       	push	r28
    594e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5952:	0f 90       	pop	r0
    5954:	0f 90       	pop	r0
    5956:	0f 90       	pop	r0
    5958:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_SYN)
    595a:	f8 01       	movw	r30, r16
    595c:	85 85       	ldd	r24, Z+13	; 0x0d
    595e:	81 ff       	sbrs	r24, 1
    5960:	0c c0       	rjmp	.+24     	; 0x597a <netPrintTcpHeader+0x110>
    fprintf_P(stream, PSTR("SYN "));
    5962:	85 eb       	ldi	r24, 0xB5	; 181
    5964:	9c e0       	ldi	r25, 0x0C	; 12
    5966:	9f 93       	push	r25
    5968:	8f 93       	push	r24
    596a:	df 93       	push	r29
    596c:	cf 93       	push	r28
    596e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5972:	0f 90       	pop	r0
    5974:	0f 90       	pop	r0
    5976:	0f 90       	pop	r0
    5978:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_RST)
    597a:	f8 01       	movw	r30, r16
    597c:	85 85       	ldd	r24, Z+13	; 0x0d
    597e:	82 ff       	sbrs	r24, 2
    5980:	0c c0       	rjmp	.+24     	; 0x599a <netPrintTcpHeader+0x130>
    fprintf_P(stream, PSTR("RST "));
    5982:	80 eb       	ldi	r24, 0xB0	; 176
    5984:	9c e0       	ldi	r25, 0x0C	; 12
    5986:	9f 93       	push	r25
    5988:	8f 93       	push	r24
    598a:	df 93       	push	r29
    598c:	cf 93       	push	r28
    598e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5992:	0f 90       	pop	r0
    5994:	0f 90       	pop	r0
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_PSH)
    599a:	f8 01       	movw	r30, r16
    599c:	85 85       	ldd	r24, Z+13	; 0x0d
    599e:	83 ff       	sbrs	r24, 3
    59a0:	0c c0       	rjmp	.+24     	; 0x59ba <netPrintTcpHeader+0x150>
    fprintf_P(stream, PSTR("PSH "));
    59a2:	8b ea       	ldi	r24, 0xAB	; 171
    59a4:	9c e0       	ldi	r25, 0x0C	; 12
    59a6:	9f 93       	push	r25
    59a8:	8f 93       	push	r24
    59aa:	df 93       	push	r29
    59ac:	cf 93       	push	r28
    59ae:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    59b2:	0f 90       	pop	r0
    59b4:	0f 90       	pop	r0
    59b6:	0f 90       	pop	r0
    59b8:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_ACK)
    59ba:	f8 01       	movw	r30, r16
    59bc:	85 85       	ldd	r24, Z+13	; 0x0d
    59be:	84 ff       	sbrs	r24, 4
    59c0:	0c c0       	rjmp	.+24     	; 0x59da <netPrintTcpHeader+0x170>
    fprintf_P(stream, PSTR("ACK "));
    59c2:	86 ea       	ldi	r24, 0xA6	; 166
    59c4:	9c e0       	ldi	r25, 0x0C	; 12
    59c6:	9f 93       	push	r25
    59c8:	8f 93       	push	r24
    59ca:	df 93       	push	r29
    59cc:	cf 93       	push	r28
    59ce:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    59d2:	0f 90       	pop	r0
    59d4:	0f 90       	pop	r0
    59d6:	0f 90       	pop	r0
    59d8:	0f 90       	pop	r0
  if(tcpheader->flags & TCP_FLAGS_URG)
    59da:	f8 01       	movw	r30, r16
    59dc:	85 85       	ldd	r24, Z+13	; 0x0d
    59de:	85 ff       	sbrs	r24, 5
    59e0:	0c c0       	rjmp	.+24     	; 0x59fa <netPrintTcpHeader+0x190>
    fprintf_P(stream, PSTR("URG "));
    59e2:	81 ea       	ldi	r24, 0xA1	; 161
    59e4:	9c e0       	ldi	r25, 0x0C	; 12
    59e6:	9f 93       	push	r25
    59e8:	8f 93       	push	r24
    59ea:	df 93       	push	r29
    59ec:	cf 93       	push	r28
    59ee:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    59f2:	0f 90       	pop	r0
    59f4:	0f 90       	pop	r0
    59f6:	0f 90       	pop	r0
    59f8:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    59fa:	8e e9       	ldi	r24, 0x9E	; 158
    59fc:	9c e0       	ldi	r25, 0x0C	; 12
    59fe:	9f 93       	push	r25
    5a00:	8f 93       	push	r24
    5a02:	df 93       	push	r29
    5a04:	cf 93       	push	r28
    5a06:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5a0a:	0f 90       	pop	r0
    5a0c:	0f 90       	pop	r0
    5a0e:	0f 90       	pop	r0
    5a10:	0f 90       	pop	r0
}
    5a12:	df 91       	pop	r29
    5a14:	cf 91       	pop	r28
    5a16:	1f 91       	pop	r17
    5a18:	0f 91       	pop	r16
    5a1a:	08 95       	ret

00005a1c <ipInit>:
static uint32_t myip_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_IP4   << 24) + ((uint32_t)MY_IP3   <<16) + ((uint32_t)MY_IP2   <<8) + MY_IP1;
static uint32_t mask_eep    __attribute__((section (".eeprom"))) = ((uint32_t)MY_MASK4 << 24) + ((uint32_t)MY_MASK3 <<16) + ((uint32_t)MY_MASK2 <<8) + MY_MASK1;
static uint32_t defGw_eep   __attribute__((section (".eeprom"))) = ((uint32_t)MY_GW4   << 24) + ((uint32_t)MY_GW3   <<16) + ((uint32_t)MY_GW2   <<8) + MY_GW1;

void ipInit()
{
    5a1c:	08 95       	ret

00005a1e <ipLoadConfig>:

}

void ipLoadConfig(void)
{
    5a1e:	cf 93       	push	r28
    5a20:	df 93       	push	r29
  IpMyConfig.ip      = eeprom_read_dword(&myip_eep);
    5a22:	8e e2       	ldi	r24, 0x2E	; 46
    5a24:	90 e0       	ldi	r25, 0x00	; 0
    5a26:	0e 94 4d 53 	call	0xa69a	; 0xa69a <eeprom_read_dword>
    5a2a:	ce e4       	ldi	r28, 0x4E	; 78
    5a2c:	df e0       	ldi	r29, 0x0F	; 15
    5a2e:	68 83       	st	Y, r22
    5a30:	79 83       	std	Y+1, r23	; 0x01
    5a32:	8a 83       	std	Y+2, r24	; 0x02
    5a34:	9b 83       	std	Y+3, r25	; 0x03
  IpMyConfig.netmask = eeprom_read_dword(&mask_eep);
    5a36:	8a e2       	ldi	r24, 0x2A	; 42
    5a38:	90 e0       	ldi	r25, 0x00	; 0
    5a3a:	0e 94 4d 53 	call	0xa69a	; 0xa69a <eeprom_read_dword>
    5a3e:	6c 83       	std	Y+4, r22	; 0x04
    5a40:	7d 83       	std	Y+5, r23	; 0x05
    5a42:	8e 83       	std	Y+6, r24	; 0x06
    5a44:	9f 83       	std	Y+7, r25	; 0x07
  IpMyConfig.gateway = eeprom_read_dword(&defGw_eep);
    5a46:	86 e2       	ldi	r24, 0x26	; 38
    5a48:	90 e0       	ldi	r25, 0x00	; 0
    5a4a:	0e 94 4d 53 	call	0xa69a	; 0xa69a <eeprom_read_dword>
    5a4e:	68 87       	std	Y+8, r22	; 0x08
    5a50:	79 87       	std	Y+9, r23	; 0x09
    5a52:	8a 87       	std	Y+10, r24	; 0x0a
    5a54:	9b 87       	std	Y+11, r25	; 0x0b
#if IP_DEBUG
  IpMyConfig.dbgLevel = 0;
    5a56:	1e 86       	std	Y+14, r1	; 0x0e
  IpMyConfig.dbgStream = NULL;
    5a58:	1d 86       	std	Y+13, r1	; 0x0d
    5a5a:	1c 86       	std	Y+12, r1	; 0x0c
#endif
}
    5a5c:	df 91       	pop	r29
    5a5e:	cf 91       	pop	r28
    5a60:	08 95       	ret

00005a62 <ipSaveConfig>:

void ipSaveConfig(void)
{
    5a62:	cf 93       	push	r28
    5a64:	df 93       	push	r29
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
    5a66:	ce e4       	ldi	r28, 0x4E	; 78
    5a68:	df e0       	ldi	r29, 0x0F	; 15
    5a6a:	48 81       	ld	r20, Y
    5a6c:	59 81       	ldd	r21, Y+1	; 0x01
    5a6e:	6a 81       	ldd	r22, Y+2	; 0x02
    5a70:	7b 81       	ldd	r23, Y+3	; 0x03
    5a72:	8e e2       	ldi	r24, 0x2E	; 46
    5a74:	90 e0       	ldi	r25, 0x00	; 0
    5a76:	0e 94 7a 53 	call	0xa6f4	; 0xa6f4 <eeprom_update_dword>
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
    5a7a:	4c 81       	ldd	r20, Y+4	; 0x04
    5a7c:	5d 81       	ldd	r21, Y+5	; 0x05
    5a7e:	6e 81       	ldd	r22, Y+6	; 0x06
    5a80:	7f 81       	ldd	r23, Y+7	; 0x07
    5a82:	8a e2       	ldi	r24, 0x2A	; 42
    5a84:	90 e0       	ldi	r25, 0x00	; 0
    5a86:	0e 94 7a 53 	call	0xa6f4	; 0xa6f4 <eeprom_update_dword>
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    5a8a:	48 85       	ldd	r20, Y+8	; 0x08
    5a8c:	59 85       	ldd	r21, Y+9	; 0x09
    5a8e:	6a 85       	ldd	r22, Y+10	; 0x0a
    5a90:	7b 85       	ldd	r23, Y+11	; 0x0b
    5a92:	86 e2       	ldi	r24, 0x26	; 38
    5a94:	90 e0       	ldi	r25, 0x00	; 0
}
    5a96:	df 91       	pop	r29
    5a98:	cf 91       	pop	r28

void ipSaveConfig(void)
{
  eeprom_update_dword(&myip_eep,  IpMyConfig.ip);
  eeprom_update_dword(&mask_eep,  IpMyConfig.netmask);
  eeprom_update_dword(&defGw_eep, IpMyConfig.gateway);
    5a9a:	0c 94 7a 53 	jmp	0xa6f4	; 0xa6f4 <eeprom_update_dword>

00005a9e <netstackIPv4Process>:
}

inline void netstackIPv4Process(void)
{
    5a9e:	0f 93       	push	r16
    5aa0:	1f 93       	push	r17
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&                                   //Różne adresy IP
    5aa2:	e0 91 88 0e 	lds	r30, 0x0E88
    5aa6:	f0 91 89 0e 	lds	r31, 0x0E89
    5aaa:	40 89       	ldd	r20, Z+16	; 0x10
    5aac:	51 89       	ldd	r21, Z+17	; 0x11
    5aae:	62 89       	ldd	r22, Z+18	; 0x12
    5ab0:	73 89       	ldd	r23, Z+19	; 0x13
    5ab2:	80 91 4e 0f 	lds	r24, 0x0F4E
    5ab6:	90 91 4f 0f 	lds	r25, 0x0F4F
    5aba:	a0 91 50 0f 	lds	r26, 0x0F50
    5abe:	b0 91 51 0f 	lds	r27, 0x0F51
    5ac2:	48 17       	cp	r20, r24
    5ac4:	59 07       	cpc	r21, r25
    5ac6:	6a 07       	cpc	r22, r26
    5ac8:	7b 07       	cpc	r23, r27
    5aca:	d9 f0       	breq	.+54     	; 0x5b02 <netstackIPv4Process+0x64>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip | (~ipGetConfig()->netmask))) &&     //Nie jest to adres rozgłoszeniowy sieci
    5acc:	00 91 52 0f 	lds	r16, 0x0F52
    5ad0:	10 91 53 0f 	lds	r17, 0x0F53
    5ad4:	20 91 54 0f 	lds	r18, 0x0F54
    5ad8:	30 91 55 0f 	lds	r19, 0x0F55
    5adc:	00 95       	com	r16
    5ade:	10 95       	com	r17
    5ae0:	20 95       	com	r18
    5ae2:	30 95       	com	r19
    5ae4:	80 2b       	or	r24, r16
    5ae6:	91 2b       	or	r25, r17
    5ae8:	a2 2b       	or	r26, r18
    5aea:	b3 2b       	or	r27, r19
}

inline void netstackIPv4Process(void)
{
// check IP addressing, stop processing if not for me and not a broadcast
  if( (nicState.layer3.ip->destipaddr != ipGetConfig()->ip) &&                                   //Różne adresy IP
    5aec:	48 17       	cp	r20, r24
    5aee:	59 07       	cpc	r21, r25
    5af0:	6a 07       	cpc	r22, r26
    5af2:	7b 07       	cpc	r23, r27
    5af4:	31 f0       	breq	.+12     	; 0x5b02 <netstackIPv4Process+0x64>
      (nicState.layer3.ip->destipaddr != (ipGetConfig()->ip | (~ipGetConfig()->netmask))) &&     //Nie jest to adres rozgłoszeniowy sieci
    5af6:	4f 3f       	cpi	r20, 0xFF	; 255
    5af8:	5f 4f       	sbci	r21, 0xFF	; 255
    5afa:	6f 4f       	sbci	r22, 0xFF	; 255
    5afc:	7f 4f       	sbci	r23, 0xFF	; 255
    5afe:	09 f0       	breq	.+2      	; 0x5b02 <netstackIPv4Process+0x64>
    5b00:	59 c0       	rjmp	.+178    	; 0x5bb4 <netstackIPv4Process+0x116>
      (nicState.layer3.ip->destipaddr != 0xFFFFFFFF))                                            //Nie jest to brodcast
    return;

// handle ICMP packet
  if(nicState.layer3.ip->proto == IP_PROTO_ICMP)
    5b02:	21 85       	ldd	r18, Z+9	; 0x09
    5b04:	80 91 5a 0f 	lds	r24, 0x0F5A
    5b08:	90 91 5b 0f 	lds	r25, 0x0F5B
    5b0c:	21 30       	cpi	r18, 0x01	; 1
    5b0e:	41 f5       	brne	.+80     	; 0x5b60 <netstackIPv4Process+0xc2>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    5b10:	00 97       	sbiw	r24, 0x00	; 0
    5b12:	11 f1       	breq	.+68     	; 0x5b58 <netstackIPv4Process+0xba>
    {
      if (IpMyConfig.dbgLevel > 0)
    5b14:	20 91 5c 0f 	lds	r18, 0x0F5C
    5b18:	22 23       	and	r18, r18
    5b1a:	61 f0       	breq	.+24     	; 0x5b34 <netstackIPv4Process+0x96>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
    5b1c:	23 ef       	ldi	r18, 0xF3	; 243
    5b1e:	3e e0       	ldi	r19, 0x0E	; 14
    5b20:	3f 93       	push	r19
    5b22:	2f 93       	push	r18
    5b24:	9f 93       	push	r25
    5b26:	8f 93       	push	r24
    5b28:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5b2c:	0f 90       	pop	r0
    5b2e:	0f 90       	pop	r0
    5b30:	0f 90       	pop	r0
    5b32:	0f 90       	pop	r0
      if (IpMyConfig.dbgLevel > 2)
    5b34:	80 91 5c 0f 	lds	r24, 0x0F5C
    5b38:	83 30       	cpi	r24, 0x03	; 3
    5b3a:	70 f0       	brcs	.+28     	; 0x5b58 <netstackIPv4Process+0xba>
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    5b3c:	40 91 8a 0e 	lds	r20, 0x0E8A
    5b40:	50 91 8b 0e 	lds	r21, 0x0E8B
    5b44:	60 91 88 0e 	lds	r22, 0x0E88
    5b48:	70 91 89 0e 	lds	r23, 0x0E89
    5b4c:	80 91 5a 0f 	lds	r24, 0x0F5A
    5b50:	90 91 5b 0f 	lds	r25, 0x0F5B
    5b54:	0e 94 5f 2f 	call	0x5ebe	; 0x5ebe <icmpPrintHeader>
  {
    if (IpMyConfig.dbgLevel > 0)
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
  }
#endif /*IP_DEBUG*/
}
    5b58:	1f 91       	pop	r17
    5b5a:	0f 91       	pop	r16
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: ICMP/IP packet\r\n"));
      if (IpMyConfig.dbgLevel > 2)
        icmpPrintHeader(IpMyConfig.dbgStream, nicState.layer3.ip, nicState.layer4.icmp);
    }
#endif /*IP_DEBUG*/
    icmpIpIn();
    5b5c:	0c 94 4b 30 	jmp	0x6096	; 0x6096 <icmpIpIn>
    return;
  }
  if( nicState.layer3.ip->proto == IP_PROTO_UDP )
    5b60:	21 31       	cpi	r18, 0x11	; 17
    5b62:	b1 f4       	brne	.+44     	; 0x5b90 <netstackIPv4Process+0xf2>
  {
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    5b64:	00 97       	sbiw	r24, 0x00	; 0
    5b66:	81 f0       	breq	.+32     	; 0x5b88 <netstackIPv4Process+0xea>
    {
      if (IpMyConfig.dbgLevel > 0)
    5b68:	20 91 5c 0f 	lds	r18, 0x0F5C
    5b6c:	22 23       	and	r18, r18
    5b6e:	61 f0       	breq	.+24     	; 0x5b88 <netstackIPv4Process+0xea>
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    5b70:	2b ed       	ldi	r18, 0xDB	; 219
    5b72:	3e e0       	ldi	r19, 0x0E	; 14
    5b74:	3f 93       	push	r19
    5b76:	2f 93       	push	r18
    5b78:	9f 93       	push	r25
    5b7a:	8f 93       	push	r24
    5b7c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5b80:	0f 90       	pop	r0
    5b82:	0f 90       	pop	r0
    5b84:	0f 90       	pop	r0
    5b86:	0f 90       	pop	r0
  {
    if (IpMyConfig.dbgLevel > 0)
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
  }
#endif /*IP_DEBUG*/
}
    5b88:	1f 91       	pop	r17
    5b8a:	0f 91       	pop	r16
    {
      if (IpMyConfig.dbgLevel > 0)
        fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: UDP/IP packet\r\n"));
    }
#endif /*IP_DEBUG*/
    netstackUDPIPProcess();
    5b8c:	0c 94 13 37 	jmp	0x6e26	; 0x6e26 <netstackUDPIPProcess>
    netstackTCPIPProcess();
    return;
  }
#endif
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    5b90:	00 97       	sbiw	r24, 0x00	; 0
    5b92:	81 f0       	breq	.+32     	; 0x5bb4 <netstackIPv4Process+0x116>
  {
    if (IpMyConfig.dbgLevel > 0)
    5b94:	20 91 5c 0f 	lds	r18, 0x0F5C
    5b98:	22 23       	and	r18, r18
    5b9a:	61 f0       	breq	.+24     	; 0x5bb4 <netstackIPv4Process+0x116>
      fprintf_P(IpMyConfig.dbgStream, PSTR("NET Rx: Unknown IP packet\r\n"));
    5b9c:	2f eb       	ldi	r18, 0xBF	; 191
    5b9e:	3e e0       	ldi	r19, 0x0E	; 14
    5ba0:	3f 93       	push	r19
    5ba2:	2f 93       	push	r18
    5ba4:	9f 93       	push	r25
    5ba6:	8f 93       	push	r24
    5ba8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5bac:	0f 90       	pop	r0
    5bae:	0f 90       	pop	r0
    5bb0:	0f 90       	pop	r0
    5bb2:	0f 90       	pop	r0
  }
#endif /*IP_DEBUG*/
}
    5bb4:	1f 91       	pop	r17
    5bb6:	0f 91       	pop	r16
    5bb8:	08 95       	ret

00005bba <setIpDebug>:

#if IP_DEBUG
void setIpDebug(FILE *stream, uint8_t level)
{
  IpMyConfig.dbgStream = stream;
    5bba:	90 93 5b 0f 	sts	0x0F5B, r25
    5bbe:	80 93 5a 0f 	sts	0x0F5A, r24
  IpMyConfig.dbgLevel = level;
    5bc2:	60 93 5c 0f 	sts	0x0F5C, r22
  if (level == 0)
    5bc6:	61 11       	cpse	r22, r1
    5bc8:	04 c0       	rjmp	.+8      	; 0x5bd2 <setIpDebug+0x18>
    IpMyConfig.dbgStream = NULL;
    5bca:	10 92 5b 0f 	sts	0x0F5B, r1
    5bce:	10 92 5a 0f 	sts	0x0F5A, r1
    5bd2:	08 95       	ret

00005bd4 <ipSetConfig>:
}
#endif

void ipSetConfig(uint32_t myIp, uint32_t netmask, uint32_t gatewayIp)
{
    5bd4:	ef 92       	push	r14
    5bd6:	ff 92       	push	r15
    5bd8:	0f 93       	push	r16
    5bda:	1f 93       	push	r17
  // set local addressing
  IpMyConfig.ip = myIp;
    5bdc:	ee e4       	ldi	r30, 0x4E	; 78
    5bde:	ff e0       	ldi	r31, 0x0F	; 15
    5be0:	60 83       	st	Z, r22
    5be2:	71 83       	std	Z+1, r23	; 0x01
    5be4:	82 83       	std	Z+2, r24	; 0x02
    5be6:	93 83       	std	Z+3, r25	; 0x03
  IpMyConfig.netmask = netmask;
    5be8:	24 83       	std	Z+4, r18	; 0x04
    5bea:	35 83       	std	Z+5, r19	; 0x05
    5bec:	46 83       	std	Z+6, r20	; 0x06
    5bee:	57 83       	std	Z+7, r21	; 0x07
  IpMyConfig.gateway = gatewayIp;
    5bf0:	e0 86       	std	Z+8, r14	; 0x08
    5bf2:	f1 86       	std	Z+9, r15	; 0x09
    5bf4:	02 87       	std	Z+10, r16	; 0x0a
    5bf6:	13 87       	std	Z+11, r17	; 0x0b
}
    5bf8:	1f 91       	pop	r17
    5bfa:	0f 91       	pop	r16
    5bfc:	ff 90       	pop	r15
    5bfe:	ef 90       	pop	r14
    5c00:	08 95       	ret

00005c02 <ipSetConfigIp>:

void ipSetConfigIp(uint32_t myIp)
{
  // set local addressing
  IpMyConfig.ip = myIp;
    5c02:	60 93 4e 0f 	sts	0x0F4E, r22
    5c06:	70 93 4f 0f 	sts	0x0F4F, r23
    5c0a:	80 93 50 0f 	sts	0x0F50, r24
    5c0e:	90 93 51 0f 	sts	0x0F51, r25
    5c12:	08 95       	ret

00005c14 <ipSetConfigMask>:
}

void ipSetConfigMask(uint32_t netmask)
{
  IpMyConfig.netmask = netmask;
    5c14:	60 93 52 0f 	sts	0x0F52, r22
    5c18:	70 93 53 0f 	sts	0x0F53, r23
    5c1c:	80 93 54 0f 	sts	0x0F54, r24
    5c20:	90 93 55 0f 	sts	0x0F55, r25
    5c24:	08 95       	ret

00005c26 <ipSetConfigGw>:
}

void ipSetConfigGw(uint32_t gatewayIp)
{
  IpMyConfig.gateway = gatewayIp;
    5c26:	60 93 56 0f 	sts	0x0F56, r22
    5c2a:	70 93 57 0f 	sts	0x0F57, r23
    5c2e:	80 93 58 0f 	sts	0x0F58, r24
    5c32:	90 93 59 0f 	sts	0x0F59, r25
    5c36:	08 95       	ret

00005c38 <ipGetConfig>:


struct ipConfig* ipGetConfig(void)
{
  return &IpMyConfig;
}
    5c38:	8e e4       	ldi	r24, 0x4E	; 78
    5c3a:	9f e0       	ldi	r25, 0x0F	; 15
    5c3c:	08 95       	ret

00005c3e <ipSend>:

void ipSend(uint32_t dstIp, uint8_t protocol, uint16_t len)
{
    5c3e:	af 92       	push	r10
    5c40:	bf 92       	push	r11
    5c42:	cf 92       	push	r12
    5c44:	df 92       	push	r13
    5c46:	ef 92       	push	r14
    5c48:	ff 92       	push	r15
    5c4a:	0f 93       	push	r16
    5c4c:	1f 93       	push	r17
    5c4e:	cf 93       	push	r28
    5c50:	df 93       	push	r29
    5c52:	1f 92       	push	r1
    5c54:	cd b7       	in	r28, 0x3d	; 61
    5c56:	de b7       	in	r29, 0x3e	; 62
    5c58:	6b 01       	movw	r12, r22
    5c5a:	7c 01       	movw	r14, r24
    5c5c:	89 01       	movw	r16, r18
// make pointer to ethernet/IP header
#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    5c5e:	20 91 5a 0f 	lds	r18, 0x0F5A
    5c62:	30 91 5b 0f 	lds	r19, 0x0F5B
    5c66:	21 15       	cp	r18, r1
    5c68:	31 05       	cpc	r19, r1
    5c6a:	91 f0       	breq	.+36     	; 0x5c90 <ipSend+0x52>
  {
    if (IpMyConfig.dbgLevel > 2)
    5c6c:	80 91 5c 0f 	lds	r24, 0x0F5C
    5c70:	83 30       	cpi	r24, 0x03	; 3
    5c72:	70 f0       	brcs	.+28     	; 0x5c90 <ipSend+0x52>
      fprintf_P(IpMyConfig.dbgStream, "Sending Ip packet\r\n");
    5c74:	82 e5       	ldi	r24, 0x52	; 82
    5c76:	91 e0       	ldi	r25, 0x01	; 1
    5c78:	9f 93       	push	r25
    5c7a:	8f 93       	push	r24
    5c7c:	3f 93       	push	r19
    5c7e:	2f 93       	push	r18
    5c80:	49 83       	std	Y+1, r20	; 0x01
    5c82:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5c86:	0f 90       	pop	r0
    5c88:	0f 90       	pop	r0
    5c8a:	0f 90       	pop	r0
    5c8c:	0f 90       	pop	r0
    5c8e:	49 81       	ldd	r20, Y+1	; 0x01

// adjust length to add IP header
  len += IP_HEADER_LEN;

// fill IP header
  nicState.layer3.ip->destipaddr = dstIp;
    5c90:	a0 90 88 0e 	lds	r10, 0x0E88
    5c94:	b0 90 89 0e 	lds	r11, 0x0E89
    5c98:	f5 01       	movw	r30, r10
    5c9a:	c0 8a       	std	Z+16, r12	; 0x10
    5c9c:	d1 8a       	std	Z+17, r13	; 0x11
    5c9e:	e2 8a       	std	Z+18, r14	; 0x12
    5ca0:	f3 8a       	std	Z+19, r15	; 0x13
  nicState.layer3.ip->srcipaddr  = IpMyConfig.ip;
    5ca2:	80 91 4e 0f 	lds	r24, 0x0F4E
    5ca6:	90 91 4f 0f 	lds	r25, 0x0F4F
    5caa:	a0 91 50 0f 	lds	r26, 0x0F50
    5cae:	b0 91 51 0f 	lds	r27, 0x0F51
    5cb2:	84 87       	std	Z+12, r24	; 0x0c
    5cb4:	95 87       	std	Z+13, r25	; 0x0d
    5cb6:	a6 87       	std	Z+14, r26	; 0x0e
    5cb8:	b7 87       	std	Z+15, r27	; 0x0f
  nicState.layer3.ip->proto      = protocol;
    5cba:	41 87       	std	Z+9, r20	; 0x09
  nicState.layer3.ip->len        = htons(len);
    5cbc:	c8 01       	movw	r24, r16
    5cbe:	44 96       	adiw	r24, 0x14	; 20
    5cc0:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    5cc4:	f5 01       	movw	r30, r10
    5cc6:	93 83       	std	Z+3, r25	; 0x03
    5cc8:	82 83       	std	Z+2, r24	; 0x02
  nicState.layer3.ip->vhl        = 0x45;
    5cca:	a0 90 88 0e 	lds	r10, 0x0E88
    5cce:	b0 90 89 0e 	lds	r11, 0x0E89
    5cd2:	85 e4       	ldi	r24, 0x45	; 69
    5cd4:	f5 01       	movw	r30, r10
    5cd6:	80 83       	st	Z, r24
  nicState.layer3.ip->tos        = 0;
    5cd8:	11 82       	std	Z+1, r1	; 0x01
  nicState.layer3.ip->ipid       = 0;
    5cda:	15 82       	std	Z+5, r1	; 0x05
    5cdc:	14 82       	std	Z+4, r1	; 0x04
  nicState.layer3.ip->ipoffset   = 0;
    5cde:	17 82       	std	Z+7, r1	; 0x07
    5ce0:	16 82       	std	Z+6, r1	; 0x06
  nicState.layer3.ip->ttl        = IP_TIME_TO_LIVE;
    5ce2:	80 e8       	ldi	r24, 0x80	; 128
    5ce4:	80 87       	std	Z+8, r24	; 0x08
  nicState.layer3.ip->ipchksum   = 0;
    5ce6:	13 86       	std	Z+11, r1	; 0x0b
    5ce8:	12 86       	std	Z+10, r1	; 0x0a

// calculate and apply IP checksum
// DO THIS ONLY AFTER ALL CHANGES HAVE BEEN MADE TO IP HEADER
  nicState.layer3.ip->ipchksum   = netChecksum((uint8_t *)(nicState.layer3.ip), IP_HEADER_LEN);
    5cea:	64 e1       	ldi	r22, 0x14	; 20
    5cec:	70 e0       	ldi	r23, 0x00	; 0
    5cee:	c5 01       	movw	r24, r10
    5cf0:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <netChecksum>
    5cf4:	f5 01       	movw	r30, r10
    5cf6:	93 87       	std	Z+11, r25	; 0x0b
    5cf8:	82 87       	std	Z+10, r24	; 0x0a

// add ethernet routing
// check if we need to send to gateway
  if( (dstIp & IpMyConfig.netmask) == (IpMyConfig.ip & IpMyConfig.netmask) )
    5cfa:	80 91 4e 0f 	lds	r24, 0x0F4E
    5cfe:	90 91 4f 0f 	lds	r25, 0x0F4F
    5d02:	a0 91 50 0f 	lds	r26, 0x0F50
    5d06:	b0 91 51 0f 	lds	r27, 0x0F51
    5d0a:	8c 25       	eor	r24, r12
    5d0c:	9d 25       	eor	r25, r13
    5d0e:	ae 25       	eor	r26, r14
    5d10:	bf 25       	eor	r27, r15
    5d12:	40 91 52 0f 	lds	r20, 0x0F52
    5d16:	50 91 53 0f 	lds	r21, 0x0F53
    5d1a:	60 91 54 0f 	lds	r22, 0x0F54
    5d1e:	70 91 55 0f 	lds	r23, 0x0F55
    5d22:	84 23       	and	r24, r20
    5d24:	95 23       	and	r25, r21
    5d26:	a6 23       	and	r26, r22
    5d28:	b7 23       	and	r27, r23
    5d2a:	89 2b       	or	r24, r25
    5d2c:	8a 2b       	or	r24, r26
    5d2e:	8b 2b       	or	r24, r27
    5d30:	71 f4       	brne	.+28     	; 0x5d4e <ipSend+0x110>
  {
    arpIpOut(0);  // local send
    5d32:	60 e0       	ldi	r22, 0x00	; 0
    5d34:	70 e0       	ldi	r23, 0x00	; 0
    5d36:	cb 01       	movw	r24, r22
    5d38:	0e 94 52 31 	call	0x62a4	; 0x62a4 <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    5d3c:	80 91 5a 0f 	lds	r24, 0x0F5A
    5d40:	90 91 5b 0f 	lds	r25, 0x0F5B
    5d44:	00 97       	sbiw	r24, 0x00	; 0
    5d46:	f9 f0       	breq	.+62     	; 0x5d86 <ipSend+0x148>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet on local net\r\n"));
    5d48:	2e e9       	ldi	r18, 0x9E	; 158
    5d4a:	3e e0       	ldi	r19, 0x0E	; 14
    5d4c:	12 c0       	rjmp	.+36     	; 0x5d72 <ipSend+0x134>
#endif
  }
  else
  {
    arpIpOut(IpMyConfig.gateway);  // gateway send
    5d4e:	60 91 56 0f 	lds	r22, 0x0F56
    5d52:	70 91 57 0f 	lds	r23, 0x0F57
    5d56:	80 91 58 0f 	lds	r24, 0x0F58
    5d5a:	90 91 59 0f 	lds	r25, 0x0F59
    5d5e:	0e 94 52 31 	call	0x62a4	; 0x62a4 <arpIpOut>
#if IP_DEBUG
    if (IpMyConfig.dbgStream != NULL)
    5d62:	80 91 5a 0f 	lds	r24, 0x0F5A
    5d66:	90 91 5b 0f 	lds	r25, 0x0F5B
    5d6a:	00 97       	sbiw	r24, 0x00	; 0
    5d6c:	61 f0       	breq	.+24     	; 0x5d86 <ipSend+0x148>
      fprintf_P(IpMyConfig.dbgStream, PSTR("Sending IP packet to gateway\r\n"));
    5d6e:	2f e7       	ldi	r18, 0x7F	; 127
    5d70:	3e e0       	ldi	r19, 0x0E	; 14
    5d72:	3f 93       	push	r19
    5d74:	2f 93       	push	r18
    5d76:	9f 93       	push	r25
    5d78:	8f 93       	push	r24
    5d7a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5d7e:	0f 90       	pop	r0
    5d80:	0f 90       	pop	r0
    5d82:	0f 90       	pop	r0
    5d84:	0f 90       	pop	r0
#endif
  }

// adjust length to add ethernet header
  len += ETH_HEADER_LEN;
    5d86:	0e 5d       	subi	r16, 0xDE	; 222
    5d88:	1f 4f       	sbci	r17, 0xFF	; 255

#if IP_DEBUG
  if (IpMyConfig.dbgStream != NULL)
    5d8a:	80 91 5a 0f 	lds	r24, 0x0F5A
    5d8e:	90 91 5b 0f 	lds	r25, 0x0F5B
    5d92:	00 97       	sbiw	r24, 0x00	; 0
    5d94:	e9 f0       	breq	.+58     	; 0x5dd0 <ipSend+0x192>
  {
    if (IpMyConfig.dbgLevel > 3)
    5d96:	20 91 5c 0f 	lds	r18, 0x0F5C
    5d9a:	24 30       	cpi	r18, 0x04	; 4
    5d9c:	c8 f0       	brcs	.+50     	; 0x5dd0 <ipSend+0x192>
    {
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(ETH_HEADER_LEN, &data[0]);"));
    5d9e:	21 e5       	ldi	r18, 0x51	; 81
    5da0:	3e e0       	ldi	r19, 0x0E	; 14
    5da2:	3f 93       	push	r19
    5da4:	2f 93       	push	r18
    5da6:	9f 93       	push	r25
    5da8:	8f 93       	push	r24
    5daa:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    5dae:	82 e1       	ldi	r24, 0x12	; 18
    5db0:	9e e0       	ldi	r25, 0x0E	; 14
    5db2:	9f 93       	push	r25
    5db4:	8f 93       	push	r24
    5db6:	80 91 5b 0f 	lds	r24, 0x0F5B
    5dba:	8f 93       	push	r24
    5dbc:	80 91 5a 0f 	lds	r24, 0x0F5A
    5dc0:	8f 93       	push	r24
    5dc2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5dc6:	0f b6       	in	r0, 0x3f	; 63
    5dc8:	f8 94       	cli
    5dca:	de bf       	out	0x3e, r29	; 62
    5dcc:	0f be       	out	0x3f, r0	; 63
    5dce:	cd bf       	out	0x3d, r28	; 61
    }
  }
#endif
// send it
  nicSend(len);
    5dd0:	c8 01       	movw	r24, r16
}
    5dd2:	0f 90       	pop	r0
    5dd4:	df 91       	pop	r29
    5dd6:	cf 91       	pop	r28
    5dd8:	1f 91       	pop	r17
    5dda:	0f 91       	pop	r16
    5ddc:	ff 90       	pop	r15
    5dde:	ef 90       	pop	r14
    5de0:	df 90       	pop	r13
    5de2:	cf 90       	pop	r12
    5de4:	bf 90       	pop	r11
    5de6:	af 90       	pop	r10
      fprintf_P(IpMyConfig.dbgStream, PSTR("debugPrintHexTable(len-ETH_HEADER_LEN, &data[ETH_HEADER_LEN]);"));
    }
  }
#endif
// send it
  nicSend(len);
    5de8:	0c 94 0e 28 	jmp	0x501c	; 0x501c <nicSend>

00005dec <ipPrintConfig>:
}

void ipPrintConfig(FILE *stream, struct ipConfig* config)
{
    5dec:	0f 93       	push	r16
    5dee:	1f 93       	push	r17
    5df0:	cf 93       	push	r28
    5df2:	df 93       	push	r29
    5df4:	ec 01       	movw	r28, r24
    5df6:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("IP Addr : ")); netPrintIPAddr(stream, config->ip);        fprintf_P(stream, PSTR("\r\n"));
    5df8:	87 e0       	ldi	r24, 0x07	; 7
    5dfa:	9e e0       	ldi	r25, 0x0E	; 14
    5dfc:	9f 93       	push	r25
    5dfe:	8f 93       	push	r24
    5e00:	df 93       	push	r29
    5e02:	cf 93       	push	r28
    5e04:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5e08:	f8 01       	movw	r30, r16
    5e0a:	40 81       	ld	r20, Z
    5e0c:	51 81       	ldd	r21, Z+1	; 0x01
    5e0e:	62 81       	ldd	r22, Z+2	; 0x02
    5e10:	73 81       	ldd	r23, Z+3	; 0x03
    5e12:	ce 01       	movw	r24, r28
    5e14:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    5e18:	84 e0       	ldi	r24, 0x04	; 4
    5e1a:	9e e0       	ldi	r25, 0x0E	; 14
    5e1c:	9f 93       	push	r25
    5e1e:	8f 93       	push	r24
    5e20:	df 93       	push	r29
    5e22:	cf 93       	push	r28
    5e24:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Netmask : ")); netPrintIPAddr(stream, config->netmask);   fprintf_P(stream, PSTR("\r\n"));
    5e28:	89 ef       	ldi	r24, 0xF9	; 249
    5e2a:	9d e0       	ldi	r25, 0x0D	; 13
    5e2c:	9f 93       	push	r25
    5e2e:	8f 93       	push	r24
    5e30:	df 93       	push	r29
    5e32:	cf 93       	push	r28
    5e34:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5e38:	f8 01       	movw	r30, r16
    5e3a:	44 81       	ldd	r20, Z+4	; 0x04
    5e3c:	55 81       	ldd	r21, Z+5	; 0x05
    5e3e:	66 81       	ldd	r22, Z+6	; 0x06
    5e40:	77 81       	ldd	r23, Z+7	; 0x07
    5e42:	ce 01       	movw	r24, r28
    5e44:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    5e48:	86 ef       	ldi	r24, 0xF6	; 246
    5e4a:	9d e0       	ldi	r25, 0x0D	; 13
    5e4c:	9f 93       	push	r25
    5e4e:	8f 93       	push	r24
    5e50:	df 93       	push	r29
    5e52:	cf 93       	push	r28
    5e54:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("Gateway : ")); netPrintIPAddr(stream, config->gateway);   fprintf_P(stream, PSTR("\r\n"));
    5e58:	8b ee       	ldi	r24, 0xEB	; 235
    5e5a:	9d e0       	ldi	r25, 0x0D	; 13
    5e5c:	9f 93       	push	r25
    5e5e:	8f 93       	push	r24
    5e60:	df 93       	push	r29
    5e62:	cf 93       	push	r28
    5e64:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5e68:	f8 01       	movw	r30, r16
    5e6a:	40 85       	ldd	r20, Z+8	; 0x08
    5e6c:	51 85       	ldd	r21, Z+9	; 0x09
    5e6e:	62 85       	ldd	r22, Z+10	; 0x0a
    5e70:	73 85       	ldd	r23, Z+11	; 0x0b
    5e72:	ce 01       	movw	r24, r28
    5e74:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    5e78:	88 ee       	ldi	r24, 0xE8	; 232
    5e7a:	9d e0       	ldi	r25, 0x0D	; 13
    5e7c:	9f 93       	push	r25
    5e7e:	8f 93       	push	r24
    5e80:	df 93       	push	r29
    5e82:	cf 93       	push	r28
    5e84:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5e88:	8d b7       	in	r24, 0x3d	; 61
    5e8a:	9e b7       	in	r25, 0x3e	; 62
    5e8c:	48 96       	adiw	r24, 0x18	; 24
    5e8e:	0f b6       	in	r0, 0x3f	; 63
    5e90:	f8 94       	cli
    5e92:	9e bf       	out	0x3e, r25	; 62
    5e94:	0f be       	out	0x3f, r0	; 63
    5e96:	8d bf       	out	0x3d, r24	; 61
}
    5e98:	df 91       	pop	r29
    5e9a:	cf 91       	pop	r28
    5e9c:	1f 91       	pop	r17
    5e9e:	0f 91       	pop	r16
    5ea0:	08 95       	ret

00005ea2 <icmpInit>:


// functions
void icmpInit(void)
{
  icmpDebug = NULL;
    5ea2:	10 92 ab 0e 	sts	0x0EAB, r1
    5ea6:	10 92 aa 0e 	sts	0x0EAA, r1
  icmpDebugLevel = 0;
    5eaa:	10 92 4b 0f 	sts	0x0F4B, r1
    5eae:	08 95       	ret

00005eb0 <setIcmpDebug>:
}

#if ICMP_DEBUG
void setIcmpDebug(FILE *stream, uint8_t level)
{
  icmpDebug = stream;
    5eb0:	90 93 ab 0e 	sts	0x0EAB, r25
    5eb4:	80 93 aa 0e 	sts	0x0EAA, r24
  icmpDebugLevel = level;
    5eb8:	60 93 4b 0f 	sts	0x0F4B, r22
    5ebc:	08 95       	ret

00005ebe <icmpPrintHeader>:
}
#endif

void icmpPrintHeader(FILE *stream, struct netIpHeader *ipPacket, struct netIcmpHeader *icmpPacket)
{
    5ebe:	ef 92       	push	r14
    5ec0:	ff 92       	push	r15
    5ec2:	0f 93       	push	r16
    5ec4:	1f 93       	push	r17
    5ec6:	cf 93       	push	r28
    5ec8:	df 93       	push	r29
    5eca:	ec 01       	movw	r28, r24
    5ecc:	7b 01       	movw	r14, r22
    5ece:	8a 01       	movw	r16, r20
  fprintf_P(stream, PSTR("ICMP Packet:\r\n"));
    5ed0:	89 e4       	ldi	r24, 0x49	; 73
    5ed2:	9f e0       	ldi	r25, 0x0F	; 15
    5ed4:	9f 93       	push	r25
    5ed6:	8f 93       	push	r24
    5ed8:	df 93       	push	r29
    5eda:	cf 93       	push	r28
    5edc:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print source IP address
  fprintf_P(stream, PSTR("SrcIpAddr: "));  netPrintIPAddr(stream, ipPacket->srcipaddr);  fprintf_P(stream, PSTR("\r\n"));
    5ee0:	8d e3       	ldi	r24, 0x3D	; 61
    5ee2:	9f e0       	ldi	r25, 0x0F	; 15
    5ee4:	9f 93       	push	r25
    5ee6:	8f 93       	push	r24
    5ee8:	df 93       	push	r29
    5eea:	cf 93       	push	r28
    5eec:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5ef0:	f7 01       	movw	r30, r14
    5ef2:	44 85       	ldd	r20, Z+12	; 0x0c
    5ef4:	55 85       	ldd	r21, Z+13	; 0x0d
    5ef6:	66 85       	ldd	r22, Z+14	; 0x0e
    5ef8:	77 85       	ldd	r23, Z+15	; 0x0f
    5efa:	ce 01       	movw	r24, r28
    5efc:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    5f00:	8a e3       	ldi	r24, 0x3A	; 58
    5f02:	9f e0       	ldi	r25, 0x0F	; 15
    5f04:	9f 93       	push	r25
    5f06:	8f 93       	push	r24
    5f08:	df 93       	push	r29
    5f0a:	cf 93       	push	r28
    5f0c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print dest IP address
  fprintf_P(stream, PSTR("DstIpAddr: "));  netPrintIPAddr(stream, ipPacket->destipaddr); fprintf_P(stream, PSTR("\r\n"));
    5f10:	8e e2       	ldi	r24, 0x2E	; 46
    5f12:	9f e0       	ldi	r25, 0x0F	; 15
    5f14:	9f 93       	push	r25
    5f16:	8f 93       	push	r24
    5f18:	df 93       	push	r29
    5f1a:	cf 93       	push	r28
    5f1c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5f20:	f7 01       	movw	r30, r14
    5f22:	40 89       	ldd	r20, Z+16	; 0x10
    5f24:	51 89       	ldd	r21, Z+17	; 0x11
    5f26:	62 89       	ldd	r22, Z+18	; 0x12
    5f28:	73 89       	ldd	r23, Z+19	; 0x13
    5f2a:	ce 01       	movw	r24, r28
    5f2c:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    5f30:	8b e2       	ldi	r24, 0x2B	; 43
    5f32:	9f e0       	ldi	r25, 0x0F	; 15
    5f34:	9f 93       	push	r25
    5f36:	8f 93       	push	r24
    5f38:	df 93       	push	r29
    5f3a:	cf 93       	push	r28
    5f3c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print type
  fprintf_P(stream, PSTR("Type: 0x%x    "), icmpPacket->type);
    5f40:	f8 01       	movw	r30, r16
    5f42:	80 81       	ld	r24, Z
    5f44:	1f 92       	push	r1
    5f46:	8f 93       	push	r24
    5f48:	8c e1       	ldi	r24, 0x1C	; 28
    5f4a:	9f e0       	ldi	r25, 0x0F	; 15
    5f4c:	9f 93       	push	r25
    5f4e:	8f 93       	push	r24
    5f50:	df 93       	push	r29
    5f52:	cf 93       	push	r28
    5f54:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
//    fprintf_P(stream, ("???"));
//    break;
//}
//  fprintf_P(stream, PSTR("\r\n"));
// print code
  fprintf_P(stream, PSTR("Code   : 0x%x\r\n"), icmpPacket->icode);
    5f58:	f8 01       	movw	r30, r16
    5f5a:	81 81       	ldd	r24, Z+1	; 0x01
    5f5c:	1f 92       	push	r1
    5f5e:	8f 93       	push	r24
    5f60:	8c e0       	ldi	r24, 0x0C	; 12
    5f62:	9f e0       	ldi	r25, 0x0F	; 15
    5f64:	9f 93       	push	r25
    5f66:	8f 93       	push	r24
    5f68:	df 93       	push	r29
    5f6a:	cf 93       	push	r28
    5f6c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5f70:	8d b7       	in	r24, 0x3d	; 61
    5f72:	9e b7       	in	r25, 0x3e	; 62
    5f74:	80 96       	adiw	r24, 0x20	; 32
    5f76:	0f b6       	in	r0, 0x3f	; 63
    5f78:	f8 94       	cli
    5f7a:	9e bf       	out	0x3e, r25	; 62
    5f7c:	0f be       	out	0x3f, r0	; 63
    5f7e:	8d bf       	out	0x3d, r24	; 61
}
    5f80:	df 91       	pop	r29
    5f82:	cf 91       	pop	r28
    5f84:	1f 91       	pop	r17
    5f86:	0f 91       	pop	r16
    5f88:	ff 90       	pop	r15
    5f8a:	ef 90       	pop	r14
    5f8c:	08 95       	ret

00005f8e <icmpEchoRequest>:
      break;
  }
}

void icmpEchoRequest(void)
{
    5f8e:	cf 93       	push	r28
    5f90:	df 93       	push	r29
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    5f92:	80 91 aa 0e 	lds	r24, 0x0EAA
    5f96:	90 91 ab 0e 	lds	r25, 0x0EAB
    5f9a:	00 97       	sbiw	r24, 0x00	; 0
    5f9c:	81 f0       	breq	.+32     	; 0x5fbe <icmpEchoRequest+0x30>
  {
    if (icmpDebugLevel > 1)
    5f9e:	20 91 4b 0f 	lds	r18, 0x0F4B
    5fa2:	22 30       	cpi	r18, 0x02	; 2
    5fa4:	60 f0       	brcs	.+24     	; 0x5fbe <icmpEchoRequest+0x30>
      fprintf_P(icmpDebug, PSTR("Received ICMP request: "));
    5fa6:	2c e6       	ldi	r18, 0x6C	; 108
    5fa8:	3f e0       	ldi	r19, 0x0F	; 15
    5faa:	3f 93       	push	r19
    5fac:	2f 93       	push	r18
    5fae:	9f 93       	push	r25
    5fb0:	8f 93       	push	r24
    5fb2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    5fb6:	0f 90       	pop	r0
    5fb8:	0f 90       	pop	r0
    5fba:	0f 90       	pop	r0
    5fbc:	0f 90       	pop	r0
  }
#endif
  uint32_t tempIp;

  // change type to reply
  nicState.layer4.icmp->type = ICMP_TYPE_ECHOREPLY;
    5fbe:	e0 91 8a 0e 	lds	r30, 0x0E8A
    5fc2:	f0 91 8b 0e 	lds	r31, 0x0E8B
    5fc6:	10 82       	st	Z, r1
  // recalculate checksum
  nicState.layer4.icmp->icmpchksum = 0;
    5fc8:	e0 91 8a 0e 	lds	r30, 0x0E8A
    5fcc:	f0 91 8b 0e 	lds	r31, 0x0E8B
    5fd0:	13 82       	std	Z+3, r1	; 0x03
    5fd2:	12 82       	std	Z+2, r1	; 0x02
  nicState.layer4.icmp->icmpchksum = netChecksum((uint8_t*)(nicState.layer4.icmp), htons(nicState.layer3.ip->len)-IP_HEADER_LEN);
    5fd4:	e0 91 88 0e 	lds	r30, 0x0E88
    5fd8:	f0 91 89 0e 	lds	r31, 0x0E89
    5fdc:	82 81       	ldd	r24, Z+2	; 0x02
    5fde:	93 81       	ldd	r25, Z+3	; 0x03
    5fe0:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    5fe4:	c0 91 8a 0e 	lds	r28, 0x0E8A
    5fe8:	d0 91 8b 0e 	lds	r29, 0x0E8B
    5fec:	bc 01       	movw	r22, r24
    5fee:	64 51       	subi	r22, 0x14	; 20
    5ff0:	71 09       	sbc	r23, r1
    5ff2:	ce 01       	movw	r24, r28
    5ff4:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <netChecksum>
    5ff8:	9b 83       	std	Y+3, r25	; 0x03
    5ffa:	8a 83       	std	Y+2, r24	; 0x02
  // return to sender
  tempIp = nicState.layer3.ip->destipaddr;
    5ffc:	e0 91 88 0e 	lds	r30, 0x0E88
    6000:	f0 91 89 0e 	lds	r31, 0x0E89
    6004:	80 89       	ldd	r24, Z+16	; 0x10
    6006:	91 89       	ldd	r25, Z+17	; 0x11
    6008:	a2 89       	ldd	r26, Z+18	; 0x12
    600a:	b3 89       	ldd	r27, Z+19	; 0x13
  nicState.layer3.ip->destipaddr = nicState.layer3.ip->srcipaddr;
    600c:	44 85       	ldd	r20, Z+12	; 0x0c
    600e:	55 85       	ldd	r21, Z+13	; 0x0d
    6010:	66 85       	ldd	r22, Z+14	; 0x0e
    6012:	77 85       	ldd	r23, Z+15	; 0x0f
    6014:	40 8b       	std	Z+16, r20	; 0x10
    6016:	51 8b       	std	Z+17, r21	; 0x11
    6018:	62 8b       	std	Z+18, r22	; 0x12
    601a:	73 8b       	std	Z+19, r23	; 0x13
  nicState.layer3.ip->srcipaddr = tempIp;
    601c:	84 87       	std	Z+12, r24	; 0x0c
    601e:	95 87       	std	Z+13, r25	; 0x0d
    6020:	a6 87       	std	Z+14, r26	; 0x0e
    6022:	b7 87       	std	Z+15, r27	; 0x0f
  // add ethernet routing
  arpIpOut(0);
    6024:	60 e0       	ldi	r22, 0x00	; 0
    6026:	70 e0       	ldi	r23, 0x00	; 0
    6028:	cb 01       	movw	r24, r22
    602a:	0e 94 52 31 	call	0x62a4	; 0x62a4 <arpIpOut>

  // debugging
  if (icmpDebug != NULL)
    602e:	80 91 aa 0e 	lds	r24, 0x0EAA
    6032:	90 91 ab 0e 	lds	r25, 0x0EAB
    6036:	00 97       	sbiw	r24, 0x00	; 0
    6038:	51 f0       	breq	.+20     	; 0x604e <icmpEchoRequest+0xc0>
    icmpPrintHeader(icmpDebug, nicState.layer3.ip, nicState.layer4.icmp);
    603a:	40 91 8a 0e 	lds	r20, 0x0E8A
    603e:	50 91 8b 0e 	lds	r21, 0x0E8B
    6042:	60 91 88 0e 	lds	r22, 0x0E88
    6046:	70 91 89 0e 	lds	r23, 0x0E89
    604a:	0e 94 5f 2f 	call	0x5ebe	; 0x5ebe <icmpPrintHeader>
  //debugPrintHexTable(htons(packet->ip.len), (uint8_t*)packet);

  // send it (packet->ip.len+ETH_HEADER_LEN
  nicSend(htons(nicState.layer3.ip->len) + ETH_HEADER_LEN);
    604e:	e0 91 88 0e 	lds	r30, 0x0E88
    6052:	f0 91 89 0e 	lds	r31, 0x0E89
    6056:	82 81       	ldd	r24, Z+2	; 0x02
    6058:	93 81       	ldd	r25, Z+3	; 0x03
    605a:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    605e:	0e 96       	adiw	r24, 0x0e	; 14
    6060:	0e 94 0e 28 	call	0x501c	; 0x501c <nicSend>
#if ICMP_DEBUG
  if (icmpDebug != NULL)
    6064:	80 91 aa 0e 	lds	r24, 0x0EAA
    6068:	90 91 ab 0e 	lds	r25, 0x0EAB
    606c:	00 97       	sbiw	r24, 0x00	; 0
    606e:	81 f0       	breq	.+32     	; 0x6090 <icmpEchoRequest+0x102>
  {
    if (icmpDebugLevel > 1)
    6070:	20 91 4b 0f 	lds	r18, 0x0F4B
    6074:	22 30       	cpi	r18, 0x02	; 2
    6076:	60 f0       	brcs	.+24     	; 0x6090 <icmpEchoRequest+0x102>
      fprintf_P(icmpDebug, PSTR("Sending ICMP PONG\r\n"));
    6078:	28 e5       	ldi	r18, 0x58	; 88
    607a:	3f e0       	ldi	r19, 0x0F	; 15
    607c:	3f 93       	push	r19
    607e:	2f 93       	push	r18
    6080:	9f 93       	push	r25
    6082:	8f 93       	push	r24
    6084:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6088:	0f 90       	pop	r0
    608a:	0f 90       	pop	r0
    608c:	0f 90       	pop	r0
    608e:	0f 90       	pop	r0
  }
#endif
}
    6090:	df 91       	pop	r29
    6092:	cf 91       	pop	r28
    6094:	08 95       	ret

00006096 <icmpIpIn>:
}

void icmpIpIn(void)
{
  // check ICMP type
  switch(nicState.layer4.icmp->type)
    6096:	e0 91 8a 0e 	lds	r30, 0x0E8A
    609a:	f0 91 8b 0e 	lds	r31, 0x0E8B
    609e:	80 81       	ld	r24, Z
    60a0:	88 30       	cpi	r24, 0x08	; 8
    60a2:	11 f4       	brne	.+4      	; 0x60a8 <icmpIpIn+0x12>
  {
    case ICMP_TYPE_ECHOREQUEST:
      icmpEchoRequest();       // echo request
    60a4:	0c 94 c7 2f 	jmp	0x5f8e	; 0x5f8e <icmpEchoRequest>
      break;
    default:
#if ICMP_DEBUG
      if (icmpDebug != NULL)
    60a8:	80 91 aa 0e 	lds	r24, 0x0EAA
    60ac:	90 91 ab 0e 	lds	r25, 0x0EAB
    60b0:	00 97       	sbiw	r24, 0x00	; 0
    60b2:	81 f0       	breq	.+32     	; 0x60d4 <icmpIpIn+0x3e>
      {
        if (icmpDebugLevel > 0)
    60b4:	20 91 4b 0f 	lds	r18, 0x0F4B
    60b8:	22 23       	and	r18, r18
    60ba:	61 f0       	breq	.+24     	; 0x60d4 <icmpIpIn+0x3e>
          fprintf_P(icmpDebug, PSTR("Unknown ICMP typeReceived ICMP request: "));
    60bc:	24 e8       	ldi	r18, 0x84	; 132
    60be:	3f e0       	ldi	r19, 0x0F	; 15
    60c0:	3f 93       	push	r19
    60c2:	2f 93       	push	r18
    60c4:	9f 93       	push	r25
    60c6:	8f 93       	push	r24
    60c8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    60cc:	0f 90       	pop	r0
    60ce:	0f 90       	pop	r0
    60d0:	0f 90       	pop	r0
    60d2:	0f 90       	pop	r0
    60d4:	08 95       	ret

000060d6 <setArpDebug>:

#ifdef ARP_DEBUG

void setArpDebug(FILE *stream, uint8_t level)
{
  arpDebug = stream;
    60d6:	90 93 8d 0e 	sts	0x0E8D, r25
    60da:	80 93 8c 0e 	sts	0x0E8C, r24
  arpDebugLevel = level;
    60de:	60 93 5d 0f 	sts	0x0F5D, r22
  if (level == 0)
    60e2:	61 11       	cpse	r22, r1
    60e4:	04 c0       	rjmp	.+8      	; 0x60ee <setArpDebug+0x18>
    arpDebug = NULL;
    60e6:	10 92 8d 0e 	sts	0x0E8D, r1
    60ea:	10 92 8c 0e 	sts	0x0E8C, r1
    60ee:	08 95       	ret

000060f0 <arpInit>:
#endif /*ARP_DEBUG*/

void arpInit()
{

  memset(ArpTable, 0, sizeof(ArpTable));
    60f0:	8e e6       	ldi	r24, 0x6E	; 110
    60f2:	e8 e6       	ldi	r30, 0x68	; 104
    60f4:	ff e0       	ldi	r31, 0x0F	; 15
    60f6:	df 01       	movw	r26, r30
    60f8:	1d 92       	st	X+, r1
    60fa:	8a 95       	dec	r24
    60fc:	e9 f7       	brne	.-6      	; 0x60f8 <arpInit+0x8>
  arpDebug = NULL;
    60fe:	10 92 8d 0e 	sts	0x0E8D, r1
    6102:	10 92 8c 0e 	sts	0x0E8C, r1
    6106:	08 95       	ret

00006108 <arpTimer>:
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
  }
}

void arpTimer(void)
{
    6108:	e2 e7       	ldi	r30, 0x72	; 114
    610a:	ff e0       	ldi	r31, 0x0F	; 15
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time)
    610c:	80 81       	ld	r24, Z
    610e:	88 23       	and	r24, r24
    6110:	11 f0       	breq	.+4      	; 0x6116 <arpTimer+0xe>
      ArpTable[index].time--;
    6112:	81 50       	subi	r24, 0x01	; 1
    6114:	80 83       	st	Z, r24
    6116:	3b 96       	adiw	r30, 0x0b	; 11
{
  int index;
// this function meant to be called on a regular time interval

// decrement time-to-live for all entries
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6118:	8f e0       	ldi	r24, 0x0F	; 15
    611a:	e0 3e       	cpi	r30, 0xE0	; 224
    611c:	f8 07       	cpc	r31, r24
    611e:	b1 f7       	brne	.-20     	; 0x610c <arpTimer+0x4>
  {
    if(ArpTable[index].time)
      ArpTable[index].time--;
  }
}
    6120:	08 95       	ret

00006122 <arpMatchIp>:

int arpMatchIp(uint32_t ipaddr)
{
    6122:	0f 93       	push	r16
    6124:	1f 93       	push	r17
    6126:	e8 e6       	ldi	r30, 0x68	; 104
    6128:	ff e0       	ldi	r31, 0x0F	; 15
    612a:	20 e0       	ldi	r18, 0x00	; 0
    612c:	30 e0       	ldi	r19, 0x00	; 0
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if(ArpTable[i].ipaddr == ipaddr)
    612e:	a9 01       	movw	r20, r18
    6130:	00 81       	ld	r16, Z
    6132:	11 81       	ldd	r17, Z+1	; 0x01
    6134:	22 81       	ldd	r18, Z+2	; 0x02
    6136:	33 81       	ldd	r19, Z+3	; 0x03
    6138:	06 17       	cp	r16, r22
    613a:	17 07       	cpc	r17, r23
    613c:	28 07       	cpc	r18, r24
    613e:	39 07       	cpc	r19, r25
    6140:	49 f0       	breq	.+18     	; 0x6154 <arpMatchIp+0x32>
    6142:	9a 01       	movw	r18, r20
    6144:	2f 5f       	subi	r18, 0xFF	; 255
    6146:	3f 4f       	sbci	r19, 0xFF	; 255
    6148:	3b 96       	adiw	r30, 0x0b	; 11
int arpMatchIp(uint32_t ipaddr)
{
  uint8_t i;

  // check if IP address is present in arp table
  for(i=0; i<ARP_TABLE_SIZE; i++)
    614a:	2a 30       	cpi	r18, 0x0A	; 10
    614c:	31 05       	cpc	r19, r1
    614e:	79 f7       	brne	.-34     	; 0x612e <arpMatchIp+0xc>
      return i;
    }
  }

// no match
  return -1;
    6150:	4f ef       	ldi	r20, 0xFF	; 255
    6152:	5f ef       	ldi	r21, 0xFF	; 255
}
    6154:	ca 01       	movw	r24, r20
    6156:	1f 91       	pop	r17
    6158:	0f 91       	pop	r16
    615a:	08 95       	ret

0000615c <arpIpIn>:
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
  }
}

void arpIpIn(void)
{
    615c:	cf 93       	push	r28
    615e:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    6160:	80 91 8c 0e 	lds	r24, 0x0E8C
    6164:	90 91 8d 0e 	lds	r25, 0x0E8D
    6168:	00 97       	sbiw	r24, 0x00	; 0
    616a:	09 f4       	brne	.+2      	; 0x616e <arpIpIn+0x12>
    616c:	47 c0       	rjmp	.+142    	; 0x61fc <arpIpIn+0xa0>
  {
    if (arpDebugLevel > 0)
    616e:	20 91 5d 0f 	lds	r18, 0x0F5D
    6172:	22 23       	and	r18, r18
    6174:	09 f4       	brne	.+2      	; 0x6178 <arpIpIn+0x1c>
    6176:	42 c0       	rjmp	.+132    	; 0x61fc <arpIpIn+0xa0>
    {
      fprintf_P(arpDebug, PSTR("ARP IP in MAC: "));
    6178:	27 e9       	ldi	r18, 0x97	; 151
    617a:	30 e1       	ldi	r19, 0x10	; 16
    617c:	3f 93       	push	r19
    617e:	2f 93       	push	r18
    6180:	9f 93       	push	r25
    6182:	8f 93       	push	r24
    6184:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
      netPrintEthAddr(arpDebug, &nicState.layer2.ethHeader->src);
    6188:	60 91 86 0e 	lds	r22, 0x0E86
    618c:	70 91 87 0e 	lds	r23, 0x0E87
    6190:	6a 5f       	subi	r22, 0xFA	; 250
    6192:	7f 4f       	sbci	r23, 0xFF	; 255
    6194:	80 91 8c 0e 	lds	r24, 0x0E8C
    6198:	90 91 8d 0e 	lds	r25, 0x0E8D
    619c:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
      fprintf_P(arpDebug, PSTR(" IP: "));
    61a0:	81 e9       	ldi	r24, 0x91	; 145
    61a2:	90 e1       	ldi	r25, 0x10	; 16
    61a4:	9f 93       	push	r25
    61a6:	8f 93       	push	r24
    61a8:	80 91 8d 0e 	lds	r24, 0x0E8D
    61ac:	8f 93       	push	r24
    61ae:	80 91 8c 0e 	lds	r24, 0x0E8C
    61b2:	8f 93       	push	r24
    61b4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
      netPrintIPAddr(arpDebug, nicState.layer3.ip->srcipaddr);
    61b8:	e0 91 88 0e 	lds	r30, 0x0E88
    61bc:	f0 91 89 0e 	lds	r31, 0x0E89
    61c0:	44 85       	ldd	r20, Z+12	; 0x0c
    61c2:	55 85       	ldd	r21, Z+13	; 0x0d
    61c4:	66 85       	ldd	r22, Z+14	; 0x0e
    61c6:	77 85       	ldd	r23, Z+15	; 0x0f
    61c8:	80 91 8c 0e 	lds	r24, 0x0E8C
    61cc:	90 91 8d 0e 	lds	r25, 0x0E8D
    61d0:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
      fprintf_P(arpDebug, PSTR("\r\n"));
    61d4:	8e e8       	ldi	r24, 0x8E	; 142
    61d6:	90 e1       	ldi	r25, 0x10	; 16
    61d8:	9f 93       	push	r25
    61da:	8f 93       	push	r24
    61dc:	80 91 8d 0e 	lds	r24, 0x0E8D
    61e0:	8f 93       	push	r24
    61e2:	80 91 8c 0e 	lds	r24, 0x0E8C
    61e6:	8f 93       	push	r24
    61e8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    61ec:	8d b7       	in	r24, 0x3d	; 61
    61ee:	9e b7       	in	r25, 0x3e	; 62
    61f0:	0c 96       	adiw	r24, 0x0c	; 12
    61f2:	0f b6       	in	r0, 0x3f	; 63
    61f4:	f8 94       	cli
    61f6:	9e bf       	out	0x3e, r25	; 62
    61f8:	0f be       	out	0x3f, r0	; 63
    61fa:	8d bf       	out	0x3d, r24	; 61
  }
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
    61fc:	c0 91 88 0e 	lds	r28, 0x0E88
    6200:	d0 91 89 0e 	lds	r29, 0x0E89
    6204:	6c 85       	ldd	r22, Y+12	; 0x0c
    6206:	7d 85       	ldd	r23, Y+13	; 0x0d
    6208:	8e 85       	ldd	r24, Y+14	; 0x0e
    620a:	9f 85       	ldd	r25, Y+15	; 0x0f
    620c:	0e 94 91 30 	call	0x6122	; 0x6122 <arpMatchIp>
  if(index != -1)
    6210:	8f 3f       	cpi	r24, 0xFF	; 255
    6212:	b9 f0       	breq	.+46     	; 0x6242 <arpIpIn+0xe6>
  {
// sender's IP address found, update ARP entry
    ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6214:	2b e0       	ldi	r18, 0x0B	; 11
    6216:	82 02       	muls	r24, r18
    6218:	c0 01       	movw	r24, r0
    621a:	11 24       	eor	r1, r1
    621c:	dc 01       	movw	r26, r24
    621e:	a4 59       	subi	r26, 0x94	; 148
    6220:	b0 4f       	sbci	r27, 0xF0	; 240
    6222:	e0 91 86 0e 	lds	r30, 0x0E86
    6226:	f0 91 87 0e 	lds	r31, 0x0E87
    622a:	26 e0       	ldi	r18, 0x06	; 6
    622c:	36 96       	adiw	r30, 0x06	; 6
    622e:	01 90       	ld	r0, Z+
    6230:	0d 92       	st	X+, r0
    6232:	2a 95       	dec	r18
    6234:	e1 f7       	brne	.-8      	; 0x622e <arpIpIn+0xd2>
    ArpTable[index].time = ARP_CACHE_TIME_TO_LIVE;
    6236:	fc 01       	movw	r30, r24
    6238:	e8 59       	subi	r30, 0x98	; 152
    623a:	f0 4f       	sbci	r31, 0xF0	; 240
    623c:	20 e8       	ldi	r18, 0x80	; 128
    623e:	22 87       	std	Z+10, r18	; 0x0a
// and we're done
    return;
    6240:	2e c0       	rjmp	.+92     	; 0x629e <arpIpIn+0x142>
    6242:	e2 e7       	ldi	r30, 0x72	; 114
    6244:	ff e0       	ldi	r31, 0x0F	; 15
#endif
  int8_t index;

// check if sender is already present in arp table
  index = arpMatchIp(nicState.layer3.ip->srcipaddr);
  if(index != -1)
    6246:	20 e0       	ldi	r18, 0x00	; 0
    6248:	30 e0       	ldi	r19, 0x00	; 0

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
  {
    if(ArpTable[index].time == 0)
    624a:	80 81       	ld	r24, Z
    624c:	81 11       	cpse	r24, r1
    624e:	21 c0       	rjmp	.+66     	; 0x6292 <arpIpIn+0x136>
    {
// write entry
      ArpTable[index].ethaddr = nicState.layer2.ethHeader->src;
    6250:	4b e0       	ldi	r20, 0x0B	; 11
    6252:	42 9f       	mul	r20, r18
    6254:	c0 01       	movw	r24, r0
    6256:	43 9f       	mul	r20, r19
    6258:	90 0d       	add	r25, r0
    625a:	11 24       	eor	r1, r1
    625c:	dc 01       	movw	r26, r24
    625e:	a4 59       	subi	r26, 0x94	; 148
    6260:	b0 4f       	sbci	r27, 0xF0	; 240
    6262:	e0 91 86 0e 	lds	r30, 0x0E86
    6266:	f0 91 87 0e 	lds	r31, 0x0E87
    626a:	26 e0       	ldi	r18, 0x06	; 6
    626c:	36 96       	adiw	r30, 0x06	; 6
    626e:	01 90       	ld	r0, Z+
    6270:	0d 92       	st	X+, r0
    6272:	2a 95       	dec	r18
    6274:	e1 f7       	brne	.-8      	; 0x626e <arpIpIn+0x112>
      ArpTable[index].ipaddr  = nicState.layer3.ip->srcipaddr;
    6276:	fc 01       	movw	r30, r24
    6278:	e8 59       	subi	r30, 0x98	; 152
    627a:	f0 4f       	sbci	r31, 0xF0	; 240
    627c:	8c 85       	ldd	r24, Y+12	; 0x0c
    627e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6280:	ae 85       	ldd	r26, Y+14	; 0x0e
    6282:	bf 85       	ldd	r27, Y+15	; 0x0f
    6284:	80 83       	st	Z, r24
    6286:	91 83       	std	Z+1, r25	; 0x01
    6288:	a2 83       	std	Z+2, r26	; 0x02
    628a:	b3 83       	std	Z+3, r27	; 0x03
      ArpTable[index].time    = ARP_CACHE_TIME_TO_LIVE;
    628c:	80 e8       	ldi	r24, 0x80	; 128
    628e:	82 87       	std	Z+10, r24	; 0x0a
// and we're done
      return;
    6290:	06 c0       	rjmp	.+12     	; 0x629e <arpIpIn+0x142>
    6292:	2f 5f       	subi	r18, 0xFF	; 255
    6294:	3f 4f       	sbci	r19, 0xFF	; 255
    6296:	3b 96       	adiw	r30, 0x0b	; 11
    return;
  }

// sender was not present in table,
// must add in empty/expired slot
  for(index=0; index<ARP_TABLE_SIZE; index++)
    6298:	2a 30       	cpi	r18, 0x0A	; 10
    629a:	31 05       	cpc	r19, r1
    629c:	b1 f6       	brne	.-84     	; 0x624a <arpIpIn+0xee>
// and we're done
      return;
    }
  }
// no space in table, we give up
}
    629e:	df 91       	pop	r29
    62a0:	cf 91       	pop	r28
    62a2:	08 95       	ret

000062a4 <arpIpOut>:
void arpIpOut(uint32_t phyDstIp)
{
  int index;
// check if destination is already present in arp table
// use the physical dstIp if it's provided, otherwise the dstIp in packet
  if(phyDstIp)
    62a4:	61 15       	cp	r22, r1
    62a6:	71 05       	cpc	r23, r1
    62a8:	81 05       	cpc	r24, r1
    62aa:	91 05       	cpc	r25, r1
    62ac:	41 f4       	brne	.+16     	; 0x62be <arpIpOut+0x1a>
    index = arpMatchIp(phyDstIp);
  else
    index = arpMatchIp(nicState.layer3.ip->destipaddr);
    62ae:	e0 91 88 0e 	lds	r30, 0x0E88
    62b2:	f0 91 89 0e 	lds	r31, 0x0E89
    62b6:	60 89       	ldd	r22, Z+16	; 0x10
    62b8:	71 89       	ldd	r23, Z+17	; 0x11
    62ba:	82 89       	ldd	r24, Z+18	; 0x12
    62bc:	93 89       	ldd	r25, Z+19	; 0x13
    62be:	0e 94 91 30 	call	0x6122	; 0x6122 <arpMatchIp>
    62c2:	a0 91 86 0e 	lds	r26, 0x0E86
    62c6:	b0 91 87 0e 	lds	r27, 0x0E87
// fill in ethernet info
  if(index != -1)
    62ca:	8f 3f       	cpi	r24, 0xFF	; 255
    62cc:	2f ef       	ldi	r18, 0xFF	; 255
    62ce:	92 07       	cpc	r25, r18
    62d0:	d1 f0       	breq	.+52     	; 0x6306 <arpIpOut+0x62>
  {
// ARP entry present, fill eth address(es)
    nicState.layer2.ethHeader->src      = nicState.mac;
    62d2:	26 e0       	ldi	r18, 0x06	; 6
    62d4:	e0 e8       	ldi	r30, 0x80	; 128
    62d6:	fe e0       	ldi	r31, 0x0E	; 14
    62d8:	16 96       	adiw	r26, 0x06	; 6
    62da:	01 90       	ld	r0, Z+
    62dc:	0d 92       	st	X+, r0
    62de:	2a 95       	dec	r18
    62e0:	e1 f7       	brne	.-8      	; 0x62da <arpIpOut+0x36>
    nicState.layer2.ethHeader->dest     = ArpTable[index].ethaddr;
    62e2:	a0 91 86 0e 	lds	r26, 0x0E86
    62e6:	b0 91 87 0e 	lds	r27, 0x0E87
    62ea:	2b e0       	ldi	r18, 0x0B	; 11
    62ec:	28 9f       	mul	r18, r24
    62ee:	f0 01       	movw	r30, r0
    62f0:	29 9f       	mul	r18, r25
    62f2:	f0 0d       	add	r31, r0
    62f4:	11 24       	eor	r1, r1
    62f6:	e4 59       	subi	r30, 0x94	; 148
    62f8:	f0 4f       	sbci	r31, 0xF0	; 240
    62fa:	86 e0       	ldi	r24, 0x06	; 6
    62fc:	01 90       	ld	r0, Z+
    62fe:	0d 92       	st	X+, r0
    6300:	8a 95       	dec	r24
    6302:	e1 f7       	brne	.-8      	; 0x62fc <arpIpOut+0x58>
    6304:	12 c0       	rjmp	.+36     	; 0x632a <arpIpOut+0x86>
    nicState.layer2.ethHeader->type     = HTONS(ETHTYPE_IP);
  }
  else
  {
// not in table, must send ARP request
    nicState.layer2.ethHeader->src      = nicState.mac;
    6306:	86 e0       	ldi	r24, 0x06	; 6
    6308:	e0 e8       	ldi	r30, 0x80	; 128
    630a:	fe e0       	ldi	r31, 0x0E	; 14
    630c:	16 96       	adiw	r26, 0x06	; 6
    630e:	01 90       	ld	r0, Z+
    6310:	0d 92       	st	X+, r0
    6312:	8a 95       	dec	r24
    6314:	e1 f7       	brne	.-8      	; 0x630e <arpIpOut+0x6a>
// TODO MUST CHANGE, but for now, send this one broadcast
// before sending frame, must copy buffer
    memset(nicState.layer2.ethHeader->dest.addr, 0xFF, 6);
    6316:	46 e0       	ldi	r20, 0x06	; 6
    6318:	50 e0       	ldi	r21, 0x00	; 0
    631a:	6f ef       	ldi	r22, 0xFF	; 255
    631c:	70 e0       	ldi	r23, 0x00	; 0
    631e:	80 91 86 0e 	lds	r24, 0x0E86
    6322:	90 91 87 0e 	lds	r25, 0x0E87
    6326:	0e 94 7f 4f 	call	0x9efe	; 0x9efe <memset>
    nicState.layer2.ethHeader->type = HTONS(ETHTYPE_IP);
    632a:	e0 91 86 0e 	lds	r30, 0x0E86
    632e:	f0 91 87 0e 	lds	r31, 0x0E87
    6332:	88 e0       	ldi	r24, 0x08	; 8
    6334:	90 e0       	ldi	r25, 0x00	; 0
    6336:	95 87       	std	Z+13, r25	; 0x0d
    6338:	84 87       	std	Z+12, r24	; 0x0c
    633a:	08 95       	ret

0000633c <arpPrintHeader>:
  return -1;
}

#if ARP_DEBUG
void arpPrintHeader(FILE *stream, struct netArpHeader* packet)
{
    633c:	ef 92       	push	r14
    633e:	ff 92       	push	r15
    6340:	0f 93       	push	r16
    6342:	1f 93       	push	r17
    6344:	cf 93       	push	r28
    6346:	df 93       	push	r29
    6348:	ec 01       	movw	r28, r24
    634a:	8b 01       	movw	r16, r22
  fprintf_P(stream, PSTR("ARP Packet:\r\n"));
    634c:	80 e8       	ldi	r24, 0x80	; 128
    634e:	90 e1       	ldi	r25, 0x10	; 16
    6350:	9f 93       	push	r25
    6352:	8f 93       	push	r24
    6354:	df 93       	push	r29
    6356:	cf 93       	push	r28
    6358:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  //debugPrintHexTable(60, (unsigned char*)&packet);
  // print operation type
  fprintf_P(stream, PSTR("Operation   : "));
    635c:	81 e7       	ldi	r24, 0x71	; 113
    635e:	90 e1       	ldi	r25, 0x10	; 16
    6360:	9f 93       	push	r25
    6362:	8f 93       	push	r24
    6364:	df 93       	push	r29
    6366:	cf 93       	push	r28
    6368:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if(packet->opcode == htons(ARP_OPCODE_REQUEST))
    636c:	f8 01       	movw	r30, r16
    636e:	e6 80       	ldd	r14, Z+6	; 0x06
    6370:	f7 80       	ldd	r15, Z+7	; 0x07
    6372:	81 e0       	ldi	r24, 0x01	; 1
    6374:	90 e0       	ldi	r25, 0x00	; 0
    6376:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    637a:	2d b7       	in	r18, 0x3d	; 61
    637c:	3e b7       	in	r19, 0x3e	; 62
    637e:	28 5f       	subi	r18, 0xF8	; 248
    6380:	3f 4f       	sbci	r19, 0xFF	; 255
    6382:	0f b6       	in	r0, 0x3f	; 63
    6384:	f8 94       	cli
    6386:	3e bf       	out	0x3e, r19	; 62
    6388:	0f be       	out	0x3f, r0	; 63
    638a:	2d bf       	out	0x3d, r18	; 61
    638c:	e8 16       	cp	r14, r24
    638e:	f9 06       	cpc	r15, r25
    6390:	19 f4       	brne	.+6      	; 0x6398 <arpPrintHeader+0x5c>
    fprintf_P(stream, PSTR("REQUEST"));
    6392:	89 e6       	ldi	r24, 0x69	; 105
    6394:	90 e1       	ldi	r25, 0x10	; 16
    6396:	0f c0       	rjmp	.+30     	; 0x63b6 <arpPrintHeader+0x7a>
  else if(packet->opcode == htons(ARP_OPCODE_REPLY))
    6398:	f8 01       	movw	r30, r16
    639a:	e6 80       	ldd	r14, Z+6	; 0x06
    639c:	f7 80       	ldd	r15, Z+7	; 0x07
    639e:	82 e0       	ldi	r24, 0x02	; 2
    63a0:	90 e0       	ldi	r25, 0x00	; 0
    63a2:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    63a6:	e8 16       	cp	r14, r24
    63a8:	f9 06       	cpc	r15, r25
    63aa:	19 f4       	brne	.+6      	; 0x63b2 <arpPrintHeader+0x76>
    fprintf_P(stream, PSTR("REPLY"));
    63ac:	83 e6       	ldi	r24, 0x63	; 99
    63ae:	90 e1       	ldi	r25, 0x10	; 16
    63b0:	02 c0       	rjmp	.+4      	; 0x63b6 <arpPrintHeader+0x7a>
  else
    fprintf_P(stream, PSTR("UNKNOWN"));
    63b2:	8b e5       	ldi	r24, 0x5B	; 91
    63b4:	90 e1       	ldi	r25, 0x10	; 16
    63b6:	9f 93       	push	r25
    63b8:	8f 93       	push	r24
    63ba:	df 93       	push	r29
    63bc:	cf 93       	push	r28
    63be:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    63c2:	0f 90       	pop	r0
    63c4:	0f 90       	pop	r0
    63c6:	0f 90       	pop	r0
    63c8:	0f 90       	pop	r0
  fprintf_P(stream, PSTR("\r\n"));
    63ca:	88 e5       	ldi	r24, 0x58	; 88
    63cc:	90 e1       	ldi	r25, 0x10	; 16
    63ce:	9f 93       	push	r25
    63d0:	8f 93       	push	r24
    63d2:	df 93       	push	r29
    63d4:	cf 93       	push	r28
    63d6:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print source hardware address
  fprintf_P(stream, PSTR("SrcHwAddr   : "));  netPrintEthAddr(stream, &packet->shwaddr);   fprintf_P(stream, PSTR("\r\n"));
    63da:	89 e4       	ldi	r24, 0x49	; 73
    63dc:	90 e1       	ldi	r25, 0x10	; 16
    63de:	9f 93       	push	r25
    63e0:	8f 93       	push	r24
    63e2:	df 93       	push	r29
    63e4:	cf 93       	push	r28
    63e6:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    63ea:	b8 01       	movw	r22, r16
    63ec:	68 5f       	subi	r22, 0xF8	; 248
    63ee:	7f 4f       	sbci	r23, 0xFF	; 255
    63f0:	ce 01       	movw	r24, r28
    63f2:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
    63f6:	86 e4       	ldi	r24, 0x46	; 70
    63f8:	90 e1       	ldi	r25, 0x10	; 16
    63fa:	9f 93       	push	r25
    63fc:	8f 93       	push	r24
    63fe:	df 93       	push	r29
    6400:	cf 93       	push	r28
    6402:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print source protocol address
  fprintf_P(stream, PSTR("SrcProtoAddr: "));  netPrintIPAddr(stream, packet->sipaddr);     fprintf_P(stream, PSTR("\r\n"));
    6406:	87 e3       	ldi	r24, 0x37	; 55
    6408:	90 e1       	ldi	r25, 0x10	; 16
    640a:	9f 93       	push	r25
    640c:	8f 93       	push	r24
    640e:	df 93       	push	r29
    6410:	cf 93       	push	r28
    6412:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6416:	f8 01       	movw	r30, r16
    6418:	46 85       	ldd	r20, Z+14	; 0x0e
    641a:	57 85       	ldd	r21, Z+15	; 0x0f
    641c:	60 89       	ldd	r22, Z+16	; 0x10
    641e:	71 89       	ldd	r23, Z+17	; 0x11
    6420:	ce 01       	movw	r24, r28
    6422:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    6426:	84 e3       	ldi	r24, 0x34	; 52
    6428:	90 e1       	ldi	r25, 0x10	; 16
    642a:	9f 93       	push	r25
    642c:	8f 93       	push	r24
    642e:	df 93       	push	r29
    6430:	cf 93       	push	r28
    6432:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print target hardware address
  fprintf_P(stream, PSTR("DstHwAddr   : "));  netPrintEthAddr(stream, &packet->dhwaddr);   fprintf_P(stream, PSTR("\r\n"));
    6436:	85 e2       	ldi	r24, 0x25	; 37
    6438:	90 e1       	ldi	r25, 0x10	; 16
    643a:	9f 93       	push	r25
    643c:	8f 93       	push	r24
    643e:	df 93       	push	r29
    6440:	cf 93       	push	r28
    6442:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6446:	b8 01       	movw	r22, r16
    6448:	6e 5e       	subi	r22, 0xEE	; 238
    644a:	7f 4f       	sbci	r23, 0xFF	; 255
    644c:	ce 01       	movw	r24, r28
    644e:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
    6452:	82 e2       	ldi	r24, 0x22	; 34
    6454:	90 e1       	ldi	r25, 0x10	; 16
    6456:	9f 93       	push	r25
    6458:	8f 93       	push	r24
    645a:	df 93       	push	r29
    645c:	cf 93       	push	r28
    645e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
// print target protocol address
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
    6462:	83 e1       	ldi	r24, 0x13	; 19
    6464:	90 e1       	ldi	r25, 0x10	; 16
    6466:	9f 93       	push	r25
    6468:	8f 93       	push	r24
    646a:	df 93       	push	r29
    646c:	cf 93       	push	r28
    646e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6472:	2d b7       	in	r18, 0x3d	; 61
    6474:	3e b7       	in	r19, 0x3e	; 62
    6476:	20 5e       	subi	r18, 0xE0	; 224
    6478:	3f 4f       	sbci	r19, 0xFF	; 255
    647a:	0f b6       	in	r0, 0x3f	; 63
    647c:	f8 94       	cli
    647e:	3e bf       	out	0x3e, r19	; 62
    6480:	0f be       	out	0x3f, r0	; 63
    6482:	2d bf       	out	0x3d, r18	; 61
    6484:	f8 01       	movw	r30, r16
    6486:	40 8d       	ldd	r20, Z+24	; 0x18
    6488:	51 8d       	ldd	r21, Z+25	; 0x19
    648a:	62 8d       	ldd	r22, Z+26	; 0x1a
    648c:	73 8d       	ldd	r23, Z+27	; 0x1b
    648e:	ce 01       	movw	r24, r28
    6490:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    6494:	80 e1       	ldi	r24, 0x10	; 16
    6496:	90 e1       	ldi	r25, 0x10	; 16
    6498:	9f 93       	push	r25
    649a:	8f 93       	push	r24
    649c:	df 93       	push	r29
    649e:	cf 93       	push	r28
    64a0:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    64a4:	0f 90       	pop	r0
    64a6:	0f 90       	pop	r0
    64a8:	0f 90       	pop	r0
    64aa:	0f 90       	pop	r0
}
    64ac:	df 91       	pop	r29
    64ae:	cf 91       	pop	r28
    64b0:	1f 91       	pop	r17
    64b2:	0f 91       	pop	r16
    64b4:	ff 90       	pop	r15
    64b6:	ef 90       	pop	r14
    64b8:	08 95       	ret

000064ba <arpArpIn>:
  memset(ArpTable, 0, sizeof(ArpTable));
  arpDebug = NULL;
}

void arpArpIn(void)
{
    64ba:	cf 93       	push	r28
    64bc:	df 93       	push	r29
#ifdef ARP_DEBUG
  if (arpDebug != NULL)
    64be:	80 91 8c 0e 	lds	r24, 0x0E8C
    64c2:	90 91 8d 0e 	lds	r25, 0x0E8D
    64c6:	00 97       	sbiw	r24, 0x00	; 0
    64c8:	f1 f0       	breq	.+60     	; 0x6506 <arpArpIn+0x4c>
  {
    if (arpDebugLevel > 1)
    64ca:	20 91 5d 0f 	lds	r18, 0x0F5D
    64ce:	22 30       	cpi	r18, 0x02	; 2
    64d0:	60 f0       	brcs	.+24     	; 0x64ea <arpArpIn+0x30>
      fprintf_P(arpDebug, PSTR("Received ARP Request\r\n"));
    64d2:	2b eb       	ldi	r18, 0xBB	; 187
    64d4:	30 e1       	ldi	r19, 0x10	; 16
    64d6:	3f 93       	push	r19
    64d8:	2f 93       	push	r18
    64da:	9f 93       	push	r25
    64dc:	8f 93       	push	r24
    64de:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    64e2:	0f 90       	pop	r0
    64e4:	0f 90       	pop	r0
    64e6:	0f 90       	pop	r0
    64e8:	0f 90       	pop	r0
    if (arpDebugLevel > 2)
    64ea:	80 91 5d 0f 	lds	r24, 0x0F5D
    64ee:	83 30       	cpi	r24, 0x03	; 3
    64f0:	50 f0       	brcs	.+20     	; 0x6506 <arpArpIn+0x4c>
      arpPrintHeader(arpDebug, nicState.layer3.arp);
    64f2:	60 91 88 0e 	lds	r22, 0x0E88
    64f6:	70 91 89 0e 	lds	r23, 0x0E89
    64fa:	80 91 8c 0e 	lds	r24, 0x0E8C
    64fe:	90 91 8d 0e 	lds	r25, 0x0E8D
    6502:	0e 94 9e 31 	call	0x633c	; 0x633c <arpPrintHeader>
  }
#endif

// for now, we just reply to requests
// need to add ARP cache
  if((nicState.layer3.arp->dipaddr == IpMyConfig.ip) && (nicState.layer3.arp->opcode == htons(ARP_OPCODE_REQUEST)) )
    6506:	e0 91 88 0e 	lds	r30, 0x0E88
    650a:	f0 91 89 0e 	lds	r31, 0x0E89
    650e:	40 8d       	ldd	r20, Z+24	; 0x18
    6510:	51 8d       	ldd	r21, Z+25	; 0x19
    6512:	62 8d       	ldd	r22, Z+26	; 0x1a
    6514:	73 8d       	ldd	r23, Z+27	; 0x1b
    6516:	80 91 4e 0f 	lds	r24, 0x0F4E
    651a:	90 91 4f 0f 	lds	r25, 0x0F4F
    651e:	a0 91 50 0f 	lds	r26, 0x0F50
    6522:	b0 91 51 0f 	lds	r27, 0x0F51
    6526:	48 17       	cp	r20, r24
    6528:	59 07       	cpc	r21, r25
    652a:	6a 07       	cpc	r22, r26
    652c:	7b 07       	cpc	r23, r27
    652e:	09 f0       	breq	.+2      	; 0x6532 <arpArpIn+0x78>
    6530:	7b c0       	rjmp	.+246    	; 0x6628 <arpArpIn+0x16e>
    6532:	c6 81       	ldd	r28, Z+6	; 0x06
    6534:	d7 81       	ldd	r29, Z+7	; 0x07
    6536:	81 e0       	ldi	r24, 0x01	; 1
    6538:	90 e0       	ldi	r25, 0x00	; 0
    653a:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    653e:	c8 17       	cp	r28, r24
    6540:	d9 07       	cpc	r29, r25
    6542:	09 f0       	breq	.+2      	; 0x6546 <arpArpIn+0x8c>
    6544:	71 c0       	rjmp	.+226    	; 0x6628 <arpArpIn+0x16e>
  {
// in ARP header
// copy sender's address info to dest. fields
    nicState.layer3.arp->dhwaddr = nicState.layer3.arp->shwaddr;
    6546:	c0 91 88 0e 	lds	r28, 0x0E88
    654a:	d0 91 89 0e 	lds	r29, 0x0E89
    654e:	86 e0       	ldi	r24, 0x06	; 6
    6550:	fe 01       	movw	r30, r28
    6552:	38 96       	adiw	r30, 0x08	; 8
    6554:	de 01       	movw	r26, r28
    6556:	52 96       	adiw	r26, 0x12	; 18
    6558:	01 90       	ld	r0, Z+
    655a:	0d 92       	st	X+, r0
    655c:	8a 95       	dec	r24
    655e:	e1 f7       	brne	.-8      	; 0x6558 <arpArpIn+0x9e>
    nicState.layer3.arp->dipaddr = nicState.layer3.arp->sipaddr;
    6560:	8e 85       	ldd	r24, Y+14	; 0x0e
    6562:	9f 85       	ldd	r25, Y+15	; 0x0f
    6564:	a8 89       	ldd	r26, Y+16	; 0x10
    6566:	b9 89       	ldd	r27, Y+17	; 0x11
    6568:	88 8f       	std	Y+24, r24	; 0x18
    656a:	99 8f       	std	Y+25, r25	; 0x19
    656c:	aa 8f       	std	Y+26, r26	; 0x1a
    656e:	bb 8f       	std	Y+27, r27	; 0x1b
// fill in our information
    nicState.layer3.arp->shwaddr =  nicState.mac;
    6570:	86 e0       	ldi	r24, 0x06	; 6
    6572:	e0 e8       	ldi	r30, 0x80	; 128
    6574:	fe e0       	ldi	r31, 0x0E	; 14
    6576:	de 01       	movw	r26, r28
    6578:	18 96       	adiw	r26, 0x08	; 8
    657a:	01 90       	ld	r0, Z+
    657c:	0d 92       	st	X+, r0
    657e:	8a 95       	dec	r24
    6580:	e1 f7       	brne	.-8      	; 0x657a <arpArpIn+0xc0>
    nicState.layer3.arp->sipaddr =  IpMyConfig.ip;
    6582:	80 91 4e 0f 	lds	r24, 0x0F4E
    6586:	90 91 4f 0f 	lds	r25, 0x0F4F
    658a:	a0 91 50 0f 	lds	r26, 0x0F50
    658e:	b0 91 51 0f 	lds	r27, 0x0F51
    6592:	8e 87       	std	Y+14, r24	; 0x0e
    6594:	9f 87       	std	Y+15, r25	; 0x0f
    6596:	a8 8b       	std	Y+16, r26	; 0x10
    6598:	b9 8b       	std	Y+17, r27	; 0x11
// change op to reply
    nicState.layer3.arp->opcode = htons(ARP_OPCODE_REPLY);
    659a:	82 e0       	ldi	r24, 0x02	; 2
    659c:	90 e0       	ldi	r25, 0x00	; 0
    659e:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    65a2:	9f 83       	std	Y+7, r25	; 0x07
    65a4:	8e 83       	std	Y+6, r24	; 0x06

// in ethernet header
    nicState.layer2.ethHeader->dest = nicState.layer2.ethHeader->src;
    65a6:	a0 91 86 0e 	lds	r26, 0x0E86
    65aa:	b0 91 87 0e 	lds	r27, 0x0E87
    65ae:	86 e0       	ldi	r24, 0x06	; 6
    65b0:	fd 01       	movw	r30, r26
    65b2:	36 96       	adiw	r30, 0x06	; 6
    65b4:	01 90       	ld	r0, Z+
    65b6:	0d 92       	st	X+, r0
    65b8:	8a 95       	dec	r24
    65ba:	e1 f7       	brne	.-8      	; 0x65b4 <arpArpIn+0xfa>
    nicState.layer2.ethHeader->src  = nicState.mac;
    65bc:	a0 91 86 0e 	lds	r26, 0x0E86
    65c0:	b0 91 87 0e 	lds	r27, 0x0E87
    65c4:	86 e0       	ldi	r24, 0x06	; 6
    65c6:	e0 e8       	ldi	r30, 0x80	; 128
    65c8:	fe e0       	ldi	r31, 0x0E	; 14
    65ca:	16 96       	adiw	r26, 0x06	; 6
    65cc:	01 90       	ld	r0, Z+
    65ce:	0d 92       	st	X+, r0
    65d0:	8a 95       	dec	r24
    65d2:	e1 f7       	brne	.-8      	; 0x65cc <arpArpIn+0x112>

#ifdef ARP_DEBUG
    if (arpDebug != NULL)
    65d4:	80 91 8c 0e 	lds	r24, 0x0E8C
    65d8:	90 91 8d 0e 	lds	r25, 0x0E8D
    65dc:	00 97       	sbiw	r24, 0x00	; 0
    65de:	f1 f0       	breq	.+60     	; 0x661c <arpArpIn+0x162>
    {
      if (arpDebugLevel > 0)
    65e0:	20 91 5d 0f 	lds	r18, 0x0F5D
    65e4:	22 23       	and	r18, r18
    65e6:	61 f0       	breq	.+24     	; 0x6600 <arpArpIn+0x146>
        fprintf_P(arpDebug, PSTR("Sending ARP Reply\r\n"));
    65e8:	27 ea       	ldi	r18, 0xA7	; 167
    65ea:	30 e1       	ldi	r19, 0x10	; 16
    65ec:	3f 93       	push	r19
    65ee:	2f 93       	push	r18
    65f0:	9f 93       	push	r25
    65f2:	8f 93       	push	r24
    65f4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    65f8:	0f 90       	pop	r0
    65fa:	0f 90       	pop	r0
    65fc:	0f 90       	pop	r0
    65fe:	0f 90       	pop	r0
      if (arpDebugLevel > 2)
    6600:	80 91 5d 0f 	lds	r24, 0x0F5D
    6604:	83 30       	cpi	r24, 0x03	; 3
    6606:	50 f0       	brcs	.+20     	; 0x661c <arpArpIn+0x162>
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    6608:	60 91 88 0e 	lds	r22, 0x0E88
    660c:	70 91 89 0e 	lds	r23, 0x0E89
    6610:	80 91 8c 0e 	lds	r24, 0x0E8C
    6614:	90 91 8d 0e 	lds	r25, 0x0E8D
    6618:	0e 94 9e 31 	call	0x633c	; 0x633c <arpPrintHeader>
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    661c:	8a e2       	ldi	r24, 0x2A	; 42
    661e:	90 e0       	ldi	r25, 0x00	; 0
  }
}
    6620:	df 91       	pop	r29
    6622:	cf 91       	pop	r28
      if (arpDebugLevel > 2)
        arpPrintHeader(arpDebug, nicState.layer3.arp);
    }
#endif
// send reply!
    nicSend(sizeof(struct netArpHeader) + ETH_HEADER_LEN);
    6624:	0c 94 0e 28 	jmp	0x501c	; 0x501c <nicSend>
  }
}
    6628:	df 91       	pop	r29
    662a:	cf 91       	pop	r28
    662c:	08 95       	ret

0000662e <arpPrintTable>:
  fprintf_P(stream, PSTR("DstProtoAddr: "));  netPrintIPAddr(stream, packet->dipaddr);     fprintf_P(stream, PSTR("\r\n"));
}
#endif /*ARP_DEBUG*/

void arpPrintTable(FILE *stream)
{
    662e:	af 92       	push	r10
    6630:	bf 92       	push	r11
    6632:	cf 92       	push	r12
    6634:	df 92       	push	r13
    6636:	ef 92       	push	r14
    6638:	ff 92       	push	r15
    663a:	0f 93       	push	r16
    663c:	1f 93       	push	r17
    663e:	cf 93       	push	r28
    6640:	df 93       	push	r29
    6642:	ec 01       	movw	r28, r24
  uint8_t i;

  // print ARP table
  fprintf_P(stream, PSTR("Time Eth Address        IP Address\r\n"));
    6644:	8b ee       	ldi	r24, 0xEB	; 235
    6646:	9f e0       	ldi	r25, 0x0F	; 15
    6648:	9f 93       	push	r25
    664a:	8f 93       	push	r24
    664c:	df 93       	push	r29
    664e:	cf 93       	push	r28
    6650:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("-----------------------------------\r\n"));
    6654:	85 ec       	ldi	r24, 0xC5	; 197
    6656:	9f e0       	ldi	r25, 0x0F	; 15
    6658:	9f 93       	push	r25
    665a:	8f 93       	push	r24
    665c:	df 93       	push	r29
    665e:	cf 93       	push	r28
    6660:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR(" MY  "));
    6664:	8f eb       	ldi	r24, 0xBF	; 191
    6666:	9f e0       	ldi	r25, 0x0F	; 15
    6668:	9f 93       	push	r25
    666a:	8f 93       	push	r24
    666c:	df 93       	push	r29
    666e:	cf 93       	push	r28
    6670:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintEthAddr(stream, &nicState.mac);
    6674:	60 e8       	ldi	r22, 0x80	; 128
    6676:	7e e0       	ldi	r23, 0x0E	; 14
    6678:	ce 01       	movw	r24, r28
    667a:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
  fprintf_P(stream, PSTR("  "));
    667e:	8c eb       	ldi	r24, 0xBC	; 188
    6680:	9f e0       	ldi	r25, 0x0F	; 15
    6682:	9f 93       	push	r25
    6684:	8f 93       	push	r24
    6686:	df 93       	push	r29
    6688:	cf 93       	push	r28
    668a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  netPrintIPAddr(stream, IpMyConfig.ip);
    668e:	40 91 4e 0f 	lds	r20, 0x0F4E
    6692:	50 91 4f 0f 	lds	r21, 0x0F4F
    6696:	60 91 50 0f 	lds	r22, 0x0F50
    669a:	70 91 51 0f 	lds	r23, 0x0F51
    669e:	ce 01       	movw	r24, r28
    66a0:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n"));
    66a4:	89 eb       	ldi	r24, 0xB9	; 185
    66a6:	9f e0       	ldi	r25, 0x0F	; 15
    66a8:	9f 93       	push	r25
    66aa:	8f 93       	push	r24
    66ac:	df 93       	push	r29
    66ae:	cf 93       	push	r28
    66b0:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    66b4:	08 e6       	ldi	r16, 0x68	; 104
    66b6:	1f e0       	ldi	r17, 0x0F	; 15
    66b8:	8d b7       	in	r24, 0x3d	; 61
    66ba:	9e b7       	in	r25, 0x3e	; 62
    66bc:	44 96       	adiw	r24, 0x14	; 20
    66be:	0f b6       	in	r0, 0x3f	; 63
    66c0:	f8 94       	cli
    66c2:	9e bf       	out	0x3e, r25	; 62
    66c4:	0f be       	out	0x3f, r0	; 63
    66c6:	8d bf       	out	0x3d, r24	; 61

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    66c8:	83 eb       	ldi	r24, 0xB3	; 179
    66ca:	e8 2e       	mov	r14, r24
    66cc:	8f e0       	ldi	r24, 0x0F	; 15
    66ce:	f8 2e       	mov	r15, r24
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    66d0:	90 eb       	ldi	r25, 0xB0	; 176
    66d2:	c9 2e       	mov	r12, r25
    66d4:	9f e0       	ldi	r25, 0x0F	; 15
    66d6:	d9 2e       	mov	r13, r25
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
    66d8:	2d ea       	ldi	r18, 0xAD	; 173
    66da:	a2 2e       	mov	r10, r18
    66dc:	2f e0       	ldi	r18, 0x0F	; 15
    66de:	b2 2e       	mov	r11, r18
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
  {
    if (ArpTable[i].ipaddr == 0)
    66e0:	f8 01       	movw	r30, r16
    66e2:	80 81       	ld	r24, Z
    66e4:	91 81       	ldd	r25, Z+1	; 0x01
    66e6:	a2 81       	ldd	r26, Z+2	; 0x02
    66e8:	b3 81       	ldd	r27, Z+3	; 0x03
    66ea:	89 2b       	or	r24, r25
    66ec:	8a 2b       	or	r24, r26
    66ee:	8b 2b       	or	r24, r27
    66f0:	59 f1       	breq	.+86     	; 0x6748 <arpPrintTable+0x11a>
      continue;
    fprintf_P(stream, PSTR("%3d  "), ArpTable[i].time);
    66f2:	82 85       	ldd	r24, Z+10	; 0x0a
    66f4:	1f 92       	push	r1
    66f6:	8f 93       	push	r24
    66f8:	ff 92       	push	r15
    66fa:	ef 92       	push	r14
    66fc:	df 93       	push	r29
    66fe:	cf 93       	push	r28
    6700:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6704:	b8 01       	movw	r22, r16
    6706:	6c 5f       	subi	r22, 0xFC	; 252
    6708:	7f 4f       	sbci	r23, 0xFF	; 255
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    670a:	ce 01       	movw	r24, r28
    670c:	0e 94 05 2b 	call	0x560a	; 0x560a <netPrintEthAddr>
    fprintf_P(stream, PSTR("  "));
    6710:	df 92       	push	r13
    6712:	cf 92       	push	r12
    6714:	df 93       	push	r29
    6716:	cf 93       	push	r28
    6718:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    671c:	f8 01       	movw	r30, r16
    671e:	40 81       	ld	r20, Z
    6720:	51 81       	ldd	r21, Z+1	; 0x01
    6722:	62 81       	ldd	r22, Z+2	; 0x02
    6724:	73 81       	ldd	r23, Z+3	; 0x03
    6726:	ce 01       	movw	r24, r28
    6728:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
    fprintf_P(stream, PSTR("\r\n"));
    672c:	bf 92       	push	r11
    672e:	af 92       	push	r10
    6730:	df 93       	push	r29
    6732:	cf 93       	push	r28
    6734:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6738:	8d b7       	in	r24, 0x3d	; 61
    673a:	9e b7       	in	r25, 0x3e	; 62
    673c:	0e 96       	adiw	r24, 0x0e	; 14
    673e:	0f b6       	in	r0, 0x3f	; 63
    6740:	f8 94       	cli
    6742:	9e bf       	out	0x3e, r25	; 62
    6744:	0f be       	out	0x3f, r0	; 63
    6746:	8d bf       	out	0x3d, r24	; 61
    6748:	05 5f       	subi	r16, 0xF5	; 245
    674a:	1f 4f       	sbci	r17, 0xFF	; 255
  netPrintEthAddr(stream, &nicState.mac);
  fprintf_P(stream, PSTR("  "));
  netPrintIPAddr(stream, IpMyConfig.ip);
  fprintf_P(stream, PSTR("\r\n"));

  for(i=0; i<ARP_TABLE_SIZE; i++)
    674c:	9f e0       	ldi	r25, 0x0F	; 15
    674e:	06 3d       	cpi	r16, 0xD6	; 214
    6750:	19 07       	cpc	r17, r25
    6752:	31 f6       	brne	.-116    	; 0x66e0 <arpPrintTable+0xb2>
    netPrintEthAddr(stream, &ArpTable[i].ethaddr);
    fprintf_P(stream, PSTR("  "));
    netPrintIPAddr(stream, ArpTable[i].ipaddr);
    fprintf_P(stream, PSTR("\r\n"));
  }
}
    6754:	df 91       	pop	r29
    6756:	cf 91       	pop	r28
    6758:	1f 91       	pop	r17
    675a:	0f 91       	pop	r16
    675c:	ff 90       	pop	r15
    675e:	ef 90       	pop	r14
    6760:	df 90       	pop	r13
    6762:	cf 90       	pop	r12
    6764:	bf 90       	pop	r11
    6766:	af 90       	pop	r10
    6768:	08 95       	ret

0000676a <socketInit>:
 * @param *sck socket
 */
static inline void tcpAcceptConn(struct TcpIpSocket *sck);

inline void socketInit(void)
{
    676a:	8f 92       	push	r8
    676c:	9f 92       	push	r9
    676e:	af 92       	push	r10
    6770:	bf 92       	push	r11
    6772:	ff 92       	push	r15
    6774:	0f 93       	push	r16
    6776:	1f 93       	push	r17
    6778:	cf 93       	push	r28
    677a:	df 93       	push	r29
  sockets = xmalloc(NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    677c:	80 e3       	ldi	r24, 0x30	; 48
    677e:	92 e0       	ldi	r25, 0x02	; 2
    6780:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <xmalloc>
    6784:	90 93 bd 0e 	sts	0x0EBD, r25
    6788:	80 93 bc 0e 	sts	0x0EBC, r24
  memset(sockets, 0, NUMBER_OF_SOCKETS * sizeof(struct TcpIpSocket));
    678c:	20 e3       	ldi	r18, 0x30	; 48
    678e:	32 e0       	ldi	r19, 0x02	; 2
    6790:	fc 01       	movw	r30, r24
    6792:	a9 01       	movw	r20, r18
    6794:	11 92       	st	Z+, r1
    6796:	41 50       	subi	r20, 0x01	; 1
    6798:	50 40       	sbci	r21, 0x00	; 0
    679a:	e1 f7       	brne	.-8      	; 0x6794 <socketInit+0x2a>

  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
    679c:	00 91 bc 0e 	lds	r16, 0x0EBC
    67a0:	10 91 bd 0e 	lds	r17, 0x0EBD
    67a4:	c8 ea       	ldi	r28, 0xA8	; 168
    67a6:	d1 e6       	ldi	r29, 0x61	; 97
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233);
    67a8:	88 24       	eor	r8, r8
    67aa:	8a 94       	dec	r8
    67ac:	81 e1       	ldi	r24, 0x11	; 17
    67ae:	98 2e       	mov	r9, r24
    67b0:	82 e2       	ldi	r24, 0x22	; 34
    67b2:	a8 2e       	mov	r10, r24
    67b4:	83 e3       	ldi	r24, 0x33	; 51
    67b6:	b8 2e       	mov	r11, r24
    sck->state         = LISTEN;
    67b8:	ff 24       	eor	r15, r15
    67ba:	f3 94       	inc	r15
    67bc:	8c 2f       	mov	r24, r28
    67be:	88 5a       	subi	r24, 0xA8	; 168
//    sck->Rx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;
//    sck->Tx = xQueueCreateExternal(255, 1, (void *)(ptr));
    ptr+=256;

    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    67c0:	80 31       	cpi	r24, 0x10	; 16
    67c2:	20 f4       	brcc	.+8      	; 0x67cc <socketInit+0x62>
    67c4:	ce 01       	movw	r24, r28
    67c6:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    67ca:	02 c0       	rjmp	.+4      	; 0x67d0 <socketInit+0x66>
    67cc:	88 eb       	ldi	r24, 0xB8	; 184
    67ce:	91 e6       	ldi	r25, 0x61	; 97
    67d0:	f8 01       	movw	r30, r16
    67d2:	96 83       	std	Z+6, r25	; 0x06
    67d4:	85 83       	std	Z+5, r24	; 0x05
    sck->seqNoLastSent = HTONL(0xFF112233);
    67d6:	85 86       	std	Z+13, r8	; 0x0d
    67d8:	96 86       	std	Z+14, r9	; 0x0e
    67da:	a7 86       	std	Z+15, r10	; 0x0f
    67dc:	b0 8a       	std	Z+16, r11	; 0x10
    sck->state         = LISTEN;
    67de:	f0 82       	st	Z, r15
    sck++;
    67e0:	04 5e       	subi	r16, 0xE4	; 228
    67e2:	1f 4f       	sbci	r17, 0xFF	; 255
    67e4:	21 96       	adiw	r28, 0x01	; 1

  uint8_t            i;
  uint8_t            *ptr = (uint8_t *)RTOS_TCP_BUF_BASE_ADDR;

  struct TcpIpSocket *sck = sockets;
  for (i=0; i < NUMBER_OF_SOCKETS; i++)
    67e6:	cc 3b       	cpi	r28, 0xBC	; 188
    67e8:	f1 e6       	ldi	r31, 0x61	; 97
    67ea:	df 07       	cpc	r29, r31
    67ec:	39 f7       	brne	.-50     	; 0x67bc <socketInit+0x52>
    sck->localPort     = (i<16) ? htons(MYTELNETPOERT + i) : (MYTELNETPOERT + 16);
    sck->seqNoLastSent = HTONL(0xFF112233);
    sck->state         = LISTEN;
    sck++;
  }
}
    67ee:	df 91       	pop	r29
    67f0:	cf 91       	pop	r28
    67f2:	1f 91       	pop	r17
    67f4:	0f 91       	pop	r16
    67f6:	ff 90       	pop	r15
    67f8:	bf 90       	pop	r11
    67fa:	af 90       	pop	r10
    67fc:	9f 90       	pop	r9
    67fe:	8f 90       	pop	r8
    6800:	08 95       	ret

00006802 <calculateTcpChecksun>:

  return 0;
}

void calculateTcpChecksun(uint16_t tcpLen)
{
    6802:	cf 93       	push	r28
    6804:	df 93       	push	r29
  nicState.layer4.tcp->tcpchksum = 0;
    6806:	c0 91 8a 0e 	lds	r28, 0x0E8A
    680a:	d0 91 8b 0e 	lds	r29, 0x0E8B
    680e:	19 8a       	std	Y+17, r1	; 0x11
    6810:	18 8a       	std	Y+16, r1	; 0x10
  nicState.layer4.tcp->tcpchksum = netChecksum((uint8_t *)nicState.layer4.tcp, tcpLen); //TODO finish it
    6812:	bc 01       	movw	r22, r24
    6814:	ce 01       	movw	r24, r28
    6816:	0e 94 d5 2a 	call	0x55aa	; 0x55aa <netChecksum>
    681a:	99 8b       	std	Y+17, r25	; 0x11
    681c:	88 8b       	std	Y+16, r24	; 0x10
}
    681e:	df 91       	pop	r29
    6820:	cf 91       	pop	r28
    6822:	08 95       	ret

00006824 <processTcpPacket>:
  sck->remotePort   = nicState.layer4.tcp->srcport;
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
}

inline uint8_t processTcpPacket(void)
{
    6824:	6f 92       	push	r6
    6826:	7f 92       	push	r7
    6828:	8f 92       	push	r8
    682a:	9f 92       	push	r9
    682c:	af 92       	push	r10
    682e:	bf 92       	push	r11
    6830:	cf 92       	push	r12
    6832:	df 92       	push	r13
    6834:	ef 92       	push	r14
    6836:	ff 92       	push	r15
    6838:	0f 93       	push	r16
    683a:	1f 93       	push	r17
    683c:	cf 93       	push	r28
    683e:	df 93       	push	r29
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    6840:	e0 91 bc 0e 	lds	r30, 0x0EBC
    6844:	f0 91 bd 0e 	lds	r31, 0x0EBD
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED))
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    6848:	40 91 88 0e 	lds	r20, 0x0E88
    684c:	50 91 89 0e 	lds	r21, 0x0E89
    6850:	60 90 8a 0e 	lds	r6, 0x0E8A
    6854:	70 90 8b 0e 	lds	r7, 0x0E8B
    6858:	cf 01       	movw	r24, r30
    685a:	80 5d       	subi	r24, 0xD0	; 208
    685c:	9d 4f       	sbci	r25, 0xFD	; 253
  }
}

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
    685e:	ef 01       	movw	r28, r30
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ( ((result->state != LISTEN) && (result->state != CLOSED))
    6860:	28 81       	ld	r18, Y
    6862:	22 30       	cpi	r18, 0x02	; 2
    6864:	f0 f1       	brcs	.+124    	; 0x68e2 <processTcpPacket+0xbe>
      && (result->RemoteIpAddr == nicState.layer3.ip->srcipaddr) && (result->localPort == nicState.layer4.tcp->destport) && (result->remotePort == nicState.layer4.tcp->srcport))
    6866:	89 80       	ldd	r8, Y+1	; 0x01
    6868:	9a 80       	ldd	r9, Y+2	; 0x02
    686a:	ab 80       	ldd	r10, Y+3	; 0x03
    686c:	bc 80       	ldd	r11, Y+4	; 0x04
    686e:	da 01       	movw	r26, r20
    6870:	1c 96       	adiw	r26, 0x0c	; 12
    6872:	cd 90       	ld	r12, X+
    6874:	dd 90       	ld	r13, X+
    6876:	ed 90       	ld	r14, X+
    6878:	fc 90       	ld	r15, X
    687a:	1f 97       	sbiw	r26, 0x0f	; 15
    687c:	8c 14       	cp	r8, r12
    687e:	9d 04       	cpc	r9, r13
    6880:	ae 04       	cpc	r10, r14
    6882:	bf 04       	cpc	r11, r15
    6884:	71 f5       	brne	.+92     	; 0x68e2 <processTcpPacket+0xbe>
    6886:	0d 81       	ldd	r16, Y+5	; 0x05
    6888:	1e 81       	ldd	r17, Y+6	; 0x06
    688a:	d3 01       	movw	r26, r6
    688c:	12 96       	adiw	r26, 0x02	; 2
    688e:	6d 91       	ld	r22, X+
    6890:	7c 91       	ld	r23, X
    6892:	13 97       	sbiw	r26, 0x03	; 3
    6894:	06 17       	cp	r16, r22
    6896:	17 07       	cpc	r17, r23
    6898:	21 f5       	brne	.+72     	; 0x68e2 <processTcpPacket+0xbe>
    689a:	0f 81       	ldd	r16, Y+7	; 0x07
    689c:	18 85       	ldd	r17, Y+8	; 0x08
    689e:	6d 91       	ld	r22, X+
    68a0:	7c 91       	ld	r23, X
    68a2:	06 17       	cp	r16, r22
    68a4:	17 07       	cpc	r17, r23
    68a6:	e9 f4       	brne	.+58     	; 0x68e2 <processTcpPacket+0xbe>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    68a8:	80 91 4c 0f 	lds	r24, 0x0F4C
    68ac:	90 91 4d 0f 	lds	r25, 0x0F4D
    68b0:	00 97       	sbiw	r24, 0x00	; 0
    68b2:	09 f4       	brne	.+2      	; 0x68b6 <processTcpPacket+0x92>
    68b4:	7b c0       	rjmp	.+246    	; 0x69ac <processTcpPacket+0x188>
        if (tcpDebugLevel > 2)
    68b6:	30 91 a5 0e 	lds	r19, 0x0EA5
    68ba:	33 30       	cpi	r19, 0x03	; 3
    68bc:	08 f4       	brcc	.+2      	; 0x68c0 <processTcpPacket+0x9c>
    68be:	76 c0       	rjmp	.+236    	; 0x69ac <processTcpPacket+0x188>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket state %d\r\n"), result->state);
    68c0:	1f 92       	push	r1
    68c2:	2f 93       	push	r18
    68c4:	29 e3       	ldi	r18, 0x39	; 57
    68c6:	31 e1       	ldi	r19, 0x11	; 17
    68c8:	3f 93       	push	r19
    68ca:	2f 93       	push	r18
    68cc:	9f 93       	push	r25
    68ce:	8f 93       	push	r24
    68d0:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    68d4:	0f 90       	pop	r0
    68d6:	0f 90       	pop	r0
    68d8:	0f 90       	pop	r0
    68da:	0f 90       	pop	r0
    68dc:	0f 90       	pop	r0
    68de:	0f 90       	pop	r0
    68e0:	65 c0       	rjmp	.+202    	; 0x69ac <processTcpPacket+0x188>
#endif
      return result;
    }
    result++;
    68e2:	6c 96       	adiw	r28, 0x1c	; 28

struct TcpIpSocket* findConnectedSocket(void)
{
  struct TcpIpSocket *result = sockets;
  uint8_t i;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    68e4:	c8 17       	cp	r28, r24
    68e6:	d9 07       	cpc	r29, r25
    68e8:	09 f0       	breq	.+2      	; 0x68ec <processTcpPacket+0xc8>
    68ea:	ba cf       	rjmp	.-140    	; 0x6860 <processTcpPacket+0x3c>
    68ec:	d0 e0       	ldi	r29, 0x00	; 0
  }

  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
  {
    if ((result->state == LISTEN) && (result->localPort == nicState.layer4.tcp->destport))
    68ee:	80 81       	ld	r24, Z
    68f0:	81 30       	cpi	r24, 0x01	; 1
    68f2:	81 f5       	brne	.+96     	; 0x6954 <processTcpPacket+0x130>
    68f4:	25 81       	ldd	r18, Z+5	; 0x05
    68f6:	36 81       	ldd	r19, Z+6	; 0x06
    68f8:	d3 01       	movw	r26, r6
    68fa:	12 96       	adiw	r26, 0x02	; 2
    68fc:	8d 91       	ld	r24, X+
    68fe:	9c 91       	ld	r25, X
    6900:	13 97       	sbiw	r26, 0x03	; 3
    6902:	28 17       	cp	r18, r24
    6904:	39 07       	cpc	r19, r25
    6906:	31 f5       	brne	.+76     	; 0x6954 <processTcpPacket+0x130>
    {
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    6908:	80 91 4c 0f 	lds	r24, 0x0F4C
    690c:	90 91 4d 0f 	lds	r25, 0x0F4D
    6910:	00 97       	sbiw	r24, 0x00	; 0
    6912:	a1 f0       	breq	.+40     	; 0x693c <processTcpPacket+0x118>
        if (tcpDebugLevel > 2)
    6914:	20 91 a5 0e 	lds	r18, 0x0EA5
    6918:	23 30       	cpi	r18, 0x03	; 3
    691a:	80 f0       	brcs	.+32     	; 0x693c <processTcpPacket+0x118>
          fprintf_P(tcpDebugStream, PSTR("Found TCP socket no %d state LISTEN\r\n"), i);
    691c:	1f 92       	push	r1
    691e:	df 93       	push	r29
    6920:	23 e1       	ldi	r18, 0x13	; 19
    6922:	31 e1       	ldi	r19, 0x11	; 17
    6924:	3f 93       	push	r19
    6926:	2f 93       	push	r18
    6928:	9f 93       	push	r25
    692a:	8f 93       	push	r24
    692c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6930:	0f 90       	pop	r0
    6932:	0f 90       	pop	r0
    6934:	0f 90       	pop	r0
    6936:	0f 90       	pop	r0
    6938:	0f 90       	pop	r0
    693a:	0f 90       	pop	r0
#endif
      return &sockets[i];
    693c:	80 91 bc 0e 	lds	r24, 0x0EBC
    6940:	90 91 bd 0e 	lds	r25, 0x0EBD
    6944:	fc 01       	movw	r30, r24
    6946:	2c e1       	ldi	r18, 0x1C	; 28
    6948:	d2 9f       	mul	r29, r18
    694a:	e0 0d       	add	r30, r0
    694c:	f1 1d       	adc	r31, r1
    694e:	11 24       	eor	r1, r1
    6950:	ef 01       	movw	r28, r30
    6952:	2c c0       	rjmp	.+88     	; 0x69ac <processTcpPacket+0x188>
    }
    result++;
    6954:	7c 96       	adiw	r30, 0x1c	; 28
    }
    result++;
  }

  result = sockets;
  for (i=0; i<NUMBER_OF_SOCKETS; i++)
    6956:	df 5f       	subi	r29, 0xFF	; 255
    6958:	d4 31       	cpi	r29, 0x14	; 20
    695a:	49 f6       	brne	.-110    	; 0x68ee <processTcpPacket+0xca>
      return &sockets[i];
    }
    result++;
  }
#if TCP_DEBUG
  if (tcpDebugStream != NULL)
    695c:	80 91 4c 0f 	lds	r24, 0x0F4C
    6960:	90 91 4d 0f 	lds	r25, 0x0F4D
    6964:	89 2b       	or	r24, r25
    6966:	09 f4       	brne	.+2      	; 0x696a <processTcpPacket+0x146>
    6968:	55 c1       	rjmp	.+682    	; 0x6c14 <processTcpPacket+0x3f0>
    if (tcpDebugLevel > 2)
    696a:	80 91 a5 0e 	lds	r24, 0x0EA5
    696e:	83 30       	cpi	r24, 0x03	; 3
    6970:	08 f4       	brcc	.+2      	; 0x6974 <processTcpPacket+0x150>
    6972:	50 c1       	rjmp	.+672    	; 0x6c14 <processTcpPacket+0x3f0>
      fprintf_P(tcpDebugStream, PSTR("Can't find TCP socket with localPort %d\r\n"), htons(nicState.layer4.tcp->destport));
    6974:	d3 01       	movw	r26, r6
    6976:	12 96       	adiw	r26, 0x02	; 2
    6978:	8d 91       	ld	r24, X+
    697a:	9c 91       	ld	r25, X
    697c:	13 97       	sbiw	r26, 0x03	; 3
    697e:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    6982:	9f 93       	push	r25
    6984:	8f 93       	push	r24
    6986:	89 ee       	ldi	r24, 0xE9	; 233
    6988:	90 e1       	ldi	r25, 0x10	; 16
    698a:	9f 93       	push	r25
    698c:	8f 93       	push	r24
    698e:	80 91 4d 0f 	lds	r24, 0x0F4D
    6992:	8f 93       	push	r24
    6994:	80 91 4c 0f 	lds	r24, 0x0F4C
    6998:	8f 93       	push	r24
    699a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    699e:	0f 90       	pop	r0
    69a0:	0f 90       	pop	r0
    69a2:	0f 90       	pop	r0
    69a4:	0f 90       	pop	r0
    69a6:	0f 90       	pop	r0
    69a8:	0f 90       	pop	r0
    69aa:	34 c1       	rjmp	.+616    	; 0x6c14 <processTcpPacket+0x3f0>

inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();

  if (socket == NULL)
    69ac:	20 97       	sbiw	r28, 0x00	; 0
    69ae:	09 f4       	brne	.+2      	; 0x69b2 <processTcpPacket+0x18e>
    69b0:	31 c1       	rjmp	.+610    	; 0x6c14 <processTcpPacket+0x3f0>
    return 1;


  socket->seqNoLastReceived = htonl(nicState.layer4.tcp->seqno);
    69b2:	e0 91 8a 0e 	lds	r30, 0x0E8A
    69b6:	f0 91 8b 0e 	lds	r31, 0x0E8B
    69ba:	64 81       	ldd	r22, Z+4	; 0x04
    69bc:	75 81       	ldd	r23, Z+5	; 0x05
    69be:	86 81       	ldd	r24, Z+6	; 0x06
    69c0:	97 81       	ldd	r25, Z+7	; 0x07
    69c2:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    69c6:	69 87       	std	Y+9, r22	; 0x09
    69c8:	7a 87       	std	Y+10, r23	; 0x0a
    69ca:	8b 87       	std	Y+11, r24	; 0x0b
    69cc:	9c 87       	std	Y+12, r25	; 0x0c

  if (socket->state == LISTEN)
    69ce:	88 81       	ld	r24, Y
    69d0:	81 30       	cpi	r24, 0x01	; 1
    69d2:	09 f0       	breq	.+2      	; 0x69d6 <processTcpPacket+0x1b2>
    69d4:	a0 c0       	rjmp	.+320    	; 0x6b16 <processTcpPacket+0x2f2>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_SYN)
    69d6:	e0 91 8a 0e 	lds	r30, 0x0E8A
    69da:	f0 91 8b 0e 	lds	r31, 0x0E8B
    69de:	25 85       	ldd	r18, Z+13	; 0x0d
    69e0:	80 91 4c 0f 	lds	r24, 0x0F4C
    69e4:	90 91 4d 0f 	lds	r25, 0x0F4D
    69e8:	12 2f       	mov	r17, r18
    69ea:	12 70       	andi	r17, 0x02	; 2
    69ec:	21 ff       	sbrs	r18, 1
    69ee:	88 c0       	rjmp	.+272    	; 0x6b00 <processTcpPacket+0x2dc>
    {
//      uint16_t len = nicState.layer4.tcp->tcpoffset>>4;
//      len *=4;
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    69f0:	00 97       	sbiw	r24, 0x00	; 0
    69f2:	81 f0       	breq	.+32     	; 0x6a14 <processTcpPacket+0x1f0>
        if (tcpDebugLevel > 2)
    69f4:	20 91 a5 0e 	lds	r18, 0x0EA5
    69f8:	23 30       	cpi	r18, 0x03	; 3
    69fa:	60 f0       	brcs	.+24     	; 0x6a14 <processTcpPacket+0x1f0>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
    69fc:	25 e0       	ldi	r18, 0x05	; 5
    69fe:	32 e1       	ldi	r19, 0x12	; 18
    6a00:	3f 93       	push	r19
    6a02:	2f 93       	push	r18
    6a04:	9f 93       	push	r25
    6a06:	8f 93       	push	r24
    6a08:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6a0c:	0f 90       	pop	r0
    6a0e:	0f 90       	pop	r0
    6a10:	0f 90       	pop	r0
    6a12:	0f 90       	pop	r0
  return NULL;
}

static inline void tcpAcceptConn(struct TcpIpSocket *sck)
{
  sck->state        = SYN_RECEIVED;
    6a14:	82 e0       	ldi	r24, 0x02	; 2
    6a16:	88 83       	st	Y, r24
  sck->remotePort   = nicState.layer4.tcp->srcport;
    6a18:	00 91 8a 0e 	lds	r16, 0x0E8A
    6a1c:	10 91 8b 0e 	lds	r17, 0x0E8B
    6a20:	f8 01       	movw	r30, r16
    6a22:	80 81       	ld	r24, Z
    6a24:	91 81       	ldd	r25, Z+1	; 0x01
    6a26:	98 87       	std	Y+8, r25	; 0x08
    6a28:	8f 83       	std	Y+7, r24	; 0x07
  sck->RemoteIpAddr = nicState.layer3.ip->srcipaddr;
    6a2a:	e0 91 88 0e 	lds	r30, 0x0E88
    6a2e:	f0 91 89 0e 	lds	r31, 0x0E89
    6a32:	44 85       	ldd	r20, Z+12	; 0x0c
    6a34:	55 85       	ldd	r21, Z+13	; 0x0d
    6a36:	66 85       	ldd	r22, Z+14	; 0x0e
    6a38:	77 85       	ldd	r23, Z+15	; 0x0f
    6a3a:	49 83       	std	Y+1, r20	; 0x01
    6a3c:	5a 83       	std	Y+2, r21	; 0x02
    6a3e:	6b 83       	std	Y+3, r22	; 0x03
    6a40:	7c 83       	std	Y+4, r23	; 0x04
        if (tcpDebugLevel > 2)
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change LISTEN->SYN_RECEIVED\r\n"));
#endif
      tcpAcceptConn(socket);
      //Preparing response
      nicState.layer4.tcp->srcport   = socket->localPort;
    6a42:	2d 81       	ldd	r18, Y+5	; 0x05
    6a44:	3e 81       	ldd	r19, Y+6	; 0x06
    6a46:	d8 01       	movw	r26, r16
    6a48:	11 96       	adiw	r26, 0x01	; 1
    6a4a:	3c 93       	st	X, r19
    6a4c:	2e 93       	st	-X, r18
      nicState.layer4.tcp->destport  = socket->remotePort;
    6a4e:	13 96       	adiw	r26, 0x03	; 3
    6a50:	9c 93       	st	X, r25
    6a52:	8e 93       	st	-X, r24
    6a54:	12 97       	sbiw	r26, 0x02	; 2
      nicState.layer4.tcp->seqno     = htonl(socket->seqNoLastSent);
    6a56:	6d 85       	ldd	r22, Y+13	; 0x0d
    6a58:	7e 85       	ldd	r23, Y+14	; 0x0e
    6a5a:	8f 85       	ldd	r24, Y+15	; 0x0f
    6a5c:	98 89       	ldd	r25, Y+16	; 0x10
    6a5e:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    6a62:	f8 01       	movw	r30, r16
    6a64:	64 83       	std	Z+4, r22	; 0x04
    6a66:	75 83       	std	Z+5, r23	; 0x05
    6a68:	86 83       	std	Z+6, r24	; 0x06
    6a6a:	97 83       	std	Z+7, r25	; 0x07
      nicState.layer4.tcp->ackno     = htonl(socket->seqNoLastReceived+1);
    6a6c:	00 91 8a 0e 	lds	r16, 0x0E8A
    6a70:	10 91 8b 0e 	lds	r17, 0x0E8B
    6a74:	89 85       	ldd	r24, Y+9	; 0x09
    6a76:	9a 85       	ldd	r25, Y+10	; 0x0a
    6a78:	ab 85       	ldd	r26, Y+11	; 0x0b
    6a7a:	bc 85       	ldd	r27, Y+12	; 0x0c
    6a7c:	bc 01       	movw	r22, r24
    6a7e:	cd 01       	movw	r24, r26
    6a80:	6f 5f       	subi	r22, 0xFF	; 255
    6a82:	7f 4f       	sbci	r23, 0xFF	; 255
    6a84:	8f 4f       	sbci	r24, 0xFF	; 255
    6a86:	9f 4f       	sbci	r25, 0xFF	; 255
    6a88:	0e 94 cf 2a 	call	0x559e	; 0x559e <htonl>
    6a8c:	d8 01       	movw	r26, r16
    6a8e:	18 96       	adiw	r26, 0x08	; 8
    6a90:	6d 93       	st	X+, r22
    6a92:	7d 93       	st	X+, r23
    6a94:	8d 93       	st	X+, r24
    6a96:	9c 93       	st	X, r25
    6a98:	1b 97       	sbiw	r26, 0x0b	; 11
      nicState.layer4.tcp->tcpoffset = 5<<4;
    6a9a:	00 91 8a 0e 	lds	r16, 0x0E8A
    6a9e:	10 91 8b 0e 	lds	r17, 0x0E8B
    6aa2:	80 e5       	ldi	r24, 0x50	; 80
    6aa4:	f8 01       	movw	r30, r16
    6aa6:	84 87       	std	Z+12, r24	; 0x0c
      nicState.layer4.tcp->flags     = TCP_FLAGS_ACK+TCP_FLAGS_SYN;
    6aa8:	82 e1       	ldi	r24, 0x12	; 18
    6aaa:	85 87       	std	Z+13, r24	; 0x0d
      nicState.layer4.tcp->wnd       = htons(100);
    6aac:	84 e6       	ldi	r24, 0x64	; 100
    6aae:	90 e0       	ldi	r25, 0x00	; 0
    6ab0:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    6ab4:	d8 01       	movw	r26, r16
    6ab6:	1f 96       	adiw	r26, 0x0f	; 15
    6ab8:	9c 93       	st	X, r25
    6aba:	8e 93       	st	-X, r24
    6abc:	1e 97       	sbiw	r26, 0x0e	; 14
      nicState.layer4.tcp->tcpchksum = 0;
    6abe:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6ac2:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6ac6:	11 8a       	std	Z+17, r1	; 0x11
    6ac8:	10 8a       	std	Z+16, r1	; 0x10
      nicState.layer4.tcp->urgp      = 0;
    6aca:	13 8a       	std	Z+19, r1	; 0x13
    6acc:	12 8a       	std	Z+18, r1	; 0x12
      calculateTcpChecksun(TCP_HEADER_LEN);
    6ace:	84 e1       	ldi	r24, 0x14	; 20
    6ad0:	90 e0       	ldi	r25, 0x00	; 0
    6ad2:	0e 94 01 34 	call	0x6802	; 0x6802 <calculateTcpChecksun>

      socket->seqNoLastSent++;
    6ad6:	8d 85       	ldd	r24, Y+13	; 0x0d
    6ad8:	9e 85       	ldd	r25, Y+14	; 0x0e
    6ada:	af 85       	ldd	r26, Y+15	; 0x0f
    6adc:	b8 89       	ldd	r27, Y+16	; 0x10
    6ade:	01 96       	adiw	r24, 0x01	; 1
    6ae0:	a1 1d       	adc	r26, r1
    6ae2:	b1 1d       	adc	r27, r1
    6ae4:	8d 87       	std	Y+13, r24	; 0x0d
    6ae6:	9e 87       	std	Y+14, r25	; 0x0e
    6ae8:	af 87       	std	Y+15, r26	; 0x0f
    6aea:	b8 8b       	std	Y+16, r27	; 0x10
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    6aec:	69 81       	ldd	r22, Y+1	; 0x01
    6aee:	7a 81       	ldd	r23, Y+2	; 0x02
    6af0:	8b 81       	ldd	r24, Y+3	; 0x03
    6af2:	9c 81       	ldd	r25, Y+4	; 0x04
    6af4:	24 e1       	ldi	r18, 0x14	; 20
    6af6:	30 e0       	ldi	r19, 0x00	; 0
    6af8:	46 e0       	ldi	r20, 0x06	; 6
    6afa:	0e 94 1f 2e 	call	0x5c3e	; 0x5c3e <ipSend>
    6afe:	88 c0       	rjmp	.+272    	; 0x6c10 <processTcpPacket+0x3ec>
    }
#if TCP_DEBUG
    else
    {
      if (tcpDebugStream != NULL)
    6b00:	00 97       	sbiw	r24, 0x00	; 0
    6b02:	09 f4       	brne	.+2      	; 0x6b06 <processTcpPacket+0x2e2>
    6b04:	85 c0       	rjmp	.+266    	; 0x6c10 <processTcpPacket+0x3ec>
        if (tcpDebugLevel > 1)
    6b06:	20 91 a5 0e 	lds	r18, 0x0EA5
    6b0a:	22 30       	cpi	r18, 0x02	; 2
    6b0c:	08 f4       	brcc	.+2      	; 0x6b10 <processTcpPacket+0x2ec>
    6b0e:	80 c0       	rjmp	.+256    	; 0x6c10 <processTcpPacket+0x3ec>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: syn flag wasn't set\r\n"));
    6b10:	21 ed       	ldi	r18, 0xD1	; 209
    6b12:	31 e1       	ldi	r19, 0x11	; 17
    6b14:	32 c0       	rjmp	.+100    	; 0x6b7a <processTcpPacket+0x356>
    }
#endif
    return 0;
  }

  if (socket->state == SYN_RECEIVED)
    6b16:	82 30       	cpi	r24, 0x02	; 2
    6b18:	d9 f5       	brne	.+118    	; 0x6b90 <processTcpPacket+0x36c>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_ACK)
    6b1a:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6b1e:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6b22:	25 85       	ldd	r18, Z+13	; 0x0d
    6b24:	80 91 4c 0f 	lds	r24, 0x0F4C
    6b28:	90 91 4d 0f 	lds	r25, 0x0F4D
    6b2c:	12 2f       	mov	r17, r18
    6b2e:	10 71       	andi	r17, 0x10	; 16
    6b30:	24 ff       	sbrs	r18, 4
    6b32:	17 c0       	rjmp	.+46     	; 0x6b62 <processTcpPacket+0x33e>
    {
      socket->state    = ESTABILISHED;
    6b34:	23 e0       	ldi	r18, 0x03	; 3
    6b36:	28 83       	st	Y, r18
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    6b38:	00 97       	sbiw	r24, 0x00	; 0
    6b3a:	09 f4       	brne	.+2      	; 0x6b3e <processTcpPacket+0x31a>
    6b3c:	69 c0       	rjmp	.+210    	; 0x6c10 <processTcpPacket+0x3ec>
      if (tcpDebugLevel > 2)
    6b3e:	20 91 a5 0e 	lds	r18, 0x0EA5
    6b42:	23 30       	cpi	r18, 0x03	; 3
    6b44:	08 f4       	brcc	.+2      	; 0x6b48 <processTcpPacket+0x324>
    6b46:	64 c0       	rjmp	.+200    	; 0x6c10 <processTcpPacket+0x3ec>
        fprintf_P(tcpDebugStream, PSTR("Opening TCP connection socket state change SYN_RECEIVED->ESTABILISHED\r\n"));
    6b48:	29 e8       	ldi	r18, 0x89	; 137
    6b4a:	31 e1       	ldi	r19, 0x11	; 17
    6b4c:	3f 93       	push	r19
    6b4e:	2f 93       	push	r18
    6b50:	9f 93       	push	r25
    6b52:	8f 93       	push	r24
    6b54:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6b58:	0f 90       	pop	r0
    6b5a:	0f 90       	pop	r0
    6b5c:	0f 90       	pop	r0
    6b5e:	0f 90       	pop	r0
    6b60:	57 c0       	rjmp	.+174    	; 0x6c10 <processTcpPacket+0x3ec>
#endif

    }
    else
    {
      socket->state = LISTEN;
    6b62:	21 e0       	ldi	r18, 0x01	; 1
    6b64:	28 83       	st	Y, r18
#if TCP_DEBUG
      if (tcpDebugStream != NULL)
    6b66:	00 97       	sbiw	r24, 0x00	; 0
    6b68:	09 f4       	brne	.+2      	; 0x6b6c <processTcpPacket+0x348>
    6b6a:	52 c0       	rjmp	.+164    	; 0x6c10 <processTcpPacket+0x3ec>
        if (tcpDebugLevel > 1)
    6b6c:	20 91 a5 0e 	lds	r18, 0x0EA5
    6b70:	22 30       	cpi	r18, 0x02	; 2
    6b72:	08 f4       	brcc	.+2      	; 0x6b76 <processTcpPacket+0x352>
    6b74:	4d c0       	rjmp	.+154    	; 0x6c10 <processTcpPacket+0x3ec>
          fprintf_P(tcpDebugStream, PSTR("Opening TCP connection ERROR: ack flag wasn't set\r\n"));
    6b76:	25 e5       	ldi	r18, 0x55	; 85
    6b78:	31 e1       	ldi	r19, 0x11	; 17
    6b7a:	3f 93       	push	r19
    6b7c:	2f 93       	push	r18
    6b7e:	9f 93       	push	r25
    6b80:	8f 93       	push	r24
    6b82:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6b86:	0f 90       	pop	r0
    6b88:	0f 90       	pop	r0
    6b8a:	0f 90       	pop	r0
    6b8c:	0f 90       	pop	r0
    6b8e:	43 c0       	rjmp	.+134    	; 0x6c16 <processTcpPacket+0x3f2>
    }
    return 0;
  }


  if (socket->state == ESTABILISHED)
    6b90:	83 30       	cpi	r24, 0x03	; 3
    6b92:	f1 f5       	brne	.+124    	; 0x6c10 <processTcpPacket+0x3ec>
  {
    if (nicState.layer4.tcp->flags & TCP_FLAGS_FIN)  //ESTABILISHED -> CLOSE_WAIT -> closed
    6b94:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6b98:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6b9c:	85 85       	ldd	r24, Z+13	; 0x0d
    6b9e:	80 ff       	sbrs	r24, 0
    6ba0:	37 c0       	rjmp	.+110    	; 0x6c10 <processTcpPacket+0x3ec>
    {
      socket->timer              = timer100Hz;
    6ba2:	80 91 88 01 	lds	r24, 0x0188
    6ba6:	8d 8b       	std	Y+21, r24	; 0x15
      nicState.layer4.tcp->flags = TCP_FLAGS_ACK;
    6ba8:	80 e1       	ldi	r24, 0x10	; 16
    6baa:	85 87       	std	Z+13, r24	; 0x0d

      uint8_t dataFromBufLen = 0;
      uint8_t *dataPtr = (uint8_t *)(nicState.layer4.tcp+1);
    6bac:	8f 01       	movw	r16, r30
    6bae:	0c 5e       	subi	r16, 0xEC	; 236
    6bb0:	1f 4f       	sbci	r17, 0xFF	; 255
    6bb2:	68 01       	movw	r12, r16
    6bb4:	fc 2c       	mov	r15, r12
    6bb6:	f0 1a       	sub	r15, r16
      while (xQueueReceive(socket->Tx, dataPtr, 0) == pdTRUE)
    6bb8:	20 e0       	ldi	r18, 0x00	; 0
    6bba:	40 e0       	ldi	r20, 0x00	; 0
    6bbc:	50 e0       	ldi	r21, 0x00	; 0
    6bbe:	b6 01       	movw	r22, r12
    6bc0:	88 8d       	ldd	r24, Y+24	; 0x18
    6bc2:	99 8d       	ldd	r25, Y+25	; 0x19
    6bc4:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    6bc8:	81 30       	cpi	r24, 0x01	; 1
    6bca:	21 f4       	brne	.+8      	; 0x6bd4 <processTcpPacket+0x3b0>
      {
        dataFromBufLen++;
        dataPtr++;
    6bcc:	bf ef       	ldi	r27, 0xFF	; 255
    6bce:	cb 1a       	sub	r12, r27
    6bd0:	db 0a       	sbc	r13, r27
    6bd2:	f0 cf       	rjmp	.-32     	; 0x6bb4 <processTcpPacket+0x390>
      }
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN + dataFromBufLen);
    6bd4:	2f 2d       	mov	r18, r15
    6bd6:	30 e0       	ldi	r19, 0x00	; 0
    6bd8:	2c 5e       	subi	r18, 0xEC	; 236
    6bda:	3f 4f       	sbci	r19, 0xFF	; 255
    6bdc:	69 81       	ldd	r22, Y+1	; 0x01
    6bde:	7a 81       	ldd	r23, Y+2	; 0x02
    6be0:	8b 81       	ldd	r24, Y+3	; 0x03
    6be2:	9c 81       	ldd	r25, Y+4	; 0x04
    6be4:	46 e0       	ldi	r20, 0x06	; 6
    6be6:	0e 94 1f 2e 	call	0x5c3e	; 0x5c3e <ipSend>
      socket->state    = CLOSE_WAIT;
    6bea:	84 e0       	ldi	r24, 0x04	; 4
    6bec:	88 83       	st	Y, r24


      nicState.layer4.tcp->flags = TCP_FLAGS_FIN;
    6bee:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6bf2:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6bf6:	81 e0       	ldi	r24, 0x01	; 1
    6bf8:	85 87       	std	Z+13, r24	; 0x0d
      ipSend(socket->RemoteIpAddr, IP_PROTO_TCP, TCP_HEADER_LEN);
    6bfa:	69 81       	ldd	r22, Y+1	; 0x01
    6bfc:	7a 81       	ldd	r23, Y+2	; 0x02
    6bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    6c00:	9c 81       	ldd	r25, Y+4	; 0x04
    6c02:	24 e1       	ldi	r18, 0x14	; 20
    6c04:	30 e0       	ldi	r19, 0x00	; 0
    6c06:	46 e0       	ldi	r20, 0x06	; 6
    6c08:	0e 94 1f 2e 	call	0x5c3e	; 0x5c3e <ipSend>
      socket->state    = LAST_ACK;
    6c0c:	85 e0       	ldi	r24, 0x05	; 5
    6c0e:	88 83       	st	Y, r24
    }
    return 0;
    6c10:	10 e0       	ldi	r17, 0x00	; 0
    6c12:	01 c0       	rjmp	.+2      	; 0x6c16 <processTcpPacket+0x3f2>
inline uint8_t processTcpPacket(void)
{
  struct TcpIpSocket *socket = findConnectedSocket();

  if (socket == NULL)
    return 1;
    6c14:	11 e0       	ldi	r17, 0x01	; 1
  }

  //Read data and put into the queue

  return 0;
}
    6c16:	81 2f       	mov	r24, r17
    6c18:	df 91       	pop	r29
    6c1a:	cf 91       	pop	r28
    6c1c:	1f 91       	pop	r17
    6c1e:	0f 91       	pop	r16
    6c20:	ff 90       	pop	r15
    6c22:	ef 90       	pop	r14
    6c24:	df 90       	pop	r13
    6c26:	cf 90       	pop	r12
    6c28:	bf 90       	pop	r11
    6c2a:	af 90       	pop	r10
    6c2c:	9f 90       	pop	r9
    6c2e:	8f 90       	pop	r8
    6c30:	7f 90       	pop	r7
    6c32:	6f 90       	pop	r6
    6c34:	08 95       	ret

00006c36 <sendTcpBuffer>:
uint8_t sendTcpBuffer(uint8_t socketNo)
{
  (void) socketNo;
  //struct TcpIpSocket *sck = &sockets[socketNo];
  return 0;
}
    6c36:	80 e0       	ldi	r24, 0x00	; 0
    6c38:	08 95       	ret

00006c3a <netstackTCPIPProcess>:

void netstackTCPIPProcess(void)
{
    6c3a:	cf 93       	push	r28
    6c3c:	df 93       	push	r29
  if (nicState.layer4.tcp->destport == htons(80))
    6c3e:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6c42:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6c46:	c2 81       	ldd	r28, Z+2	; 0x02
    6c48:	d3 81       	ldd	r29, Z+3	; 0x03
    6c4a:	80 e5       	ldi	r24, 0x50	; 80
    6c4c:	90 e0       	ldi	r25, 0x00	; 0
    6c4e:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    6c52:	c8 17       	cp	r28, r24
    6c54:	d9 07       	cpc	r29, r25
    6c56:	99 f4       	brne	.+38     	; 0x6c7e <netstackTCPIPProcess+0x44>
  {
#if TCP_DEBUG
    if (tcpDebugStream != NULL)
    6c58:	80 91 4c 0f 	lds	r24, 0x0F4C
    6c5c:	90 91 4d 0f 	lds	r25, 0x0F4D
    6c60:	00 97       	sbiw	r24, 0x00	; 0
    6c62:	89 f0       	breq	.+34     	; 0x6c86 <netstackTCPIPProcess+0x4c>
      fprintf_P(tcpDebugStream, PSTR("HTTP not implemented\r\n"));
    6c64:	22 ed       	ldi	r18, 0xD2	; 210
    6c66:	30 e1       	ldi	r19, 0x10	; 16
    6c68:	3f 93       	push	r19
    6c6a:	2f 93       	push	r18
    6c6c:	9f 93       	push	r25
    6c6e:	8f 93       	push	r24
    6c70:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6c74:	0f 90       	pop	r0
    6c76:	0f 90       	pop	r0
    6c78:	0f 90       	pop	r0
    6c7a:	0f 90       	pop	r0
    6c7c:	04 c0       	rjmp	.+8      	; 0x6c86 <netstackTCPIPProcess+0x4c>
  }
  else
  {
    processTcpPacket();
  }
}
    6c7e:	df 91       	pop	r29
    6c80:	cf 91       	pop	r28
#endif
    ;
  }
  else
  {
    processTcpPacket();
    6c82:	0c 94 12 34 	jmp	0x6824	; 0x6824 <processTcpPacket>
  }
}
    6c86:	df 91       	pop	r29
    6c88:	cf 91       	pop	r28
    6c8a:	08 95       	ret

00006c8c <setTcpDebug>:

#if TCP_DEBUG
void setTcpDebug(FILE *stream, uint8_t level)
{
  tcpDebugStream = stream;
    6c8c:	90 93 4d 0f 	sts	0x0F4D, r25
    6c90:	80 93 4c 0f 	sts	0x0F4C, r24
  tcpDebugLevel = level;
    6c94:	60 93 a5 0e 	sts	0x0EA5, r22
    6c98:	08 95       	ret

00006c9a <flushTcpQueues>:
}
#endif /* TCP_DEBUG */

void flushTcpQueues()
{
    6c9a:	08 95       	ret

00006c9c <httpProcess>:
  }
}


inline void httpProcess()
{
    6c9c:	08 95       	ret

00006c9e <udpLoadConfig>:
#include "udp.h"

void udpLoadConfig()
{
    6c9e:	cf 93       	push	r28
    6ca0:	df 93       	push	r29
  udpSocket->dstIp      = eeprom_read_dword(&udpIpDst_eep);
    6ca2:	c0 91 a2 0e 	lds	r28, 0x0EA2
    6ca6:	d0 91 a3 0e 	lds	r29, 0x0EA3
    6caa:	84 e0       	ldi	r24, 0x04	; 4
    6cac:	90 e0       	ldi	r25, 0x00	; 0
    6cae:	0e 94 4d 53 	call	0xa69a	; 0xa69a <eeprom_read_dword>
    6cb2:	6e 83       	std	Y+6, r22	; 0x06
    6cb4:	7f 83       	std	Y+7, r23	; 0x07
    6cb6:	88 87       	std	Y+8, r24	; 0x08
    6cb8:	99 87       	std	Y+9, r25	; 0x09
  udpSocket->dstPortDef = eeprom_read_word(&udpPortDstEep);
    6cba:	82 e0       	ldi	r24, 0x02	; 2
    6cbc:	90 e0       	ldi	r25, 0x00	; 0
    6cbe:	0e 94 53 53 	call	0xa6a6	; 0xa6a6 <eeprom_read_word>
    6cc2:	99 83       	std	Y+1, r25	; 0x01
    6cc4:	88 83       	st	Y, r24
  udpSocket->srcPort    = eeprom_read_word(&udpPortSrcEep);
    6cc6:	80 e0       	ldi	r24, 0x00	; 0
    6cc8:	90 e0       	ldi	r25, 0x00	; 0
    6cca:	0e 94 53 53 	call	0xa6a6	; 0xa6a6 <eeprom_read_word>
    6cce:	9d 83       	std	Y+5, r25	; 0x05
    6cd0:	8c 83       	std	Y+4, r24	; 0x04
}
    6cd2:	df 91       	pop	r29
    6cd4:	cf 91       	pop	r28
    6cd6:	08 95       	ret

00006cd8 <udpInit_0>:

void udpInit_0(void)
{
    6cd8:	cf 93       	push	r28
    6cda:	df 93       	push	r29
#if UDP_DEBUG
  udpDbgStream         = NULL;
    6cdc:	10 92 c1 0e 	sts	0x0EC1, r1
    6ce0:	10 92 c0 0e 	sts	0x0EC0, r1
  udpDbgLevel          = 0;
    6ce4:	10 92 7d 0e 	sts	0x0E7D, r1
#endif
  udpSocket = xmalloc(sizeof(UdpSocket_t));
    6ce8:	8e e0       	ldi	r24, 0x0E	; 14
    6cea:	90 e0       	ldi	r25, 0x00	; 0
    6cec:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <xmalloc>
    6cf0:	ec 01       	movw	r28, r24
    6cf2:	90 93 a3 0e 	sts	0x0EA3, r25
    6cf6:	80 93 a2 0e 	sts	0x0EA2, r24

  udpSocket->Rx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_RX_BUF_ADDR));
    6cfa:	40 e0       	ldi	r20, 0x00	; 0
    6cfc:	59 e7       	ldi	r21, 0x79	; 121
    6cfe:	61 e0       	ldi	r22, 0x01	; 1
    6d00:	8f ef       	ldi	r24, 0xFF	; 255
    6d02:	0e 94 60 46 	call	0x8cc0	; 0x8cc0 <xQueueCreateExternal>
    6d06:	9b 87       	std	Y+11, r25	; 0x0b
    6d08:	8a 87       	std	Y+10, r24	; 0x0a
  udpSocket->Tx         = xQueueCreateExternal(255, 1, (void *)(RTOS_UDP_TX_BUF_ADDR));
    6d0a:	c0 91 a2 0e 	lds	r28, 0x0EA2
    6d0e:	d0 91 a3 0e 	lds	r29, 0x0EA3
    6d12:	40 e0       	ldi	r20, 0x00	; 0
    6d14:	58 e7       	ldi	r21, 0x78	; 120
    6d16:	61 e0       	ldi	r22, 0x01	; 1
    6d18:	8f ef       	ldi	r24, 0xFF	; 255
    6d1a:	0e 94 60 46 	call	0x8cc0	; 0x8cc0 <xQueueCreateExternal>
    6d1e:	9d 87       	std	Y+13, r25	; 0x0d
    6d20:	8c 87       	std	Y+12, r24	; 0x0c
}
    6d22:	df 91       	pop	r29
    6d24:	cf 91       	pop	r28
    6d26:	08 95       	ret

00006d28 <setUdpDebug>:

#if UDP_DEBUG
void setUdpDebug(FILE *stream, uint8_t level)
{
  udpDbgStream = stream;
    6d28:	90 93 c1 0e 	sts	0x0EC1, r25
    6d2c:	80 93 c0 0e 	sts	0x0EC0, r24
  udpDbgLevel = level;
    6d30:	60 93 7d 0e 	sts	0x0E7D, r22
    6d34:	08 95       	ret

00006d36 <udpSend>:
}
#endif

inline void udpSend(uint16_t len)
{
    6d36:	ef 92       	push	r14
    6d38:	ff 92       	push	r15
    6d3a:	0f 93       	push	r16
    6d3c:	1f 93       	push	r17
    6d3e:	cf 93       	push	r28
    6d40:	df 93       	push	r29
    6d42:	ec 01       	movw	r28, r24
// make pointer to UDP header
  nicState.layer4.udp->srcport  = udpSocket->srcPort;
    6d44:	a0 91 8a 0e 	lds	r26, 0x0E8A
    6d48:	b0 91 8b 0e 	lds	r27, 0x0E8B
    6d4c:	e0 91 a2 0e 	lds	r30, 0x0EA2
    6d50:	f0 91 a3 0e 	lds	r31, 0x0EA3
    6d54:	84 81       	ldd	r24, Z+4	; 0x04
    6d56:	95 81       	ldd	r25, Z+5	; 0x05
    6d58:	8d 93       	st	X+, r24
    6d5a:	9c 93       	st	X, r25
  nicState.layer4.udp->destport = (udpSocket->dstPortDef == 0)? udpSocket->dstPort : udpSocket->dstPortDef;          //data in udpSocket are stored in network order
    6d5c:	a0 91 8a 0e 	lds	r26, 0x0E8A
    6d60:	b0 91 8b 0e 	lds	r27, 0x0E8B
    6d64:	80 81       	ld	r24, Z
    6d66:	91 81       	ldd	r25, Z+1	; 0x01
    6d68:	00 97       	sbiw	r24, 0x00	; 0
    6d6a:	11 f4       	brne	.+4      	; 0x6d70 <udpSend+0x3a>
    6d6c:	82 81       	ldd	r24, Z+2	; 0x02
    6d6e:	93 81       	ldd	r25, Z+3	; 0x03
    6d70:	13 96       	adiw	r26, 0x03	; 3
    6d72:	9c 93       	st	X, r25
    6d74:	8e 93       	st	-X, r24
    6d76:	12 97       	sbiw	r26, 0x02	; 2

  nicState.layer4.udp->udplen = htons(len + UDP_HEADER_LEN);
    6d78:	e0 90 8a 0e 	lds	r14, 0x0E8A
    6d7c:	f0 90 8b 0e 	lds	r15, 0x0E8B
    6d80:	8e 01       	movw	r16, r28
    6d82:	08 5f       	subi	r16, 0xF8	; 248
    6d84:	1f 4f       	sbci	r17, 0xFF	; 255
    6d86:	c8 01       	movw	r24, r16
    6d88:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    6d8c:	f7 01       	movw	r30, r14
    6d8e:	95 83       	std	Z+5, r25	; 0x05
    6d90:	84 83       	std	Z+4, r24	; 0x04
  nicState.layer4.udp->udpchksum = 0;
    6d92:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6d96:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6d9a:	17 82       	std	Z+7, r1	; 0x07
    6d9c:	16 82       	std	Z+6, r1	; 0x06

#if UDP_DEBUG
  if (udpDbgStream != NULL)
    6d9e:	40 91 c0 0e 	lds	r20, 0x0EC0
    6da2:	50 91 c1 0e 	lds	r21, 0x0EC1
    6da6:	41 15       	cp	r20, r1
    6da8:	51 05       	cpc	r21, r1
    6daa:	a1 f0       	breq	.+40     	; 0x6dd4 <udpSend+0x9e>
    if (udpDbgLevel > 1)
    6dac:	80 91 7d 0e 	lds	r24, 0x0E7D
    6db0:	82 30       	cpi	r24, 0x02	; 2
    6db2:	80 f0       	brcs	.+32     	; 0x6dd4 <udpSend+0x9e>
      fprintf_P(udpDbgStream, PSTR("Sending UDP packet (data length %d)\r\n"), len);
    6db4:	df 93       	push	r29
    6db6:	cf 93       	push	r28
    6db8:	8b e3       	ldi	r24, 0x3B	; 59
    6dba:	93 e1       	ldi	r25, 0x13	; 19
    6dbc:	9f 93       	push	r25
    6dbe:	8f 93       	push	r24
    6dc0:	5f 93       	push	r21
    6dc2:	4f 93       	push	r20
    6dc4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6dc8:	0f 90       	pop	r0
    6dca:	0f 90       	pop	r0
    6dcc:	0f 90       	pop	r0
    6dce:	0f 90       	pop	r0
    6dd0:	0f 90       	pop	r0
    6dd2:	0f 90       	pop	r0
#endif
  ipSend(udpSocket->dstIp, IP_PROTO_UDP, len + UDP_HEADER_LEN);
    6dd4:	e0 91 a2 0e 	lds	r30, 0x0EA2
    6dd8:	f0 91 a3 0e 	lds	r31, 0x0EA3
    6ddc:	66 81       	ldd	r22, Z+6	; 0x06
    6dde:	77 81       	ldd	r23, Z+7	; 0x07
    6de0:	80 85       	ldd	r24, Z+8	; 0x08
    6de2:	91 85       	ldd	r25, Z+9	; 0x09
    6de4:	98 01       	movw	r18, r16
    6de6:	41 e1       	ldi	r20, 0x11	; 17
    6de8:	0e 94 1f 2e 	call	0x5c3e	; 0x5c3e <ipSend>

  if(udpDbgStream != NULL)
    6dec:	80 91 c0 0e 	lds	r24, 0x0EC0
    6df0:	90 91 c1 0e 	lds	r25, 0x0EC1
    6df4:	00 97       	sbiw	r24, 0x00	; 0
    6df6:	81 f0       	breq	.+32     	; 0x6e18 <udpSend+0xe2>
    fprintf_P(udpDbgStream, PSTR("UDP tx %d bytes\r\n"), len);
    6df8:	df 93       	push	r29
    6dfa:	cf 93       	push	r28
    6dfc:	29 e2       	ldi	r18, 0x29	; 41
    6dfe:	33 e1       	ldi	r19, 0x13	; 19
    6e00:	3f 93       	push	r19
    6e02:	2f 93       	push	r18
    6e04:	9f 93       	push	r25
    6e06:	8f 93       	push	r24
    6e08:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6e0c:	0f 90       	pop	r0
    6e0e:	0f 90       	pop	r0
    6e10:	0f 90       	pop	r0
    6e12:	0f 90       	pop	r0
    6e14:	0f 90       	pop	r0
    6e16:	0f 90       	pop	r0
}
    6e18:	df 91       	pop	r29
    6e1a:	cf 91       	pop	r28
    6e1c:	1f 91       	pop	r17
    6e1e:	0f 91       	pop	r16
    6e20:	ff 90       	pop	r15
    6e22:	ef 90       	pop	r14
    6e24:	08 95       	ret

00006e26 <netstackUDPIPProcess>:

inline void netstackUDPIPProcess(void)
{
    6e26:	bf 92       	push	r11
    6e28:	cf 92       	push	r12
    6e2a:	df 92       	push	r13
    6e2c:	ef 92       	push	r14
    6e2e:	ff 92       	push	r15
    6e30:	0f 93       	push	r16
    6e32:	1f 93       	push	r17
    6e34:	cf 93       	push	r28
    6e36:	df 93       	push	r29
  uint16_t len = (uint16_t) htons(nicState.layer4.udp->udplen);
    6e38:	e0 91 8a 0e 	lds	r30, 0x0E8A
    6e3c:	f0 91 8b 0e 	lds	r31, 0x0E8B
    6e40:	84 81       	ldd	r24, Z+4	; 0x04
    6e42:	95 81       	ldd	r25, Z+5	; 0x05
    6e44:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    6e48:	8c 01       	movw	r16, r24
  uint8_t i;

  #if UDP_DEBUG
  if(udpDbgStream != NULL)
    6e4a:	80 91 c0 0e 	lds	r24, 0x0EC0
    6e4e:	90 91 c1 0e 	lds	r25, 0x0EC1
    6e52:	00 97       	sbiw	r24, 0x00	; 0
    6e54:	b9 f0       	breq	.+46     	; 0x6e84 <netstackUDPIPProcess+0x5e>
    if (udpDbgLevel > 5)
    6e56:	20 91 7d 0e 	lds	r18, 0x0E7D
    6e5a:	26 30       	cpi	r18, 0x06	; 6
    6e5c:	98 f0       	brcs	.+38     	; 0x6e84 <netstackUDPIPProcess+0x5e>
      fprintf_P(udpDbgStream, PSTR("Proc. UDP packet (data length %d)"), len-UDP_HEADER_LEN);
    6e5e:	98 01       	movw	r18, r16
    6e60:	28 50       	subi	r18, 0x08	; 8
    6e62:	31 09       	sbc	r19, r1
    6e64:	3f 93       	push	r19
    6e66:	2f 93       	push	r18
    6e68:	27 e0       	ldi	r18, 0x07	; 7
    6e6a:	33 e1       	ldi	r19, 0x13	; 19
    6e6c:	3f 93       	push	r19
    6e6e:	2f 93       	push	r18
    6e70:	9f 93       	push	r25
    6e72:	8f 93       	push	r24
    6e74:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6e78:	0f 90       	pop	r0
    6e7a:	0f 90       	pop	r0
    6e7c:	0f 90       	pop	r0
    6e7e:	0f 90       	pop	r0
    6e80:	0f 90       	pop	r0
    6e82:	0f 90       	pop	r0
#endif

  if ((udpSocket->srcPort != nicState.layer4.udp->destport) ||
    6e84:	e0 91 a2 0e 	lds	r30, 0x0EA2
    6e88:	f0 91 a3 0e 	lds	r31, 0x0EA3
    6e8c:	a0 91 8a 0e 	lds	r26, 0x0E8A
    6e90:	b0 91 8b 0e 	lds	r27, 0x0E8B
    6e94:	12 96       	adiw	r26, 0x02	; 2
    6e96:	8d 91       	ld	r24, X+
    6e98:	9c 91       	ld	r25, X
    6e9a:	13 97       	sbiw	r26, 0x03	; 3
    6e9c:	44 81       	ldd	r20, Z+4	; 0x04
    6e9e:	55 81       	ldd	r21, Z+5	; 0x05
    6ea0:	20 91 c0 0e 	lds	r18, 0x0EC0
    6ea4:	30 91 c1 0e 	lds	r19, 0x0EC1
    6ea8:	48 17       	cp	r20, r24
    6eaa:	59 07       	cpc	r21, r25
    6eac:	61 f4       	brne	.+24     	; 0x6ec6 <netstackUDPIPProcess+0xa0>
    6eae:	60 81       	ld	r22, Z
    6eb0:	71 81       	ldd	r23, Z+1	; 0x01
    6eb2:	4d 91       	ld	r20, X+
    6eb4:	5c 91       	ld	r21, X
    6eb6:	11 97       	sbiw	r26, 0x01	; 1
    6eb8:	67 2b       	or	r22, r23
    6eba:	39 f1       	breq	.+78     	; 0x6f0a <netstackUDPIPProcess+0xe4>
     ((udpSocket->dstPortDef != HTONS(0)) && (udpSocket->dstPort == nicState.layer4.udp->srcport)))
    6ebc:	62 81       	ldd	r22, Z+2	; 0x02
    6ebe:	73 81       	ldd	r23, Z+3	; 0x03
    6ec0:	64 17       	cp	r22, r20
    6ec2:	75 07       	cpc	r23, r21
    6ec4:	21 f5       	brne	.+72     	; 0x6f0e <netstackUDPIPProcess+0xe8>
  {
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    6ec6:	21 15       	cp	r18, r1
    6ec8:	31 05       	cpc	r19, r1
    6eca:	09 f4       	brne	.+2      	; 0x6ece <netstackUDPIPProcess+0xa8>
    6ecc:	ac c0       	rjmp	.+344    	; 0x7026 <netstackUDPIPProcess+0x200>
        if (udpDbgLevel > 5)
    6ece:	40 91 7d 0e 	lds	r20, 0x0E7D
    6ed2:	46 30       	cpi	r20, 0x06	; 6
    6ed4:	08 f4       	brcc	.+2      	; 0x6ed8 <netstackUDPIPProcess+0xb2>
    6ed6:	a7 c0       	rjmp	.+334    	; 0x7026 <netstackUDPIPProcess+0x200>
          fprintf_P(udpDbgStream, PSTR("Skipping, wrong ports %d %d\r\n"), nicState.layer4.udp->destport, nicState.layer4.udp->srcport );
    6ed8:	11 96       	adiw	r26, 0x01	; 1
    6eda:	4c 91       	ld	r20, X
    6edc:	11 97       	sbiw	r26, 0x01	; 1
    6ede:	4f 93       	push	r20
    6ee0:	4c 91       	ld	r20, X
    6ee2:	4f 93       	push	r20
    6ee4:	9f 93       	push	r25
    6ee6:	8f 93       	push	r24
    6ee8:	89 ee       	ldi	r24, 0xE9	; 233
    6eea:	92 e1       	ldi	r25, 0x12	; 18
    6eec:	9f 93       	push	r25
    6eee:	8f 93       	push	r24
    6ef0:	3f 93       	push	r19
    6ef2:	2f 93       	push	r18
    6ef4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6ef8:	8d b7       	in	r24, 0x3d	; 61
    6efa:	9e b7       	in	r25, 0x3e	; 62
    6efc:	08 96       	adiw	r24, 0x08	; 8
    6efe:	0f b6       	in	r0, 0x3f	; 63
    6f00:	f8 94       	cli
    6f02:	9e bf       	out	0x3e, r25	; 62
    6f04:	0f be       	out	0x3f, r0	; 63
    6f06:	8d bf       	out	0x3d, r24	; 61
    6f08:	8e c0       	rjmp	.+284    	; 0x7026 <netstackUDPIPProcess+0x200>
#endif
     return;
  }

  if (udpSocket->dstPortDef == HTONS(0))
    udpSocket->dstPort = nicState.layer4.udp->srcport;
    6f0a:	53 83       	std	Z+3, r21	; 0x03
    6f0c:	42 83       	std	Z+2, r20	; 0x02
  uint8_t *tmp = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    6f0e:	c0 91 8a 0e 	lds	r28, 0x0E8A
    6f12:	d0 91 8b 0e 	lds	r29, 0x0E8B
    6f16:	28 96       	adiw	r28, 0x08	; 8
#if UDP_DEBUG
      if(udpDbgStream != NULL)
    6f18:	21 15       	cp	r18, r1
    6f1a:	31 05       	cpc	r19, r1
    6f1c:	81 f0       	breq	.+32     	; 0x6f3e <netstackUDPIPProcess+0x118>
        if (udpDbgLevel > 4)
    6f1e:	80 91 7d 0e 	lds	r24, 0x0E7D
    6f22:	85 30       	cpi	r24, 0x05	; 5
    6f24:	60 f0       	brcs	.+24     	; 0x6f3e <netstackUDPIPProcess+0x118>
          fprintf_P(udpDbgStream, PSTR("Received UDP data:"));
    6f26:	86 ed       	ldi	r24, 0xD6	; 214
    6f28:	92 e1       	ldi	r25, 0x12	; 18
    6f2a:	9f 93       	push	r25
    6f2c:	8f 93       	push	r24
    6f2e:	3f 93       	push	r19
    6f30:	2f 93       	push	r18
    6f32:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6f36:	0f 90       	pop	r0
    6f38:	0f 90       	pop	r0
    6f3a:	0f 90       	pop	r0
    6f3c:	0f 90       	pop	r0
  if(udpDbgStream != NULL)
    fprintf_P(udpDbgStream, PSTR("UDP tx %d bytes\r\n"), len);
}

inline void netstackUDPIPProcess(void)
{
    6f3e:	88 e0       	ldi	r24, 0x08	; 8
    6f40:	b8 2e       	mov	r11, r24
  for (i=UDP_HEADER_LEN; i<len; i++)
  {
#if UDP_DEBUG
    if(udpDbgStream != NULL)
      if (udpDbgLevel > 4)
        fprintf_P(udpDbgStream, PSTR(" 0x%2x"), *tmp);
    6f42:	9f ec       	ldi	r25, 0xCF	; 207
    6f44:	e9 2e       	mov	r14, r25
    6f46:	92 e1       	ldi	r25, 0x12	; 18
    6f48:	f9 2e       	mov	r15, r25
#endif
#if UDP_DEBUG
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
        if(udpDbgStream != NULL)
          if (udpDbgLevel > 0)
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    6f4a:	2a eb       	ldi	r18, 0xBA	; 186
    6f4c:	c2 2e       	mov	r12, r18
    6f4e:	22 e1       	ldi	r18, 0x12	; 18
    6f50:	d2 2e       	mov	r13, r18
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received UDP data:"));
#endif

  for (i=UDP_HEADER_LEN; i<len; i++)
    6f52:	8b 2d       	mov	r24, r11
    6f54:	90 e0       	ldi	r25, 0x00	; 0
    6f56:	20 91 c0 0e 	lds	r18, 0x0EC0
    6f5a:	30 91 c1 0e 	lds	r19, 0x0EC1
    6f5e:	80 17       	cp	r24, r16
    6f60:	91 07       	cpc	r25, r17
    6f62:	d8 f5       	brcc	.+118    	; 0x6fda <netstackUDPIPProcess+0x1b4>
  {
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    6f64:	21 15       	cp	r18, r1
    6f66:	31 05       	cpc	r19, r1
    6f68:	99 f0       	breq	.+38     	; 0x6f90 <netstackUDPIPProcess+0x16a>
      if (udpDbgLevel > 4)
    6f6a:	80 91 7d 0e 	lds	r24, 0x0E7D
    6f6e:	85 30       	cpi	r24, 0x05	; 5
    6f70:	78 f0       	brcs	.+30     	; 0x6f90 <netstackUDPIPProcess+0x16a>
        fprintf_P(udpDbgStream, PSTR(" 0x%2x"), *tmp);
    6f72:	88 81       	ld	r24, Y
    6f74:	1f 92       	push	r1
    6f76:	8f 93       	push	r24
    6f78:	ff 92       	push	r15
    6f7a:	ef 92       	push	r14
    6f7c:	3f 93       	push	r19
    6f7e:	2f 93       	push	r18
    6f80:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6f84:	0f 90       	pop	r0
    6f86:	0f 90       	pop	r0
    6f88:	0f 90       	pop	r0
    6f8a:	0f 90       	pop	r0
    6f8c:	0f 90       	pop	r0
    6f8e:	0f 90       	pop	r0
#else
    xQueueSend(udpSocket->Rx, tmp, 0);
#endif
#if UDP_DEBUG
      if (xQueueSend(udpSocket->Rx, tmp, 10) == 0)
    6f90:	e0 91 a2 0e 	lds	r30, 0x0EA2
    6f94:	f0 91 a3 0e 	lds	r31, 0x0EA3
    6f98:	20 e0       	ldi	r18, 0x00	; 0
    6f9a:	4a e0       	ldi	r20, 0x0A	; 10
    6f9c:	50 e0       	ldi	r21, 0x00	; 0
    6f9e:	be 01       	movw	r22, r28
    6fa0:	82 85       	ldd	r24, Z+10	; 0x0a
    6fa2:	93 85       	ldd	r25, Z+11	; 0x0b
    6fa4:	0e 94 a2 46 	call	0x8d44	; 0x8d44 <xQueueGenericSend>
    6fa8:	81 11       	cpse	r24, r1
    6faa:	14 c0       	rjmp	.+40     	; 0x6fd4 <netstackUDPIPProcess+0x1ae>
        if(udpDbgStream != NULL)
    6fac:	80 91 c0 0e 	lds	r24, 0x0EC0
    6fb0:	90 91 c1 0e 	lds	r25, 0x0EC1
    6fb4:	00 97       	sbiw	r24, 0x00	; 0
    6fb6:	71 f0       	breq	.+28     	; 0x6fd4 <netstackUDPIPProcess+0x1ae>
          if (udpDbgLevel > 0)
    6fb8:	20 91 7d 0e 	lds	r18, 0x0E7D
    6fbc:	22 23       	and	r18, r18
    6fbe:	51 f0       	breq	.+20     	; 0x6fd4 <netstackUDPIPProcess+0x1ae>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
    6fc0:	df 92       	push	r13
    6fc2:	cf 92       	push	r12
    6fc4:	9f 93       	push	r25
    6fc6:	8f 93       	push	r24
    6fc8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6fcc:	0f 90       	pop	r0
    6fce:	0f 90       	pop	r0
    6fd0:	0f 90       	pop	r0
    6fd2:	0f 90       	pop	r0
#endif
      tmp++;
    6fd4:	21 96       	adiw	r28, 0x01	; 1
      if(udpDbgStream != NULL)
        if (udpDbgLevel > 4)
          fprintf_P(udpDbgStream, PSTR("Received UDP data:"));
#endif

  for (i=UDP_HEADER_LEN; i<len; i++)
    6fd6:	b3 94       	inc	r11
    6fd8:	bc cf       	rjmp	.-136    	; 0x6f52 <netstackUDPIPProcess+0x12c>
            fprintf_P(udpDbgStream, PSTR("UDP TX buffer busy\r\n"));
#endif
      tmp++;
    }
#if UDP_DEBUG
    if(udpDbgStream != NULL)
    6fda:	21 15       	cp	r18, r1
    6fdc:	31 05       	cpc	r19, r1
    6fde:	19 f1       	breq	.+70     	; 0x7026 <netstackUDPIPProcess+0x200>
    {
       if (udpDbgLevel > 4)
    6fe0:	80 91 7d 0e 	lds	r24, 0x0E7D
    6fe4:	85 30       	cpi	r24, 0x05	; 5
    6fe6:	68 f0       	brcs	.+26     	; 0x7002 <netstackUDPIPProcess+0x1dc>
        fprintf_P(udpDbgStream, PSTR("\r\n"));
    6fe8:	87 eb       	ldi	r24, 0xB7	; 183
    6fea:	92 e1       	ldi	r25, 0x12	; 18
    6fec:	9f 93       	push	r25
    6fee:	8f 93       	push	r24
    6ff0:	3f 93       	push	r19
    6ff2:	2f 93       	push	r18
    6ff4:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    6ff8:	0f 90       	pop	r0
    6ffa:	0f 90       	pop	r0
    6ffc:	0f 90       	pop	r0
    6ffe:	0f 90       	pop	r0
    7000:	12 c0       	rjmp	.+36     	; 0x7026 <netstackUDPIPProcess+0x200>
       else if (udpDbgLevel > 0)
    7002:	88 23       	and	r24, r24
    7004:	81 f0       	breq	.+32     	; 0x7026 <netstackUDPIPProcess+0x200>
        fprintf_P(udpDbgStream, PSTR("Received UDP packet (len %d)\r\n"), len);
    7006:	1f 93       	push	r17
    7008:	0f 93       	push	r16
    700a:	88 e9       	ldi	r24, 0x98	; 152
    700c:	92 e1       	ldi	r25, 0x12	; 18
    700e:	9f 93       	push	r25
    7010:	8f 93       	push	r24
    7012:	3f 93       	push	r19
    7014:	2f 93       	push	r18
    7016:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    701a:	0f 90       	pop	r0
    701c:	0f 90       	pop	r0
    701e:	0f 90       	pop	r0
    7020:	0f 90       	pop	r0
    7022:	0f 90       	pop	r0
    7024:	0f 90       	pop	r0

    }
#endif
}
    7026:	df 91       	pop	r29
    7028:	cf 91       	pop	r28
    702a:	1f 91       	pop	r17
    702c:	0f 91       	pop	r16
    702e:	ff 90       	pop	r15
    7030:	ef 90       	pop	r14
    7032:	df 90       	pop	r13
    7034:	cf 90       	pop	r12
    7036:	bf 90       	pop	r11
    7038:	08 95       	ret

0000703a <flushUdpQueues>:

inline void flushUdpQueues(void)
{
    703a:	0f 93       	push	r16
    703c:	1f 93       	push	r17
    703e:	cf 93       	push	r28
    7040:	df 93       	push	r29
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
    7042:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7046:	f0 91 a3 0e 	lds	r31, 0x0EA3
    704a:	84 85       	ldd	r24, Z+12	; 0x0c
    704c:	95 85       	ldd	r25, Z+13	; 0x0d
    704e:	0e 94 2b 48 	call	0x9056	; 0x9056 <uxQueueMessagesWaiting>
    7052:	88 23       	and	r24, r24
    7054:	01 f1       	breq	.+64     	; 0x7096 <flushUdpQueues+0x5c>
  {
    uint16_t len = 0;
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    7056:	c0 91 8a 0e 	lds	r28, 0x0E8A
    705a:	d0 91 8b 0e 	lds	r29, 0x0E8B
    705e:	28 96       	adiw	r28, 0x08	; 8

inline void flushUdpQueues(void)
{
  if (uxQueueMessagesWaiting(udpSocket->Tx) > 0)
  {
    uint16_t len = 0;
    7060:	00 e0       	ldi	r16, 0x00	; 0
    7062:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t *data = (uint8_t *)(nicState.layer4.udp) + UDP_HEADER_LEN;
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    7064:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7068:	f0 91 a3 0e 	lds	r31, 0x0EA3
    706c:	20 e0       	ldi	r18, 0x00	; 0
    706e:	40 e0       	ldi	r20, 0x00	; 0
    7070:	50 e0       	ldi	r21, 0x00	; 0
    7072:	be 01       	movw	r22, r28
    7074:	84 85       	ldd	r24, Z+12	; 0x0c
    7076:	95 85       	ldd	r25, Z+13	; 0x0d
    7078:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    707c:	81 30       	cpi	r24, 0x01	; 1
    707e:	21 f4       	brne	.+8      	; 0x7088 <flushUdpQueues+0x4e>
    {
      data++;
    7080:	21 96       	adiw	r28, 0x01	; 1
      len++;
    7082:	0f 5f       	subi	r16, 0xFF	; 255
    7084:	1f 4f       	sbci	r17, 0xFF	; 255
    7086:	ee cf       	rjmp	.-36     	; 0x7064 <flushUdpQueues+0x2a>
    }
    udpSend(len);
    7088:	c8 01       	movw	r24, r16
  }
}
    708a:	df 91       	pop	r29
    708c:	cf 91       	pop	r28
    708e:	1f 91       	pop	r17
    7090:	0f 91       	pop	r16
    while (xQueueReceive(udpSocket->Tx, data, 0) == pdTRUE)
    {
      data++;
      len++;
    }
    udpSend(len);
    7092:	0c 94 9b 36 	jmp	0x6d36	; 0x6d36 <udpSend>
  }
}
    7096:	df 91       	pop	r29
    7098:	cf 91       	pop	r28
    709a:	1f 91       	pop	r17
    709c:	0f 91       	pop	r16
    709e:	08 95       	ret

000070a0 <udpSaveConfig>:

void udpSaveConfig(void)
{
  eeprom_update_dword(&udpIpDst_eep, udpSocket->dstIp);
    70a0:	e0 91 a2 0e 	lds	r30, 0x0EA2
    70a4:	f0 91 a3 0e 	lds	r31, 0x0EA3
    70a8:	46 81       	ldd	r20, Z+6	; 0x06
    70aa:	57 81       	ldd	r21, Z+7	; 0x07
    70ac:	60 85       	ldd	r22, Z+8	; 0x08
    70ae:	71 85       	ldd	r23, Z+9	; 0x09
    70b0:	84 e0       	ldi	r24, 0x04	; 4
    70b2:	90 e0       	ldi	r25, 0x00	; 0
    70b4:	0e 94 7a 53 	call	0xa6f4	; 0xa6f4 <eeprom_update_dword>
  eeprom_update_word(&udpPortDstEep, udpSocket->dstPortDef);
    70b8:	e0 91 a2 0e 	lds	r30, 0x0EA2
    70bc:	f0 91 a3 0e 	lds	r31, 0x0EA3
    70c0:	60 81       	ld	r22, Z
    70c2:	71 81       	ldd	r23, Z+1	; 0x01
    70c4:	82 e0       	ldi	r24, 0x02	; 2
    70c6:	90 e0       	ldi	r25, 0x00	; 0
    70c8:	0e 94 86 53 	call	0xa70c	; 0xa70c <eeprom_update_word>
  eeprom_update_word(&udpPortSrcEep, udpSocket->srcPort);
    70cc:	e0 91 a2 0e 	lds	r30, 0x0EA2
    70d0:	f0 91 a3 0e 	lds	r31, 0x0EA3
    70d4:	64 81       	ldd	r22, Z+4	; 0x04
    70d6:	75 81       	ldd	r23, Z+5	; 0x05
    70d8:	80 e0       	ldi	r24, 0x00	; 0
    70da:	90 e0       	ldi	r25, 0x00	; 0
    70dc:	0c 94 86 53 	jmp	0xa70c	; 0xa70c <eeprom_update_word>

000070e0 <udpPrintStatus>:
}

void udpPrintStatus(FILE *stream)
{
    70e0:	cf 93       	push	r28
    70e2:	df 93       	push	r29
    70e4:	ec 01       	movw	r28, r24
  fprintf_P(stream, PSTR("UDP config:"));
    70e6:	8c e8       	ldi	r24, 0x8C	; 140
    70e8:	92 e1       	ldi	r25, 0x12	; 18
    70ea:	9f 93       	push	r25
    70ec:	8f 93       	push	r24
    70ee:	df 93       	push	r29
    70f0:	cf 93       	push	r28
    70f2:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  fprintf_P(stream, PSTR("\r\n  IP          : ")); netPrintIPAddr(stream, udpSocket->dstIp);
    70f6:	89 e7       	ldi	r24, 0x79	; 121
    70f8:	92 e1       	ldi	r25, 0x12	; 18
    70fa:	9f 93       	push	r25
    70fc:	8f 93       	push	r24
    70fe:	df 93       	push	r29
    7100:	cf 93       	push	r28
    7102:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    7106:	e0 91 a2 0e 	lds	r30, 0x0EA2
    710a:	f0 91 a3 0e 	lds	r31, 0x0EA3
    710e:	46 81       	ldd	r20, Z+6	; 0x06
    7110:	57 81       	ldd	r21, Z+7	; 0x07
    7112:	60 85       	ldd	r22, Z+8	; 0x08
    7114:	71 85       	ldd	r23, Z+9	; 0x09
    7116:	ce 01       	movw	r24, r28
    7118:	0e 94 29 2b 	call	0x5652	; 0x5652 <netPrintIPAddr>
  fprintf_P(stream, PSTR("\r\n  src port    : %d\r\n  dst port    : "), htons(udpSocket->srcPort));
    711c:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7120:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7124:	84 81       	ldd	r24, Z+4	; 0x04
    7126:	95 81       	ldd	r25, Z+5	; 0x05
    7128:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    712c:	9f 93       	push	r25
    712e:	8f 93       	push	r24
    7130:	82 e5       	ldi	r24, 0x52	; 82
    7132:	92 e1       	ldi	r25, 0x12	; 18
    7134:	9f 93       	push	r25
    7136:	8f 93       	push	r24
    7138:	df 93       	push	r29
    713a:	cf 93       	push	r28
    713c:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
  if (udpSocket->dstPortDef == HTONS(0))
    7140:	e0 91 a2 0e 	lds	r30, 0x0EA2
    7144:	f0 91 a3 0e 	lds	r31, 0x0EA3
    7148:	80 81       	ld	r24, Z
    714a:	91 81       	ldd	r25, Z+1	; 0x01
    714c:	2d b7       	in	r18, 0x3d	; 61
    714e:	3e b7       	in	r19, 0x3e	; 62
    7150:	22 5f       	subi	r18, 0xF2	; 242
    7152:	3f 4f       	sbci	r19, 0xFF	; 255
    7154:	0f b6       	in	r0, 0x3f	; 63
    7156:	f8 94       	cli
    7158:	3e bf       	out	0x3e, r19	; 62
    715a:	0f be       	out	0x3f, r0	; 63
    715c:	2d bf       	out	0x3d, r18	; 61
    715e:	00 97       	sbiw	r24, 0x00	; 0
    7160:	69 f4       	brne	.+26     	; 0x717c <udpPrintStatus+0x9c>
    fprintf_P(stream, PSTR("ANY\r\n"));
    7162:	8c e4       	ldi	r24, 0x4C	; 76
    7164:	92 e1       	ldi	r25, 0x12	; 18
    7166:	9f 93       	push	r25
    7168:	8f 93       	push	r24
    716a:	df 93       	push	r29
    716c:	cf 93       	push	r28
    716e:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    7172:	0f 90       	pop	r0
    7174:	0f 90       	pop	r0
    7176:	0f 90       	pop	r0
    7178:	0f 90       	pop	r0
    717a:	12 c0       	rjmp	.+36     	; 0x71a0 <udpPrintStatus+0xc0>
  else
    fprintf_P(stream, PSTR("%d\r\n"), htons(udpSocket->dstPortDef));
    717c:	0e 94 cb 2a 	call	0x5596	; 0x5596 <htons>
    7180:	9f 93       	push	r25
    7182:	8f 93       	push	r24
    7184:	87 e4       	ldi	r24, 0x47	; 71
    7186:	92 e1       	ldi	r25, 0x12	; 18
    7188:	9f 93       	push	r25
    718a:	8f 93       	push	r24
    718c:	df 93       	push	r29
    718e:	cf 93       	push	r28
    7190:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    7194:	0f 90       	pop	r0
    7196:	0f 90       	pop	r0
    7198:	0f 90       	pop	r0
    719a:	0f 90       	pop	r0
    719c:	0f 90       	pop	r0
    719e:	0f 90       	pop	r0
}
    71a0:	df 91       	pop	r29
    71a2:	cf 91       	pop	r28
    71a4:	08 95       	ret

000071a6 <_crc_xmodem_update>:
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
    71a6:	96 27       	eor	r25, r22
    71a8:	09 2e       	mov	r0, r25
    71aa:	02 94       	swap	r0
    71ac:	20 2d       	mov	r18, r0
    71ae:	2f 70       	andi	r18, 0x0F	; 15
    71b0:	29 27       	eor	r18, r25
    71b2:	69 2f       	mov	r22, r25
    71b4:	60 25       	eor	r22, r0
    71b6:	66 0f       	add	r22, r22
    71b8:	60 7e       	andi	r22, 0xE0	; 224
    71ba:	26 27       	eor	r18, r22
    71bc:	60 2d       	mov	r22, r0
    71be:	69 27       	eor	r22, r25
    71c0:	60 7f       	andi	r22, 0xF0	; 240
    71c2:	66 95       	lsr	r22
    71c4:	09 2e       	mov	r0, r25
    71c6:	00 0c       	add	r0, r0
    71c8:	66 1f       	adc	r22, r22
    71ca:	96 95       	lsr	r25
    71cc:	96 95       	lsr	r25
    71ce:	96 95       	lsr	r25
    71d0:	9f 71       	andi	r25, 0x1F	; 31
    71d2:	96 27       	eor	r25, r22
    71d4:	98 27       	eor	r25, r24
    71d6:	82 2f       	mov	r24, r18
    71d8:	08 95       	ret
    71da:	08 95       	ret
    71dc:	08 95       	ret
    71de:	08 95       	ret
    71e0:	81 e0       	ldi	r24, 0x01	; 1
    71e2:	08 95       	ret
    71e4:	81 e0       	ldi	r24, 0x01	; 1
    71e6:	08 95       	ret

000071e8 <rollersMemInit>:
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    71e8:	8e e6       	ldi	r24, 0x6E	; 110
    71ea:	90 e0       	ldi	r25, 0x00	; 0
    71ec:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <xmalloc>
    71f0:	90 93 a9 0e 	sts	0x0EA9, r25
    71f4:	80 93 a8 0e 	sts	0x0EA8, r24
  POSSIBILITY OF SUCH DAMAGE. */
    71f8:	2e e6       	ldi	r18, 0x6E	; 110
    71fa:	fc 01       	movw	r30, r24
    71fc:	11 92       	st	Z+, r1
    71fe:	2a 95       	dec	r18
    7200:	e9 f7       	brne	.-6      	; 0x71fc <rollersMemInit+0x14>
    7202:	08 95       	ret

00007204 <printRs485devices>:
        "rol    %2"              "\n\t"
        "lsr    %B0"             "\n\t"
        "lsr    %B0"             "\n\t"
        "lsr    %B0"             "\n\t"
        "andi   %B0,0x1f"        "\n\t"
        "eor    %B0,%2"          "\n\t"
    7204:	9f 92       	push	r9
    7206:	af 92       	push	r10
    7208:	bf 92       	push	r11
    720a:	cf 92       	push	r12
    720c:	df 92       	push	r13
    720e:	ef 92       	push	r14
    7210:	ff 92       	push	r15
    7212:	0f 93       	push	r16
    7214:	1f 93       	push	r17
    7216:	cf 93       	push	r28
    7218:	df 93       	push	r29
    721a:	e8 2e       	mov	r14, r24
    721c:	99 2e       	mov	r9, r25
        "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
        "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
    721e:	00 91 a8 0e 	lds	r16, 0x0EA8
    7222:	10 91 a9 0e 	lds	r17, 0x0EA9
    7226:	e8 01       	movw	r28, r16
    7228:	25 96       	adiw	r28, 0x05	; 5
    722a:	0d 58       	subi	r16, 0x8D	; 141
    722c:	1f 4f       	sbci	r17, 0xFF	; 255
        "lsr    %B0"             "\n\t"
        "lsr    %B0"             "\n\t"
        "lsr    %B0"             "\n\t"
        "andi   %B0,0x1f"        "\n\t"
        "eor    %B0,%2"          "\n\t"
        "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
    722e:	f1 2c       	mov	r15, r1
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}

    7230:	84 ee       	ldi	r24, 0xE4	; 228
    7232:	a8 2e       	mov	r10, r24
    7234:	83 e1       	ldi	r24, 0x13	; 19
    7236:	b8 2e       	mov	r11, r24
/** \ingroup util_crc
    Optimized CRC-CCITT calculation.
    7238:	99 ec       	ldi	r25, 0xC9	; 201
    723a:	c9 2e       	mov	r12, r25
    723c:	93 e1       	ldi	r25, 0x13	; 19
    723e:	d9 2e       	mov	r13, r25
    7240:	fe 01       	movw	r30, r28
    7242:	34 97       	sbiw	r30, 0x04	; 4
        "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
    7244:	80 81       	ld	r24, Z
    7246:	88 23       	and	r24, r24
    7248:	19 f1       	breq	.+70     	; 0x7290 <printRs485devices+0x8c>
    724a:	32 96       	adiw	r30, 0x02	; 2
}

    724c:	20 81       	ld	r18, Z
    724e:	2f 73       	andi	r18, 0x3F	; 63
    7250:	1f 92       	push	r1
    7252:	2f 93       	push	r18
    7254:	31 97       	sbiw	r30, 0x01	; 1
    7256:	20 81       	ld	r18, Z
    7258:	2f 73       	andi	r18, 0x3F	; 63
    725a:	1f 92       	push	r1
    725c:	2f 93       	push	r18
    725e:	1f 92       	push	r1
    7260:	8f 93       	push	r24
    7262:	bf 92       	push	r11
    7264:	af 92       	push	r10
    7266:	9f 92       	push	r9
    7268:	ef 92       	push	r14
    726a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
/** \ingroup util_crc
    Optimized CRC-CCITT calculation.
    726e:	df 93       	push	r29
    7270:	cf 93       	push	r28
    7272:	df 92       	push	r13
    7274:	cf 92       	push	r12
    7276:	9f 92       	push	r9
    7278:	ef 92       	push	r14
    727a:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>

    727e:	f3 94       	inc	r15
    7280:	8d b7       	in	r24, 0x3d	; 61
    7282:	9e b7       	in	r25, 0x3e	; 62
    7284:	40 96       	adiw	r24, 0x10	; 16
    7286:	0f b6       	in	r0, 0x3f	; 63
    7288:	f8 94       	cli
    728a:	9e bf       	out	0x3e, r25	; 62
    728c:	0f be       	out	0x3f, r0	; 63
    728e:	8d bf       	out	0x3d, r24	; 61
    7290:	2b 96       	adiw	r28, 0x0b	; 11
        "eor    %B0,%2"          "\n\t"
        "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
        "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    7292:	c0 17       	cp	r28, r16
    7294:	d1 07       	cpc	r29, r17
    7296:	a1 f6       	brne	.-88     	; 0x7240 <printRs485devices+0x3c>
    Initial value: 0xffff

    This is the CRC used by PPP and IrDA.

    See RFC1171 (PPP protocol) and IrDA IrLAP 1.1

    7298:	8f 2d       	mov	r24, r15
    729a:	df 91       	pop	r29
    729c:	cf 91       	pop	r28
    729e:	1f 91       	pop	r17
    72a0:	0f 91       	pop	r16
    72a2:	ff 90       	pop	r15
    72a4:	ef 90       	pop	r14
    72a6:	df 90       	pop	r13
    72a8:	cf 90       	pop	r12
    72aa:	bf 90       	pop	r11
    72ac:	af 90       	pop	r10
    72ae:	9f 90       	pop	r9
    72b0:	08 95       	ret

000072b2 <rs485ping>:
    \note Although the CCITT polynomial is the same as that used by the Xmodem
    protocol, they are quite different. The difference is in how the bits are
    shifted through the alorgithm. Xmodem shifts the MSB of the CRC and the
    input first, while CCITT shifts the LSB of the CRC and the input first.
    72b2:	ef 92       	push	r14
    72b4:	ff 92       	push	r15
    72b6:	0f 93       	push	r16
    72b8:	1f 93       	push	r17
    72ba:	cf 93       	push	r28
    72bc:	df 93       	push	r29
    72be:	00 d0       	rcall	.+0      	; 0x72c0 <rs485ping+0xe>
    72c0:	00 d0       	rcall	.+0      	; 0x72c2 <rs485ping+0x10>
    72c2:	cd b7       	in	r28, 0x3d	; 61
    72c4:	de b7       	in	r29, 0x3e	; 62
    72c6:	18 2f       	mov	r17, r24

    72c8:	0e 94 bf 0c 	call	0x197e	; 0x197e <takeRs485>
#define _UTIL_CRC16_H_

#include <stdint.h>

/** \file */
/** \defgroup util_crc <util/crc16.h>: CRC Computations
    72cc:	6a e5       	ldi	r22, 0x5A	; 90
    72ce:	80 e0       	ldi	r24, 0x00	; 0
    72d0:	90 e0       	ldi	r25, 0x00	; 0
    72d2:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    72d6:	7c 01       	movw	r14, r24
    \code#include <util/crc16.h>\endcode
    72d8:	8a e5       	ldi	r24, 0x5A	; 90
    72da:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>

    This header file provides a optimized inline functions for calculating
    72de:	61 2f       	mov	r22, r17
    72e0:	c7 01       	movw	r24, r14
    72e2:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    72e6:	7c 01       	movw	r14, r24
    cyclic redundancy checks (CRC) using common polynomials.
    72e8:	81 2f       	mov	r24, r17
    72ea:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>

    \par References:
    72ee:	60 e8       	ldi	r22, 0x80	; 128
    72f0:	c7 01       	movw	r24, r14
    72f2:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    72f6:	8c 01       	movw	r16, r24

    72f8:	80 e8       	ldi	r24, 0x80	; 128
    72fa:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    \par

    72fe:	68 e0       	ldi	r22, 0x08	; 8
    7300:	c8 01       	movw	r24, r16
    7302:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7306:	08 2f       	mov	r16, r24
    See the Dallas Semiconductor app note 27 for 8051 assembler example and
    7308:	88 e0       	ldi	r24, 0x08	; 8
    730a:	9c 83       	std	Y+4, r25	; 0x04
    730c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    general CRC optimization suggestions. The table on the last page of the
    app note is the key to understanding these implementations.
    7310:	10 e0       	ldi	r17, 0x00	; 0
    7312:	9c 81       	ldd	r25, Y+4	; 0x04

    \par
    7314:	61 2f       	mov	r22, r17
    7316:	80 2f       	mov	r24, r16
    7318:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    731c:	08 2f       	mov	r16, r24

    731e:	81 2f       	mov	r24, r17
    7320:	9c 83       	std	Y+4, r25	; 0x04
    7322:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>

    \par

    See the Dallas Semiconductor app note 27 for 8051 assembler example and
    general CRC optimization suggestions. The table on the last page of the
    app note is the key to understanding these implementations.
    7326:	1f 5f       	subi	r17, 0xFF	; 255
    7328:	9c 81       	ldd	r25, Y+4	; 0x04
    732a:	18 30       	cpi	r17, 0x08	; 8
    732c:	99 f7       	brne	.-26     	; 0x7314 <rs485ping+0x62>

    \par

    Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
    Embedded \e Systems \e Programming. This may be difficult to find, but it
    732e:	89 2f       	mov	r24, r25
    7330:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    explains CRC's in very clear and concise terms. Well worth the effort to
    7334:	80 2f       	mov	r24, r16
    7336:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    \code
    // Dallas iButton test vector.
    uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };

    int
    checkcrc(void)
    733a:	64 e1       	ldi	r22, 0x14	; 20
    733c:	ce 01       	movw	r24, r28
    733e:	03 96       	adiw	r24, 0x03	; 3
    7340:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7344:	88 23       	and	r24, r24
    7346:	09 f4       	brne	.+2      	; 0x734a <rs485ping+0x98>
    7348:	77 c0       	rjmp	.+238    	; 0x7438 <rs485ping+0x186>
    {
	uint8_t crc = 0, i;

    734a:	8b 81       	ldd	r24, Y+3	; 0x03
    734c:	8a 35       	cpi	r24, 0x5A	; 90
    734e:	09 f0       	breq	.+2      	; 0x7352 <rs485ping+0xa0>
    7350:	75 c0       	rjmp	.+234    	; 0x743c <rs485ping+0x18a>
	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
	    crc = _crc_ibutton_update(crc, serno[i]);
    7352:	6a e5       	ldi	r22, 0x5A	; 90
    7354:	80 e0       	ldi	r24, 0x00	; 0
    7356:	90 e0       	ldi	r25, 0x00	; 0
    7358:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    735c:	8c 01       	movw	r16, r24

	return crc; // must be 0
    }
    735e:	61 e0       	ldi	r22, 0x01	; 1
    7360:	ce 01       	movw	r24, r28
    7362:	03 96       	adiw	r24, 0x03	; 3
    7364:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7368:	88 23       	and	r24, r24
    736a:	09 f4       	brne	.+2      	; 0x736e <rs485ping+0xbc>
    736c:	69 c0       	rjmp	.+210    	; 0x7440 <rs485ping+0x18e>
    \endcode
*/

    736e:	8b 81       	ldd	r24, Y+3	; 0x03
    7370:	81 11       	cpse	r24, r1
    7372:	68 c0       	rjmp	.+208    	; 0x7444 <rs485ping+0x192>
/** \ingroup util_crc
    Optimized CRC-16 calculation.

    7374:	60 e0       	ldi	r22, 0x00	; 0
    7376:	c8 01       	movw	r24, r16
    7378:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    737c:	8c 01       	movw	r16, r24
    Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
    Initial value: 0xffff

    737e:	61 e0       	ldi	r22, 0x01	; 1
    7380:	ce 01       	movw	r24, r28
    7382:	03 96       	adiw	r24, 0x03	; 3
    7384:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7388:	88 23       	and	r24, r24
    738a:	09 f4       	brne	.+2      	; 0x738e <rs485ping+0xdc>
    738c:	5d c0       	rjmp	.+186    	; 0x7448 <rs485ping+0x196>
    This CRC is normally used in disk-drive controllers.

    738e:	8b 81       	ldd	r24, Y+3	; 0x03
    7390:	80 38       	cpi	r24, 0x80	; 128
    7392:	09 f0       	breq	.+2      	; 0x7396 <rs485ping+0xe4>
    7394:	5b c0       	rjmp	.+182    	; 0x744c <rs485ping+0x19a>
    The following is the equivalent functionality written in C.

    7396:	60 e8       	ldi	r22, 0x80	; 128
    7398:	c8 01       	movw	r24, r16
    739a:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    739e:	8c 01       	movw	r16, r24
    \code
    uint16_t
    crc16_update(uint16_t crc, uint8_t a)
    73a0:	61 e0       	ldi	r22, 0x01	; 1
    73a2:	ce 01       	movw	r24, r28
    73a4:	03 96       	adiw	r24, 0x03	; 3
    73a6:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    73aa:	88 23       	and	r24, r24
    73ac:	09 f4       	brne	.+2      	; 0x73b0 <rs485ping+0xfe>
    73ae:	50 c0       	rjmp	.+160    	; 0x7450 <rs485ping+0x19e>
    {
	int i;
    73b0:	8b 81       	ldd	r24, Y+3	; 0x03
    73b2:	88 30       	cpi	r24, 0x08	; 8
    73b4:	09 f0       	breq	.+2      	; 0x73b8 <rs485ping+0x106>
    73b6:	4e c0       	rjmp	.+156    	; 0x7454 <rs485ping+0x1a2>

	crc ^= a;
    73b8:	68 e0       	ldi	r22, 0x08	; 8
    73ba:	c8 01       	movw	r24, r16
    73bc:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    73c0:	08 2f       	mov	r16, r24
    73c2:	f9 2e       	mov	r15, r25
	for (i = 0; i < 8; ++i)
	{
	    if (crc & 1)
		crc = (crc >> 1) ^ 0xA001;
    73c4:	10 e0       	ldi	r17, 0x00	; 0
	    else
		crc = (crc >> 1);
    73c6:	65 e0       	ldi	r22, 0x05	; 5
    73c8:	ce 01       	movw	r24, r28
    73ca:	03 96       	adiw	r24, 0x03	; 3
    73cc:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    73d0:	81 11       	cpse	r24, r1
    73d2:	03 c0       	rjmp	.+6      	; 0x73da <rs485ping+0x128>
	}
    73d4:	11 0f       	add	r17, r17
    73d6:	17 5f       	subi	r17, 0xF7	; 247
    73d8:	44 c0       	rjmp	.+136    	; 0x7462 <rs485ping+0x1b0>

    73da:	6b 81       	ldd	r22, Y+3	; 0x03
    73dc:	80 2f       	mov	r24, r16
    73de:	9f 2d       	mov	r25, r15
    73e0:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    73e4:	08 2f       	mov	r16, r24
    73e6:	f9 2e       	mov	r15, r25
	return crc;
    73e8:	8b 81       	ldd	r24, Y+3	; 0x03
    73ea:	81 17       	cp	r24, r17
    73ec:	19 f0       	breq	.+6      	; 0x73f4 <rs485ping+0x142>
    }
    73ee:	11 0f       	add	r17, r17
    73f0:	16 5f       	subi	r17, 0xF6	; 246
    73f2:	37 c0       	rjmp	.+110    	; 0x7462 <rs485ping+0x1b0>

	crc ^= a;
	for (i = 0; i < 8; ++i)
	{
	    if (crc & 1)
		crc = (crc >> 1) ^ 0xA001;
    73f4:	1f 5f       	subi	r17, 0xFF	; 255
    73f6:	18 30       	cpi	r17, 0x08	; 8
    73f8:	31 f7       	brne	.-52     	; 0x73c6 <rs485ping+0x114>
    }

    \endcode */

static __inline__ uint16_t
_crc16_update(uint16_t __crc, uint8_t __data)
    73fa:	61 e0       	ldi	r22, 0x01	; 1
    73fc:	ce 01       	movw	r24, r28
    73fe:	02 96       	adiw	r24, 0x02	; 2
    7400:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7404:	81 30       	cpi	r24, 0x01	; 1
    7406:	41 f5       	brne	.+80     	; 0x7458 <rs485ping+0x1a6>
{
	uint8_t __tmp;
	uint16_t __ret;
    7408:	20 e0       	ldi	r18, 0x00	; 0
    740a:	41 e0       	ldi	r20, 0x01	; 1
    740c:	50 e0       	ldi	r21, 0x00	; 0
    740e:	be 01       	movw	r22, r28
    7410:	6f 5f       	subi	r22, 0xFF	; 255
    7412:	7f 4f       	sbci	r23, 0xFF	; 255
    7414:	80 91 9c 0e 	lds	r24, 0x0E9C
    7418:	90 91 9d 0e 	lds	r25, 0x0E9D
    741c:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    7420:	81 30       	cpi	r24, 0x01	; 1
    7422:	e1 f4       	brne	.+56     	; 0x745c <rs485ping+0x1aa>

	__asm__ __volatile__ (
		"eor %A0,%2" "\n\t"
    7424:	8a 81       	ldd	r24, Y+2	; 0x02
    7426:	8f 11       	cpse	r24, r15
    7428:	1b c0       	rjmp	.+54     	; 0x7460 <rs485ping+0x1ae>
		"mov %1,%A0" "\n\t"
		"swap %1" "\n\t"
    742a:	11 e0       	ldi	r17, 0x01	; 1
    742c:	89 81       	ldd	r24, Y+1	; 0x01
    742e:	80 13       	cpse	r24, r16
    7430:	01 c0       	rjmp	.+2      	; 0x7434 <rs485ping+0x182>
    7432:	10 e0       	ldi	r17, 0x00	; 0
    7434:	11 95       	neg	r17
    7436:	15 c0       	rjmp	.+42     	; 0x7462 <rs485ping+0x1b0>
    // Dallas iButton test vector.
    uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };

    int
    checkcrc(void)
    {
    7438:	11 e0       	ldi	r17, 0x01	; 1
    743a:	13 c0       	rjmp	.+38     	; 0x7462 <rs485ping+0x1b0>
	uint8_t crc = 0, i;

	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
    743c:	12 e0       	ldi	r17, 0x02	; 2
    743e:	11 c0       	rjmp	.+34     	; 0x7462 <rs485ping+0x1b0>
	    crc = _crc_ibutton_update(crc, serno[i]);

	return crc; // must be 0
    }
    \endcode
    7440:	13 e0       	ldi	r17, 0x03	; 3
    7442:	0f c0       	rjmp	.+30     	; 0x7462 <rs485ping+0x1b0>
*/

/** \ingroup util_crc
    7444:	14 e0       	ldi	r17, 0x04	; 4
    7446:	0d c0       	rjmp	.+26     	; 0x7462 <rs485ping+0x1b0>
    Optimized CRC-16 calculation.

    Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
    Initial value: 0xffff

    This CRC is normally used in disk-drive controllers.
    7448:	15 e0       	ldi	r17, 0x05	; 5
    744a:	0b c0       	rjmp	.+22     	; 0x7462 <rs485ping+0x1b0>

    The following is the equivalent functionality written in C.
    744c:	16 e0       	ldi	r17, 0x06	; 6
    744e:	09 c0       	rjmp	.+18     	; 0x7462 <rs485ping+0x1b0>

    \code
    uint16_t
    crc16_update(uint16_t crc, uint8_t a)
    {
    7450:	17 e0       	ldi	r17, 0x07	; 7
    7452:	07 c0       	rjmp	.+14     	; 0x7462 <rs485ping+0x1b0>
	int i;

    7454:	18 e0       	ldi	r17, 0x08	; 8
    7456:	05 c0       	rjmp	.+10     	; 0x7462 <rs485ping+0x1b0>

    \endcode */

static __inline__ uint16_t
_crc16_update(uint16_t __crc, uint8_t __data)
{
    7458:	1b e1       	ldi	r17, 0x1B	; 27
    745a:	03 c0       	rjmp	.+6      	; 0x7462 <rs485ping+0x1b0>
	uint8_t __tmp;
	uint16_t __ret;

    745c:	1c e1       	ldi	r17, 0x1C	; 28
    745e:	01 c0       	rjmp	.+2      	; 0x7462 <rs485ping+0x1b0>
	__asm__ __volatile__ (
		"eor %A0,%2" "\n\t"
		"mov %1,%A0" "\n\t"
    7460:	1e ef       	ldi	r17, 0xFE	; 254
    input first, while CCITT shifts the LSB of the CRC and the input first.

    The following is the equivalent functionality written in C.

    \code
    uint16_t
    7462:	0e 94 a2 0c 	call	0x1944	; 0x1944 <flushRs485RecBuffer>
    crc_ccitt_update (uint16_t crc, uint8_t data)
    {
    7466:	0e 94 ca 0c 	call	0x1994	; 0x1994 <releaseRs485>
        data ^= lo8 (crc);
        data ^= data << 4;
    746a:	81 2f       	mov	r24, r17
    746c:	0f 90       	pop	r0
    746e:	0f 90       	pop	r0
    7470:	0f 90       	pop	r0
    7472:	0f 90       	pop	r0
    7474:	df 91       	pop	r29
    7476:	cf 91       	pop	r28
    7478:	1f 91       	pop	r17
    747a:	0f 91       	pop	r16
    747c:	ff 90       	pop	r15
    747e:	ef 90       	pop	r14
    7480:	08 95       	ret

00007482 <rs485rollerHello>:

        return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
                ^ ((uint16_t)data << 3));
    7482:	cf 92       	push	r12
    7484:	df 92       	push	r13
    7486:	ef 92       	push	r14
    7488:	ff 92       	push	r15
    748a:	0f 93       	push	r16
    748c:	1f 93       	push	r17
    748e:	cf 93       	push	r28
    7490:	df 93       	push	r29
    7492:	00 d0       	rcall	.+0      	; 0x7494 <rs485rollerHello+0x12>
    7494:	00 d0       	rcall	.+0      	; 0x7496 <rs485rollerHello+0x14>
    7496:	cd b7       	in	r28, 0x3d	; 61
    7498:	de b7       	in	r29, 0x3e	; 62
    749a:	f8 2e       	mov	r15, r24
    }
    \endcode */

static __inline__ uint16_t
    749c:	80 91 a8 0e 	lds	r24, 0x0EA8
    74a0:	90 91 a9 0e 	lds	r25, 0x0EA9
    74a4:	fc 01       	movw	r30, r24
    74a6:	31 96       	adiw	r30, 0x01	; 1
    74a8:	81 59       	subi	r24, 0x91	; 145
    74aa:	9f 4f       	sbci	r25, 0xFF	; 255
        data ^= lo8 (crc);
        data ^= data << 4;

        return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
                ^ ((uint16_t)data << 3));
    }
    74ac:	00 e0       	ldi	r16, 0x00	; 0
    74ae:	10 e0       	ldi	r17, 0x00	; 0
    74b0:	9f 01       	movw	r18, r30
    74b2:	21 50       	subi	r18, 0x01	; 1
    74b4:	31 09       	sbc	r19, r1
    \endcode */

static __inline__ uint16_t
    74b6:	40 81       	ld	r20, Z
    74b8:	4f 11       	cpse	r20, r15
    74ba:	01 c0       	rjmp	.+2      	; 0x74be <rs485rollerHello+0x3c>
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
    74bc:	89 01       	movw	r16, r18
    74be:	3b 96       	adiw	r30, 0x0b	; 11

        return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
                ^ ((uint16_t)data << 3));
    }
    \endcode */

    74c0:	e8 17       	cp	r30, r24
    74c2:	f9 07       	cpc	r31, r25
    74c4:	a9 f7       	brne	.-22     	; 0x74b0 <rs485rollerHello+0x2e>
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;
    74c6:	8f 2d       	mov	r24, r15
    74c8:	0e 94 59 39 	call	0x72b2	; 0x72b2 <rs485ping>
    74cc:	81 11       	cpse	r24, r1
    74ce:	23 c0       	rjmp	.+70     	; 0x7516 <rs485rollerHello+0x94>

    __asm__ __volatile__ (
    74d0:	01 15       	cp	r16, r1
    74d2:	11 05       	cpc	r17, r1
    74d4:	d1 f4       	brne	.+52     	; 0x750a <rs485rollerHello+0x88>
        "eor    %A0,%1"          "\n\t"

        "mov    __tmp_reg__,%A0" "\n\t"
        "swap   %A0"             "\n\t"
    74d6:	80 91 a8 0e 	lds	r24, 0x0EA8
    74da:	90 91 a9 0e 	lds	r25, 0x0EA9
    74de:	fc 01       	movw	r30, r24
    74e0:	31 96       	adiw	r30, 0x01	; 1
    74e2:	81 59       	subi	r24, 0x91	; 145
    74e4:	9f 4f       	sbci	r25, 0xFF	; 255
    74e6:	8f 01       	movw	r16, r30
    74e8:	01 50       	subi	r16, 0x01	; 1
    74ea:	11 09       	sbc	r17, r1
    74ec:	20 81       	ld	r18, Z
    74ee:	21 11       	cpse	r18, r1
    74f0:	07 c0       	rjmp	.+14     	; 0x7500 <rs485rollerHello+0x7e>
        "andi   %A0,0xf0"        "\n\t"
        "eor    %A0,__tmp_reg__" "\n\t"

    74f2:	f8 01       	movw	r30, r16
    74f4:	f1 82       	std	Z+1, r15	; 0x01
        "mov    __tmp_reg__,%B0" "\n\t"

        "mov    %B0,%A0"         "\n\t"

        "swap   %A0"             "\n\t"
    74f6:	01 15       	cp	r16, r1
    74f8:	11 05       	cpc	r17, r1
    74fa:	39 f4       	brne	.+14     	; 0x750a <rs485rollerHello+0x88>
        "andi   %A0,0x0f"        "\n\t"
        "eor    __tmp_reg__,%A0" "\n\t"

        "lsr    %A0"             "\n\t"
        "eor    %B0,%A0"         "\n\t"

    74fc:	81 e0       	ldi	r24, 0x01	; 1
    74fe:	e0 c0       	rjmp	.+448    	; 0x76c0 <rs485rollerHello+0x23e>
    7500:	3b 96       	adiw	r30, 0x0b	; 11
{
    uint16_t __ret;

    __asm__ __volatile__ (
        "eor    %A0,%1"          "\n\t"

    7502:	e8 17       	cp	r30, r24
    7504:	f9 07       	cpc	r31, r25
    7506:	79 f7       	brne	.-34     	; 0x74e6 <rs485rollerHello+0x64>
    7508:	f9 cf       	rjmp	.-14     	; 0x74fc <rs485rollerHello+0x7a>

        "mov    %B0,%A0"         "\n\t"

        "swap   %A0"             "\n\t"
        "andi   %A0,0x0f"        "\n\t"
        "eor    __tmp_reg__,%A0" "\n\t"
    750a:	f8 01       	movw	r30, r16
    750c:	80 81       	ld	r24, Z
    750e:	8e 7f       	andi	r24, 0xFE	; 254
    7510:	80 83       	st	Z, r24

    7512:	f1 82       	std	Z+1, r15	; 0x01
    7514:	0c c0       	rjmp	.+24     	; 0x752e <rs485rollerHello+0xac>
        "eor    %B0,%A0"         "\n\t"

        "eor    %A0,%B0"         "\n\t"
        "lsl    %A0"             "\n\t"
        "lsl    %A0"             "\n\t"
        "lsl    %A0"             "\n\t"
    7516:	01 15       	cp	r16, r1
    7518:	11 05       	cpc	r17, r1
    751a:	49 f0       	breq	.+18     	; 0x752e <rs485rollerHello+0xac>
        "eor    %A0,__tmp_reg__"

    751c:	f8 01       	movw	r30, r16
    751e:	80 81       	ld	r24, Z
    7520:	80 fd       	sbrc	r24, 0
        : "=d" (__ret)
        : "r" (__data), "0" (__crc)
    7522:	11 82       	std	Z+1, r1	; 0x01
        : "r0"
    );
    7524:	81 60       	ori	r24, 0x01	; 1
    7526:	f8 01       	movw	r30, r16
    7528:	80 83       	st	Z, r24
    return __ret;
    752a:	82 e0       	ldi	r24, 0x02	; 2
    752c:	c9 c0       	rjmp	.+402    	; 0x76c0 <rs485rollerHello+0x23e>
}

/** \ingroup util_crc
    Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.
    752e:	0e 94 bf 0c 	call	0x197e	; 0x197e <takeRs485>
		"lsr %1" "\n\t"
		"lsr %1" "\n\t"
		"eor %1,__tmp_reg__" "\n\t"
		"mov __tmp_reg__,%1" "\n\t"
		"lsr %1" "\n\t"
		"eor %1,__tmp_reg__" "\n\t"
    7532:	6a e5       	ldi	r22, 0x5A	; 90
    7534:	80 e0       	ldi	r24, 0x00	; 0
    7536:	90 e0       	ldi	r25, 0x00	; 0
    7538:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    753c:	6c 01       	movw	r12, r24
		"andi %1,0x07" "\n\t"
    753e:	8a e5       	ldi	r24, 0x5A	; 90
    7540:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
		"mov __tmp_reg__,%A0" "\n\t"
		"mov %A0,%B0" "\n\t"
    7544:	6f 2d       	mov	r22, r15
    7546:	c6 01       	movw	r24, r12
    7548:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    754c:	6c 01       	movw	r12, r24
		"lsr %1" "\n\t"
    754e:	8f 2d       	mov	r24, r15
    7550:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
		"ror __tmp_reg__" "\n\t"
		"ror %1" "\n\t"
    7554:	62 e8       	ldi	r22, 0x82	; 130
    7556:	c6 01       	movw	r24, r12
    7558:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    755c:	7c 01       	movw	r14, r24
		"mov %B0,__tmp_reg__" "\n\t"
    755e:	82 e8       	ldi	r24, 0x82	; 130
    7560:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
		"eor %A0,%1" "\n\t"
		"lsr __tmp_reg__" "\n\t"
    7564:	60 e0       	ldi	r22, 0x00	; 0
    7566:	c7 01       	movw	r24, r14
    7568:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    756c:	f8 2e       	mov	r15, r24
		"ror %1" "\n\t"
    756e:	80 e0       	ldi	r24, 0x00	; 0
    7570:	9c 83       	std	Y+4, r25	; 0x04
    7572:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
		"eor %B0,__tmp_reg__" "\n\t"
		"eor %A0,%1"
    7576:	9c 81       	ldd	r25, Y+4	; 0x04
    7578:	89 2f       	mov	r24, r25
    757a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
		: "=r" (__ret), "=d" (__tmp)
    757e:	8f 2d       	mov	r24, r15
    7580:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
	);
	return __ret;
}

/** \ingroup util_crc
    Optimized CRC-XMODEM calculation.
    7584:	64 e1       	ldi	r22, 0x14	; 20
    7586:	ce 01       	movw	r24, r28
    7588:	03 96       	adiw	r24, 0x03	; 3
    758a:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    758e:	88 23       	and	r24, r24
    7590:	09 f4       	brne	.+2      	; 0x7594 <rs485rollerHello+0x112>
    7592:	7b c0       	rjmp	.+246    	; 0x768a <rs485rollerHello+0x208>

    Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
    Initial value: 0x0
    7594:	8b 81       	ldd	r24, Y+3	; 0x03
    7596:	8a 35       	cpi	r24, 0x5A	; 90
    7598:	09 f0       	breq	.+2      	; 0x759c <rs485rollerHello+0x11a>
    759a:	79 c0       	rjmp	.+242    	; 0x768e <rs485rollerHello+0x20c>

    This is the CRC used by the Xmodem-CRC protocol.
    759c:	6a e5       	ldi	r22, 0x5A	; 90
    759e:	80 e0       	ldi	r24, 0x00	; 0
    75a0:	90 e0       	ldi	r25, 0x00	; 0
    75a2:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    75a6:	7c 01       	movw	r14, r24

    The following is the equivalent functionality written in C.

    75a8:	61 e0       	ldi	r22, 0x01	; 1
    75aa:	ce 01       	movw	r24, r28
    75ac:	03 96       	adiw	r24, 0x03	; 3
    75ae:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    75b2:	88 23       	and	r24, r24
    75b4:	09 f4       	brne	.+2      	; 0x75b8 <rs485rollerHello+0x136>
    75b6:	6d c0       	rjmp	.+218    	; 0x7692 <rs485rollerHello+0x210>
    \code
    uint16_t
    crc_xmodem_update (uint16_t crc, uint8_t data)
    75b8:	8b 81       	ldd	r24, Y+3	; 0x03
    75ba:	81 11       	cpse	r24, r1
    75bc:	6c c0       	rjmp	.+216    	; 0x7696 <rs485rollerHello+0x214>
    {
        int i;

    75be:	60 e0       	ldi	r22, 0x00	; 0
    75c0:	c7 01       	movw	r24, r14
    75c2:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    75c6:	7c 01       	movw	r14, r24
        crc = crc ^ ((uint16_t)data << 8);
        for (i=0; i<8; i++)
        {
    75c8:	61 e0       	ldi	r22, 0x01	; 1
    75ca:	ce 01       	movw	r24, r28
    75cc:	03 96       	adiw	r24, 0x03	; 3
    75ce:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    75d2:	88 23       	and	r24, r24
    75d4:	09 f4       	brne	.+2      	; 0x75d8 <rs485rollerHello+0x156>
    75d6:	61 c0       	rjmp	.+194    	; 0x769a <rs485rollerHello+0x218>
            if (crc & 0x8000)
                crc = (crc << 1) ^ 0x1021;
    75d8:	8b 81       	ldd	r24, Y+3	; 0x03
    75da:	82 38       	cpi	r24, 0x82	; 130
    75dc:	09 f0       	breq	.+2      	; 0x75e0 <rs485rollerHello+0x15e>
    75de:	5f c0       	rjmp	.+190    	; 0x769e <rs485rollerHello+0x21c>
            else
                crc <<= 1;
    75e0:	62 e8       	ldi	r22, 0x82	; 130
    75e2:	c7 01       	movw	r24, r14
    75e4:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    75e8:	7c 01       	movw	r14, r24
        }

        return crc;
    75ea:	61 e0       	ldi	r22, 0x01	; 1
    75ec:	ce 01       	movw	r24, r28
    75ee:	03 96       	adiw	r24, 0x03	; 3
    75f0:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    75f4:	88 23       	and	r24, r24
    75f6:	09 f4       	brne	.+2      	; 0x75fa <rs485rollerHello+0x178>
    75f8:	54 c0       	rjmp	.+168    	; 0x76a2 <rs485rollerHello+0x220>
    }
    \endcode */
    75fa:	6b 81       	ldd	r22, Y+3	; 0x03
    75fc:	69 30       	cpi	r22, 0x09	; 9
    75fe:	08 f0       	brcs	.+2      	; 0x7602 <rs485rollerHello+0x180>
    7600:	52 c0       	rjmp	.+164    	; 0x76a6 <rs485rollerHello+0x224>
}

/** \ingroup util_crc
    Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.

    Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
    7602:	0e 5f       	subi	r16, 0xFE	; 254
    7604:	1f 4f       	sbci	r17, 0xFF	; 255
        return crc;
    }
    \endcode */

static __inline__ uint16_t
_crc_xmodem_update(uint16_t __crc, uint8_t __data)
    7606:	c7 01       	movw	r24, r14
    7608:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    760c:	f8 2e       	mov	r15, r24
    760e:	e9 2e       	mov	r14, r25
{
    7610:	88 e0       	ldi	r24, 0x08	; 8
    7612:	f8 01       	movw	r30, r16
    7614:	11 92       	st	Z+, r1
    7616:	8a 95       	dec	r24
    7618:	e9 f7       	brne	.-6      	; 0x7614 <rs485rollerHello+0x192>
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    761a:	db 80       	ldd	r13, Y+3	; 0x03
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
    761c:	1b 82       	std	Y+3, r1	; 0x03
    761e:	8b 81       	ldd	r24, Y+3	; 0x03
    7620:	8d 15       	cp	r24, r13
    7622:	98 f4       	brcc	.+38     	; 0x764a <rs485rollerHello+0x1c8>
                                /* %3  __data */

    7624:	65 e0       	ldi	r22, 0x05	; 5
    7626:	c8 01       	movw	r24, r16
    7628:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    762c:	88 23       	and	r24, r24
    762e:	e9 f1       	breq	.+122    	; 0x76aa <rs485rollerHello+0x228>
    __asm__ __volatile__ (
        "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
    7630:	f8 01       	movw	r30, r16
    7632:	61 91       	ld	r22, Z+
    7634:	8f 01       	movw	r16, r30
    7636:	8f 2d       	mov	r24, r15
    7638:	9e 2d       	mov	r25, r14
    763a:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    763e:	f8 2e       	mov	r15, r24
    7640:	e9 2e       	mov	r14, r25
static __inline__ uint16_t
_crc_xmodem_update(uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
    7642:	8b 81       	ldd	r24, Y+3	; 0x03
    7644:	8f 5f       	subi	r24, 0xFF	; 255
    7646:	8b 83       	std	Y+3, r24	; 0x03
    7648:	ea cf       	rjmp	.-44     	; 0x761e <rs485rollerHello+0x19c>
        "mov    __tmp_reg__,%B0" "\n\t"
        "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */

        /* Calculate the ret.lo of the CRC. */
        "mov    %1,__tmp_reg__"  "\n\t"
        "andi   %1,0x0f"         "\n\t"
    764a:	61 e0       	ldi	r22, 0x01	; 1
    764c:	ce 01       	movw	r24, r28
    764e:	02 96       	adiw	r24, 0x02	; 2
    7650:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7654:	81 30       	cpi	r24, 0x01	; 1
    7656:	59 f5       	brne	.+86     	; 0x76ae <rs485rollerHello+0x22c>
        "eor    %1,%B0"          "\n\t"
        "mov    %2,%B0"          "\n\t"
        "eor    %2,__tmp_reg__"  "\n\t"
    7658:	20 e0       	ldi	r18, 0x00	; 0
    765a:	41 e0       	ldi	r20, 0x01	; 1
    765c:	50 e0       	ldi	r21, 0x00	; 0
    765e:	be 01       	movw	r22, r28
    7660:	6f 5f       	subi	r22, 0xFF	; 255
    7662:	7f 4f       	sbci	r23, 0xFF	; 255
    7664:	80 91 9c 0e 	lds	r24, 0x0E9C
    7668:	90 91 9d 0e 	lds	r25, 0x0E9D
    766c:	0e 94 5e 47 	call	0x8ebc	; 0x8ebc <xQueueGenericReceive>
    7670:	81 30       	cpi	r24, 0x01	; 1
    7672:	f9 f4       	brne	.+62     	; 0x76b2 <rs485rollerHello+0x230>
        "lsl    %2"              "\n\t"
        "andi   %2,0xe0"         "\n\t"
        "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
    7674:	8a 81       	ldd	r24, Y+2	; 0x02
    7676:	8e 11       	cpse	r24, r14
    7678:	1e c0       	rjmp	.+60     	; 0x76b6 <rs485rollerHello+0x234>

        /* Calculate the ret.hi of the CRC. */
    767a:	91 e0       	ldi	r25, 0x01	; 1
    767c:	89 81       	ldd	r24, Y+1	; 0x01
    767e:	8f 11       	cpse	r24, r15
    7680:	01 c0       	rjmp	.+2      	; 0x7684 <rs485rollerHello+0x202>
    7682:	90 e0       	ldi	r25, 0x00	; 0
    7684:	89 2f       	mov	r24, r25
    7686:	81 95       	neg	r24
    7688:	17 c0       	rjmp	.+46     	; 0x76b8 <rs485rollerHello+0x236>
	return __ret;
}

/** \ingroup util_crc
    Optimized CRC-XMODEM calculation.

    768a:	88 e0       	ldi	r24, 0x08	; 8
    768c:	15 c0       	rjmp	.+42     	; 0x76b8 <rs485rollerHello+0x236>
    Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
    Initial value: 0x0

    768e:	82 e0       	ldi	r24, 0x02	; 2
    7690:	13 c0       	rjmp	.+38     	; 0x76b8 <rs485rollerHello+0x236>
    This is the CRC used by the Xmodem-CRC protocol.

    The following is the equivalent functionality written in C.

    \code
    7692:	83 e0       	ldi	r24, 0x03	; 3
    7694:	11 c0       	rjmp	.+34     	; 0x76b8 <rs485rollerHello+0x236>
    uint16_t
    crc_xmodem_update (uint16_t crc, uint8_t data)
    {
    7696:	84 e0       	ldi	r24, 0x04	; 4
    7698:	0f c0       	rjmp	.+30     	; 0x76b8 <rs485rollerHello+0x236>
        int i;

        crc = crc ^ ((uint16_t)data << 8);
        for (i=0; i<8; i++)
        {
            if (crc & 0x8000)
    769a:	85 e0       	ldi	r24, 0x05	; 5
    769c:	0d c0       	rjmp	.+26     	; 0x76b8 <rs485rollerHello+0x236>
                crc = (crc << 1) ^ 0x1021;
            else
    769e:	86 e0       	ldi	r24, 0x06	; 6
    76a0:	0b c0       	rjmp	.+22     	; 0x76b8 <rs485rollerHello+0x236>
                crc <<= 1;
        }

        return crc;
    }
    76a2:	87 e0       	ldi	r24, 0x07	; 7
    76a4:	09 c0       	rjmp	.+18     	; 0x76b8 <rs485rollerHello+0x236>
    \endcode */

    76a6:	81 e0       	ldi	r24, 0x01	; 1
    76a8:	07 c0       	rjmp	.+14     	; 0x76b8 <rs485rollerHello+0x236>
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
    76aa:	84 e1       	ldi	r24, 0x14	; 20
    76ac:	05 c0       	rjmp	.+10     	; 0x76b8 <rs485rollerHello+0x236>
        "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */

        /* Calculate the ret.lo of the CRC. */
        "mov    %1,__tmp_reg__"  "\n\t"
        "andi   %1,0x0f"         "\n\t"
        "eor    %1,%B0"          "\n\t"
    76ae:	85 e1       	ldi	r24, 0x15	; 21
    76b0:	03 c0       	rjmp	.+6      	; 0x76b8 <rs485rollerHello+0x236>
        "mov    %2,%B0"          "\n\t"
        "eor    %2,__tmp_reg__"  "\n\t"
        "lsl    %2"              "\n\t"
    76b2:	86 e1       	ldi	r24, 0x16	; 22
    76b4:	01 c0       	rjmp	.+2      	; 0x76b8 <rs485rollerHello+0x236>
        "andi   %2,0xe0"         "\n\t"
        "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */

    76b6:	8e ef       	ldi	r24, 0xFE	; 254

/** \ingroup util_crc
    Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.

    Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
    Initial value: 0x0
    76b8:	8c 83       	std	Y+4, r24	; 0x04
    76ba:	0e 94 ca 0c 	call	0x1994	; 0x1994 <releaseRs485>
    76be:	8c 81       	ldd	r24, Y+4	; 0x04

    See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
    76c0:	0f 90       	pop	r0
    76c2:	0f 90       	pop	r0
    76c4:	0f 90       	pop	r0
    76c6:	0f 90       	pop	r0
    76c8:	df 91       	pop	r29
    76ca:	cf 91       	pop	r28
    76cc:	1f 91       	pop	r17
    76ce:	0f 91       	pop	r16
    76d0:	ff 90       	pop	r15
    76d2:	ef 90       	pop	r14
    76d4:	df 90       	pop	r13
    76d6:	cf 90       	pop	r12
    76d8:	08 95       	ret

000076da <rs485xModemFlash>:

    The following is the equivalent functionality written in C.

    \code
    76da:	7f 92       	push	r7
    76dc:	8f 92       	push	r8
    76de:	9f 92       	push	r9
    76e0:	af 92       	push	r10
    76e2:	bf 92       	push	r11
    76e4:	cf 92       	push	r12
    76e6:	df 92       	push	r13
    76e8:	ef 92       	push	r14
    76ea:	ff 92       	push	r15
    76ec:	0f 93       	push	r16
    76ee:	1f 93       	push	r17
    76f0:	cf 93       	push	r28
    76f2:	df 93       	push	r29
    76f4:	00 d0       	rcall	.+0      	; 0x76f6 <rs485xModemFlash+0x1c>
    76f6:	1f 92       	push	r1
    76f8:	cd b7       	in	r28, 0x3d	; 61
    76fa:	de b7       	in	r29, 0x3e	; 62
    76fc:	6c 01       	movw	r12, r24
    76fe:	e6 2e       	mov	r14, r22
    7700:	8a 01       	movw	r16, r20
    _crc_ibutton_update(uint8_t crc, uint8_t data)
    {
	uint8_t i;

	crc = crc ^ data;
	for (i = 0; i < 8; i++)
    7702:	0e 94 bf 0c 	call	0x197e	; 0x197e <takeRs485>
	{
	    if (crc & 0x01)
	        crc = (crc >> 1) ^ 0x8C;
    7706:	6a e5       	ldi	r22, 0x5A	; 90
    7708:	80 e0       	ldi	r24, 0x00	; 0
    770a:	90 e0       	ldi	r25, 0x00	; 0
    770c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7710:	5c 01       	movw	r10, r24
    7712:	8a e5       	ldi	r24, 0x5A	; 90
    7714:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
	    else
    7718:	6e 2d       	mov	r22, r14
    771a:	c5 01       	movw	r24, r10
    771c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7720:	5c 01       	movw	r10, r24
    7722:	8e 2d       	mov	r24, r14
    7724:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
	        crc >>= 1;
    7728:	61 e8       	ldi	r22, 0x81	; 129
    772a:	c5 01       	movw	r24, r10
    772c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7730:	5c 01       	movw	r10, r24
    7732:	81 e8       	ldi	r24, 0x81	; 129
    7734:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
	}
    7738:	61 e0       	ldi	r22, 0x01	; 1
    773a:	c5 01       	movw	r24, r10
    773c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7740:	5c 01       	movw	r10, r24
    7742:	81 e0       	ldi	r24, 0x01	; 1
    7744:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>

    7748:	6e 2d       	mov	r22, r14
    774a:	c5 01       	movw	r24, r10
    774c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7750:	f8 2e       	mov	r15, r24
    7752:	8e 2d       	mov	r24, r14
    7754:	9b 83       	std	Y+3, r25	; 0x03
    7756:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
	return crc;
    775a:	9b 81       	ldd	r25, Y+3	; 0x03
    775c:	89 2f       	mov	r24, r25
    775e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    }
    7762:	8f 2d       	mov	r24, r15
    7764:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    \endcode
*/

static __inline__ uint8_t
_crc_ibutton_update(uint8_t __crc, uint8_t __data)
    7768:	64 e6       	ldi	r22, 0x64	; 100
    776a:	ce 01       	movw	r24, r28
    776c:	02 96       	adiw	r24, 0x02	; 2
    776e:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7772:	81 30       	cpi	r24, 0x01	; 1
    7774:	81 f0       	breq	.+32     	; 0x7796 <rs485xModemFlash+0xbc>
{
	uint8_t __i, __pattern;
	__asm__ __volatile__ (
    7776:	01 15       	cp	r16, r1
    7778:	11 05       	cpc	r17, r1
    777a:	79 f0       	breq	.+30     	; 0x779a <rs485xModemFlash+0xc0>
		"	eor	%0, %4" "\n\t"
    777c:	88 eb       	ldi	r24, 0xB8	; 184
    777e:	93 e1       	ldi	r25, 0x13	; 19
    7780:	9f 93       	push	r25
    7782:	8f 93       	push	r24
    7784:	1f 93       	push	r17
    7786:	0f 93       	push	r16
    7788:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    778c:	0f 90       	pop	r0
    778e:	0f 90       	pop	r0
    7790:	0f 90       	pop	r0
    7792:	0f 90       	pop	r0
    7794:	02 c0       	rjmp	.+4      	; 0x779a <rs485xModemFlash+0xc0>

    The following is the equivalent functionality written in C.

    \code
    uint8_t
    _crc_ibutton_update(uint8_t crc, uint8_t data)
    7796:	f1 2c       	mov	r15, r1
    7798:	02 c0       	rjmp	.+4      	; 0x779e <rs485xModemFlash+0xc4>
*/

static __inline__ uint8_t
_crc_ibutton_update(uint8_t __crc, uint8_t __data)
{
	uint8_t __i, __pattern;
    779a:	ff 24       	eor	r15, r15
    779c:	f3 94       	inc	r15
	__asm__ __volatile__ (
		"	eor	%0, %4" "\n\t"
		"	ldi	%1, 8" "\n\t"
		"	ldi	%2, 0x8C" "\n\t"
    779e:	6a 81       	ldd	r22, Y+2	; 0x02
    77a0:	80 e0       	ldi	r24, 0x00	; 0
    77a2:	90 e0       	ldi	r25, 0x00	; 0
    77a4:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    77a8:	5c 01       	movw	r10, r24
    77aa:	9a 81       	ldd	r25, Y+2	; 0x02
		"1:	lsr	%0" "\n\t"
		"	brcc	2f" "\n\t"
    77ac:	f1 10       	cpse	r15, r1
    77ae:	13 c0       	rjmp	.+38     	; 0x77d6 <rs485xModemFlash+0xfc>
    77b0:	93 34       	cpi	r25, 0x43	; 67
    77b2:	89 f4       	brne	.+34     	; 0x77d6 <rs485xModemFlash+0xfc>
		"	eor	%0, %2" "\n\t"
		"2:	dec	%1" "\n\t"
		"	brne	1b" "\n\t"
    77b4:	01 15       	cp	r16, r1
    77b6:	11 05       	cpc	r17, r1
    77b8:	09 f4       	brne	.+2      	; 0x77bc <rs485xModemFlash+0xe2>
    77ba:	c6 c0       	rjmp	.+396    	; 0x7948 <rs485xModemFlash+0x26e>
		: "=r" (__crc), "=d" (__i), "=d" (__pattern)
    77bc:	8b e8       	ldi	r24, 0x8B	; 139
    77be:	93 e1       	ldi	r25, 0x13	; 19
    77c0:	9f 93       	push	r25
    77c2:	8f 93       	push	r24
    77c4:	1f 93       	push	r17
    77c6:	0f 93       	push	r16
    77c8:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    77cc:	0f 90       	pop	r0
    77ce:	0f 90       	pop	r0
    77d0:	0f 90       	pop	r0
    77d2:	0f 90       	pop	r0
    77d4:	b9 c0       	rjmp	.+370    	; 0x7948 <rs485xModemFlash+0x26e>
		: "0" (__crc), "r" (__data));
	return __crc;
}

    77d6:	9a 35       	cpi	r25, 0x5A	; 90
    77d8:	09 f0       	breq	.+2      	; 0x77dc <rs485xModemFlash+0x102>
    77da:	71 c0       	rjmp	.+226    	; 0x78be <rs485xModemFlash+0x1e4>
/** \ingroup util_crc
    Optimized CRC-8-CCITT calculation.

    Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
    
    For use with simple CRC-8<br>
    77dc:	f1 10       	cpse	r15, r1
    77de:	6f c0       	rjmp	.+222    	; 0x78be <rs485xModemFlash+0x1e4>
    Initial value: 0x0
    
    77e0:	61 e0       	ldi	r22, 0x01	; 1
    77e2:	ce 01       	movw	r24, r28
    77e4:	02 96       	adiw	r24, 0x02	; 2
    77e6:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    77ea:	81 30       	cpi	r24, 0x01	; 1
    77ec:	31 f4       	brne	.+12     	; 0x77fa <rs485xModemFlash+0x120>
    For use with CRC-8-ROHC<br>
    Initial value: 0xff<br>
    Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
    
    77ee:	8a 81       	ldd	r24, Y+2	; 0x02
    77f0:	88 23       	and	r24, r24
    77f2:	29 f0       	breq	.+10     	; 0x77fe <rs485xModemFlash+0x124>
    For use with CRC-8-ATM/ITU<br>
    77f4:	b4 e0       	ldi	r27, 0x04	; 4
    77f6:	fb 2e       	mov	r15, r27
    77f8:	02 c0       	rjmp	.+4      	; 0x77fe <rs485xModemFlash+0x124>
    Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
    
    For use with simple CRC-8<br>
    Initial value: 0x0
    
    For use with CRC-8-ROHC<br>
    77fa:	a3 e0       	ldi	r26, 0x03	; 3
    77fc:	fa 2e       	mov	r15, r26
    Initial value: 0xff<br>
    Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
    
    For use with CRC-8-ATM/ITU<br>
    Initial value: 0xff<br>
    Final XOR value: 0x55<br>
    77fe:	6a 81       	ldd	r22, Y+2	; 0x02
    7800:	c5 01       	movw	r24, r10
    7802:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7806:	5c 01       	movw	r10, r24
    Reference: http://www.itu.int/rec/T-REC-I.432.1-199902-I/en
    
    The C equivalent has been originally written by Dave Hylands.
    Assembly code is based on _crc_ibutton_update optimization.
    7808:	f1 10       	cpse	r15, r1
    780a:	59 c0       	rjmp	.+178    	; 0x78be <rs485xModemFlash+0x1e4>

    The following is the equivalent functionality written in C.
    780c:	61 e0       	ldi	r22, 0x01	; 1
    780e:	ce 01       	movw	r24, r28
    7810:	02 96       	adiw	r24, 0x02	; 2
    7812:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7816:	81 30       	cpi	r24, 0x01	; 1
    7818:	31 f4       	brne	.+12     	; 0x7826 <rs485xModemFlash+0x14c>

    \code
    uint8_t
    _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
    781a:	8a 81       	ldd	r24, Y+2	; 0x02
    781c:	81 38       	cpi	r24, 0x81	; 129
    781e:	29 f0       	breq	.+10     	; 0x782a <rs485xModemFlash+0x150>
    {
    7820:	f6 e0       	ldi	r31, 0x06	; 6
    7822:	ff 2e       	mov	r15, r31
    7824:	02 c0       	rjmp	.+4      	; 0x782a <rs485xModemFlash+0x150>
    
    The C equivalent has been originally written by Dave Hylands.
    Assembly code is based on _crc_ibutton_update optimization.

    The following is the equivalent functionality written in C.

    7826:	e5 e0       	ldi	r30, 0x05	; 5
    7828:	fe 2e       	mov	r15, r30
    \code
    uint8_t
    _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
    {
        uint8_t   i;
        uint8_t   data;
    782a:	6a 81       	ldd	r22, Y+2	; 0x02
    782c:	c5 01       	movw	r24, r10
    782e:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7832:	5c 01       	movw	r10, r24

        data = inCrc ^ inData;

        for ( i = 0; i < 8; i++ )
    7834:	f1 10       	cpse	r15, r1
    7836:	43 c0       	rjmp	.+134    	; 0x78be <rs485xModemFlash+0x1e4>
        {
            if (( data & 0x80 ) != 0 )
    7838:	61 e0       	ldi	r22, 0x01	; 1
    783a:	ce 01       	movw	r24, r28
    783c:	02 96       	adiw	r24, 0x02	; 2
    783e:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7842:	81 30       	cpi	r24, 0x01	; 1
    7844:	31 f4       	brne	.+12     	; 0x7852 <rs485xModemFlash+0x178>
            {
                data <<= 1;
                data ^= 0x07;
            }
    7846:	8a 81       	ldd	r24, Y+2	; 0x02
    7848:	81 30       	cpi	r24, 0x01	; 1
    784a:	29 f0       	breq	.+10     	; 0x7856 <rs485xModemFlash+0x17c>
            else
    784c:	78 e0       	ldi	r23, 0x08	; 8
    784e:	f7 2e       	mov	r15, r23
    7850:	02 c0       	rjmp	.+4      	; 0x7856 <rs485xModemFlash+0x17c>
        data = inCrc ^ inData;

        for ( i = 0; i < 8; i++ )
        {
            if (( data & 0x80 ) != 0 )
            {
    7852:	67 e0       	ldi	r22, 0x07	; 7
    7854:	f6 2e       	mov	r15, r22
                data <<= 1;
                data ^= 0x07;
            }
            else
            {
                data <<= 1;
    7856:	6a 81       	ldd	r22, Y+2	; 0x02
    7858:	c5 01       	movw	r24, r10
    785a:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    785e:	5c 01       	movw	r10, r24
            }
        }
        return data;
    }
    7860:	f1 10       	cpse	r15, r1
    7862:	2d c0       	rjmp	.+90     	; 0x78be <rs485xModemFlash+0x1e4>
    \endcode
*/
    7864:	61 e0       	ldi	r22, 0x01	; 1
    7866:	ce 01       	movw	r24, r28
    7868:	02 96       	adiw	r24, 0x02	; 2
    786a:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    786e:	81 30       	cpi	r24, 0x01	; 1
    7870:	31 f4       	brne	.+12     	; 0x787e <rs485xModemFlash+0x1a4>

static __inline__ uint8_t
_crc8_ccitt_update(uint8_t __crc, uint8_t __data)
{
    7872:	8a 81       	ldd	r24, Y+2	; 0x02
    7874:	8e 15       	cp	r24, r14
    7876:	29 f0       	breq	.+10     	; 0x7882 <rs485xModemFlash+0x1a8>
    uint8_t __i, __pattern;
    7878:	5a e0       	ldi	r21, 0x0A	; 10
    787a:	f5 2e       	mov	r15, r21
    787c:	02 c0       	rjmp	.+4      	; 0x7882 <rs485xModemFlash+0x1a8>
        }
        return data;
    }
    \endcode
*/

    787e:	49 e0       	ldi	r20, 0x09	; 9
    7880:	f4 2e       	mov	r15, r20
static __inline__ uint8_t
_crc8_ccitt_update(uint8_t __crc, uint8_t __data)
{
    uint8_t __i, __pattern;
    __asm__ __volatile__ (
        "    eor    %0, %4" "\n\t"
    7882:	6a 81       	ldd	r22, Y+2	; 0x02
    7884:	c5 01       	movw	r24, r10
    7886:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    788a:	b8 2e       	mov	r11, r24
    788c:	a9 2e       	mov	r10, r25
        "    ldi    %1, 8" "\n\t"
        "    ldi    %2, 0x07" "\n\t"
        "1:  lsl    %0" "\n\t"
        "    brcc   2f" "\n\t"
    788e:	f1 10       	cpse	r15, r1
    7890:	16 c0       	rjmp	.+44     	; 0x78be <rs485xModemFlash+0x1e4>
        "    eor    %0, %2" "\n\t"
        "2:  dec    %1" "\n\t"
    7892:	61 e0       	ldi	r22, 0x01	; 1
    7894:	ce 01       	movw	r24, r28
    7896:	01 96       	adiw	r24, 0x01	; 1
    7898:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    789c:	81 30       	cpi	r24, 0x01	; 1
    789e:	79 f4       	brne	.+30     	; 0x78be <rs485xModemFlash+0x1e4>
        "    brne   1b" "\n\t"
        : "=r" (__crc), "=d" (__i), "=d" (__pattern)
        : "0" (__crc), "r" (__data));
    return __crc;
    78a0:	89 81       	ldd	r24, Y+1	; 0x01
    78a2:	8a 11       	cpse	r24, r10
    78a4:	0c c0       	rjmp	.+24     	; 0x78be <rs485xModemFlash+0x1e4>
#endif /* _UTIL_CRC16_H_ */
    78a6:	61 e0       	ldi	r22, 0x01	; 1
    78a8:	ce 01       	movw	r24, r28
    78aa:	01 96       	adiw	r24, 0x01	; 1
    78ac:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    78b0:	f8 2e       	mov	r15, r24
    78b2:	a1 e0       	ldi	r26, 0x01	; 1
    78b4:	8a 13       	cpse	r24, r26
    78b6:	03 c0       	rjmp	.+6      	; 0x78be <rs485xModemFlash+0x1e4>
    78b8:	89 81       	ldd	r24, Y+1	; 0x01
    78ba:	8b 15       	cp	r24, r11
    78bc:	39 f0       	breq	.+14     	; 0x78cc <rs485xModemFlash+0x1f2>
    78be:	0e 94 ca 0c 	call	0x1994	; 0x1994 <releaseRs485>
    78c2:	0e 94 a2 0c 	call	0x1944	; 0x1944 <flushRs485RecBuffer>
    78c6:	ff 24       	eor	r15, r15
    78c8:	f3 94       	inc	r15
    78ca:	12 c1       	rjmp	.+548    	; 0x7af0 <rs485xModemFlash+0x416>
    78cc:	84 e6       	ldi	r24, 0x64	; 100
    78ce:	90 e0       	ldi	r25, 0x00	; 0
    78d0:	0e 94 81 43 	call	0x8702	; 0x8702 <vTaskDelay>
    78d4:	6a e5       	ldi	r22, 0x5A	; 90
    78d6:	80 e0       	ldi	r24, 0x00	; 0
    78d8:	90 e0       	ldi	r25, 0x00	; 0
    78da:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    78de:	5c 01       	movw	r10, r24
    78e0:	8a e5       	ldi	r24, 0x5A	; 90
    78e2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    78e6:	6e 2d       	mov	r22, r14
    78e8:	c5 01       	movw	r24, r10
    78ea:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    78ee:	5c 01       	movw	r10, r24
    78f0:	8e 2d       	mov	r24, r14
    78f2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    78f6:	61 e8       	ldi	r22, 0x81	; 129
    78f8:	c5 01       	movw	r24, r10
    78fa:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    78fe:	5c 01       	movw	r10, r24
    7900:	81 e8       	ldi	r24, 0x81	; 129
    7902:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7906:	61 e0       	ldi	r22, 0x01	; 1
    7908:	c5 01       	movw	r24, r10
    790a:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    790e:	5c 01       	movw	r10, r24
    7910:	81 e0       	ldi	r24, 0x01	; 1
    7912:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7916:	6e 2d       	mov	r22, r14
    7918:	c5 01       	movw	r24, r10
    791a:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    791e:	b8 2e       	mov	r11, r24
    7920:	8e 2d       	mov	r24, r14
    7922:	9b 83       	std	Y+3, r25	; 0x03
    7924:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7928:	9b 81       	ldd	r25, Y+3	; 0x03
    792a:	89 2f       	mov	r24, r25
    792c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7930:	8b 2d       	mov	r24, r11
    7932:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7936:	66 e9       	ldi	r22, 0x96	; 150
    7938:	ce 01       	movw	r24, r28
    793a:	02 96       	adiw	r24, 0x02	; 2
    793c:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7940:	8a 81       	ldd	r24, Y+2	; 0x02
    7942:	83 34       	cpi	r24, 0x43	; 67
    7944:	09 f0       	breq	.+2      	; 0x7948 <rs485xModemFlash+0x26e>
    7946:	bd c0       	rjmp	.+378    	; 0x7ac2 <rs485xModemFlash+0x3e8>
    7948:	d6 01       	movw	r26, r12
    794a:	14 96       	adiw	r26, 0x04	; 4
    794c:	ed 91       	ld	r30, X+
    794e:	fc 91       	ld	r31, X
    7950:	15 97       	sbiw	r26, 0x05	; 5
    7952:	e2 80       	ldd	r14, Z+2	; 0x02
    7954:	ee 0c       	add	r14, r14
    7956:	81 81       	ldd	r24, Z+1	; 0x01
    7958:	80 38       	cpi	r24, 0x80	; 128
    795a:	09 f4       	brne	.+2      	; 0x795e <rs485xModemFlash+0x284>
    795c:	e3 94       	inc	r14
    795e:	81 e0       	ldi	r24, 0x01	; 1
    7960:	89 83       	std	Y+1, r24	; 0x01
    7962:	b1 2c       	mov	r11, r1
    7964:	f1 2c       	mov	r15, r1
    7966:	36 e6       	ldi	r19, 0x66	; 102
    7968:	83 2e       	mov	r8, r19
    796a:	31 e0       	ldi	r19, 0x01	; 1
    796c:	93 2e       	mov	r9, r19
    796e:	89 81       	ldd	r24, Y+1	; 0x01
    7970:	e8 16       	cp	r14, r24
    7972:	08 f4       	brcc	.+2      	; 0x7976 <rs485xModemFlash+0x29c>
    7974:	8a c0       	rjmp	.+276    	; 0x7a8a <rs485xModemFlash+0x3b0>
    7976:	81 e0       	ldi	r24, 0x01	; 1
    7978:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    797c:	89 81       	ldd	r24, Y+1	; 0x01
    797e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7982:	89 81       	ldd	r24, Y+1	; 0x01
    7984:	80 95       	com	r24
    7986:	8a 83       	std	Y+2, r24	; 0x02
    7988:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    798c:	f1 2c       	mov	r15, r1
    798e:	a1 2c       	mov	r10, r1
    7990:	71 2c       	mov	r7, r1
    7992:	be 01       	movw	r22, r28
    7994:	6e 5f       	subi	r22, 0xFE	; 254
    7996:	7f 4f       	sbci	r23, 0xFF	; 255
    7998:	c6 01       	movw	r24, r12
    799a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <ramDyskCzytajBajtZPliku>
    799e:	81 11       	cpse	r24, r1
    79a0:	1a 82       	std	Y+2, r1	; 0x02
    79a2:	6a 81       	ldd	r22, Y+2	; 0x02
    79a4:	8a 2d       	mov	r24, r10
    79a6:	97 2d       	mov	r25, r7
    79a8:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    79ac:	a8 2e       	mov	r10, r24
    79ae:	79 2e       	mov	r7, r25
    79b0:	8a 81       	ldd	r24, Y+2	; 0x02
    79b2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    79b6:	f3 94       	inc	r15
    79b8:	b0 e8       	ldi	r27, 0x80	; 128
    79ba:	fb 12       	cpse	r15, r27
    79bc:	ea cf       	rjmp	.-44     	; 0x7992 <rs485xModemFlash+0x2b8>
    79be:	87 2d       	mov	r24, r7
    79c0:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    79c4:	8a 2d       	mov	r24, r10
    79c6:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    79ca:	64 e6       	ldi	r22, 0x64	; 100
    79cc:	ce 01       	movw	r24, r28
    79ce:	02 96       	adiw	r24, 0x02	; 2
    79d0:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    79d4:	81 30       	cpi	r24, 0x01	; 1
    79d6:	59 f0       	breq	.+22     	; 0x79ee <rs485xModemFlash+0x314>
    79d8:	01 15       	cp	r16, r1
    79da:	11 05       	cpc	r17, r1
    79dc:	29 f0       	breq	.+10     	; 0x79e8 <rs485xModemFlash+0x30e>
    79de:	b8 01       	movw	r22, r16
    79e0:	83 e2       	ldi	r24, 0x23	; 35
    79e2:	90 e0       	ldi	r25, 0x00	; 0
    79e4:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    79e8:	1a 82       	std	Y+2, r1	; 0x02
    79ea:	2a ef       	ldi	r18, 0xFA	; 250
    79ec:	f2 2e       	mov	r15, r18
    79ee:	0e 94 a2 0c 	call	0x1944	; 0x1944 <flushRs485RecBuffer>
    79f2:	8a 81       	ldd	r24, Y+2	; 0x02
    79f4:	86 30       	cpi	r24, 0x06	; 6
    79f6:	d9 f4       	brne	.+54     	; 0x7a2e <rs485xModemFlash+0x354>
    79f8:	89 81       	ldd	r24, Y+1	; 0x01
    79fa:	8f 5f       	subi	r24, 0xFF	; 255
    79fc:	89 83       	std	Y+1, r24	; 0x01
    79fe:	01 15       	cp	r16, r1
    7a00:	11 05       	cpc	r17, r1
    7a02:	91 f0       	breq	.+36     	; 0x7a28 <rs485xModemFlash+0x34e>
    7a04:	b8 01       	movw	r22, r16
    7a06:	8e e2       	ldi	r24, 0x2E	; 46
    7a08:	90 e0       	ldi	r25, 0x00	; 0
    7a0a:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    7a0e:	89 81       	ldd	r24, Y+1	; 0x01
    7a10:	8f 70       	andi	r24, 0x0F	; 15
    7a12:	51 f4       	brne	.+20     	; 0x7a28 <rs485xModemFlash+0x34e>
    7a14:	b8 01       	movw	r22, r16
    7a16:	8d e0       	ldi	r24, 0x0D	; 13
    7a18:	90 e0       	ldi	r25, 0x00	; 0
    7a1a:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    7a1e:	b8 01       	movw	r22, r16
    7a20:	8a e0       	ldi	r24, 0x0A	; 10
    7a22:	90 e0       	ldi	r25, 0x00	; 0
    7a24:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    7a28:	b1 2c       	mov	r11, r1
    7a2a:	f1 2c       	mov	r15, r1
    7a2c:	a0 cf       	rjmp	.-192    	; 0x796e <rs485xModemFlash+0x294>
    7a2e:	88 31       	cpi	r24, 0x18	; 24
    7a30:	51 f4       	brne	.+20     	; 0x7a46 <rs485xModemFlash+0x36c>
    7a32:	01 15       	cp	r16, r1
    7a34:	11 05       	cpc	r17, r1
    7a36:	09 f4       	brne	.+2      	; 0x7a3a <rs485xModemFlash+0x360>
    7a38:	58 c0       	rjmp	.+176    	; 0x7aea <rs485xModemFlash+0x410>
    7a3a:	b8 01       	movw	r22, r16
    7a3c:	83 e4       	ldi	r24, 0x43	; 67
    7a3e:	90 e0       	ldi	r25, 0x00	; 0
    7a40:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    7a44:	52 c0       	rjmp	.+164    	; 0x7aea <rs485xModemFlash+0x410>
    7a46:	01 15       	cp	r16, r1
    7a48:	11 05       	cpc	r17, r1
    7a4a:	c1 f0       	breq	.+48     	; 0x7a7c <rs485xModemFlash+0x3a2>
    7a4c:	85 31       	cpi	r24, 0x15	; 21
    7a4e:	29 f4       	brne	.+10     	; 0x7a5a <rs485xModemFlash+0x380>
    7a50:	b8 01       	movw	r22, r16
    7a52:	8e e4       	ldi	r24, 0x4E	; 78
    7a54:	90 e0       	ldi	r25, 0x00	; 0
    7a56:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    7a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    7a5c:	88 23       	and	r24, r24
    7a5e:	71 f0       	breq	.+28     	; 0x7a7c <rs485xModemFlash+0x3a2>
    7a60:	1f 92       	push	r1
    7a62:	8f 93       	push	r24
    7a64:	9f 92       	push	r9
    7a66:	8f 92       	push	r8
    7a68:	1f 93       	push	r17
    7a6a:	0f 93       	push	r16
    7a6c:	0e 94 0a 50 	call	0xa014	; 0xa014 <fprintf>
    7a70:	0f 90       	pop	r0
    7a72:	0f 90       	pop	r0
    7a74:	0f 90       	pop	r0
    7a76:	0f 90       	pop	r0
    7a78:	0f 90       	pop	r0
    7a7a:	0f 90       	pop	r0
    7a7c:	b3 94       	inc	r11
    7a7e:	83 e0       	ldi	r24, 0x03	; 3
    7a80:	b8 12       	cpse	r11, r24
    7a82:	75 cf       	rjmp	.-278    	; 0x796e <rs485xModemFlash+0x294>
    7a84:	88 ef       	ldi	r24, 0xF8	; 248
    7a86:	f8 2e       	mov	r15, r24
    7a88:	17 c0       	rjmp	.+46     	; 0x7ab8 <rs485xModemFlash+0x3de>
    7a8a:	f1 10       	cpse	r15, r1
    7a8c:	15 c0       	rjmp	.+42     	; 0x7ab8 <rs485xModemFlash+0x3de>
    7a8e:	84 e0       	ldi	r24, 0x04	; 4
    7a90:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7a94:	69 e1       	ldi	r22, 0x19	; 25
    7a96:	ce 01       	movw	r24, r28
    7a98:	02 96       	adiw	r24, 0x02	; 2
    7a9a:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7a9e:	81 30       	cpi	r24, 0x01	; 1
    7aa0:	59 f4       	brne	.+22     	; 0x7ab8 <rs485xModemFlash+0x3de>
    7aa2:	8a 81       	ldd	r24, Y+2	; 0x02
    7aa4:	86 30       	cpi	r24, 0x06	; 6
    7aa6:	41 f4       	brne	.+16     	; 0x7ab8 <rs485xModemFlash+0x3de>
    7aa8:	84 e0       	ldi	r24, 0x04	; 4
    7aaa:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7aae:	69 e1       	ldi	r22, 0x19	; 25
    7ab0:	ce 01       	movw	r24, r28
    7ab2:	02 96       	adiw	r24, 0x02	; 2
    7ab4:	0e 94 42 0c 	call	0x1884	; 0x1884 <rs485Receive>
    7ab8:	0e 94 a2 0c 	call	0x1944	; 0x1944 <flushRs485RecBuffer>
    7abc:	0e 94 ca 0c 	call	0x1994	; 0x1994 <releaseRs485>
    7ac0:	17 c0       	rjmp	.+46     	; 0x7af0 <rs485xModemFlash+0x416>
    7ac2:	0e 94 ca 0c 	call	0x1994	; 0x1994 <releaseRs485>
    7ac6:	0e 94 a2 0c 	call	0x1944	; 0x1944 <flushRs485RecBuffer>
    7aca:	01 15       	cp	r16, r1
    7acc:	11 05       	cpc	r17, r1
    7ace:	81 f0       	breq	.+32     	; 0x7af0 <rs485xModemFlash+0x416>
    7ad0:	81 e6       	ldi	r24, 0x61	; 97
    7ad2:	93 e1       	ldi	r25, 0x13	; 19
    7ad4:	9f 93       	push	r25
    7ad6:	8f 93       	push	r24
    7ad8:	1f 93       	push	r17
    7ada:	0f 93       	push	r16
    7adc:	0e 94 1a 50 	call	0xa034	; 0xa034 <fprintf_P>
    7ae0:	0f 90       	pop	r0
    7ae2:	0f 90       	pop	r0
    7ae4:	0f 90       	pop	r0
    7ae6:	0f 90       	pop	r0
    7ae8:	03 c0       	rjmp	.+6      	; 0x7af0 <rs485xModemFlash+0x416>
    7aea:	99 ef       	ldi	r25, 0xF9	; 249
    7aec:	f9 2e       	mov	r15, r25
    7aee:	e4 cf       	rjmp	.-56     	; 0x7ab8 <rs485xModemFlash+0x3de>
    7af0:	8f 2d       	mov	r24, r15
    7af2:	0f 90       	pop	r0
    7af4:	0f 90       	pop	r0
    7af6:	0f 90       	pop	r0
    7af8:	df 91       	pop	r29
    7afa:	cf 91       	pop	r28
    7afc:	1f 91       	pop	r17
    7afe:	0f 91       	pop	r16
    7b00:	ff 90       	pop	r15
    7b02:	ef 90       	pop	r14
    7b04:	df 90       	pop	r13
    7b06:	cf 90       	pop	r12
    7b08:	bf 90       	pop	r11
    7b0a:	af 90       	pop	r10
    7b0c:	9f 90       	pop	r9
    7b0e:	8f 90       	pop	r8
    7b10:	7f 90       	pop	r7
    7b12:	08 95       	ret

00007b14 <rs485curtainUp>:
    7b14:	df 92       	push	r13
    7b16:	ef 92       	push	r14
    7b18:	ff 92       	push	r15
    7b1a:	0f 93       	push	r16
    7b1c:	1f 93       	push	r17
    7b1e:	cf 93       	push	r28
    7b20:	df 93       	push	r29
    7b22:	1f 92       	push	r1
    7b24:	cd b7       	in	r28, 0x3d	; 61
    7b26:	de b7       	in	r29, 0x3e	; 62
    7b28:	e8 2e       	mov	r14, r24
    7b2a:	f6 2e       	mov	r15, r22
    7b2c:	d4 2e       	mov	r13, r20
    7b2e:	6a e5       	ldi	r22, 0x5A	; 90
    7b30:	80 e0       	ldi	r24, 0x00	; 0
    7b32:	90 e0       	ldi	r25, 0x00	; 0
    7b34:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7b38:	8c 01       	movw	r16, r24
    7b3a:	8a e5       	ldi	r24, 0x5A	; 90
    7b3c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7b40:	6e 2d       	mov	r22, r14
    7b42:	c8 01       	movw	r24, r16
    7b44:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7b48:	8c 01       	movw	r16, r24
    7b4a:	8e 2d       	mov	r24, r14
    7b4c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7b50:	f1 10       	cpse	r15, r1
    7b52:	07 c0       	rjmp	.+14     	; 0x7b62 <rs485curtainUp+0x4e>
    7b54:	60 e2       	ldi	r22, 0x20	; 32
    7b56:	c8 01       	movw	r24, r16
    7b58:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7b5c:	8c 01       	movw	r16, r24
    7b5e:	80 e2       	ldi	r24, 0x20	; 32
    7b60:	06 c0       	rjmp	.+12     	; 0x7b6e <rs485curtainUp+0x5a>
    7b62:	61 e2       	ldi	r22, 0x21	; 33
    7b64:	c8 01       	movw	r24, r16
    7b66:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7b6a:	8c 01       	movw	r16, r24
    7b6c:	81 e2       	ldi	r24, 0x21	; 33
    7b6e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7b72:	61 e0       	ldi	r22, 0x01	; 1
    7b74:	c8 01       	movw	r24, r16
    7b76:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7b7a:	8c 01       	movw	r16, r24
    7b7c:	81 e0       	ldi	r24, 0x01	; 1
    7b7e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7b82:	6d 2d       	mov	r22, r13
    7b84:	c8 01       	movw	r24, r16
    7b86:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7b8a:	18 2f       	mov	r17, r24
    7b8c:	8d 2d       	mov	r24, r13
    7b8e:	99 83       	std	Y+1, r25	; 0x01
    7b90:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7b94:	99 81       	ldd	r25, Y+1	; 0x01
    7b96:	89 2f       	mov	r24, r25
    7b98:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7b9c:	81 2f       	mov	r24, r17
    7b9e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7ba2:	80 e0       	ldi	r24, 0x00	; 0
    7ba4:	0f 90       	pop	r0
    7ba6:	df 91       	pop	r29
    7ba8:	cf 91       	pop	r28
    7baa:	1f 91       	pop	r17
    7bac:	0f 91       	pop	r16
    7bae:	ff 90       	pop	r15
    7bb0:	ef 90       	pop	r14
    7bb2:	df 90       	pop	r13
    7bb4:	08 95       	ret

00007bb6 <rs485Led>:
    7bb6:	df 92       	push	r13
    7bb8:	ef 92       	push	r14
    7bba:	ff 92       	push	r15
    7bbc:	0f 93       	push	r16
    7bbe:	1f 93       	push	r17
    7bc0:	cf 93       	push	r28
    7bc2:	df 93       	push	r29
    7bc4:	1f 92       	push	r1
    7bc6:	cd b7       	in	r28, 0x3d	; 61
    7bc8:	de b7       	in	r29, 0x3e	; 62
    7bca:	e8 2e       	mov	r14, r24
    7bcc:	f6 2e       	mov	r15, r22
    7bce:	d4 2e       	mov	r13, r20
    7bd0:	6a e5       	ldi	r22, 0x5A	; 90
    7bd2:	80 e0       	ldi	r24, 0x00	; 0
    7bd4:	90 e0       	ldi	r25, 0x00	; 0
    7bd6:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7bda:	8c 01       	movw	r16, r24
    7bdc:	8a e5       	ldi	r24, 0x5A	; 90
    7bde:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7be2:	6e 2d       	mov	r22, r14
    7be4:	c8 01       	movw	r24, r16
    7be6:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7bea:	8c 01       	movw	r16, r24
    7bec:	8e 2d       	mov	r24, r14
    7bee:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7bf2:	6f 2d       	mov	r22, r15
    7bf4:	c8 01       	movw	r24, r16
    7bf6:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7bfa:	61 e0       	ldi	r22, 0x01	; 1
    7bfc:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c00:	8c 01       	movw	r16, r24
    7c02:	81 e0       	ldi	r24, 0x01	; 1
    7c04:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c08:	6d 2d       	mov	r22, r13
    7c0a:	c8 01       	movw	r24, r16
    7c0c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c10:	18 2f       	mov	r17, r24
    7c12:	8d 2d       	mov	r24, r13
    7c14:	99 83       	std	Y+1, r25	; 0x01
    7c16:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c1a:	99 81       	ldd	r25, Y+1	; 0x01
    7c1c:	89 2f       	mov	r24, r25
    7c1e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c22:	81 2f       	mov	r24, r17
    7c24:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c28:	80 e0       	ldi	r24, 0x00	; 0
    7c2a:	0f 90       	pop	r0
    7c2c:	df 91       	pop	r29
    7c2e:	cf 91       	pop	r28
    7c30:	1f 91       	pop	r17
    7c32:	0f 91       	pop	r16
    7c34:	ff 90       	pop	r15
    7c36:	ef 90       	pop	r14
    7c38:	df 90       	pop	r13
    7c3a:	08 95       	ret

00007c3c <sendSettings>:
    7c3c:	ef 92       	push	r14
    7c3e:	ff 92       	push	r15
    7c40:	0f 93       	push	r16
    7c42:	1f 93       	push	r17
    7c44:	cf 93       	push	r28
    7c46:	df 93       	push	r29
    7c48:	1f 92       	push	r1
    7c4a:	cd b7       	in	r28, 0x3d	; 61
    7c4c:	de b7       	in	r29, 0x3e	; 62
    7c4e:	f8 2e       	mov	r15, r24
    7c50:	e6 2e       	mov	r14, r22
    7c52:	6a e5       	ldi	r22, 0x5A	; 90
    7c54:	80 e0       	ldi	r24, 0x00	; 0
    7c56:	90 e0       	ldi	r25, 0x00	; 0
    7c58:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c5c:	8c 01       	movw	r16, r24
    7c5e:	8a e5       	ldi	r24, 0x5A	; 90
    7c60:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c64:	6f 2d       	mov	r22, r15
    7c66:	c8 01       	movw	r24, r16
    7c68:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c6c:	8c 01       	movw	r16, r24
    7c6e:	8f 2d       	mov	r24, r15
    7c70:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c74:	60 e4       	ldi	r22, 0x40	; 64
    7c76:	c8 01       	movw	r24, r16
    7c78:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c7c:	8c 01       	movw	r16, r24
    7c7e:	80 e4       	ldi	r24, 0x40	; 64
    7c80:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c84:	61 e0       	ldi	r22, 0x01	; 1
    7c86:	c8 01       	movw	r24, r16
    7c88:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c8c:	8c 01       	movw	r16, r24
    7c8e:	81 e0       	ldi	r24, 0x01	; 1
    7c90:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7c94:	6e 2d       	mov	r22, r14
    7c96:	c8 01       	movw	r24, r16
    7c98:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7c9c:	18 2f       	mov	r17, r24
    7c9e:	8e 2d       	mov	r24, r14
    7ca0:	99 83       	std	Y+1, r25	; 0x01
    7ca2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7ca6:	99 81       	ldd	r25, Y+1	; 0x01
    7ca8:	89 2f       	mov	r24, r25
    7caa:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7cae:	81 2f       	mov	r24, r17
    7cb0:	0f 90       	pop	r0
    7cb2:	df 91       	pop	r29
    7cb4:	cf 91       	pop	r28
    7cb6:	1f 91       	pop	r17
    7cb8:	0f 91       	pop	r16
    7cba:	ff 90       	pop	r15
    7cbc:	ef 90       	pop	r14
    7cbe:	0c 94 2b 0c 	jmp	0x1856	; 0x1856 <uartRs485SendByte>

00007cc2 <saveSettings>:
    7cc2:	ff 92       	push	r15
    7cc4:	0f 93       	push	r16
    7cc6:	1f 93       	push	r17
    7cc8:	cf 93       	push	r28
    7cca:	df 93       	push	r29
    7ccc:	1f 92       	push	r1
    7cce:	cd b7       	in	r28, 0x3d	; 61
    7cd0:	de b7       	in	r29, 0x3e	; 62
    7cd2:	f8 2e       	mov	r15, r24
    7cd4:	6a e5       	ldi	r22, 0x5A	; 90
    7cd6:	80 e0       	ldi	r24, 0x00	; 0
    7cd8:	90 e0       	ldi	r25, 0x00	; 0
    7cda:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7cde:	8c 01       	movw	r16, r24
    7ce0:	8a e5       	ldi	r24, 0x5A	; 90
    7ce2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7ce6:	6f 2d       	mov	r22, r15
    7ce8:	c8 01       	movw	r24, r16
    7cea:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7cee:	8c 01       	movw	r16, r24
    7cf0:	8f 2d       	mov	r24, r15
    7cf2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7cf6:	61 e4       	ldi	r22, 0x41	; 65
    7cf8:	c8 01       	movw	r24, r16
    7cfa:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7cfe:	8c 01       	movw	r16, r24
    7d00:	81 e4       	ldi	r24, 0x41	; 65
    7d02:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7d06:	60 e0       	ldi	r22, 0x00	; 0
    7d08:	c8 01       	movw	r24, r16
    7d0a:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7d0e:	18 2f       	mov	r17, r24
    7d10:	80 e0       	ldi	r24, 0x00	; 0
    7d12:	99 83       	std	Y+1, r25	; 0x01
    7d14:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7d18:	99 81       	ldd	r25, Y+1	; 0x01
    7d1a:	89 2f       	mov	r24, r25
    7d1c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7d20:	81 2f       	mov	r24, r17
    7d22:	0f 90       	pop	r0
    7d24:	df 91       	pop	r29
    7d26:	cf 91       	pop	r28
    7d28:	1f 91       	pop	r17
    7d2a:	0f 91       	pop	r16
    7d2c:	ff 90       	pop	r15
    7d2e:	0c 94 2b 0c 	jmp	0x1856	; 0x1856 <uartRs485SendByte>

00007d32 <rs485curtainDown>:
    7d32:	df 92       	push	r13
    7d34:	ef 92       	push	r14
    7d36:	ff 92       	push	r15
    7d38:	0f 93       	push	r16
    7d3a:	1f 93       	push	r17
    7d3c:	cf 93       	push	r28
    7d3e:	df 93       	push	r29
    7d40:	1f 92       	push	r1
    7d42:	cd b7       	in	r28, 0x3d	; 61
    7d44:	de b7       	in	r29, 0x3e	; 62
    7d46:	e8 2e       	mov	r14, r24
    7d48:	f6 2e       	mov	r15, r22
    7d4a:	d4 2e       	mov	r13, r20
    7d4c:	6a e5       	ldi	r22, 0x5A	; 90
    7d4e:	80 e0       	ldi	r24, 0x00	; 0
    7d50:	90 e0       	ldi	r25, 0x00	; 0
    7d52:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7d56:	8c 01       	movw	r16, r24
    7d58:	8a e5       	ldi	r24, 0x5A	; 90
    7d5a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7d5e:	6e 2d       	mov	r22, r14
    7d60:	c8 01       	movw	r24, r16
    7d62:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7d66:	8c 01       	movw	r16, r24
    7d68:	8e 2d       	mov	r24, r14
    7d6a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7d6e:	f1 10       	cpse	r15, r1
    7d70:	07 c0       	rjmp	.+14     	; 0x7d80 <rs485curtainDown+0x4e>
    7d72:	60 e1       	ldi	r22, 0x10	; 16
    7d74:	c8 01       	movw	r24, r16
    7d76:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7d7a:	8c 01       	movw	r16, r24
    7d7c:	80 e1       	ldi	r24, 0x10	; 16
    7d7e:	06 c0       	rjmp	.+12     	; 0x7d8c <rs485curtainDown+0x5a>
    7d80:	61 e1       	ldi	r22, 0x11	; 17
    7d82:	c8 01       	movw	r24, r16
    7d84:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7d88:	8c 01       	movw	r16, r24
    7d8a:	81 e1       	ldi	r24, 0x11	; 17
    7d8c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7d90:	61 e0       	ldi	r22, 0x01	; 1
    7d92:	c8 01       	movw	r24, r16
    7d94:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7d98:	8c 01       	movw	r16, r24
    7d9a:	81 e0       	ldi	r24, 0x01	; 1
    7d9c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7da0:	6d 2d       	mov	r22, r13
    7da2:	c8 01       	movw	r24, r16
    7da4:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <_crc_xmodem_update>
    7da8:	18 2f       	mov	r17, r24
    7daa:	8d 2d       	mov	r24, r13
    7dac:	99 83       	std	Y+1, r25	; 0x01
    7dae:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7db2:	99 81       	ldd	r25, Y+1	; 0x01
    7db4:	89 2f       	mov	r24, r25
    7db6:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7dba:	81 2f       	mov	r24, r17
    7dbc:	0e 94 2b 0c 	call	0x1856	; 0x1856 <uartRs485SendByte>
    7dc0:	80 e0       	ldi	r24, 0x00	; 0
    7dc2:	0f 90       	pop	r0
    7dc4:	df 91       	pop	r29
    7dc6:	cf 91       	pop	r28
    7dc8:	1f 91       	pop	r17
    7dca:	0f 91       	pop	r16
    7dcc:	ff 90       	pop	r15
    7dce:	ef 90       	pop	r14
    7dd0:	df 90       	pop	r13
    7dd2:	08 95       	ret

00007dd4 <prvIdleTask>:
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    7dd4:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
    7dd8:	fd cf       	rjmp	.-6      	; 0x7dd4 <prvIdleTask>

00007dda <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
    7dda:	2f 92       	push	r2
    7ddc:	3f 92       	push	r3
    7dde:	4f 92       	push	r4
    7de0:	5f 92       	push	r5
    7de2:	6f 92       	push	r6
    7de4:	7f 92       	push	r7
    7de6:	8f 92       	push	r8
    7de8:	9f 92       	push	r9
    7dea:	af 92       	push	r10
    7dec:	bf 92       	push	r11
    7dee:	cf 92       	push	r12
    7df0:	df 92       	push	r13
    7df2:	ef 92       	push	r14
    7df4:	ff 92       	push	r15
    7df6:	0f 93       	push	r16
    7df8:	1f 93       	push	r17
    7dfa:	cf 93       	push	r28
    7dfc:	df 93       	push	r29
    7dfe:	1f 92       	push	r1
    7e00:	cd b7       	in	r28, 0x3d	; 61
    7e02:	de b7       	in	r29, 0x3e	; 62
    7e04:	4c 01       	movw	r8, r24
    7e06:	1b 01       	movw	r2, r22
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    7e08:	db 01       	movw	r26, r22
    7e0a:	11 96       	adiw	r26, 0x01	; 1
    7e0c:	ed 91       	ld	r30, X+
    7e0e:	fc 91       	ld	r31, X
    7e10:	12 97       	sbiw	r26, 0x02	; 2
    7e12:	82 81       	ldd	r24, Z+2	; 0x02
    7e14:	93 81       	ldd	r25, Z+3	; 0x03
    7e16:	12 96       	adiw	r26, 0x02	; 2
    7e18:	9c 93       	st	X, r25
    7e1a:	8e 93       	st	-X, r24
    7e1c:	11 97       	sbiw	r26, 0x01	; 1
    7e1e:	3b 01       	movw	r6, r22
    7e20:	b3 e0       	ldi	r27, 0x03	; 3
    7e22:	6b 0e       	add	r6, r27
    7e24:	71 1c       	adc	r7, r1
    7e26:	86 15       	cp	r24, r6
    7e28:	97 05       	cpc	r25, r7
    7e2a:	41 f4       	brne	.+16     	; 0x7e3c <prvListTaskWithinSingleList+0x62>
    7e2c:	f3 01       	movw	r30, r6
    7e2e:	82 81       	ldd	r24, Z+2	; 0x02
    7e30:	93 81       	ldd	r25, Z+3	; 0x03
    7e32:	db 01       	movw	r26, r22
    7e34:	12 96       	adiw	r26, 0x02	; 2
    7e36:	9c 93       	st	X, r25
    7e38:	8e 93       	st	-X, r24
    7e3a:	11 97       	sbiw	r26, 0x01	; 1
    7e3c:	d1 01       	movw	r26, r2
    7e3e:	11 96       	adiw	r26, 0x01	; 1
    7e40:	ed 91       	ld	r30, X+
    7e42:	fc 91       	ld	r31, X
    7e44:	12 97       	sbiw	r26, 0x02	; 2
    7e46:	a6 80       	ldd	r10, Z+6	; 0x06
    7e48:	b7 80       	ldd	r11, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    7e4a:	44 2e       	mov	r4, r20
    7e4c:	04 2e       	mov	r0, r20
    7e4e:	00 0c       	add	r0, r0
    7e50:	55 08       	sbc	r5, r5
    7e52:	81 e7       	ldi	r24, 0x71	; 113
    7e54:	c8 2e       	mov	r12, r24
    7e56:	81 e0       	ldi	r24, 0x01	; 1
    7e58:	d8 2e       	mov	r13, r24
    7e5a:	95 e9       	ldi	r25, 0x95	; 149
    7e5c:	e9 2e       	mov	r14, r25
    7e5e:	91 e0       	ldi	r25, 0x01	; 1
    7e60:	f9 2e       	mov	r15, r25

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    7e62:	d1 01       	movw	r26, r2
    7e64:	11 96       	adiw	r26, 0x01	; 1
    7e66:	ed 91       	ld	r30, X+
    7e68:	fc 91       	ld	r31, X
    7e6a:	12 97       	sbiw	r26, 0x02	; 2
    7e6c:	82 81       	ldd	r24, Z+2	; 0x02
    7e6e:	93 81       	ldd	r25, Z+3	; 0x03
    7e70:	12 96       	adiw	r26, 0x02	; 2
    7e72:	9c 93       	st	X, r25
    7e74:	8e 93       	st	-X, r24
    7e76:	11 97       	sbiw	r26, 0x01	; 1
    7e78:	86 15       	cp	r24, r6
    7e7a:	97 05       	cpc	r25, r7
    7e7c:	41 f4       	brne	.+16     	; 0x7e8e <prvListTaskWithinSingleList+0xb4>
    7e7e:	15 96       	adiw	r26, 0x05	; 5
    7e80:	8d 91       	ld	r24, X+
    7e82:	9c 91       	ld	r25, X
    7e84:	16 97       	sbiw	r26, 0x06	; 6
    7e86:	12 96       	adiw	r26, 0x02	; 2
    7e88:	9c 93       	st	X, r25
    7e8a:	8e 93       	st	-X, r24
    7e8c:	11 97       	sbiw	r26, 0x01	; 1
    7e8e:	d1 01       	movw	r26, r2
    7e90:	11 96       	adiw	r26, 0x01	; 1
    7e92:	ed 91       	ld	r30, X+
    7e94:	fc 91       	ld	r31, X
    7e96:	12 97       	sbiw	r26, 0x02	; 2
    7e98:	06 81       	ldd	r16, Z+6	; 0x06
    7e9a:	17 81       	ldd	r17, Z+7	; 0x07
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
    7e9c:	f8 01       	movw	r30, r16
    7e9e:	27 89       	ldd	r18, Z+23	; 0x17
    7ea0:	30 8d       	ldd	r19, Z+24	; 0x18
    7ea2:	f9 01       	movw	r30, r18
    7ea4:	cf 01       	movw	r24, r30
    7ea6:	82 1b       	sub	r24, r18
    7ea8:	93 0b       	sbc	r25, r19

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    7eaa:	51 91       	ld	r21, Z+
    7eac:	55 3a       	cpi	r21, 0xA5	; 165
    7eae:	d1 f3       	breq	.-12     	; 0x7ea4 <prvListTaskWithinSingleList+0xca>
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
    7eb0:	d8 01       	movw	r26, r16
    7eb2:	93 96       	adiw	r26, 0x23	; 35
    7eb4:	3c 91       	ld	r19, X
    7eb6:	93 97       	sbiw	r26, 0x23	; 35
    7eb8:	56 96       	adiw	r26, 0x16	; 22
    7eba:	2c 91       	ld	r18, X
    7ebc:	1f 92       	push	r1
    7ebe:	3f 93       	push	r19
    7ec0:	9f 93       	push	r25
    7ec2:	8f 93       	push	r24
    7ec4:	1f 92       	push	r1
    7ec6:	2f 93       	push	r18
    7ec8:	5f 92       	push	r5
    7eca:	4f 93       	push	r20
    7ecc:	c8 01       	movw	r24, r16
    7ece:	49 96       	adiw	r24, 0x19	; 25
    7ed0:	9f 93       	push	r25
    7ed2:	8f 93       	push	r24
    7ed4:	df 92       	push	r13
    7ed6:	cf 92       	push	r12
    7ed8:	ff 92       	push	r15
    7eda:	ef 92       	push	r14
    7edc:	49 83       	std	Y+1, r20	; 0x01
    7ede:	0e 94 9b 50 	call	0xa136	; 0xa136 <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
    7ee2:	65 e9       	ldi	r22, 0x95	; 149
    7ee4:	71 e0       	ldi	r23, 0x01	; 1
    7ee6:	c4 01       	movw	r24, r8
    7ee8:	0e 94 86 4f 	call	0x9f0c	; 0x9f0c <strcat>

		} while( pxNextTCB != pxFirstTCB );
    7eec:	0f b6       	in	r0, 0x3f	; 63
    7eee:	f8 94       	cli
    7ef0:	de bf       	out	0x3e, r29	; 62
    7ef2:	0f be       	out	0x3f, r0	; 63
    7ef4:	cd bf       	out	0x3d, r28	; 61
    7ef6:	49 81       	ldd	r20, Y+1	; 0x01
    7ef8:	0a 15       	cp	r16, r10
    7efa:	1b 05       	cpc	r17, r11
    7efc:	09 f0       	breq	.+2      	; 0x7f00 <prvListTaskWithinSingleList+0x126>
    7efe:	b1 cf       	rjmp	.-158    	; 0x7e62 <prvListTaskWithinSingleList+0x88>
	}
    7f00:	0f 90       	pop	r0
    7f02:	df 91       	pop	r29
    7f04:	cf 91       	pop	r28
    7f06:	1f 91       	pop	r17
    7f08:	0f 91       	pop	r16
    7f0a:	ff 90       	pop	r15
    7f0c:	ef 90       	pop	r14
    7f0e:	df 90       	pop	r13
    7f10:	cf 90       	pop	r12
    7f12:	bf 90       	pop	r11
    7f14:	af 90       	pop	r10
    7f16:	9f 90       	pop	r9
    7f18:	8f 90       	pop	r8
    7f1a:	7f 90       	pop	r7
    7f1c:	6f 90       	pop	r6
    7f1e:	5f 90       	pop	r5
    7f20:	4f 90       	pop	r4
    7f22:	3f 90       	pop	r3
    7f24:	2f 90       	pop	r2
    7f26:	08 95       	ret

00007f28 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    7f28:	4f 92       	push	r4
    7f2a:	5f 92       	push	r5
    7f2c:	6f 92       	push	r6
    7f2e:	7f 92       	push	r7
    7f30:	8f 92       	push	r8
    7f32:	9f 92       	push	r9
    7f34:	af 92       	push	r10
    7f36:	bf 92       	push	r11
    7f38:	cf 92       	push	r12
    7f3a:	df 92       	push	r13
    7f3c:	ef 92       	push	r14
    7f3e:	ff 92       	push	r15
    7f40:	0f 93       	push	r16
    7f42:	1f 93       	push	r17
    7f44:	cf 93       	push	r28
    7f46:	df 93       	push	r29
    7f48:	5c 01       	movw	r10, r24
    7f4a:	3b 01       	movw	r6, r22
    7f4c:	ea 01       	movw	r28, r20
    7f4e:	49 01       	movw	r8, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    7f50:	84 e2       	ldi	r24, 0x24	; 36
    7f52:	90 e0       	ldi	r25, 0x00	; 0
    7f54:	0e 94 a9 4a 	call	0x9552	; 0x9552 <pvPortMalloc>
    7f58:	2c 01       	movw	r4, r24

	if( pxNewTCB != NULL )
    7f5a:	89 2b       	or	r24, r25
    7f5c:	09 f4       	brne	.+2      	; 0x7f60 <xTaskGenericCreate+0x38>
    7f5e:	c4 c0       	rjmp	.+392    	; 0x80e8 <xTaskGenericCreate+0x1c0>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    7f60:	c1 14       	cp	r12, r1
    7f62:	d1 04       	cpc	r13, r1
    7f64:	21 f4       	brne	.+8      	; 0x7f6e <xTaskGenericCreate+0x46>
    7f66:	ce 01       	movw	r24, r28
    7f68:	0e 94 a9 4a 	call	0x9552	; 0x9552 <pvPortMalloc>
    7f6c:	01 c0       	rjmp	.+2      	; 0x7f70 <xTaskGenericCreate+0x48>
    7f6e:	c6 01       	movw	r24, r12
    7f70:	f2 01       	movw	r30, r4
    7f72:	90 8f       	std	Z+24, r25	; 0x18
    7f74:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    7f76:	00 97       	sbiw	r24, 0x00	; 0
    7f78:	21 f4       	brne	.+8      	; 0x7f82 <xTaskGenericCreate+0x5a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    7f7a:	c2 01       	movw	r24, r4
    7f7c:	0e 94 cf 4a 	call	0x959e	; 0x959e <vPortFree>
    7f80:	b3 c0       	rjmp	.+358    	; 0x80e8 <xTaskGenericCreate+0x1c0>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    7f82:	ae 01       	movw	r20, r28
    7f84:	65 ea       	ldi	r22, 0xA5	; 165
    7f86:	70 e0       	ldi	r23, 0x00	; 0
    7f88:	0e 94 7f 4f 	call	0x9efe	; 0x9efe <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    7f8c:	21 97       	sbiw	r28, 0x01	; 1
    7f8e:	f2 01       	movw	r30, r4
    7f90:	c7 88       	ldd	r12, Z+23	; 0x17
    7f92:	d0 8c       	ldd	r13, Z+24	; 0x18
    7f94:	cc 0e       	add	r12, r28
    7f96:	dd 1e       	adc	r13, r29
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    7f98:	4a e0       	ldi	r20, 0x0A	; 10
    7f9a:	50 e0       	ldi	r21, 0x00	; 0
    7f9c:	b3 01       	movw	r22, r6
    7f9e:	c2 01       	movw	r24, r4
    7fa0:	49 96       	adiw	r24, 0x19	; 25
    7fa2:	0e 94 a6 4f 	call	0x9f4c	; 0x9f4c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    7fa6:	f2 01       	movw	r30, r4
    7fa8:	12 a2       	std	Z+34, r1	; 0x22
    7faa:	10 2f       	mov	r17, r16
    7fac:	03 30       	cpi	r16, 0x03	; 3
    7fae:	08 f0       	brcs	.+2      	; 0x7fb2 <xTaskGenericCreate+0x8a>
    7fb0:	12 e0       	ldi	r17, 0x02	; 2
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    7fb2:	f2 01       	movw	r30, r4
    7fb4:	16 8b       	std	Z+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    7fb6:	e2 01       	movw	r28, r4
    7fb8:	22 96       	adiw	r28, 0x02	; 2
    7fba:	ce 01       	movw	r24, r28
    7fbc:	0e 94 5d 48 	call	0x90ba	; 0x90ba <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    7fc0:	c2 01       	movw	r24, r4
    7fc2:	0c 96       	adiw	r24, 0x0c	; 12
    7fc4:	0e 94 5d 48 	call	0x90ba	; 0x90ba <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    7fc8:	f2 01       	movw	r30, r4
    7fca:	51 86       	std	Z+9, r5	; 0x09
    7fcc:	40 86       	std	Z+8, r4	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    7fce:	83 e0       	ldi	r24, 0x03	; 3
    7fd0:	90 e0       	ldi	r25, 0x00	; 0
    7fd2:	81 1b       	sub	r24, r17
    7fd4:	91 09       	sbc	r25, r1
    7fd6:	95 87       	std	Z+13, r25	; 0x0d
    7fd8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    7fda:	53 8a       	std	Z+19, r5	; 0x13
    7fdc:	42 8a       	std	Z+18, r4	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    7fde:	a4 01       	movw	r20, r8
    7fe0:	b5 01       	movw	r22, r10
    7fe2:	c6 01       	movw	r24, r12
    7fe4:	0e 94 de 4a 	call	0x95bc	; 0x95bc <pxPortInitialiseStack>
    7fe8:	f2 01       	movw	r30, r4
    7fea:	91 83       	std	Z+1, r25	; 0x01
    7fec:	80 83       	st	Z, r24
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    7fee:	0f b6       	in	r0, 0x3f	; 63
    7ff0:	f8 94       	cli
    7ff2:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    7ff4:	80 91 d8 01 	lds	r24, 0x01D8
    7ff8:	8f 5f       	subi	r24, 0xFF	; 255
    7ffa:	80 93 d8 01 	sts	0x01D8, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    7ffe:	80 91 d8 01 	lds	r24, 0x01D8
    8002:	81 30       	cpi	r24, 0x01	; 1
    8004:	69 f5       	brne	.+90     	; 0x8060 <xTaskGenericCreate+0x138>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    8006:	50 92 94 01 	sts	0x0194, r5
    800a:	40 92 93 01 	sts	0x0193, r4
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    800e:	81 e0       	ldi	r24, 0x01	; 1
    8010:	92 e0       	ldi	r25, 0x02	; 2
    8012:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
    8016:	8a e0       	ldi	r24, 0x0A	; 10
    8018:	92 e0       	ldi	r25, 0x02	; 2
    801a:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
    801e:	83 e1       	ldi	r24, 0x13	; 19
    8020:	92 e0       	ldi	r25, 0x02	; 2
    8022:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    8026:	88 ef       	ldi	r24, 0xF8	; 248
    8028:	91 e0       	ldi	r25, 0x01	; 1
    802a:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    802e:	8f ee       	ldi	r24, 0xEF	; 239
    8030:	91 e0       	ldi	r25, 0x01	; 1
    8032:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    8036:	82 ee       	ldi	r24, 0xE2	; 226
    8038:	91 e0       	ldi	r25, 0x01	; 1
    803a:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    803e:	89 ed       	ldi	r24, 0xD9	; 217
    8040:	91 e0       	ldi	r25, 0x01	; 1
    8042:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    8046:	88 ef       	ldi	r24, 0xF8	; 248
    8048:	91 e0       	ldi	r25, 0x01	; 1
    804a:	90 93 ee 01 	sts	0x01EE, r25
    804e:	80 93 ed 01 	sts	0x01ED, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    8052:	8f ee       	ldi	r24, 0xEF	; 239
    8054:	91 e0       	ldi	r25, 0x01	; 1
    8056:	90 93 ec 01 	sts	0x01EC, r25
    805a:	80 93 eb 01 	sts	0x01EB, r24
    805e:	0f c0       	rjmp	.+30     	; 0x807e <xTaskGenericCreate+0x156>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    8060:	80 91 d3 01 	lds	r24, 0x01D3
    8064:	81 11       	cpse	r24, r1
    8066:	0b c0       	rjmp	.+22     	; 0x807e <xTaskGenericCreate+0x156>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    8068:	e0 91 93 01 	lds	r30, 0x0193
    806c:	f0 91 94 01 	lds	r31, 0x0194
    8070:	86 89       	ldd	r24, Z+22	; 0x16
    8072:	08 17       	cp	r16, r24
    8074:	20 f0       	brcs	.+8      	; 0x807e <xTaskGenericCreate+0x156>
					{
						pxCurrentTCB = pxNewTCB;
    8076:	50 92 94 01 	sts	0x0194, r5
    807a:	40 92 93 01 	sts	0x0193, r4
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    807e:	f2 01       	movw	r30, r4
    8080:	86 89       	ldd	r24, Z+22	; 0x16
    8082:	90 91 d5 01 	lds	r25, 0x01D5
    8086:	98 17       	cp	r25, r24
    8088:	10 f4       	brcc	.+4      	; 0x808e <xTaskGenericCreate+0x166>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    808a:	80 93 d5 01 	sts	0x01D5, r24
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    808e:	90 91 ce 01 	lds	r25, 0x01CE
    8092:	f2 01       	movw	r30, r4
    8094:	93 a3       	std	Z+35, r25	; 0x23
			}
			#endif
			uxTaskNumber++;
    8096:	9f 5f       	subi	r25, 0xFF	; 255
    8098:	90 93 ce 01 	sts	0x01CE, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    809c:	90 91 d4 01 	lds	r25, 0x01D4
    80a0:	98 17       	cp	r25, r24
    80a2:	10 f4       	brcc	.+4      	; 0x80a8 <xTaskGenericCreate+0x180>
    80a4:	80 93 d4 01 	sts	0x01D4, r24
    80a8:	f9 e0       	ldi	r31, 0x09	; 9
    80aa:	8f 9f       	mul	r24, r31
    80ac:	c0 01       	movw	r24, r0
    80ae:	11 24       	eor	r1, r1
    80b0:	be 01       	movw	r22, r28
    80b2:	8f 5f       	subi	r24, 0xFF	; 255
    80b4:	9d 4f       	sbci	r25, 0xFD	; 253
    80b6:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    80ba:	0f 90       	pop	r0
    80bc:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    80be:	e1 14       	cp	r14, r1
    80c0:	f1 04       	cpc	r15, r1
    80c2:	19 f0       	breq	.+6      	; 0x80ca <xTaskGenericCreate+0x1a2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    80c4:	f7 01       	movw	r30, r14
    80c6:	51 82       	std	Z+1, r5	; 0x01
    80c8:	40 82       	st	Z, r4
		}

		if( xSchedulerRunning != pdFALSE )
    80ca:	80 91 d3 01 	lds	r24, 0x01D3
    80ce:	88 23       	and	r24, r24
    80d0:	49 f0       	breq	.+18     	; 0x80e4 <xTaskGenericCreate+0x1bc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    80d2:	e0 91 93 01 	lds	r30, 0x0193
    80d6:	f0 91 94 01 	lds	r31, 0x0194
    80da:	86 89       	ldd	r24, Z+22	; 0x16
    80dc:	80 17       	cp	r24, r16
    80de:	10 f4       	brcc	.+4      	; 0x80e4 <xTaskGenericCreate+0x1bc>
			{
				portYIELD_WITHIN_API();
    80e0:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    80e4:	81 e0       	ldi	r24, 0x01	; 1
    80e6:	01 c0       	rjmp	.+2      	; 0x80ea <xTaskGenericCreate+0x1c2>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    80e8:	8f ef       	ldi	r24, 0xFF	; 255
			}
		}
	}

	return xReturn;
}
    80ea:	df 91       	pop	r29
    80ec:	cf 91       	pop	r28
    80ee:	1f 91       	pop	r17
    80f0:	0f 91       	pop	r16
    80f2:	ff 90       	pop	r15
    80f4:	ef 90       	pop	r14
    80f6:	df 90       	pop	r13
    80f8:	cf 90       	pop	r12
    80fa:	bf 90       	pop	r11
    80fc:	af 90       	pop	r10
    80fe:	9f 90       	pop	r9
    8100:	8f 90       	pop	r8
    8102:	7f 90       	pop	r7
    8104:	6f 90       	pop	r6
    8106:	5f 90       	pop	r5
    8108:	4f 90       	pop	r4
    810a:	08 95       	ret

0000810c <uxTaskPriorityGet>:
	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		portENTER_CRITICAL();
    810c:	0f b6       	in	r0, 0x3f	; 63
    810e:	f8 94       	cli
    8110:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    8112:	00 97       	sbiw	r24, 0x00	; 0
    8114:	21 f4       	brne	.+8      	; 0x811e <uxTaskPriorityGet+0x12>
    8116:	80 91 93 01 	lds	r24, 0x0193
    811a:	90 91 94 01 	lds	r25, 0x0194
			uxReturn = pxTCB->uxPriority;
		}
		portEXIT_CRITICAL();
    811e:	0f 90       	pop	r0
    8120:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    8122:	fc 01       	movw	r30, r24
    8124:	86 89       	ldd	r24, Z+22	; 0x16
    8126:	08 95       	ret

00008128 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    8128:	ef 92       	push	r14
    812a:	ff 92       	push	r15
    812c:	1f 93       	push	r17
    812e:	cf 93       	push	r28
    8130:	df 93       	push	r29
    8132:	ec 01       	movw	r28, r24
    8134:	63 30       	cpi	r22, 0x03	; 3
    8136:	08 f0       	brcs	.+2      	; 0x813a <vTaskPrioritySet+0x12>
    8138:	62 e0       	ldi	r22, 0x02	; 2
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		portENTER_CRITICAL();
    813a:	0f b6       	in	r0, 0x3f	; 63
    813c:	f8 94       	cli
    813e:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    8140:	80 91 93 01 	lds	r24, 0x0193
    8144:	90 91 94 01 	lds	r25, 0x0194
    8148:	c8 17       	cp	r28, r24
    814a:	d9 07       	cpc	r29, r25
    814c:	11 f0       	breq	.+4      	; 0x8152 <vTaskPrioritySet+0x2a>
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    814e:	20 97       	sbiw	r28, 0x00	; 0
    8150:	39 f4       	brne	.+14     	; 0x8160 <vTaskPrioritySet+0x38>
    8152:	c0 91 93 01 	lds	r28, 0x0193
    8156:	d0 91 94 01 	lds	r29, 0x0194
    815a:	20 e0       	ldi	r18, 0x00	; 0
    815c:	30 e0       	ldi	r19, 0x00	; 0
    815e:	01 c0       	rjmp	.+2      	; 0x8162 <vTaskPrioritySet+0x3a>
    8160:	9e 01       	movw	r18, r28
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    8162:	8e 89       	ldd	r24, Y+22	; 0x16
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    8164:	86 17       	cp	r24, r22
    8166:	b1 f1       	breq	.+108    	; 0x81d4 <vTaskPrioritySet+0xac>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
				{
					if( pxTask != NULL )
    8168:	11 e0       	ldi	r17, 0x01	; 1

			if( uxCurrentPriority != uxNewPriority )
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    816a:	86 17       	cp	r24, r22
    816c:	18 f4       	brcc	.+6      	; 0x8174 <vTaskPrioritySet+0x4c>
				{
					if( pxTask != NULL )
    816e:	23 2b       	or	r18, r19
    8170:	21 f4       	brne	.+8      	; 0x817a <vTaskPrioritySet+0x52>
    8172:	02 c0       	rjmp	.+4      	; 0x8178 <vTaskPrioritySet+0x50>
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
					}
				}
				else if( pxTask == NULL )
    8174:	23 2b       	or	r18, r19
    8176:	09 f0       	breq	.+2      	; 0x817a <vTaskPrioritySet+0x52>
    8178:	10 e0       	ldi	r17, 0x00	; 0
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    817a:	6e 8b       	std	Y+22, r22	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    817c:	23 e0       	ldi	r18, 0x03	; 3
    817e:	30 e0       	ldi	r19, 0x00	; 0
    8180:	26 1b       	sub	r18, r22
    8182:	31 09       	sbc	r19, r1
    8184:	3d 87       	std	Y+13, r19	; 0x0d
    8186:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    8188:	29 e0       	ldi	r18, 0x09	; 9
    818a:	82 9f       	mul	r24, r18
    818c:	c0 01       	movw	r24, r0
    818e:	11 24       	eor	r1, r1
    8190:	8f 5f       	subi	r24, 0xFF	; 255
    8192:	9d 4f       	sbci	r25, 0xFD	; 253
    8194:	2a 85       	ldd	r18, Y+10	; 0x0a
    8196:	3b 85       	ldd	r19, Y+11	; 0x0b
    8198:	28 17       	cp	r18, r24
    819a:	39 07       	cpc	r19, r25
    819c:	b9 f4       	brne	.+46     	; 0x81cc <vTaskPrioritySet+0xa4>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    819e:	7e 01       	movw	r14, r28
    81a0:	82 e0       	ldi	r24, 0x02	; 2
    81a2:	e8 0e       	add	r14, r24
    81a4:	f1 1c       	adc	r15, r1
    81a6:	c7 01       	movw	r24, r14
    81a8:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    81ac:	9e 89       	ldd	r25, Y+22	; 0x16
    81ae:	80 91 d4 01 	lds	r24, 0x01D4
    81b2:	89 17       	cp	r24, r25
    81b4:	10 f4       	brcc	.+4      	; 0x81ba <vTaskPrioritySet+0x92>
    81b6:	90 93 d4 01 	sts	0x01D4, r25
    81ba:	29 e0       	ldi	r18, 0x09	; 9
    81bc:	92 9f       	mul	r25, r18
    81be:	c0 01       	movw	r24, r0
    81c0:	11 24       	eor	r1, r1
    81c2:	b7 01       	movw	r22, r14
    81c4:	8f 5f       	subi	r24, 0xFF	; 255
    81c6:	9d 4f       	sbci	r25, 0xFD	; 253
    81c8:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    81cc:	11 30       	cpi	r17, 0x01	; 1
    81ce:	11 f4       	brne	.+4      	; 0x81d4 <vTaskPrioritySet+0xac>
				{
					portYIELD_WITHIN_API();
    81d0:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
				}
			}
		}
		portEXIT_CRITICAL();
    81d4:	0f 90       	pop	r0
    81d6:	0f be       	out	0x3f, r0	; 63
	}
    81d8:	df 91       	pop	r29
    81da:	cf 91       	pop	r28
    81dc:	1f 91       	pop	r17
    81de:	ff 90       	pop	r15
    81e0:	ef 90       	pop	r14
    81e2:	08 95       	ret

000081e4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    81e4:	ef 92       	push	r14
    81e6:	ff 92       	push	r15
    81e8:	0f 93       	push	r16
    81ea:	1f 93       	push	r17
    81ec:	cf 93       	push	r28
    81ee:	df 93       	push	r29
    81f0:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    81f2:	0f b6       	in	r0, 0x3f	; 63
    81f4:	f8 94       	cli
    81f6:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    81f8:	80 91 93 01 	lds	r24, 0x0193
    81fc:	90 91 94 01 	lds	r25, 0x0194
    8200:	c8 17       	cp	r28, r24
    8202:	d9 07       	cpc	r29, r25
    8204:	11 f0       	breq	.+4      	; 0x820a <vTaskSuspend+0x26>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    8206:	20 97       	sbiw	r28, 0x00	; 0
    8208:	39 f4       	brne	.+14     	; 0x8218 <vTaskSuspend+0x34>
    820a:	00 91 93 01 	lds	r16, 0x0193
    820e:	10 91 94 01 	lds	r17, 0x0194
    8212:	c0 e0       	ldi	r28, 0x00	; 0
    8214:	d0 e0       	ldi	r29, 0x00	; 0
    8216:	01 c0       	rjmp	.+2      	; 0x821a <vTaskSuspend+0x36>
    8218:	8e 01       	movw	r16, r28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    821a:	78 01       	movw	r14, r16
    821c:	82 e0       	ldi	r24, 0x02	; 2
    821e:	e8 0e       	add	r14, r24
    8220:	f1 1c       	adc	r15, r1
    8222:	c7 01       	movw	r24, r14
    8224:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    8228:	f8 01       	movw	r30, r16
    822a:	84 89       	ldd	r24, Z+20	; 0x14
    822c:	95 89       	ldd	r25, Z+21	; 0x15
    822e:	89 2b       	or	r24, r25
    8230:	21 f0       	breq	.+8      	; 0x823a <vTaskSuspend+0x56>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    8232:	c8 01       	movw	r24, r16
    8234:	0c 96       	adiw	r24, 0x0c	; 12
    8236:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    823a:	b7 01       	movw	r22, r14
    823c:	89 ed       	ldi	r24, 0xD9	; 217
    823e:	91 e0       	ldi	r25, 0x01	; 1
    8240:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    8244:	0f 90       	pop	r0
    8246:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    8248:	cd 2b       	or	r28, r29
    824a:	11 f4       	brne	.+4      	; 0x8250 <vTaskSuspend+0x6c>
		{
			portYIELD_WITHIN_API();
    824c:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
		}
	}
    8250:	df 91       	pop	r29
    8252:	cf 91       	pop	r28
    8254:	1f 91       	pop	r17
    8256:	0f 91       	pop	r16
    8258:	ff 90       	pop	r15
    825a:	ef 90       	pop	r14
    825c:	08 95       	ret

0000825e <xTaskIsTaskSuspended>:
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    825e:	fc 01       	movw	r30, r24
    8260:	22 85       	ldd	r18, Z+10	; 0x0a
    8262:	33 85       	ldd	r19, Z+11	; 0x0b
    8264:	29 5d       	subi	r18, 0xD9	; 217
    8266:	31 40       	sbci	r19, 0x01	; 1
    8268:	51 f4       	brne	.+20     	; 0x827e <xTaskIsTaskSuspended+0x20>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    826a:	fc 01       	movw	r30, r24
    826c:	24 89       	ldd	r18, Z+20	; 0x14
    826e:	35 89       	ldd	r19, Z+21	; 0x15
    8270:	f1 e0       	ldi	r31, 0x01	; 1
    8272:	22 3e       	cpi	r18, 0xE2	; 226
    8274:	3f 07       	cpc	r19, r31
    8276:	19 f0       	breq	.+6      	; 0x827e <xTaskIsTaskSuspended+0x20>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    8278:	81 e0       	ldi	r24, 0x01	; 1
    827a:	23 2b       	or	r18, r19
    827c:	09 f0       	breq	.+2      	; 0x8280 <xTaskIsTaskSuspended+0x22>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    827e:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    8280:	08 95       	ret

00008282 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    8282:	0f 93       	push	r16
    8284:	1f 93       	push	r17
    8286:	cf 93       	push	r28
    8288:	df 93       	push	r29
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    828a:	00 97       	sbiw	r24, 0x00	; 0
    828c:	89 f1       	breq	.+98     	; 0x82f0 <vTaskResume+0x6e>
    828e:	20 91 93 01 	lds	r18, 0x0193
    8292:	30 91 94 01 	lds	r19, 0x0194
    8296:	82 17       	cp	r24, r18
    8298:	93 07       	cpc	r25, r19
    829a:	51 f1       	breq	.+84     	; 0x82f0 <vTaskResume+0x6e>
    829c:	ec 01       	movw	r28, r24
		{
			portENTER_CRITICAL();
    829e:	0f b6       	in	r0, 0x3f	; 63
    82a0:	f8 94       	cli
    82a2:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    82a4:	0e 94 2f 41 	call	0x825e	; 0x825e <xTaskIsTaskSuspended>
    82a8:	81 30       	cpi	r24, 0x01	; 1
    82aa:	01 f5       	brne	.+64     	; 0x82ec <vTaskResume+0x6a>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    82ac:	8e 01       	movw	r16, r28
    82ae:	0e 5f       	subi	r16, 0xFE	; 254
    82b0:	1f 4f       	sbci	r17, 0xFF	; 255
    82b2:	c8 01       	movw	r24, r16
    82b4:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    82b8:	9e 89       	ldd	r25, Y+22	; 0x16
    82ba:	80 91 d4 01 	lds	r24, 0x01D4
    82be:	89 17       	cp	r24, r25
    82c0:	10 f4       	brcc	.+4      	; 0x82c6 <vTaskResume+0x44>
    82c2:	90 93 d4 01 	sts	0x01D4, r25
    82c6:	29 e0       	ldi	r18, 0x09	; 9
    82c8:	92 9f       	mul	r25, r18
    82ca:	c0 01       	movw	r24, r0
    82cc:	11 24       	eor	r1, r1
    82ce:	b8 01       	movw	r22, r16
    82d0:	8f 5f       	subi	r24, 0xFF	; 255
    82d2:	9d 4f       	sbci	r25, 0xFD	; 253
    82d4:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    82d8:	e0 91 93 01 	lds	r30, 0x0193
    82dc:	f0 91 94 01 	lds	r31, 0x0194
    82e0:	9e 89       	ldd	r25, Y+22	; 0x16
    82e2:	86 89       	ldd	r24, Z+22	; 0x16
    82e4:	98 17       	cp	r25, r24
    82e6:	10 f0       	brcs	.+4      	; 0x82ec <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    82e8:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    82ec:	0f 90       	pop	r0
    82ee:	0f be       	out	0x3f, r0	; 63
		}
	}
    82f0:	df 91       	pop	r29
    82f2:	cf 91       	pop	r28
    82f4:	1f 91       	pop	r17
    82f6:	0f 91       	pop	r16
    82f8:	08 95       	ret

000082fa <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    82fa:	ef 92       	push	r14
    82fc:	ff 92       	push	r15
    82fe:	1f 93       	push	r17
    8300:	cf 93       	push	r28
    8302:	df 93       	push	r29
    8304:	ec 01       	movw	r28, r24
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    8306:	0e 94 2f 41 	call	0x825e	; 0x825e <xTaskIsTaskSuspended>
    830a:	81 30       	cpi	r24, 0x01	; 1
    830c:	69 f5       	brne	.+90     	; 0x8368 <xTaskResumeFromISR+0x6e>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    830e:	80 91 d2 01 	lds	r24, 0x01D2
    8312:	81 11       	cpse	r24, r1
    8314:	22 c0       	rjmp	.+68     	; 0x835a <xTaskResumeFromISR+0x60>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    8316:	e0 91 93 01 	lds	r30, 0x0193
    831a:	f0 91 94 01 	lds	r31, 0x0194
    831e:	11 e0       	ldi	r17, 0x01	; 1
    8320:	9e 89       	ldd	r25, Y+22	; 0x16
    8322:	86 89       	ldd	r24, Z+22	; 0x16
    8324:	98 17       	cp	r25, r24
    8326:	08 f4       	brcc	.+2      	; 0x832a <xTaskResumeFromISR+0x30>
    8328:	10 e0       	ldi	r17, 0x00	; 0
				vListRemove(  &( pxTCB->xGenericListItem ) );
    832a:	7e 01       	movw	r14, r28
    832c:	32 e0       	ldi	r19, 0x02	; 2
    832e:	e3 0e       	add	r14, r19
    8330:	f1 1c       	adc	r15, r1
    8332:	c7 01       	movw	r24, r14
    8334:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    8338:	2e 89       	ldd	r18, Y+22	; 0x16
    833a:	80 91 d4 01 	lds	r24, 0x01D4
    833e:	82 17       	cp	r24, r18
    8340:	10 f4       	brcc	.+4      	; 0x8346 <xTaskResumeFromISR+0x4c>
    8342:	20 93 d4 01 	sts	0x01D4, r18
    8346:	39 e0       	ldi	r19, 0x09	; 9
    8348:	23 9f       	mul	r18, r19
    834a:	c0 01       	movw	r24, r0
    834c:	11 24       	eor	r1, r1
    834e:	b7 01       	movw	r22, r14
    8350:	8f 5f       	subi	r24, 0xFF	; 255
    8352:	9d 4f       	sbci	r25, 0xFD	; 253
    8354:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
    8358:	08 c0       	rjmp	.+16     	; 0x836a <xTaskResumeFromISR+0x70>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    835a:	be 01       	movw	r22, r28
    835c:	64 5f       	subi	r22, 0xF4	; 244
    835e:	7f 4f       	sbci	r23, 0xFF	; 255
    8360:	82 ee       	ldi	r24, 0xE2	; 226
    8362:	91 e0       	ldi	r25, 0x01	; 1
    8364:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    8368:	10 e0       	ldi	r17, 0x00	; 0
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
    836a:	81 2f       	mov	r24, r17
    836c:	df 91       	pop	r29
    836e:	cf 91       	pop	r28
    8370:	1f 91       	pop	r17
    8372:	ff 90       	pop	r15
    8374:	ef 90       	pop	r14
    8376:	08 95       	ret

00008378 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    8378:	af 92       	push	r10
    837a:	bf 92       	push	r11
    837c:	cf 92       	push	r12
    837e:	df 92       	push	r13
    8380:	ef 92       	push	r14
    8382:	ff 92       	push	r15
    8384:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    8386:	a1 2c       	mov	r10, r1
    8388:	b1 2c       	mov	r11, r1
    838a:	c1 2c       	mov	r12, r1
    838c:	d1 2c       	mov	r13, r1
    838e:	e1 2c       	mov	r14, r1
    8390:	f1 2c       	mov	r15, r1
    8392:	00 e0       	ldi	r16, 0x00	; 0
    8394:	20 e0       	ldi	r18, 0x00	; 0
    8396:	30 e0       	ldi	r19, 0x00	; 0
    8398:	44 e6       	ldi	r20, 0x64	; 100
    839a:	50 e0       	ldi	r21, 0x00	; 0
    839c:	63 e8       	ldi	r22, 0x83	; 131
    839e:	71 e0       	ldi	r23, 0x01	; 1
    83a0:	8a ee       	ldi	r24, 0xEA	; 234
    83a2:	9e e3       	ldi	r25, 0x3E	; 62
    83a4:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    83a8:	81 30       	cpi	r24, 0x01	; 1
    83aa:	81 f4       	brne	.+32     	; 0x83cc <vTaskStartScheduler+0x54>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    83ac:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    83ae:	80 93 d3 01 	sts	0x01D3, r24
		xTickCount = ( portTickType ) 0;
    83b2:	10 92 d7 01 	sts	0x01D7, r1
    83b6:	10 92 d6 01 	sts	0x01D6, r1
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    83ba:	0f 91       	pop	r16
    83bc:	ff 90       	pop	r15
    83be:	ef 90       	pop	r14
    83c0:	df 90       	pop	r13
    83c2:	cf 90       	pop	r12
    83c4:	bf 90       	pop	r11
    83c6:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    83c8:	0c 94 4a 4b 	jmp	0x9694	; 0x9694 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    83cc:	0f 91       	pop	r16
    83ce:	ff 90       	pop	r15
    83d0:	ef 90       	pop	r14
    83d2:	df 90       	pop	r13
    83d4:	cf 90       	pop	r12
    83d6:	bf 90       	pop	r11
    83d8:	af 90       	pop	r10
    83da:	08 95       	ret

000083dc <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    83dc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    83de:	10 92 d3 01 	sts	0x01D3, r1
	vPortEndScheduler();
    83e2:	0c 94 80 4b 	jmp	0x9700	; 0x9700 <vPortEndScheduler>

000083e6 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    83e6:	80 91 d2 01 	lds	r24, 0x01D2
    83ea:	8f 5f       	subi	r24, 0xFF	; 255
    83ec:	80 93 d2 01 	sts	0x01D2, r24
    83f0:	08 95       	ret

000083f2 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    83f2:	0f b6       	in	r0, 0x3f	; 63
    83f4:	f8 94       	cli
    83f6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    83f8:	80 91 d6 01 	lds	r24, 0x01D6
    83fc:	90 91 d7 01 	lds	r25, 0x01D7
	}
	portEXIT_CRITICAL();
    8400:	0f 90       	pop	r0
    8402:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    8404:	08 95       	ret

00008406 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    8406:	80 91 d8 01 	lds	r24, 0x01D8
}
    840a:	08 95       	ret

0000840c <vTaskStartTrace>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
	{
		portENTER_CRITICAL();
    840c:	0f b6       	in	r0, 0x3f	; 63
    840e:	f8 94       	cli
    8410:	0f 92       	push	r0
		{
			pcTraceBuffer = ( signed char * )pcBuffer;
    8412:	90 93 cd 01 	sts	0x01CD, r25
    8416:	80 93 cc 01 	sts	0x01CC, r24
			pcTraceBufferStart = pcBuffer;
    841a:	90 93 cb 01 	sts	0x01CB, r25
    841e:	80 93 ca 01 	sts	0x01CA, r24
			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
    8422:	48 50       	subi	r20, 0x08	; 8
    8424:	51 09       	sbc	r21, r1
    8426:	48 0f       	add	r20, r24
    8428:	59 1f       	adc	r21, r25
    842a:	50 93 c9 01 	sts	0x01C9, r21
    842e:	40 93 c8 01 	sts	0x01C8, r20
			xTracing = pdTRUE;
    8432:	81 e0       	ldi	r24, 0x01	; 1
    8434:	80 93 c7 01 	sts	0x01C7, r24
		}
		portEXIT_CRITICAL();
    8438:	0f 90       	pop	r0
    843a:	0f be       	out	0x3f, r0	; 63
    843c:	08 95       	ret

0000843e <ulTaskEndTrace>:

	unsigned long ulTaskEndTrace( void )
	{
	unsigned long ulBufferLength;

		portENTER_CRITICAL();
    843e:	0f b6       	in	r0, 0x3f	; 63
    8440:	f8 94       	cli
    8442:	0f 92       	push	r0
			xTracing = pdFALSE;
    8444:	10 92 c7 01 	sts	0x01C7, r1
		portEXIT_CRITICAL();
    8448:	0f 90       	pop	r0
    844a:	0f be       	out	0x3f, r0	; 63

		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
    844c:	60 91 cc 01 	lds	r22, 0x01CC
    8450:	70 91 cd 01 	lds	r23, 0x01CD
    8454:	80 91 ca 01 	lds	r24, 0x01CA
    8458:	90 91 cb 01 	lds	r25, 0x01CB
    845c:	68 1b       	sub	r22, r24
    845e:	79 0b       	sbc	r23, r25
    8460:	07 2e       	mov	r0, r23
    8462:	00 0c       	add	r0, r0
    8464:	88 0b       	sbc	r24, r24
    8466:	99 0b       	sbc	r25, r25

		return ulBufferLength;
	}
    8468:	08 95       	ret

0000846a <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    846a:	ff 92       	push	r15
    846c:	0f 93       	push	r16
    846e:	1f 93       	push	r17
    8470:	cf 93       	push	r28
    8472:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    8474:	80 91 d2 01 	lds	r24, 0x01D2
    8478:	81 11       	cpse	r24, r1
    847a:	5f c0       	rjmp	.+190    	; 0x853a <vTaskIncrementTick+0xd0>
	{
		++xTickCount;
    847c:	80 91 d6 01 	lds	r24, 0x01D6
    8480:	90 91 d7 01 	lds	r25, 0x01D7
    8484:	01 96       	adiw	r24, 0x01	; 1
    8486:	90 93 d7 01 	sts	0x01D7, r25
    848a:	80 93 d6 01 	sts	0x01D6, r24
		if( xTickCount == ( portTickType ) 0 )
    848e:	80 91 d6 01 	lds	r24, 0x01D6
    8492:	90 91 d7 01 	lds	r25, 0x01D7
    8496:	89 2b       	or	r24, r25
    8498:	a9 f4       	brne	.+42     	; 0x84c4 <vTaskIncrementTick+0x5a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    849a:	80 91 ed 01 	lds	r24, 0x01ED
    849e:	90 91 ee 01 	lds	r25, 0x01EE
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    84a2:	20 91 eb 01 	lds	r18, 0x01EB
    84a6:	30 91 ec 01 	lds	r19, 0x01EC
    84aa:	30 93 ee 01 	sts	0x01EE, r19
    84ae:	20 93 ed 01 	sts	0x01ED, r18
			pxOverflowDelayedTaskList = pxTemp;
    84b2:	90 93 ec 01 	sts	0x01EC, r25
    84b6:	80 93 eb 01 	sts	0x01EB, r24
			xNumOfOverflows++;
    84ba:	80 91 cf 01 	lds	r24, 0x01CF
    84be:	8f 5f       	subi	r24, 0xFF	; 255
    84c0:	80 93 cf 01 	sts	0x01CF, r24
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    84c4:	89 e0       	ldi	r24, 0x09	; 9
    84c6:	f8 2e       	mov	r15, r24
    84c8:	e0 91 ed 01 	lds	r30, 0x01ED
    84cc:	f0 91 ee 01 	lds	r31, 0x01EE
    84d0:	80 81       	ld	r24, Z
    84d2:	88 23       	and	r24, r24
    84d4:	c9 f1       	breq	.+114    	; 0x8548 <vTaskIncrementTick+0xde>
    84d6:	e0 91 ed 01 	lds	r30, 0x01ED
    84da:	f0 91 ee 01 	lds	r31, 0x01EE
    84de:	05 80       	ldd	r0, Z+5	; 0x05
    84e0:	f6 81       	ldd	r31, Z+6	; 0x06
    84e2:	e0 2d       	mov	r30, r0
    84e4:	c6 81       	ldd	r28, Z+6	; 0x06
    84e6:	d7 81       	ldd	r29, Z+7	; 0x07
    84e8:	20 97       	sbiw	r28, 0x00	; 0
    84ea:	71 f1       	breq	.+92     	; 0x8548 <vTaskIncrementTick+0xde>
    84ec:	20 91 d6 01 	lds	r18, 0x01D6
    84f0:	30 91 d7 01 	lds	r19, 0x01D7
    84f4:	8a 81       	ldd	r24, Y+2	; 0x02
    84f6:	9b 81       	ldd	r25, Y+3	; 0x03
    84f8:	28 17       	cp	r18, r24
    84fa:	39 07       	cpc	r19, r25
    84fc:	28 f1       	brcs	.+74     	; 0x8548 <vTaskIncrementTick+0xde>
    84fe:	8e 01       	movw	r16, r28
    8500:	0e 5f       	subi	r16, 0xFE	; 254
    8502:	1f 4f       	sbci	r17, 0xFF	; 255
    8504:	c8 01       	movw	r24, r16
    8506:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
    850a:	8c 89       	ldd	r24, Y+20	; 0x14
    850c:	9d 89       	ldd	r25, Y+21	; 0x15
    850e:	89 2b       	or	r24, r25
    8510:	21 f0       	breq	.+8      	; 0x851a <vTaskIncrementTick+0xb0>
    8512:	ce 01       	movw	r24, r28
    8514:	0c 96       	adiw	r24, 0x0c	; 12
    8516:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
    851a:	9e 89       	ldd	r25, Y+22	; 0x16
    851c:	80 91 d4 01 	lds	r24, 0x01D4
    8520:	89 17       	cp	r24, r25
    8522:	10 f4       	brcc	.+4      	; 0x8528 <vTaskIncrementTick+0xbe>
    8524:	90 93 d4 01 	sts	0x01D4, r25
    8528:	f9 9e       	mul	r15, r25
    852a:	c0 01       	movw	r24, r0
    852c:	11 24       	eor	r1, r1
    852e:	b8 01       	movw	r22, r16
    8530:	8f 5f       	subi	r24, 0xFF	; 255
    8532:	9d 4f       	sbci	r25, 0xFD	; 253
    8534:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
    8538:	c7 cf       	rjmp	.-114    	; 0x84c8 <vTaskIncrementTick+0x5e>
	}
	else
	{
		++uxMissedTicks;
    853a:	80 91 d1 01 	lds	r24, 0x01D1
    853e:	8f 5f       	subi	r24, 0xFF	; 255
    8540:	80 93 d1 01 	sts	0x01D1, r24
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
    8544:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <vApplicationTickHook>
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
    8548:	80 91 d1 01 	lds	r24, 0x01D1
    854c:	81 11       	cpse	r24, r1
    854e:	07 c0       	rjmp	.+14     	; 0x855e <vTaskIncrementTick+0xf4>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    8550:	df 91       	pop	r29
    8552:	cf 91       	pop	r28
    8554:	1f 91       	pop	r17
    8556:	0f 91       	pop	r16
    8558:	ff 90       	pop	r15

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
		{
			vApplicationTickHook();
    855a:	0c 94 5b 0b 	jmp	0x16b6	; 0x16b6 <vApplicationTickHook>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    855e:	df 91       	pop	r29
    8560:	cf 91       	pop	r28
    8562:	1f 91       	pop	r17
    8564:	0f 91       	pop	r16
    8566:	ff 90       	pop	r15
    8568:	08 95       	ret

0000856a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    856a:	ef 92       	push	r14
    856c:	ff 92       	push	r15
    856e:	0f 93       	push	r16
    8570:	1f 93       	push	r17
    8572:	cf 93       	push	r28
    8574:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    8576:	0f b6       	in	r0, 0x3f	; 63
    8578:	f8 94       	cli
    857a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    857c:	80 91 d2 01 	lds	r24, 0x01D2
    8580:	81 50       	subi	r24, 0x01	; 1
    8582:	80 93 d2 01 	sts	0x01D2, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    8586:	80 91 d2 01 	lds	r24, 0x01D2
    858a:	88 23       	and	r24, r24
    858c:	11 f0       	breq	.+4      	; 0x8592 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    858e:	80 e0       	ldi	r24, 0x00	; 0
    8590:	54 c0       	rjmp	.+168    	; 0x863a <xTaskResumeAll+0xd0>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    8592:	80 91 d8 01 	lds	r24, 0x01D8
    8596:	88 23       	and	r24, r24
    8598:	d1 f3       	breq	.-12     	; 0x858e <xTaskResumeAll+0x24>
    859a:	10 e0       	ldi	r17, 0x00	; 0
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    859c:	09 e0       	ldi	r16, 0x09	; 9
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    859e:	80 91 e2 01 	lds	r24, 0x01E2
    85a2:	81 11       	cpse	r24, r1
    85a4:	05 c0       	rjmp	.+10     	; 0x85b0 <xTaskResumeAll+0x46>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    85a6:	80 91 d1 01 	lds	r24, 0x01D1
    85aa:	81 11       	cpse	r24, r1
    85ac:	30 c0       	rjmp	.+96     	; 0x860e <xTaskResumeAll+0xa4>
    85ae:	2c c0       	rjmp	.+88     	; 0x8608 <xTaskResumeAll+0x9e>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    85b0:	e0 91 e7 01 	lds	r30, 0x01E7
    85b4:	f0 91 e8 01 	lds	r31, 0x01E8
    85b8:	c6 81       	ldd	r28, Z+6	; 0x06
    85ba:	d7 81       	ldd	r29, Z+7	; 0x07
    85bc:	20 97       	sbiw	r28, 0x00	; 0
    85be:	99 f3       	breq	.-26     	; 0x85a6 <xTaskResumeAll+0x3c>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    85c0:	ce 01       	movw	r24, r28
    85c2:	0c 96       	adiw	r24, 0x0c	; 12
    85c4:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    85c8:	7e 01       	movw	r14, r28
    85ca:	82 e0       	ldi	r24, 0x02	; 2
    85cc:	e8 0e       	add	r14, r24
    85ce:	f1 1c       	adc	r15, r1
    85d0:	c7 01       	movw	r24, r14
    85d2:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    85d6:	9e 89       	ldd	r25, Y+22	; 0x16
    85d8:	80 91 d4 01 	lds	r24, 0x01D4
    85dc:	89 17       	cp	r24, r25
    85de:	10 f4       	brcc	.+4      	; 0x85e4 <xTaskResumeAll+0x7a>
    85e0:	90 93 d4 01 	sts	0x01D4, r25
    85e4:	09 9f       	mul	r16, r25
    85e6:	c0 01       	movw	r24, r0
    85e8:	11 24       	eor	r1, r1
    85ea:	b7 01       	movw	r22, r14
    85ec:	8f 5f       	subi	r24, 0xFF	; 255
    85ee:	9d 4f       	sbci	r25, 0xFD	; 253
    85f0:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    85f4:	e0 91 93 01 	lds	r30, 0x0193
    85f8:	f0 91 94 01 	lds	r31, 0x0194
    85fc:	9e 89       	ldd	r25, Y+22	; 0x16
    85fe:	86 89       	ldd	r24, Z+22	; 0x16
    8600:	98 17       	cp	r25, r24
    8602:	68 f2       	brcs	.-102    	; 0x859e <xTaskResumeAll+0x34>
					{
						xYieldRequired = pdTRUE;
    8604:	11 e0       	ldi	r17, 0x01	; 1
    8606:	cb cf       	rjmp	.-106    	; 0x859e <xTaskResumeAll+0x34>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    8608:	11 30       	cpi	r17, 0x01	; 1
    860a:	69 f4       	brne	.+26     	; 0x8626 <xTaskResumeAll+0xbc>
    860c:	11 c0       	rjmp	.+34     	; 0x8630 <xTaskResumeAll+0xc6>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    860e:	80 91 d1 01 	lds	r24, 0x01D1
    8612:	88 23       	and	r24, r24
    8614:	c9 f3       	breq	.-14     	; 0x8608 <xTaskResumeAll+0x9e>
					{
						vTaskIncrementTick();
    8616:	0e 94 35 42 	call	0x846a	; 0x846a <vTaskIncrementTick>
						--uxMissedTicks;
    861a:	80 91 d1 01 	lds	r24, 0x01D1
    861e:	81 50       	subi	r24, 0x01	; 1
    8620:	80 93 d1 01 	sts	0x01D1, r24
    8624:	f4 cf       	rjmp	.-24     	; 0x860e <xTaskResumeAll+0xa4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    8626:	80 91 d0 01 	lds	r24, 0x01D0
    862a:	81 30       	cpi	r24, 0x01	; 1
    862c:	09 f0       	breq	.+2      	; 0x8630 <xTaskResumeAll+0xc6>
    862e:	af cf       	rjmp	.-162    	; 0x858e <xTaskResumeAll+0x24>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    8630:	10 92 d0 01 	sts	0x01D0, r1
					portYIELD_WITHIN_API();
    8634:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    8638:	81 e0       	ldi	r24, 0x01	; 1
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
    863a:	0f 90       	pop	r0
    863c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    863e:	df 91       	pop	r29
    8640:	cf 91       	pop	r28
    8642:	1f 91       	pop	r17
    8644:	0f 91       	pop	r16
    8646:	ff 90       	pop	r15
    8648:	ef 90       	pop	r14
    864a:	08 95       	ret

0000864c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    864c:	0f 93       	push	r16
    864e:	1f 93       	push	r17
    8650:	cf 93       	push	r28
    8652:	df 93       	push	r29
    8654:	8c 01       	movw	r16, r24
    8656:	eb 01       	movw	r28, r22
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
    8658:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    865c:	f8 01       	movw	r30, r16
    865e:	20 81       	ld	r18, Z
    8660:	31 81       	ldd	r19, Z+1	; 0x01
    8662:	c2 0f       	add	r28, r18
    8664:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    8666:	80 91 d6 01 	lds	r24, 0x01D6
    866a:	90 91 d7 01 	lds	r25, 0x01D7
    866e:	82 17       	cp	r24, r18
    8670:	93 07       	cpc	r25, r19
    8672:	20 f4       	brcc	.+8      	; 0x867c <vTaskDelayUntil+0x30>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    8674:	c2 17       	cp	r28, r18
    8676:	d3 07       	cpc	r29, r19
    8678:	60 f4       	brcc	.+24     	; 0x8692 <vTaskDelayUntil+0x46>
    867a:	03 c0       	rjmp	.+6      	; 0x8682 <vTaskDelayUntil+0x36>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    867c:	c2 17       	cp	r28, r18
    867e:	d3 07       	cpc	r29, r19
    8680:	50 f0       	brcs	.+20     	; 0x8696 <vTaskDelayUntil+0x4a>
    8682:	20 91 d6 01 	lds	r18, 0x01D6
    8686:	30 91 d7 01 	lds	r19, 0x01D7
    868a:	91 e0       	ldi	r25, 0x01	; 1
    868c:	2c 17       	cp	r18, r28
    868e:	3d 07       	cpc	r19, r29
    8690:	18 f0       	brcs	.+6      	; 0x8698 <vTaskDelayUntil+0x4c>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    8692:	90 e0       	ldi	r25, 0x00	; 0
    8694:	01 c0       	rjmp	.+2      	; 0x8698 <vTaskDelayUntil+0x4c>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
    8696:	91 e0       	ldi	r25, 0x01	; 1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    8698:	f8 01       	movw	r30, r16
    869a:	d1 83       	std	Z+1, r29	; 0x01
    869c:	c0 83       	st	Z, r28

			if( xShouldDelay )
    869e:	99 23       	and	r25, r25
    86a0:	29 f1       	breq	.+74     	; 0x86ec <vTaskDelayUntil+0xa0>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    86a2:	80 91 93 01 	lds	r24, 0x0193
    86a6:	90 91 94 01 	lds	r25, 0x0194
    86aa:	02 96       	adiw	r24, 0x02	; 2
    86ac:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    86b0:	e0 91 93 01 	lds	r30, 0x0193
    86b4:	f0 91 94 01 	lds	r31, 0x0194
    86b8:	d3 83       	std	Z+3, r29	; 0x03
    86ba:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    86bc:	80 91 d6 01 	lds	r24, 0x01D6
    86c0:	90 91 d7 01 	lds	r25, 0x01D7
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    86c4:	60 91 93 01 	lds	r22, 0x0193
    86c8:	70 91 94 01 	lds	r23, 0x0194
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

				if( xTimeToWake < xTickCount )
    86cc:	c8 17       	cp	r28, r24
    86ce:	d9 07       	cpc	r29, r25
    86d0:	28 f4       	brcc	.+10     	; 0x86dc <vTaskDelayUntil+0x90>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    86d2:	80 91 eb 01 	lds	r24, 0x01EB
    86d6:	90 91 ec 01 	lds	r25, 0x01EC
    86da:	04 c0       	rjmp	.+8      	; 0x86e4 <vTaskDelayUntil+0x98>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    86dc:	80 91 ed 01 	lds	r24, 0x01ED
    86e0:	90 91 ee 01 	lds	r25, 0x01EE
    86e4:	6e 5f       	subi	r22, 0xFE	; 254
    86e6:	7f 4f       	sbci	r23, 0xFF	; 255
    86e8:	0e 94 84 48 	call	0x9108	; 0x9108 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    86ec:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    86f0:	81 11       	cpse	r24, r1
    86f2:	02 c0       	rjmp	.+4      	; 0x86f8 <vTaskDelayUntil+0xac>
		{
			portYIELD_WITHIN_API();
    86f4:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
		}
	}
    86f8:	df 91       	pop	r29
    86fa:	cf 91       	pop	r28
    86fc:	1f 91       	pop	r17
    86fe:	0f 91       	pop	r16
    8700:	08 95       	ret

00008702 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    8702:	cf 93       	push	r28
    8704:	df 93       	push	r29
    8706:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    8708:	89 2b       	or	r24, r25
    870a:	19 f4       	brne	.+6      	; 0x8712 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
		{
			portYIELD_WITHIN_API();
    870c:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
    8710:	31 c0       	rjmp	.+98     	; 0x8774 <vTaskDelay+0x72>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
    8712:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    8716:	20 91 d6 01 	lds	r18, 0x01D6
    871a:	30 91 d7 01 	lds	r19, 0x01D7
    871e:	c2 0f       	add	r28, r18
    8720:	d3 1f       	adc	r29, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    8722:	80 91 93 01 	lds	r24, 0x0193
    8726:	90 91 94 01 	lds	r25, 0x0194
    872a:	02 96       	adiw	r24, 0x02	; 2
    872c:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    8730:	e0 91 93 01 	lds	r30, 0x0193
    8734:	f0 91 94 01 	lds	r31, 0x0194
    8738:	d3 83       	std	Z+3, r29	; 0x03
    873a:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    873c:	80 91 d6 01 	lds	r24, 0x01D6
    8740:	90 91 d7 01 	lds	r25, 0x01D7
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    8744:	60 91 93 01 	lds	r22, 0x0193
    8748:	70 91 94 01 	lds	r23, 0x0194
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

				if( xTimeToWake < xTickCount )
    874c:	c8 17       	cp	r28, r24
    874e:	d9 07       	cpc	r29, r25
    8750:	28 f4       	brcc	.+10     	; 0x875c <vTaskDelay+0x5a>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    8752:	80 91 eb 01 	lds	r24, 0x01EB
    8756:	90 91 ec 01 	lds	r25, 0x01EC
    875a:	04 c0       	rjmp	.+8      	; 0x8764 <vTaskDelay+0x62>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    875c:	80 91 ed 01 	lds	r24, 0x01ED
    8760:	90 91 ee 01 	lds	r25, 0x01EE
    8764:	6e 5f       	subi	r22, 0xFE	; 254
    8766:	7f 4f       	sbci	r23, 0xFF	; 255
    8768:	0e 94 84 48 	call	0x9108	; 0x9108 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    876c:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    8770:	88 23       	and	r24, r24
    8772:	61 f2       	breq	.-104    	; 0x870c <vTaskDelay+0xa>
		{
			portYIELD_WITHIN_API();
		}
	}
    8774:	df 91       	pop	r29
    8776:	cf 91       	pop	r28
    8778:	08 95       	ret

0000877a <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
    877a:	0f 93       	push	r16
    877c:	1f 93       	push	r17
    877e:	cf 93       	push	r28
    8780:	df 93       	push	r29
    8782:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
    8784:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <vTaskSuspendAll>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
    8788:	18 82       	st	Y, r1
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
    878a:	6a e2       	ldi	r22, 0x2A	; 42
    878c:	71 e0       	ldi	r23, 0x01	; 1
    878e:	ce 01       	movw	r24, r28
    8790:	0e 94 86 4f 	call	0x9f0c	; 0x9f0c <strcat>

			uxQueue = uxTopUsedPriority + 1;
    8794:	10 91 d5 01 	lds	r17, 0x01D5
    8798:	1f 5f       	subi	r17, 0xFF	; 255

			do
			{
				uxQueue--;

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    879a:	09 e0       	ldi	r16, 0x09	; 9

			uxQueue = uxTopUsedPriority + 1;

			do
			{
				uxQueue--;
    879c:	11 50       	subi	r17, 0x01	; 1

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
    879e:	01 9f       	mul	r16, r17
    87a0:	b0 01       	movw	r22, r0
    87a2:	11 24       	eor	r1, r1
    87a4:	6f 5f       	subi	r22, 0xFF	; 255
    87a6:	7d 4f       	sbci	r23, 0xFD	; 253
    87a8:	fb 01       	movw	r30, r22
    87aa:	80 81       	ld	r24, Z
    87ac:	88 23       	and	r24, r24
    87ae:	21 f0       	breq	.+8      	; 0x87b8 <vTaskList+0x3e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
    87b0:	42 e5       	ldi	r20, 0x52	; 82
    87b2:	ce 01       	movw	r24, r28
    87b4:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
    87b8:	11 11       	cpse	r17, r1
    87ba:	f0 cf       	rjmp	.-32     	; 0x879c <vTaskList+0x22>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
    87bc:	e0 91 ed 01 	lds	r30, 0x01ED
    87c0:	f0 91 ee 01 	lds	r31, 0x01EE
    87c4:	80 81       	ld	r24, Z
    87c6:	88 23       	and	r24, r24
    87c8:	41 f0       	breq	.+16     	; 0x87da <vTaskList+0x60>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
    87ca:	60 91 ed 01 	lds	r22, 0x01ED
    87ce:	70 91 ee 01 	lds	r23, 0x01EE
    87d2:	42 e4       	ldi	r20, 0x42	; 66
    87d4:	ce 01       	movw	r24, r28
    87d6:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <prvListTaskWithinSingleList>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
    87da:	e0 91 eb 01 	lds	r30, 0x01EB
    87de:	f0 91 ec 01 	lds	r31, 0x01EC
    87e2:	80 81       	ld	r24, Z
    87e4:	88 23       	and	r24, r24
    87e6:	41 f0       	breq	.+16     	; 0x87f8 <vTaskList+0x7e>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
    87e8:	60 91 eb 01 	lds	r22, 0x01EB
    87ec:	70 91 ec 01 	lds	r23, 0x01EC
    87f0:	42 e4       	ldi	r20, 0x42	; 66
    87f2:	ce 01       	movw	r24, r28
    87f4:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
    87f8:	80 91 d9 01 	lds	r24, 0x01D9
    87fc:	88 23       	and	r24, r24
    87fe:	31 f0       	breq	.+12     	; 0x880c <vTaskList+0x92>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
    8800:	43 e5       	ldi	r20, 0x53	; 83
    8802:	69 ed       	ldi	r22, 0xD9	; 217
    8804:	71 e0       	ldi	r23, 0x01	; 1
    8806:	ce 01       	movw	r24, r28
    8808:	0e 94 ed 3e 	call	0x7dda	; 0x7dda <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
	}
    880c:	df 91       	pop	r29
    880e:	cf 91       	pop	r28
    8810:	1f 91       	pop	r17
    8812:	0f 91       	pop	r16
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
				}
			}
			#endif
		}
		xTaskResumeAll();
    8814:	0c 94 b5 42 	jmp	0x856a	; 0x856a <xTaskResumeAll>

00008818 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    8818:	80 91 d2 01 	lds	r24, 0x01D2
    881c:	88 23       	and	r24, r24
    881e:	21 f0       	breq	.+8      	; 0x8828 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    8820:	81 e0       	ldi	r24, 0x01	; 1
    8822:	80 93 d0 01 	sts	0x01D0, r24
		return;
    8826:	08 95       	ret

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    8828:	99 e0       	ldi	r25, 0x09	; 9
    882a:	e0 91 d4 01 	lds	r30, 0x01D4
    882e:	9e 9f       	mul	r25, r30
    8830:	f0 01       	movw	r30, r0
    8832:	11 24       	eor	r1, r1
    8834:	ef 5f       	subi	r30, 0xFF	; 255
    8836:	fd 4f       	sbci	r31, 0xFD	; 253
    8838:	80 81       	ld	r24, Z
    883a:	81 11       	cpse	r24, r1
    883c:	06 c0       	rjmp	.+12     	; 0x884a <vTaskSwitchContext+0x32>
	{
		--uxTopReadyPriority;
    883e:	80 91 d4 01 	lds	r24, 0x01D4
    8842:	81 50       	subi	r24, 0x01	; 1
    8844:	80 93 d4 01 	sts	0x01D4, r24
    8848:	f0 cf       	rjmp	.-32     	; 0x882a <vTaskSwitchContext+0x12>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    884a:	80 91 d4 01 	lds	r24, 0x01D4
    884e:	90 e0       	ldi	r25, 0x00	; 0
    8850:	49 e0       	ldi	r20, 0x09	; 9
    8852:	48 9f       	mul	r20, r24
    8854:	90 01       	movw	r18, r0
    8856:	49 9f       	mul	r20, r25
    8858:	30 0d       	add	r19, r0
    885a:	11 24       	eor	r1, r1
    885c:	f9 01       	movw	r30, r18
    885e:	ef 5f       	subi	r30, 0xFF	; 255
    8860:	fd 4f       	sbci	r31, 0xFD	; 253
    8862:	a1 81       	ldd	r26, Z+1	; 0x01
    8864:	b2 81       	ldd	r27, Z+2	; 0x02
    8866:	12 96       	adiw	r26, 0x02	; 2
    8868:	0d 90       	ld	r0, X+
    886a:	bc 91       	ld	r27, X
    886c:	a0 2d       	mov	r26, r0
    886e:	b2 83       	std	Z+2, r27	; 0x02
    8870:	a1 83       	std	Z+1, r26	; 0x01
    8872:	2c 5f       	subi	r18, 0xFC	; 252
    8874:	3d 4f       	sbci	r19, 0xFD	; 253
    8876:	a2 17       	cp	r26, r18
    8878:	b3 07       	cpc	r27, r19
    887a:	31 f4       	brne	.+12     	; 0x8888 <vTaskSwitchContext+0x70>
    887c:	12 96       	adiw	r26, 0x02	; 2
    887e:	2d 91       	ld	r18, X+
    8880:	3c 91       	ld	r19, X
    8882:	13 97       	sbiw	r26, 0x03	; 3
    8884:	32 83       	std	Z+2, r19	; 0x02
    8886:	21 83       	std	Z+1, r18	; 0x01
    8888:	29 e0       	ldi	r18, 0x09	; 9
    888a:	28 9f       	mul	r18, r24
    888c:	f0 01       	movw	r30, r0
    888e:	29 9f       	mul	r18, r25
    8890:	f0 0d       	add	r31, r0
    8892:	11 24       	eor	r1, r1
    8894:	ef 5f       	subi	r30, 0xFF	; 255
    8896:	fd 4f       	sbci	r31, 0xFD	; 253
    8898:	01 80       	ldd	r0, Z+1	; 0x01
    889a:	f2 81       	ldd	r31, Z+2	; 0x02
    889c:	e0 2d       	mov	r30, r0
    889e:	86 81       	ldd	r24, Z+6	; 0x06
    88a0:	97 81       	ldd	r25, Z+7	; 0x07
    88a2:	90 93 94 01 	sts	0x0194, r25
    88a6:	80 93 93 01 	sts	0x0193, r24

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
    88aa:	80 91 c7 01 	lds	r24, 0x01C7
    88ae:	88 23       	and	r24, r24
    88b0:	09 f4       	brne	.+2      	; 0x88b4 <vTaskSwitchContext+0x9c>
    88b2:	4c c0       	rjmp	.+152    	; 0x894c <vTaskSwitchContext+0x134>
    88b4:	e0 91 93 01 	lds	r30, 0x0193
    88b8:	f0 91 94 01 	lds	r31, 0x0194
    88bc:	90 91 04 01 	lds	r25, 0x0104
    88c0:	83 a1       	ldd	r24, Z+35	; 0x23
    88c2:	98 17       	cp	r25, r24
    88c4:	09 f4       	brne	.+2      	; 0x88c8 <vTaskSwitchContext+0xb0>
    88c6:	42 c0       	rjmp	.+132    	; 0x894c <vTaskSwitchContext+0x134>
    88c8:	80 91 cc 01 	lds	r24, 0x01CC
    88cc:	90 91 cd 01 	lds	r25, 0x01CD
    88d0:	08 96       	adiw	r24, 0x08	; 8
    88d2:	20 91 c8 01 	lds	r18, 0x01C8
    88d6:	30 91 c9 01 	lds	r19, 0x01C9
    88da:	82 17       	cp	r24, r18
    88dc:	93 07       	cpc	r25, r19
    88de:	a0 f5       	brcc	.+104    	; 0x8948 <vTaskSwitchContext+0x130>
    88e0:	e0 91 93 01 	lds	r30, 0x0193
    88e4:	f0 91 94 01 	lds	r31, 0x0194
    88e8:	83 a1       	ldd	r24, Z+35	; 0x23
    88ea:	80 93 04 01 	sts	0x0104, r24
    88ee:	e0 91 cc 01 	lds	r30, 0x01CC
    88f2:	f0 91 cd 01 	lds	r31, 0x01CD
    88f6:	40 91 d6 01 	lds	r20, 0x01D6
    88fa:	50 91 d7 01 	lds	r21, 0x01D7
    88fe:	60 e0       	ldi	r22, 0x00	; 0
    8900:	70 e0       	ldi	r23, 0x00	; 0
    8902:	40 83       	st	Z, r20
    8904:	51 83       	std	Z+1, r21	; 0x01
    8906:	62 83       	std	Z+2, r22	; 0x02
    8908:	73 83       	std	Z+3, r23	; 0x03
    890a:	20 91 cc 01 	lds	r18, 0x01CC
    890e:	30 91 cd 01 	lds	r19, 0x01CD
    8912:	2c 5f       	subi	r18, 0xFC	; 252
    8914:	3f 4f       	sbci	r19, 0xFF	; 255
    8916:	30 93 cd 01 	sts	0x01CD, r19
    891a:	20 93 cc 01 	sts	0x01CC, r18
    891e:	e0 91 cc 01 	lds	r30, 0x01CC
    8922:	f0 91 cd 01 	lds	r31, 0x01CD
    8926:	90 e0       	ldi	r25, 0x00	; 0
    8928:	a0 e0       	ldi	r26, 0x00	; 0
    892a:	b0 e0       	ldi	r27, 0x00	; 0
    892c:	80 83       	st	Z, r24
    892e:	91 83       	std	Z+1, r25	; 0x01
    8930:	a2 83       	std	Z+2, r26	; 0x02
    8932:	b3 83       	std	Z+3, r27	; 0x03
    8934:	80 91 cc 01 	lds	r24, 0x01CC
    8938:	90 91 cd 01 	lds	r25, 0x01CD
    893c:	04 96       	adiw	r24, 0x04	; 4
    893e:	90 93 cd 01 	sts	0x01CD, r25
    8942:	80 93 cc 01 	sts	0x01CC, r24
    8946:	08 95       	ret
    8948:	10 92 c7 01 	sts	0x01C7, r1
    894c:	08 95       	ret

0000894e <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    894e:	cf 93       	push	r28
    8950:	df 93       	push	r29
    8952:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    8954:	20 91 93 01 	lds	r18, 0x0193
    8958:	30 91 94 01 	lds	r19, 0x0194
    895c:	b9 01       	movw	r22, r18
    895e:	64 5f       	subi	r22, 0xF4	; 244
    8960:	7f 4f       	sbci	r23, 0xFF	; 255
    8962:	0e 94 84 48 	call	0x9108	; 0x9108 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    8966:	80 91 93 01 	lds	r24, 0x0193
    896a:	90 91 94 01 	lds	r25, 0x0194
    896e:	02 96       	adiw	r24, 0x02	; 2
    8970:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    8974:	cf 3f       	cpi	r28, 0xFF	; 255
    8976:	8f ef       	ldi	r24, 0xFF	; 255
    8978:	d8 07       	cpc	r29, r24
    897a:	61 f4       	brne	.+24     	; 0x8994 <vTaskPlaceOnEventList+0x46>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    897c:	60 91 93 01 	lds	r22, 0x0193
    8980:	70 91 94 01 	lds	r23, 0x0194
    8984:	6e 5f       	subi	r22, 0xFE	; 254
    8986:	7f 4f       	sbci	r23, 0xFF	; 255
    8988:	89 ed       	ldi	r24, 0xD9	; 217
    898a:	91 e0       	ldi	r25, 0x01	; 1
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    898c:	df 91       	pop	r29
    898e:	cf 91       	pop	r28
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    8990:	0c 94 61 48 	jmp	0x90c2	; 0x90c2 <vListInsertEnd>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    8994:	80 91 d6 01 	lds	r24, 0x01D6
    8998:	90 91 d7 01 	lds	r25, 0x01D7
    899c:	be 01       	movw	r22, r28
    899e:	68 0f       	add	r22, r24
    89a0:	79 1f       	adc	r23, r25

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    89a2:	e0 91 93 01 	lds	r30, 0x0193
    89a6:	f0 91 94 01 	lds	r31, 0x0194
    89aa:	73 83       	std	Z+3, r23	; 0x03
    89ac:	62 83       	std	Z+2, r22	; 0x02

			if( xTimeToWake < xTickCount )
    89ae:	80 91 d6 01 	lds	r24, 0x01D6
    89b2:	90 91 d7 01 	lds	r25, 0x01D7
    89b6:	68 17       	cp	r22, r24
    89b8:	79 07       	cpc	r23, r25
    89ba:	48 f4       	brcc	.+18     	; 0x89ce <vTaskPlaceOnEventList+0x80>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    89bc:	60 91 93 01 	lds	r22, 0x0193
    89c0:	70 91 94 01 	lds	r23, 0x0194
    89c4:	80 91 eb 01 	lds	r24, 0x01EB
    89c8:	90 91 ec 01 	lds	r25, 0x01EC
    89cc:	08 c0       	rjmp	.+16     	; 0x89de <vTaskPlaceOnEventList+0x90>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    89ce:	60 91 93 01 	lds	r22, 0x0193
    89d2:	70 91 94 01 	lds	r23, 0x0194
    89d6:	80 91 ed 01 	lds	r24, 0x01ED
    89da:	90 91 ee 01 	lds	r25, 0x01EE
    89de:	6e 5f       	subi	r22, 0xFE	; 254
    89e0:	7f 4f       	sbci	r23, 0xFF	; 255
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    89e2:	df 91       	pop	r29
    89e4:	cf 91       	pop	r28
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    89e6:	0c 94 84 48 	jmp	0x9108	; 0x9108 <vListInsert>

000089ea <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    89ea:	0f 93       	push	r16
    89ec:	1f 93       	push	r17
    89ee:	cf 93       	push	r28
    89f0:	df 93       	push	r29
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    89f2:	dc 01       	movw	r26, r24
    89f4:	2c 91       	ld	r18, X
    89f6:	22 23       	and	r18, r18
    89f8:	39 f0       	breq	.+14     	; 0x8a08 <xTaskRemoveFromEventList+0x1e>
    89fa:	15 96       	adiw	r26, 0x05	; 5
    89fc:	ed 91       	ld	r30, X+
    89fe:	fc 91       	ld	r31, X
    8a00:	16 97       	sbiw	r26, 0x06	; 6
    8a02:	c6 81       	ldd	r28, Z+6	; 0x06
    8a04:	d7 81       	ldd	r29, Z+7	; 0x07
    8a06:	02 c0       	rjmp	.+4      	; 0x8a0c <xTaskRemoveFromEventList+0x22>
    8a08:	c0 e0       	ldi	r28, 0x00	; 0
    8a0a:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    8a0c:	8e 01       	movw	r16, r28
    8a0e:	04 5f       	subi	r16, 0xF4	; 244
    8a10:	1f 4f       	sbci	r17, 0xFF	; 255
    8a12:	c8 01       	movw	r24, r16
    8a14:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    8a18:	80 91 d2 01 	lds	r24, 0x01D2
    8a1c:	81 11       	cpse	r24, r1
    8a1e:	14 c0       	rjmp	.+40     	; 0x8a48 <xTaskRemoveFromEventList+0x5e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    8a20:	0a 50       	subi	r16, 0x0A	; 10
    8a22:	11 09       	sbc	r17, r1
    8a24:	c8 01       	movw	r24, r16
    8a26:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    8a2a:	9e 89       	ldd	r25, Y+22	; 0x16
    8a2c:	80 91 d4 01 	lds	r24, 0x01D4
    8a30:	89 17       	cp	r24, r25
    8a32:	10 f4       	brcc	.+4      	; 0x8a38 <xTaskRemoveFromEventList+0x4e>
    8a34:	90 93 d4 01 	sts	0x01D4, r25
    8a38:	b9 e0       	ldi	r27, 0x09	; 9
    8a3a:	9b 9f       	mul	r25, r27
    8a3c:	c0 01       	movw	r24, r0
    8a3e:	11 24       	eor	r1, r1
    8a40:	b8 01       	movw	r22, r16
    8a42:	8f 5f       	subi	r24, 0xFF	; 255
    8a44:	9d 4f       	sbci	r25, 0xFD	; 253
    8a46:	03 c0       	rjmp	.+6      	; 0x8a4e <xTaskRemoveFromEventList+0x64>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    8a48:	b8 01       	movw	r22, r16
    8a4a:	82 ee       	ldi	r24, 0xE2	; 226
    8a4c:	91 e0       	ldi	r25, 0x01	; 1
    8a4e:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    8a52:	e0 91 93 01 	lds	r30, 0x0193
    8a56:	f0 91 94 01 	lds	r31, 0x0194
    8a5a:	81 e0       	ldi	r24, 0x01	; 1
    8a5c:	2e 89       	ldd	r18, Y+22	; 0x16
    8a5e:	96 89       	ldd	r25, Z+22	; 0x16
    8a60:	29 17       	cp	r18, r25
    8a62:	08 f4       	brcc	.+2      	; 0x8a66 <xTaskRemoveFromEventList+0x7c>
    8a64:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    8a66:	df 91       	pop	r29
    8a68:	cf 91       	pop	r28
    8a6a:	1f 91       	pop	r17
    8a6c:	0f 91       	pop	r16
    8a6e:	08 95       	ret

00008a70 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    8a70:	20 91 cf 01 	lds	r18, 0x01CF
    8a74:	fc 01       	movw	r30, r24
    8a76:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    8a78:	20 91 d6 01 	lds	r18, 0x01D6
    8a7c:	30 91 d7 01 	lds	r19, 0x01D7
    8a80:	32 83       	std	Z+2, r19	; 0x02
    8a82:	21 83       	std	Z+1, r18	; 0x01
    8a84:	08 95       	ret

00008a86 <xTaskCheckForTimeOut>:

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    8a86:	0f b6       	in	r0, 0x3f	; 63
    8a88:	f8 94       	cli
    8a8a:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    8a8c:	db 01       	movw	r26, r22
    8a8e:	2d 91       	ld	r18, X+
    8a90:	3c 91       	ld	r19, X
    8a92:	2f 3f       	cpi	r18, 0xFF	; 255
    8a94:	bf ef       	ldi	r27, 0xFF	; 255
    8a96:	3b 07       	cpc	r19, r27
    8a98:	31 f1       	breq	.+76     	; 0x8ae6 <xTaskCheckForTimeOut+0x60>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    8a9a:	50 91 cf 01 	lds	r21, 0x01CF
    8a9e:	fc 01       	movw	r30, r24
    8aa0:	40 81       	ld	r20, Z
    8aa2:	01 80       	ldd	r0, Z+1	; 0x01
    8aa4:	f2 81       	ldd	r31, Z+2	; 0x02
    8aa6:	e0 2d       	mov	r30, r0
    8aa8:	54 17       	cp	r21, r20
    8aaa:	39 f0       	breq	.+14     	; 0x8aba <xTaskCheckForTimeOut+0x34>
    8aac:	40 91 d6 01 	lds	r20, 0x01D6
    8ab0:	50 91 d7 01 	lds	r21, 0x01D7
    8ab4:	4e 17       	cp	r20, r30
    8ab6:	5f 07       	cpc	r21, r31
    8ab8:	c0 f4       	brcc	.+48     	; 0x8aea <xTaskCheckForTimeOut+0x64>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    8aba:	40 91 d6 01 	lds	r20, 0x01D6
    8abe:	50 91 d7 01 	lds	r21, 0x01D7
    8ac2:	4e 1b       	sub	r20, r30
    8ac4:	5f 0b       	sbc	r21, r31
    8ac6:	42 17       	cp	r20, r18
    8ac8:	53 07       	cpc	r21, r19
    8aca:	78 f4       	brcc	.+30     	; 0x8aea <xTaskCheckForTimeOut+0x64>
    8acc:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    8ace:	40 91 d6 01 	lds	r20, 0x01D6
    8ad2:	50 91 d7 01 	lds	r21, 0x01D7
    8ad6:	4e 1b       	sub	r20, r30
    8ad8:	5f 0b       	sbc	r21, r31
    8ada:	24 1b       	sub	r18, r20
    8adc:	35 0b       	sbc	r19, r21
    8ade:	2d 93       	st	X+, r18
    8ae0:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    8ae2:	0e 94 38 45 	call	0x8a70	; 0x8a70 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    8ae6:	80 e0       	ldi	r24, 0x00	; 0
    8ae8:	01 c0       	rjmp	.+2      	; 0x8aec <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    8aea:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    8aec:	0f 90       	pop	r0
    8aee:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    8af0:	08 95       	ret

00008af2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    8af2:	81 e0       	ldi	r24, 0x01	; 1
    8af4:	80 93 d0 01 	sts	0x01D0, r24
    8af8:	08 95       	ret

00008afa <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    8afa:	cf 93       	push	r28
    8afc:	df 93       	push	r29
    8afe:	ec 01       	movw	r28, r24
    8b00:	94 2f       	mov	r25, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    8b02:	8c 8d       	ldd	r24, Y+28	; 0x1c
    8b04:	88 23       	and	r24, r24
    8b06:	99 f1       	breq	.+102    	; 0x8b6e <prvCopyDataToQueue+0x74>
    8b08:	48 2f       	mov	r20, r24
    8b0a:	50 e0       	ldi	r21, 0x00	; 0
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    8b0c:	91 11       	cpse	r25, r1
    8b0e:	15 c0       	rjmp	.+42     	; 0x8b3a <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    8b10:	8c 81       	ldd	r24, Y+4	; 0x04
    8b12:	9d 81       	ldd	r25, Y+5	; 0x05
    8b14:	0e 94 76 4f 	call	0x9eec	; 0x9eec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    8b18:	2c 8d       	ldd	r18, Y+28	; 0x1c
    8b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    8b1c:	9d 81       	ldd	r25, Y+5	; 0x05
    8b1e:	82 0f       	add	r24, r18
    8b20:	91 1d       	adc	r25, r1
    8b22:	9d 83       	std	Y+5, r25	; 0x05
    8b24:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    8b26:	2a 81       	ldd	r18, Y+2	; 0x02
    8b28:	3b 81       	ldd	r19, Y+3	; 0x03
    8b2a:	82 17       	cp	r24, r18
    8b2c:	93 07       	cpc	r25, r19
    8b2e:	f8 f0       	brcs	.+62     	; 0x8b6e <prvCopyDataToQueue+0x74>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    8b30:	88 81       	ld	r24, Y
    8b32:	99 81       	ldd	r25, Y+1	; 0x01
    8b34:	9d 83       	std	Y+5, r25	; 0x05
    8b36:	8c 83       	std	Y+4, r24	; 0x04
    8b38:	1a c0       	rjmp	.+52     	; 0x8b6e <prvCopyDataToQueue+0x74>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    8b3a:	8e 81       	ldd	r24, Y+6	; 0x06
    8b3c:	9f 81       	ldd	r25, Y+7	; 0x07
    8b3e:	0e 94 76 4f 	call	0x9eec	; 0x9eec <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    8b42:	8c 8d       	ldd	r24, Y+28	; 0x1c
    8b44:	90 e0       	ldi	r25, 0x00	; 0
    8b46:	91 95       	neg	r25
    8b48:	81 95       	neg	r24
    8b4a:	91 09       	sbc	r25, r1
    8b4c:	2e 81       	ldd	r18, Y+6	; 0x06
    8b4e:	3f 81       	ldd	r19, Y+7	; 0x07
    8b50:	28 0f       	add	r18, r24
    8b52:	39 1f       	adc	r19, r25
    8b54:	3f 83       	std	Y+7, r19	; 0x07
    8b56:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    8b58:	48 81       	ld	r20, Y
    8b5a:	59 81       	ldd	r21, Y+1	; 0x01
    8b5c:	24 17       	cp	r18, r20
    8b5e:	35 07       	cpc	r19, r21
    8b60:	30 f4       	brcc	.+12     	; 0x8b6e <prvCopyDataToQueue+0x74>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    8b62:	2a 81       	ldd	r18, Y+2	; 0x02
    8b64:	3b 81       	ldd	r19, Y+3	; 0x03
    8b66:	82 0f       	add	r24, r18
    8b68:	93 1f       	adc	r25, r19
    8b6a:	9f 83       	std	Y+7, r25	; 0x07
    8b6c:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    8b6e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    8b70:	8f 5f       	subi	r24, 0xFF	; 255
    8b72:	8a 8f       	std	Y+26, r24	; 0x1a
}
    8b74:	df 91       	pop	r29
    8b76:	cf 91       	pop	r28
    8b78:	08 95       	ret

00008b7a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    8b7a:	fc 01       	movw	r30, r24
    8b7c:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    8b7e:	a0 81       	ld	r26, Z
    8b80:	b1 81       	ldd	r27, Z+1	; 0x01
    8b82:	10 97       	sbiw	r26, 0x00	; 0
    8b84:	99 f0       	breq	.+38     	; 0x8bac <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    8b86:	44 8d       	ldd	r20, Z+28	; 0x1c
    8b88:	50 e0       	ldi	r21, 0x00	; 0
    8b8a:	26 81       	ldd	r18, Z+6	; 0x06
    8b8c:	37 81       	ldd	r19, Z+7	; 0x07
    8b8e:	24 0f       	add	r18, r20
    8b90:	35 1f       	adc	r19, r21
    8b92:	37 83       	std	Z+7, r19	; 0x07
    8b94:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    8b96:	62 81       	ldd	r22, Z+2	; 0x02
    8b98:	73 81       	ldd	r23, Z+3	; 0x03
    8b9a:	26 17       	cp	r18, r22
    8b9c:	37 07       	cpc	r19, r23
    8b9e:	10 f0       	brcs	.+4      	; 0x8ba4 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    8ba0:	b7 83       	std	Z+7, r27	; 0x07
    8ba2:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    8ba4:	66 81       	ldd	r22, Z+6	; 0x06
    8ba6:	77 81       	ldd	r23, Z+7	; 0x07
    8ba8:	0c 94 76 4f 	jmp	0x9eec	; 0x9eec <memcpy>
    8bac:	08 95       	ret

00008bae <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    8bae:	0f 93       	push	r16
    8bb0:	1f 93       	push	r17
    8bb2:	cf 93       	push	r28
    8bb4:	df 93       	push	r29
    8bb6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    8bb8:	0f b6       	in	r0, 0x3f	; 63
    8bba:	f8 94       	cli
    8bbc:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    8bbe:	8c 01       	movw	r16, r24
    8bc0:	0f 5e       	subi	r16, 0xEF	; 239
    8bc2:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    8bc4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    8bc6:	19 16       	cp	r1, r25
    8bc8:	6c f4       	brge	.+26     	; 0x8be4 <prvUnlockQueue+0x36>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    8bca:	89 89       	ldd	r24, Y+17	; 0x11
    8bcc:	88 23       	and	r24, r24
    8bce:	51 f0       	breq	.+20     	; 0x8be4 <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    8bd0:	c8 01       	movw	r24, r16
    8bd2:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    8bd6:	81 11       	cpse	r24, r1
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    8bd8:	0e 94 79 45 	call	0x8af2	; 0x8af2 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    8bdc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    8bde:	91 50       	subi	r25, 0x01	; 1
    8be0:	9e 8f       	std	Y+30, r25	; 0x1e
    8be2:	f0 cf       	rjmp	.-32     	; 0x8bc4 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    8be4:	8f ef       	ldi	r24, 0xFF	; 255
    8be6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    8be8:	0f 90       	pop	r0
    8bea:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    8bec:	0f b6       	in	r0, 0x3f	; 63
    8bee:	f8 94       	cli
    8bf0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    8bf2:	8e 01       	movw	r16, r28
    8bf4:	08 5f       	subi	r16, 0xF8	; 248
    8bf6:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    8bf8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    8bfa:	19 16       	cp	r1, r25
    8bfc:	6c f4       	brge	.+26     	; 0x8c18 <prvUnlockQueue+0x6a>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    8bfe:	88 85       	ldd	r24, Y+8	; 0x08
    8c00:	88 23       	and	r24, r24
    8c02:	51 f0       	breq	.+20     	; 0x8c18 <prvUnlockQueue+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    8c04:	c8 01       	movw	r24, r16
    8c06:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    8c0a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    8c0c:	0e 94 79 45 	call	0x8af2	; 0x8af2 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    8c10:	9d 8d       	ldd	r25, Y+29	; 0x1d
    8c12:	91 50       	subi	r25, 0x01	; 1
    8c14:	9d 8f       	std	Y+29, r25	; 0x1d
    8c16:	f0 cf       	rjmp	.-32     	; 0x8bf8 <prvUnlockQueue+0x4a>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    8c18:	8f ef       	ldi	r24, 0xFF	; 255
    8c1a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    8c1c:	0f 90       	pop	r0
    8c1e:	0f be       	out	0x3f, r0	; 63
}
    8c20:	df 91       	pop	r29
    8c22:	cf 91       	pop	r28
    8c24:	1f 91       	pop	r17
    8c26:	0f 91       	pop	r16
    8c28:	08 95       	ret

00008c2a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    8c2a:	cf 92       	push	r12
    8c2c:	df 92       	push	r13
    8c2e:	ef 92       	push	r14
    8c30:	ff 92       	push	r15
    8c32:	0f 93       	push	r16
    8c34:	1f 93       	push	r17
    8c36:	cf 93       	push	r28
    8c38:	df 93       	push	r29
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    8c3a:	88 23       	and	r24, r24
    8c3c:	b1 f1       	breq	.+108    	; 0x8caa <xQueueCreate+0x80>
    8c3e:	f6 2e       	mov	r15, r22
    8c40:	e8 2e       	mov	r14, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    8c42:	8f e1       	ldi	r24, 0x1F	; 31
    8c44:	90 e0       	ldi	r25, 0x00	; 0
    8c46:	0e 94 a9 4a 	call	0x9552	; 0x9552 <pvPortMalloc>
    8c4a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    8c4c:	89 2b       	or	r24, r25
    8c4e:	69 f1       	breq	.+90     	; 0x8caa <xQueueCreate+0x80>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    8c50:	cf 2c       	mov	r12, r15
    8c52:	d1 2c       	mov	r13, r1
    8c54:	ef 9c       	mul	r14, r15
    8c56:	80 01       	movw	r16, r0
    8c58:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    8c5a:	c8 01       	movw	r24, r16
    8c5c:	01 96       	adiw	r24, 0x01	; 1
    8c5e:	0e 94 a9 4a 	call	0x9552	; 0x9552 <pvPortMalloc>
    8c62:	99 83       	std	Y+1, r25	; 0x01
    8c64:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    8c66:	00 97       	sbiw	r24, 0x00	; 0
    8c68:	e9 f0       	breq	.+58     	; 0x8ca4 <xQueueCreate+0x7a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    8c6a:	9c 01       	movw	r18, r24
    8c6c:	20 0f       	add	r18, r16
    8c6e:	31 1f       	adc	r19, r17
    8c70:	3b 83       	std	Y+3, r19	; 0x03
    8c72:	2a 83       	std	Y+2, r18	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    8c74:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    8c76:	9d 83       	std	Y+5, r25	; 0x05
    8c78:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    8c7a:	0c 19       	sub	r16, r12
    8c7c:	1d 09       	sbc	r17, r13
    8c7e:	08 0f       	add	r16, r24
    8c80:	19 1f       	adc	r17, r25
    8c82:	1f 83       	std	Y+7, r17	; 0x07
    8c84:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    8c86:	eb 8e       	std	Y+27, r14	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    8c88:	fc 8e       	std	Y+28, r15	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    8c8a:	8f ef       	ldi	r24, 0xFF	; 255
    8c8c:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    8c8e:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    8c90:	ce 01       	movw	r24, r28
    8c92:	08 96       	adiw	r24, 0x08	; 8
    8c94:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    8c98:	ce 01       	movw	r24, r28
    8c9a:	41 96       	adiw	r24, 0x11	; 17
    8c9c:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    8ca0:	ce 01       	movw	r24, r28
    8ca2:	05 c0       	rjmp	.+10     	; 0x8cae <xQueueCreate+0x84>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    8ca4:	ce 01       	movw	r24, r28
    8ca6:	0e 94 cf 4a 	call	0x959e	; 0x959e <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    8caa:	80 e0       	ldi	r24, 0x00	; 0
    8cac:	90 e0       	ldi	r25, 0x00	; 0
}
    8cae:	df 91       	pop	r29
    8cb0:	cf 91       	pop	r28
    8cb2:	1f 91       	pop	r17
    8cb4:	0f 91       	pop	r16
    8cb6:	ff 90       	pop	r15
    8cb8:	ef 90       	pop	r14
    8cba:	df 90       	pop	r13
    8cbc:	cf 90       	pop	r12
    8cbe:	08 95       	ret

00008cc0 <xQueueCreateExternal>:

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    8cc0:	ef 92       	push	r14
    8cc2:	ff 92       	push	r15
    8cc4:	0f 93       	push	r16
    8cc6:	1f 93       	push	r17
    8cc8:	cf 93       	push	r28
    8cca:	df 93       	push	r29
    xQUEUE *pxNewQueue;
    //size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    8ccc:	88 23       	and	r24, r24
    8cce:	89 f1       	breq	.+98     	; 0x8d32 <xQueueCreateExternal+0x72>
    8cd0:	8a 01       	movw	r16, r20
    8cd2:	f6 2e       	mov	r15, r22
    8cd4:	e8 2e       	mov	r14, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    8cd6:	8f e1       	ldi	r24, 0x1F	; 31
    8cd8:	90 e0       	ldi	r25, 0x00	; 0
    8cda:	0e 94 a9 4a 	call	0x9552	; 0x9552 <pvPortMalloc>
    8cde:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    8ce0:	00 97       	sbiw	r24, 0x00	; 0
    8ce2:	39 f1       	breq	.+78     	; 0x8d32 <xQueueCreateExternal+0x72>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			//xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    8ce4:	19 83       	std	Y+1, r17	; 0x01
    8ce6:	08 83       	st	Y, r16
			if( pxNewQueue->pcHead != NULL )
    8ce8:	01 15       	cp	r16, r1
    8cea:	11 05       	cpc	r17, r1
    8cec:	01 f1       	breq	.+64     	; 0x8d2e <xQueueCreateExternal+0x6e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    8cee:	ef 9c       	mul	r14, r15
    8cf0:	a0 01       	movw	r20, r0
    8cf2:	11 24       	eor	r1, r1
    8cf4:	c8 01       	movw	r24, r16
    8cf6:	84 0f       	add	r24, r20
    8cf8:	95 1f       	adc	r25, r21
    8cfa:	9b 83       	std	Y+3, r25	; 0x03
    8cfc:	8a 83       	std	Y+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    8cfe:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    8d00:	1d 83       	std	Y+5, r17	; 0x05
    8d02:	0c 83       	std	Y+4, r16	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    8d04:	4f 19       	sub	r20, r15
    8d06:	51 09       	sbc	r21, r1
    8d08:	04 0f       	add	r16, r20
    8d0a:	15 1f       	adc	r17, r21
    8d0c:	1f 83       	std	Y+7, r17	; 0x07
    8d0e:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    8d10:	eb 8e       	std	Y+27, r14	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    8d12:	fc 8e       	std	Y+28, r15	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    8d14:	8f ef       	ldi	r24, 0xFF	; 255
    8d16:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    8d18:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    8d1a:	ce 01       	movw	r24, r28
    8d1c:	08 96       	adiw	r24, 0x08	; 8
    8d1e:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    8d22:	ce 01       	movw	r24, r28
    8d24:	41 96       	adiw	r24, 0x11	; 17
    8d26:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    8d2a:	ce 01       	movw	r24, r28
    8d2c:	04 c0       	rjmp	.+8      	; 0x8d36 <xQueueCreateExternal+0x76>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    8d2e:	0e 94 cf 4a 	call	0x959e	; 0x959e <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    8d32:	80 e0       	ldi	r24, 0x00	; 0
    8d34:	90 e0       	ldi	r25, 0x00	; 0
}
    8d36:	df 91       	pop	r29
    8d38:	cf 91       	pop	r28
    8d3a:	1f 91       	pop	r17
    8d3c:	0f 91       	pop	r16
    8d3e:	ff 90       	pop	r15
    8d40:	ef 90       	pop	r14
    8d42:	08 95       	ret

00008d44 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    8d44:	af 92       	push	r10
    8d46:	bf 92       	push	r11
    8d48:	df 92       	push	r13
    8d4a:	ef 92       	push	r14
    8d4c:	ff 92       	push	r15
    8d4e:	0f 93       	push	r16
    8d50:	1f 93       	push	r17
    8d52:	cf 93       	push	r28
    8d54:	df 93       	push	r29
    8d56:	00 d0       	rcall	.+0      	; 0x8d58 <xQueueGenericSend+0x14>
    8d58:	00 d0       	rcall	.+0      	; 0x8d5a <xQueueGenericSend+0x16>
    8d5a:	1f 92       	push	r1
    8d5c:	cd b7       	in	r28, 0x3d	; 61
    8d5e:	de b7       	in	r29, 0x3e	; 62
    8d60:	8c 01       	movw	r16, r24
    8d62:	7b 01       	movw	r14, r22
    8d64:	5d 83       	std	Y+5, r21	; 0x05
    8d66:	4c 83       	std	Y+4, r20	; 0x04
    8d68:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    8d6a:	90 e0       	ldi	r25, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    8d6c:	58 01       	movw	r10, r16
    8d6e:	88 e0       	ldi	r24, 0x08	; 8
    8d70:	a8 0e       	add	r10, r24
    8d72:	b1 1c       	adc	r11, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    8d74:	0f b6       	in	r0, 0x3f	; 63
    8d76:	f8 94       	cli
    8d78:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    8d7a:	f8 01       	movw	r30, r16
    8d7c:	22 8d       	ldd	r18, Z+26	; 0x1a
    8d7e:	83 8d       	ldd	r24, Z+27	; 0x1b
    8d80:	28 17       	cp	r18, r24
    8d82:	a8 f4       	brcc	.+42     	; 0x8dae <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    8d84:	4d 2d       	mov	r20, r13
    8d86:	b7 01       	movw	r22, r14
    8d88:	c8 01       	movw	r24, r16
    8d8a:	0e 94 7d 45 	call	0x8afa	; 0x8afa <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    8d8e:	f8 01       	movw	r30, r16
    8d90:	81 89       	ldd	r24, Z+17	; 0x11
    8d92:	88 23       	and	r24, r24
    8d94:	41 f0       	breq	.+16     	; 0x8da6 <xQueueGenericSend+0x62>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    8d96:	c8 01       	movw	r24, r16
    8d98:	41 96       	adiw	r24, 0x11	; 17
    8d9a:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    8d9e:	81 30       	cpi	r24, 0x01	; 1
    8da0:	11 f4       	brne	.+4      	; 0x8da6 <xQueueGenericSend+0x62>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    8da2:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    8da6:	0f 90       	pop	r0
    8da8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    8daa:	81 e0       	ldi	r24, 0x01	; 1
    8dac:	50 c0       	rjmp	.+160    	; 0x8e4e <xQueueGenericSend+0x10a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    8dae:	2c 81       	ldd	r18, Y+4	; 0x04
    8db0:	3d 81       	ldd	r19, Y+5	; 0x05
    8db2:	23 2b       	or	r18, r19
    8db4:	19 f4       	brne	.+6      	; 0x8dbc <xQueueGenericSend+0x78>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    8db6:	0f 90       	pop	r0
    8db8:	0f be       	out	0x3f, r0	; 63
    8dba:	48 c0       	rjmp	.+144    	; 0x8e4c <xQueueGenericSend+0x108>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    8dbc:	91 11       	cpse	r25, r1
    8dbe:	04 c0       	rjmp	.+8      	; 0x8dc8 <xQueueGenericSend+0x84>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    8dc0:	ce 01       	movw	r24, r28
    8dc2:	01 96       	adiw	r24, 0x01	; 1
    8dc4:	0e 94 38 45 	call	0x8a70	; 0x8a70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    8dc8:	0f 90       	pop	r0
    8dca:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    8dcc:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    8dd0:	0f b6       	in	r0, 0x3f	; 63
    8dd2:	f8 94       	cli
    8dd4:	0f 92       	push	r0
    8dd6:	f8 01       	movw	r30, r16
    8dd8:	85 8d       	ldd	r24, Z+29	; 0x1d
    8dda:	8f 3f       	cpi	r24, 0xFF	; 255
    8ddc:	09 f4       	brne	.+2      	; 0x8de0 <xQueueGenericSend+0x9c>
    8dde:	15 8e       	std	Z+29, r1	; 0x1d
    8de0:	f8 01       	movw	r30, r16
    8de2:	86 8d       	ldd	r24, Z+30	; 0x1e
    8de4:	8f 3f       	cpi	r24, 0xFF	; 255
    8de6:	09 f4       	brne	.+2      	; 0x8dea <xQueueGenericSend+0xa6>
    8de8:	16 8e       	std	Z+30, r1	; 0x1e
    8dea:	0f 90       	pop	r0
    8dec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    8dee:	be 01       	movw	r22, r28
    8df0:	6c 5f       	subi	r22, 0xFC	; 252
    8df2:	7f 4f       	sbci	r23, 0xFF	; 255
    8df4:	ce 01       	movw	r24, r28
    8df6:	01 96       	adiw	r24, 0x01	; 1
    8df8:	0e 94 43 45 	call	0x8a86	; 0x8a86 <xTaskCheckForTimeOut>
    8dfc:	81 11       	cpse	r24, r1
    8dfe:	21 c0       	rjmp	.+66     	; 0x8e42 <xQueueGenericSend+0xfe>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    8e00:	0f b6       	in	r0, 0x3f	; 63
    8e02:	f8 94       	cli
    8e04:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    8e06:	f8 01       	movw	r30, r16
    8e08:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    8e0a:	0f 90       	pop	r0
    8e0c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    8e0e:	83 8d       	ldd	r24, Z+27	; 0x1b
    8e10:	98 13       	cpse	r25, r24
    8e12:	11 c0       	rjmp	.+34     	; 0x8e36 <xQueueGenericSend+0xf2>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    8e14:	6c 81       	ldd	r22, Y+4	; 0x04
    8e16:	7d 81       	ldd	r23, Y+5	; 0x05
    8e18:	c5 01       	movw	r24, r10
    8e1a:	0e 94 a7 44 	call	0x894e	; 0x894e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    8e1e:	c8 01       	movw	r24, r16
    8e20:	0e 94 d7 45 	call	0x8bae	; 0x8bae <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    8e24:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
    8e28:	88 23       	and	r24, r24
    8e2a:	11 f0       	breq	.+4      	; 0x8e30 <xQueueGenericSend+0xec>
    8e2c:	91 e0       	ldi	r25, 0x01	; 1
    8e2e:	a2 cf       	rjmp	.-188    	; 0x8d74 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    8e30:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
    8e34:	fb cf       	rjmp	.-10     	; 0x8e2c <xQueueGenericSend+0xe8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    8e36:	c8 01       	movw	r24, r16
    8e38:	0e 94 d7 45 	call	0x8bae	; 0x8bae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    8e3c:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
    8e40:	f5 cf       	rjmp	.-22     	; 0x8e2c <xQueueGenericSend+0xe8>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    8e42:	c8 01       	movw	r24, r16
    8e44:	0e 94 d7 45 	call	0x8bae	; 0x8bae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    8e48:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    8e4c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    8e4e:	0f 90       	pop	r0
    8e50:	0f 90       	pop	r0
    8e52:	0f 90       	pop	r0
    8e54:	0f 90       	pop	r0
    8e56:	0f 90       	pop	r0
    8e58:	df 91       	pop	r29
    8e5a:	cf 91       	pop	r28
    8e5c:	1f 91       	pop	r17
    8e5e:	0f 91       	pop	r16
    8e60:	ff 90       	pop	r15
    8e62:	ef 90       	pop	r14
    8e64:	df 90       	pop	r13
    8e66:	bf 90       	pop	r11
    8e68:	af 90       	pop	r10
    8e6a:	08 95       	ret

00008e6c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    8e6c:	0f 93       	push	r16
    8e6e:	1f 93       	push	r17
    8e70:	cf 93       	push	r28
    8e72:	df 93       	push	r29
    8e74:	ec 01       	movw	r28, r24
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    8e76:	9a 8d       	ldd	r25, Y+26	; 0x1a
    8e78:	8b 8d       	ldd	r24, Y+27	; 0x1b
    8e7a:	98 17       	cp	r25, r24
    8e7c:	c8 f4       	brcc	.+50     	; 0x8eb0 <xQueueGenericSendFromISR+0x44>
    8e7e:	8a 01       	movw	r16, r20
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    8e80:	42 2f       	mov	r20, r18
    8e82:	ce 01       	movw	r24, r28
    8e84:	0e 94 7d 45 	call	0x8afa	; 0x8afa <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    8e88:	8e 8d       	ldd	r24, Y+30	; 0x1e
    8e8a:	8f 3f       	cpi	r24, 0xFF	; 255
    8e8c:	69 f4       	brne	.+26     	; 0x8ea8 <xQueueGenericSendFromISR+0x3c>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    8e8e:	89 89       	ldd	r24, Y+17	; 0x11
    8e90:	88 23       	and	r24, r24
    8e92:	61 f0       	breq	.+24     	; 0x8eac <xQueueGenericSendFromISR+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    8e94:	ce 01       	movw	r24, r28
    8e96:	41 96       	adiw	r24, 0x11	; 17
    8e98:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    8e9c:	88 23       	and	r24, r24
    8e9e:	31 f0       	breq	.+12     	; 0x8eac <xQueueGenericSendFromISR+0x40>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    8ea0:	81 e0       	ldi	r24, 0x01	; 1
    8ea2:	f8 01       	movw	r30, r16
    8ea4:	80 83       	st	Z, r24
    8ea6:	05 c0       	rjmp	.+10     	; 0x8eb2 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    8ea8:	8f 5f       	subi	r24, 0xFF	; 255
    8eaa:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    8eac:	81 e0       	ldi	r24, 0x01	; 1
    8eae:	01 c0       	rjmp	.+2      	; 0x8eb2 <xQueueGenericSendFromISR+0x46>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    8eb0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    8eb2:	df 91       	pop	r29
    8eb4:	cf 91       	pop	r28
    8eb6:	1f 91       	pop	r17
    8eb8:	0f 91       	pop	r16
    8eba:	08 95       	ret

00008ebc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    8ebc:	af 92       	push	r10
    8ebe:	bf 92       	push	r11
    8ec0:	df 92       	push	r13
    8ec2:	ef 92       	push	r14
    8ec4:	ff 92       	push	r15
    8ec6:	0f 93       	push	r16
    8ec8:	1f 93       	push	r17
    8eca:	cf 93       	push	r28
    8ecc:	df 93       	push	r29
    8ece:	00 d0       	rcall	.+0      	; 0x8ed0 <xQueueGenericReceive+0x14>
    8ed0:	00 d0       	rcall	.+0      	; 0x8ed2 <xQueueGenericReceive+0x16>
    8ed2:	1f 92       	push	r1
    8ed4:	cd b7       	in	r28, 0x3d	; 61
    8ed6:	de b7       	in	r29, 0x3e	; 62
    8ed8:	8c 01       	movw	r16, r24
    8eda:	7b 01       	movw	r14, r22
    8edc:	5d 83       	std	Y+5, r21	; 0x05
    8ede:	4c 83       	std	Y+4, r20	; 0x04
    8ee0:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    8ee2:	90 e0       	ldi	r25, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    8ee4:	58 01       	movw	r10, r16
    8ee6:	81 e1       	ldi	r24, 0x11	; 17
    8ee8:	a8 0e       	add	r10, r24
    8eea:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    8eec:	0f b6       	in	r0, 0x3f	; 63
    8eee:	f8 94       	cli
    8ef0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    8ef2:	f8 01       	movw	r30, r16
    8ef4:	82 8d       	ldd	r24, Z+26	; 0x1a
    8ef6:	88 23       	and	r24, r24
    8ef8:	39 f1       	breq	.+78     	; 0x8f48 <xQueueGenericReceive+0x8c>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    8efa:	a6 80       	ldd	r10, Z+6	; 0x06
    8efc:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    8efe:	b7 01       	movw	r22, r14
    8f00:	c8 01       	movw	r24, r16
    8f02:	0e 94 bd 45 	call	0x8b7a	; 0x8b7a <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    8f06:	f8 01       	movw	r30, r16
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    8f08:	d1 10       	cpse	r13, r1
    8f0a:	0f c0       	rjmp	.+30     	; 0x8f2a <xQueueGenericReceive+0x6e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    8f0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    8f0e:	81 50       	subi	r24, 0x01	; 1
    8f10:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    8f12:	80 85       	ldd	r24, Z+8	; 0x08
    8f14:	88 23       	and	r24, r24
    8f16:	a1 f0       	breq	.+40     	; 0x8f40 <xQueueGenericReceive+0x84>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    8f18:	c8 01       	movw	r24, r16
    8f1a:	08 96       	adiw	r24, 0x08	; 8
    8f1c:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    8f20:	81 30       	cpi	r24, 0x01	; 1
    8f22:	71 f4       	brne	.+28     	; 0x8f40 <xQueueGenericReceive+0x84>
						{
							portYIELD_WITHIN_API();
    8f24:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
    8f28:	0b c0       	rjmp	.+22     	; 0x8f40 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    8f2a:	b7 82       	std	Z+7, r11	; 0x07
    8f2c:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    8f2e:	81 89       	ldd	r24, Z+17	; 0x11
    8f30:	88 23       	and	r24, r24
    8f32:	31 f0       	breq	.+12     	; 0x8f40 <xQueueGenericReceive+0x84>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    8f34:	c8 01       	movw	r24, r16
    8f36:	41 96       	adiw	r24, 0x11	; 17
    8f38:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    8f3c:	81 11       	cpse	r24, r1
    8f3e:	f2 cf       	rjmp	.-28     	; 0x8f24 <xQueueGenericReceive+0x68>
						}
					}

				}

				taskEXIT_CRITICAL();
    8f40:	0f 90       	pop	r0
    8f42:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    8f44:	81 e0       	ldi	r24, 0x01	; 1
    8f46:	4f c0       	rjmp	.+158    	; 0x8fe6 <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    8f48:	2c 81       	ldd	r18, Y+4	; 0x04
    8f4a:	3d 81       	ldd	r19, Y+5	; 0x05
    8f4c:	23 2b       	or	r18, r19
    8f4e:	19 f4       	brne	.+6      	; 0x8f56 <xQueueGenericReceive+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    8f50:	0f 90       	pop	r0
    8f52:	0f be       	out	0x3f, r0	; 63
    8f54:	47 c0       	rjmp	.+142    	; 0x8fe4 <xQueueGenericReceive+0x128>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    8f56:	91 11       	cpse	r25, r1
    8f58:	04 c0       	rjmp	.+8      	; 0x8f62 <xQueueGenericReceive+0xa6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    8f5a:	ce 01       	movw	r24, r28
    8f5c:	01 96       	adiw	r24, 0x01	; 1
    8f5e:	0e 94 38 45 	call	0x8a70	; 0x8a70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    8f62:	0f 90       	pop	r0
    8f64:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    8f66:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    8f6a:	0f b6       	in	r0, 0x3f	; 63
    8f6c:	f8 94       	cli
    8f6e:	0f 92       	push	r0
    8f70:	f8 01       	movw	r30, r16
    8f72:	85 8d       	ldd	r24, Z+29	; 0x1d
    8f74:	8f 3f       	cpi	r24, 0xFF	; 255
    8f76:	09 f4       	brne	.+2      	; 0x8f7a <xQueueGenericReceive+0xbe>
    8f78:	15 8e       	std	Z+29, r1	; 0x1d
    8f7a:	f8 01       	movw	r30, r16
    8f7c:	86 8d       	ldd	r24, Z+30	; 0x1e
    8f7e:	8f 3f       	cpi	r24, 0xFF	; 255
    8f80:	09 f4       	brne	.+2      	; 0x8f84 <xQueueGenericReceive+0xc8>
    8f82:	16 8e       	std	Z+30, r1	; 0x1e
    8f84:	0f 90       	pop	r0
    8f86:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    8f88:	be 01       	movw	r22, r28
    8f8a:	6c 5f       	subi	r22, 0xFC	; 252
    8f8c:	7f 4f       	sbci	r23, 0xFF	; 255
    8f8e:	ce 01       	movw	r24, r28
    8f90:	01 96       	adiw	r24, 0x01	; 1
    8f92:	0e 94 43 45 	call	0x8a86	; 0x8a86 <xTaskCheckForTimeOut>
    8f96:	81 11       	cpse	r24, r1
    8f98:	20 c0       	rjmp	.+64     	; 0x8fda <xQueueGenericReceive+0x11e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    8f9a:	0f b6       	in	r0, 0x3f	; 63
    8f9c:	f8 94       	cli
    8f9e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    8fa0:	f8 01       	movw	r30, r16
    8fa2:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    8fa4:	0f 90       	pop	r0
    8fa6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    8fa8:	81 11       	cpse	r24, r1
    8faa:	11 c0       	rjmp	.+34     	; 0x8fce <xQueueGenericReceive+0x112>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    8fac:	6c 81       	ldd	r22, Y+4	; 0x04
    8fae:	7d 81       	ldd	r23, Y+5	; 0x05
    8fb0:	c5 01       	movw	r24, r10
    8fb2:	0e 94 a7 44 	call	0x894e	; 0x894e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    8fb6:	c8 01       	movw	r24, r16
    8fb8:	0e 94 d7 45 	call	0x8bae	; 0x8bae <prvUnlockQueue>
				if( !xTaskResumeAll() )
    8fbc:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
    8fc0:	88 23       	and	r24, r24
    8fc2:	11 f0       	breq	.+4      	; 0x8fc8 <xQueueGenericReceive+0x10c>
    8fc4:	91 e0       	ldi	r25, 0x01	; 1
    8fc6:	92 cf       	rjmp	.-220    	; 0x8eec <xQueueGenericReceive+0x30>
				{
					portYIELD_WITHIN_API();
    8fc8:	0e 94 81 4b 	call	0x9702	; 0x9702 <vPortYield>
    8fcc:	fb cf       	rjmp	.-10     	; 0x8fc4 <xQueueGenericReceive+0x108>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    8fce:	c8 01       	movw	r24, r16
    8fd0:	0e 94 d7 45 	call	0x8bae	; 0x8bae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    8fd4:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
    8fd8:	f5 cf       	rjmp	.-22     	; 0x8fc4 <xQueueGenericReceive+0x108>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    8fda:	c8 01       	movw	r24, r16
    8fdc:	0e 94 d7 45 	call	0x8bae	; 0x8bae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    8fe0:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    8fe4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    8fe6:	0f 90       	pop	r0
    8fe8:	0f 90       	pop	r0
    8fea:	0f 90       	pop	r0
    8fec:	0f 90       	pop	r0
    8fee:	0f 90       	pop	r0
    8ff0:	df 91       	pop	r29
    8ff2:	cf 91       	pop	r28
    8ff4:	1f 91       	pop	r17
    8ff6:	0f 91       	pop	r16
    8ff8:	ff 90       	pop	r15
    8ffa:	ef 90       	pop	r14
    8ffc:	df 90       	pop	r13
    8ffe:	bf 90       	pop	r11
    9000:	af 90       	pop	r10
    9002:	08 95       	ret

00009004 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    9004:	0f 93       	push	r16
    9006:	1f 93       	push	r17
    9008:	cf 93       	push	r28
    900a:	df 93       	push	r29
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    900c:	fc 01       	movw	r30, r24
    900e:	22 8d       	ldd	r18, Z+26	; 0x1a
    9010:	22 23       	and	r18, r18
    9012:	d9 f0       	breq	.+54     	; 0x904a <xQueueReceiveFromISR+0x46>
    9014:	8a 01       	movw	r16, r20
    9016:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    9018:	0e 94 bd 45 	call	0x8b7a	; 0x8b7a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    901c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    901e:	81 50       	subi	r24, 0x01	; 1
    9020:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    9022:	8d 8d       	ldd	r24, Y+29	; 0x1d
    9024:	8f 3f       	cpi	r24, 0xFF	; 255
    9026:	69 f4       	brne	.+26     	; 0x9042 <xQueueReceiveFromISR+0x3e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    9028:	88 85       	ldd	r24, Y+8	; 0x08
    902a:	88 23       	and	r24, r24
    902c:	61 f0       	breq	.+24     	; 0x9046 <xQueueReceiveFromISR+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    902e:	ce 01       	movw	r24, r28
    9030:	08 96       	adiw	r24, 0x08	; 8
    9032:	0e 94 f5 44 	call	0x89ea	; 0x89ea <xTaskRemoveFromEventList>
    9036:	88 23       	and	r24, r24
    9038:	31 f0       	breq	.+12     	; 0x9046 <xQueueReceiveFromISR+0x42>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    903a:	81 e0       	ldi	r24, 0x01	; 1
    903c:	f8 01       	movw	r30, r16
    903e:	80 83       	st	Z, r24
    9040:	05 c0       	rjmp	.+10     	; 0x904c <xQueueReceiveFromISR+0x48>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    9042:	8f 5f       	subi	r24, 0xFF	; 255
    9044:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    9046:	81 e0       	ldi	r24, 0x01	; 1
    9048:	01 c0       	rjmp	.+2      	; 0x904c <xQueueReceiveFromISR+0x48>
		}
		else
		{
			xReturn = pdFAIL;
    904a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    904c:	df 91       	pop	r29
    904e:	cf 91       	pop	r28
    9050:	1f 91       	pop	r17
    9052:	0f 91       	pop	r16
    9054:	08 95       	ret

00009056 <uxQueueMessagesWaiting>:

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    9056:	0f b6       	in	r0, 0x3f	; 63
    9058:	f8 94       	cli
    905a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    905c:	fc 01       	movw	r30, r24
    905e:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    9060:	0f 90       	pop	r0
    9062:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    9064:	08 95       	ret

00009066 <uxQueueMessagesWaitingFromISR>:

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    9066:	fc 01       	movw	r30, r24
    9068:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    906a:	08 95       	ret

0000906c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    906c:	cf 93       	push	r28
    906e:	df 93       	push	r29
    9070:	ec 01       	movw	r28, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    9072:	88 81       	ld	r24, Y
    9074:	99 81       	ldd	r25, Y+1	; 0x01
    9076:	0e 94 cf 4a 	call	0x959e	; 0x959e <vPortFree>
	vPortFree( pxQueue );
    907a:	ce 01       	movw	r24, r28
}
    907c:	df 91       	pop	r29
    907e:	cf 91       	pop	r28
void vQueueDelete( xQueueHandle pxQueue )
{
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
    9080:	0c 94 cf 4a 	jmp	0x959e	; 0x959e <vPortFree>

00009084 <xQueueIsQueueEmptyFromISR>:

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    9084:	fc 01       	movw	r30, r24
    9086:	92 8d       	ldd	r25, Z+26	; 0x1a
    9088:	81 e0       	ldi	r24, 0x01	; 1
    908a:	91 11       	cpse	r25, r1
    908c:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    908e:	08 95       	ret

00009090 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    9090:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    9092:	22 8d       	ldd	r18, Z+26	; 0x1a
    9094:	81 e0       	ldi	r24, 0x01	; 1
    9096:	93 8d       	ldd	r25, Z+27	; 0x1b
    9098:	29 13       	cpse	r18, r25
    909a:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    909c:	08 95       	ret

0000909e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    909e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    90a0:	03 96       	adiw	r24, 0x03	; 3
    90a2:	92 83       	std	Z+2, r25	; 0x02
    90a4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    90a6:	2f ef       	ldi	r18, 0xFF	; 255
    90a8:	3f ef       	ldi	r19, 0xFF	; 255
    90aa:	34 83       	std	Z+4, r19	; 0x04
    90ac:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    90ae:	96 83       	std	Z+6, r25	; 0x06
    90b0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    90b2:	90 87       	std	Z+8, r25	; 0x08
    90b4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = 0;
    90b6:	10 82       	st	Z, r1
    90b8:	08 95       	ret

000090ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    90ba:	fc 01       	movw	r30, r24
    90bc:	11 86       	std	Z+9, r1	; 0x09
    90be:	10 86       	std	Z+8, r1	; 0x08
    90c0:	08 95       	ret

000090c2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    90c2:	cf 93       	push	r28
    90c4:	df 93       	push	r29
    90c6:	dc 01       	movw	r26, r24
    90c8:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    90ca:	11 96       	adiw	r26, 0x01	; 1
    90cc:	2d 91       	ld	r18, X+
    90ce:	3c 91       	ld	r19, X
    90d0:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex->pxNext;
    90d2:	e9 01       	movw	r28, r18
    90d4:	8a 81       	ldd	r24, Y+2	; 0x02
    90d6:	9b 81       	ldd	r25, Y+3	; 0x03
    90d8:	93 83       	std	Z+3, r25	; 0x03
    90da:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    90dc:	35 83       	std	Z+5, r19	; 0x05
    90de:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    90e0:	8a 81       	ldd	r24, Y+2	; 0x02
    90e2:	9b 81       	ldd	r25, Y+3	; 0x03
    90e4:	ec 01       	movw	r28, r24
    90e6:	7d 83       	std	Y+5, r23	; 0x05
    90e8:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    90ea:	e9 01       	movw	r28, r18
    90ec:	7b 83       	std	Y+3, r23	; 0x03
    90ee:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    90f0:	12 96       	adiw	r26, 0x02	; 2
    90f2:	7c 93       	st	X, r23
    90f4:	6e 93       	st	-X, r22
    90f6:	11 97       	sbiw	r26, 0x01	; 1

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    90f8:	b1 87       	std	Z+9, r27	; 0x09
    90fa:	a0 87       	std	Z+8, r26	; 0x08

	( pxList->uxNumberOfItems )++;
    90fc:	8c 91       	ld	r24, X
    90fe:	8f 5f       	subi	r24, 0xFF	; 255
    9100:	8c 93       	st	X, r24
}
    9102:	df 91       	pop	r29
    9104:	cf 91       	pop	r28
    9106:	08 95       	ret

00009108 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    9108:	cf 93       	push	r28
    910a:	df 93       	push	r29
    910c:	ac 01       	movw	r20, r24
    910e:	db 01       	movw	r26, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    9110:	8d 91       	ld	r24, X+
    9112:	9c 91       	ld	r25, X
    9114:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    9116:	8f 3f       	cpi	r24, 0xFF	; 255
    9118:	2f ef       	ldi	r18, 0xFF	; 255
    911a:	92 07       	cpc	r25, r18
    911c:	21 f4       	brne	.+8      	; 0x9126 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    911e:	ea 01       	movw	r28, r20
    9120:	ef 81       	ldd	r30, Y+7	; 0x07
    9122:	f8 85       	ldd	r31, Y+8	; 0x08
    9124:	0e c0       	rjmp	.+28     	; 0x9142 <vListInsert+0x3a>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    9126:	fa 01       	movw	r30, r20
    9128:	33 96       	adiw	r30, 0x03	; 3
    912a:	22 81       	ldd	r18, Z+2	; 0x02
    912c:	33 81       	ldd	r19, Z+3	; 0x03
    912e:	e9 01       	movw	r28, r18
    9130:	28 81       	ld	r18, Y
    9132:	39 81       	ldd	r19, Y+1	; 0x01
    9134:	82 17       	cp	r24, r18
    9136:	93 07       	cpc	r25, r19
    9138:	20 f0       	brcs	.+8      	; 0x9142 <vListInsert+0x3a>
    913a:	02 80       	ldd	r0, Z+2	; 0x02
    913c:	f3 81       	ldd	r31, Z+3	; 0x03
    913e:	e0 2d       	mov	r30, r0
    9140:	f4 cf       	rjmp	.-24     	; 0x912a <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    9142:	82 81       	ldd	r24, Z+2	; 0x02
    9144:	93 81       	ldd	r25, Z+3	; 0x03
    9146:	13 96       	adiw	r26, 0x03	; 3
    9148:	9c 93       	st	X, r25
    914a:	8e 93       	st	-X, r24
    914c:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    914e:	ec 01       	movw	r28, r24
    9150:	bd 83       	std	Y+5, r27	; 0x05
    9152:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    9154:	15 96       	adiw	r26, 0x05	; 5
    9156:	fc 93       	st	X, r31
    9158:	ee 93       	st	-X, r30
    915a:	14 97       	sbiw	r26, 0x04	; 4
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    915c:	b3 83       	std	Z+3, r27	; 0x03
    915e:	a2 83       	std	Z+2, r26	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    9160:	19 96       	adiw	r26, 0x09	; 9
    9162:	5c 93       	st	X, r21
    9164:	4e 93       	st	-X, r20
    9166:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    9168:	fa 01       	movw	r30, r20
    916a:	80 81       	ld	r24, Z
    916c:	8f 5f       	subi	r24, 0xFF	; 255
    916e:	80 83       	st	Z, r24
}
    9170:	df 91       	pop	r29
    9172:	cf 91       	pop	r28
    9174:	08 95       	ret

00009176 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    9176:	cf 93       	push	r28
    9178:	df 93       	push	r29
    917a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    917c:	a2 81       	ldd	r26, Z+2	; 0x02
    917e:	b3 81       	ldd	r27, Z+3	; 0x03
    9180:	84 81       	ldd	r24, Z+4	; 0x04
    9182:	95 81       	ldd	r25, Z+5	; 0x05
    9184:	15 96       	adiw	r26, 0x05	; 5
    9186:	9c 93       	st	X, r25
    9188:	8e 93       	st	-X, r24
    918a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    918c:	c4 81       	ldd	r28, Z+4	; 0x04
    918e:	d5 81       	ldd	r29, Z+5	; 0x05
    9190:	bb 83       	std	Y+3, r27	; 0x03
    9192:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    9194:	a0 85       	ldd	r26, Z+8	; 0x08
    9196:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    9198:	11 96       	adiw	r26, 0x01	; 1
    919a:	8d 91       	ld	r24, X+
    919c:	9c 91       	ld	r25, X
    919e:	12 97       	sbiw	r26, 0x02	; 2
    91a0:	8e 17       	cp	r24, r30
    91a2:	9f 07       	cpc	r25, r31
    91a4:	21 f4       	brne	.+8      	; 0x91ae <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    91a6:	12 96       	adiw	r26, 0x02	; 2
    91a8:	dc 93       	st	X, r29
    91aa:	ce 93       	st	-X, r28
    91ac:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    91ae:	11 86       	std	Z+9, r1	; 0x09
    91b0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    91b2:	8c 91       	ld	r24, X
    91b4:	81 50       	subi	r24, 0x01	; 1
    91b6:	8c 93       	st	X, r24
}
    91b8:	df 91       	pop	r29
    91ba:	cf 91       	pop	r28
    91bc:	08 95       	ret

000091be <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    91be:	ef 92       	push	r14
    91c0:	ff 92       	push	r15
    91c2:	0f 93       	push	r16
    91c4:	1f 93       	push	r17
    91c6:	cf 93       	push	r28
    91c8:	df 93       	push	r29
    91ca:	7c 01       	movw	r14, r24
    91cc:	14 2f       	mov	r17, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    91ce:	8a e1       	ldi	r24, 0x1A	; 26
    91d0:	90 e0       	ldi	r25, 0x00	; 0
    91d2:	0e 94 a9 4a 	call	0x9552	; 0x9552 <pvPortMalloc>
    91d6:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    91d8:	89 2b       	or	r24, r25
    91da:	09 f4       	brne	.+2      	; 0x91de <xCoRoutineCreate+0x20>
    91dc:	4f c0       	rjmp	.+158    	; 0x927c <xCoRoutineCreate+0xbe>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    91de:	80 91 1c 02 	lds	r24, 0x021C
    91e2:	90 91 1d 02 	lds	r25, 0x021D
    91e6:	89 2b       	or	r24, r25
    91e8:	01 f5       	brne	.+64     	; 0x922a <xCoRoutineCreate+0x6c>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    91ea:	d0 93 1d 02 	sts	0x021D, r29
    91ee:	c0 93 1c 02 	sts	0x021C, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    91f2:	84 e4       	ldi	r24, 0x44	; 68
    91f4:	92 e0       	ldi	r25, 0x02	; 2
    91f6:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    91fa:	8b e3       	ldi	r24, 0x3B	; 59
    91fc:	92 e0       	ldi	r25, 0x02	; 2
    91fe:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    9202:	82 e3       	ldi	r24, 0x32	; 50
    9204:	92 e0       	ldi	r25, 0x02	; 2
    9206:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    920a:	85 e2       	ldi	r24, 0x25	; 37
    920c:	92 e0       	ldi	r25, 0x02	; 2
    920e:	0e 94 4f 48 	call	0x909e	; 0x909e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    9212:	8b e3       	ldi	r24, 0x3B	; 59
    9214:	92 e0       	ldi	r25, 0x02	; 2
    9216:	90 93 31 02 	sts	0x0231, r25
    921a:	80 93 30 02 	sts	0x0230, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    921e:	82 e3       	ldi	r24, 0x32	; 50
    9220:	92 e0       	ldi	r25, 0x02	; 2
    9222:	90 93 2f 02 	sts	0x022F, r25
    9226:	80 93 2e 02 	sts	0x022E, r24
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    922a:	19 8e       	std	Y+25, r1	; 0x19
    922c:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    922e:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    9230:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    9232:	fe 01       	movw	r30, r28
    9234:	e1 92       	st	Z+, r14
    9236:	f1 92       	st	Z+, r15
    9238:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    923a:	cf 01       	movw	r24, r30
    923c:	0e 94 5d 48 	call	0x90ba	; 0x90ba <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    9240:	ce 01       	movw	r24, r28
    9242:	0c 96       	adiw	r24, 0x0c	; 12
    9244:	0e 94 5d 48 	call	0x90ba	; 0x90ba <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    9248:	d9 87       	std	Y+9, r29	; 0x09
    924a:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    924c:	db 8b       	std	Y+19, r29	; 0x13
    924e:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    9250:	83 e0       	ldi	r24, 0x03	; 3
    9252:	90 e0       	ldi	r25, 0x00	; 0
    9254:	9d 87       	std	Y+13, r25	; 0x0d
    9256:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    9258:	9e 89       	ldd	r25, Y+22	; 0x16
    925a:	80 91 24 02 	lds	r24, 0x0224
    925e:	89 17       	cp	r24, r25
    9260:	10 f4       	brcc	.+4      	; 0x9266 <xCoRoutineCreate+0xa8>
    9262:	90 93 24 02 	sts	0x0224, r25
    9266:	f9 e0       	ldi	r31, 0x09	; 9
    9268:	9f 9f       	mul	r25, r31
    926a:	c0 01       	movw	r24, r0
    926c:	11 24       	eor	r1, r1
    926e:	b8 01       	movw	r22, r16
    9270:	8c 5b       	subi	r24, 0xBC	; 188
    9272:	9d 4f       	sbci	r25, 0xFD	; 253
    9274:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>

		xReturn = pdPASS;
    9278:	81 e0       	ldi	r24, 0x01	; 1
    927a:	01 c0       	rjmp	.+2      	; 0x927e <xCoRoutineCreate+0xc0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    927c:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    927e:	df 91       	pop	r29
    9280:	cf 91       	pop	r28
    9282:	1f 91       	pop	r17
    9284:	0f 91       	pop	r16
    9286:	ff 90       	pop	r15
    9288:	ef 90       	pop	r14
    928a:	08 95       	ret

0000928c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    928c:	0f 93       	push	r16
    928e:	1f 93       	push	r17
    9290:	cf 93       	push	r28
    9292:	df 93       	push	r29
    9294:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    9296:	c0 91 22 02 	lds	r28, 0x0222
    929a:	d0 91 23 02 	lds	r29, 0x0223
    929e:	c8 0f       	add	r28, r24
    92a0:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    92a2:	80 91 1c 02 	lds	r24, 0x021C
    92a6:	90 91 1d 02 	lds	r25, 0x021D
    92aa:	02 96       	adiw	r24, 0x02	; 2
    92ac:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    92b0:	e0 91 1c 02 	lds	r30, 0x021C
    92b4:	f0 91 1d 02 	lds	r31, 0x021D
    92b8:	d3 83       	std	Z+3, r29	; 0x03
    92ba:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    92bc:	80 91 22 02 	lds	r24, 0x0222
    92c0:	90 91 23 02 	lds	r25, 0x0223
    92c4:	bf 01       	movw	r22, r30
    92c6:	6e 5f       	subi	r22, 0xFE	; 254
    92c8:	7f 4f       	sbci	r23, 0xFF	; 255
    92ca:	c8 17       	cp	r28, r24
    92cc:	d9 07       	cpc	r29, r25
    92ce:	28 f4       	brcc	.+10     	; 0x92da <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    92d0:	80 91 2e 02 	lds	r24, 0x022E
    92d4:	90 91 2f 02 	lds	r25, 0x022F
    92d8:	04 c0       	rjmp	.+8      	; 0x92e2 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    92da:	80 91 30 02 	lds	r24, 0x0230
    92de:	90 91 31 02 	lds	r25, 0x0231
    92e2:	0e 94 84 48 	call	0x9108	; 0x9108 <vListInsert>
	}

	if( pxEventList )
    92e6:	01 15       	cp	r16, r1
    92e8:	11 05       	cpc	r17, r1
    92ea:	69 f0       	breq	.+26     	; 0x9306 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    92ec:	60 91 1c 02 	lds	r22, 0x021C
    92f0:	70 91 1d 02 	lds	r23, 0x021D
    92f4:	64 5f       	subi	r22, 0xF4	; 244
    92f6:	7f 4f       	sbci	r23, 0xFF	; 255
    92f8:	c8 01       	movw	r24, r16
	}
}
    92fa:	df 91       	pop	r29
    92fc:	cf 91       	pop	r28
    92fe:	1f 91       	pop	r17
    9300:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    9302:	0c 94 84 48 	jmp	0x9108	; 0x9108 <vListInsert>
	}
}
    9306:	df 91       	pop	r29
    9308:	cf 91       	pop	r28
    930a:	1f 91       	pop	r17
    930c:	0f 91       	pop	r16
    930e:	08 95       	ret

00009310 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    9310:	ff 92       	push	r15
    9312:	0f 93       	push	r16
    9314:	1f 93       	push	r17
    9316:	cf 93       	push	r28
    9318:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    931a:	99 e0       	ldi	r25, 0x09	; 9
    931c:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    931e:	80 91 25 02 	lds	r24, 0x0225
    9322:	88 23       	and	r24, r24
    9324:	49 f1       	breq	.+82     	; 0x9378 <vCoRoutineSchedule+0x68>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    9326:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    9328:	80 91 25 02 	lds	r24, 0x0225
    932c:	88 23       	and	r24, r24
    932e:	39 f0       	breq	.+14     	; 0x933e <vCoRoutineSchedule+0x2e>
    9330:	e0 91 2a 02 	lds	r30, 0x022A
    9334:	f0 91 2b 02 	lds	r31, 0x022B
    9338:	c6 81       	ldd	r28, Z+6	; 0x06
    933a:	d7 81       	ldd	r29, Z+7	; 0x07
    933c:	02 c0       	rjmp	.+4      	; 0x9342 <vCoRoutineSchedule+0x32>
    933e:	c0 e0       	ldi	r28, 0x00	; 0
    9340:	d0 e0       	ldi	r29, 0x00	; 0
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    9342:	ce 01       	movw	r24, r28
    9344:	0c 96       	adiw	r24, 0x0c	; 12
    9346:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    934a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    934c:	8e 01       	movw	r16, r28
    934e:	0e 5f       	subi	r16, 0xFE	; 254
    9350:	1f 4f       	sbci	r17, 0xFF	; 255
    9352:	c8 01       	movw	r24, r16
    9354:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    9358:	9e 89       	ldd	r25, Y+22	; 0x16
    935a:	80 91 24 02 	lds	r24, 0x0224
    935e:	89 17       	cp	r24, r25
    9360:	10 f4       	brcc	.+4      	; 0x9366 <vCoRoutineSchedule+0x56>
    9362:	90 93 24 02 	sts	0x0224, r25
    9366:	f9 9e       	mul	r15, r25
    9368:	c0 01       	movw	r24, r0
    936a:	11 24       	eor	r1, r1
    936c:	b8 01       	movw	r22, r16
    936e:	8c 5b       	subi	r24, 0xBC	; 188
    9370:	9d 4f       	sbci	r25, 0xFD	; 253
    9372:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
    9376:	d3 cf       	rjmp	.-90     	; 0x931e <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    9378:	0e 94 f9 41 	call	0x83f2	; 0x83f2 <xTaskGetTickCount>
    937c:	20 91 20 02 	lds	r18, 0x0220
    9380:	30 91 21 02 	lds	r19, 0x0221
    9384:	82 1b       	sub	r24, r18
    9386:	93 0b       	sbc	r25, r19
    9388:	90 93 1f 02 	sts	0x021F, r25
    938c:	80 93 1e 02 	sts	0x021E, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    9390:	89 e0       	ldi	r24, 0x09	; 9
    9392:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    9394:	20 91 1e 02 	lds	r18, 0x021E
    9398:	30 91 1f 02 	lds	r19, 0x021F
    939c:	80 91 22 02 	lds	r24, 0x0222
    93a0:	90 91 23 02 	lds	r25, 0x0223
    93a4:	21 15       	cp	r18, r1
    93a6:	31 05       	cpc	r19, r1
    93a8:	09 f4       	brne	.+2      	; 0x93ac <vCoRoutineSchedule+0x9c>
    93aa:	56 c0       	rjmp	.+172    	; 0x9458 <vCoRoutineSchedule+0x148>
	{
		xCoRoutineTickCount++;
    93ac:	01 96       	adiw	r24, 0x01	; 1
    93ae:	90 93 23 02 	sts	0x0223, r25
    93b2:	80 93 22 02 	sts	0x0222, r24
		xPassedTicks--;
    93b6:	21 50       	subi	r18, 0x01	; 1
    93b8:	31 09       	sbc	r19, r1
    93ba:	30 93 1f 02 	sts	0x021F, r19
    93be:	20 93 1e 02 	sts	0x021E, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    93c2:	89 2b       	or	r24, r25
    93c4:	09 f0       	breq	.+2      	; 0x93c8 <vCoRoutineSchedule+0xb8>
    93c6:	40 c0       	rjmp	.+128    	; 0x9448 <vCoRoutineSchedule+0x138>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    93c8:	80 91 30 02 	lds	r24, 0x0230
    93cc:	90 91 31 02 	lds	r25, 0x0231
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    93d0:	20 91 2e 02 	lds	r18, 0x022E
    93d4:	30 91 2f 02 	lds	r19, 0x022F
    93d8:	30 93 31 02 	sts	0x0231, r19
    93dc:	20 93 30 02 	sts	0x0230, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    93e0:	90 93 2f 02 	sts	0x022F, r25
    93e4:	80 93 2e 02 	sts	0x022E, r24
    93e8:	2f c0       	rjmp	.+94     	; 0x9448 <vCoRoutineSchedule+0x138>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    93ea:	05 80       	ldd	r0, Z+5	; 0x05
    93ec:	f6 81       	ldd	r31, Z+6	; 0x06
    93ee:	e0 2d       	mov	r30, r0
    93f0:	c6 81       	ldd	r28, Z+6	; 0x06
    93f2:	d7 81       	ldd	r29, Z+7	; 0x07
    93f4:	20 97       	sbiw	r28, 0x00	; 0
    93f6:	71 f2       	breq	.-100    	; 0x9394 <vCoRoutineSchedule+0x84>
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    93f8:	20 91 22 02 	lds	r18, 0x0222
    93fc:	30 91 23 02 	lds	r19, 0x0223
    9400:	8a 81       	ldd	r24, Y+2	; 0x02
    9402:	9b 81       	ldd	r25, Y+3	; 0x03
    9404:	28 17       	cp	r18, r24
    9406:	39 07       	cpc	r19, r25
    9408:	28 f2       	brcs	.-118    	; 0x9394 <vCoRoutineSchedule+0x84>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    940a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    940c:	8e 01       	movw	r16, r28
    940e:	0e 5f       	subi	r16, 0xFE	; 254
    9410:	1f 4f       	sbci	r17, 0xFF	; 255
    9412:	c8 01       	movw	r24, r16
    9414:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    9418:	8c 89       	ldd	r24, Y+20	; 0x14
    941a:	9d 89       	ldd	r25, Y+21	; 0x15
    941c:	89 2b       	or	r24, r25
    941e:	21 f0       	breq	.+8      	; 0x9428 <vCoRoutineSchedule+0x118>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    9420:	ce 01       	movw	r24, r28
    9422:	0c 96       	adiw	r24, 0x0c	; 12
    9424:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    9428:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    942a:	9e 89       	ldd	r25, Y+22	; 0x16
    942c:	80 91 24 02 	lds	r24, 0x0224
    9430:	89 17       	cp	r24, r25
    9432:	10 f4       	brcc	.+4      	; 0x9438 <vCoRoutineSchedule+0x128>
    9434:	90 93 24 02 	sts	0x0224, r25
    9438:	f9 9e       	mul	r15, r25
    943a:	c0 01       	movw	r24, r0
    943c:	11 24       	eor	r1, r1
    943e:	b8 01       	movw	r22, r16
    9440:	8c 5b       	subi	r24, 0xBC	; 188
    9442:	9d 4f       	sbci	r25, 0xFD	; 253
    9444:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    9448:	e0 91 30 02 	lds	r30, 0x0230
    944c:	f0 91 31 02 	lds	r31, 0x0231
    9450:	80 81       	ld	r24, Z
    9452:	81 11       	cpse	r24, r1
    9454:	ca cf       	rjmp	.-108    	; 0x93ea <vCoRoutineSchedule+0xda>
    9456:	9e cf       	rjmp	.-196    	; 0x9394 <vCoRoutineSchedule+0x84>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    9458:	90 93 21 02 	sts	0x0221, r25
    945c:	80 93 20 02 	sts	0x0220, r24
    9460:	80 91 24 02 	lds	r24, 0x0224

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    9464:	69 e0       	ldi	r22, 0x09	; 9
    9466:	48 2f       	mov	r20, r24
    9468:	50 e0       	ldi	r21, 0x00	; 0
    946a:	64 9f       	mul	r22, r20
    946c:	90 01       	movw	r18, r0
    946e:	65 9f       	mul	r22, r21
    9470:	30 0d       	add	r19, r0
    9472:	11 24       	eor	r1, r1
    9474:	f9 01       	movw	r30, r18
    9476:	ec 5b       	subi	r30, 0xBC	; 188
    9478:	fd 4f       	sbci	r31, 0xFD	; 253
    947a:	90 81       	ld	r25, Z
    947c:	91 11       	cpse	r25, r1
    947e:	0c c0       	rjmp	.+24     	; 0x9498 <vCoRoutineSchedule+0x188>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    9480:	81 11       	cpse	r24, r1
    9482:	08 c0       	rjmp	.+16     	; 0x9494 <vCoRoutineSchedule+0x184>
    9484:	10 92 24 02 	sts	0x0224, r1

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    9488:	df 91       	pop	r29
    948a:	cf 91       	pop	r28
    948c:	1f 91       	pop	r17
    948e:	0f 91       	pop	r16
    9490:	ff 90       	pop	r15
    9492:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    9494:	81 50       	subi	r24, 0x01	; 1
    9496:	e7 cf       	rjmp	.-50     	; 0x9466 <vCoRoutineSchedule+0x156>
    9498:	80 93 24 02 	sts	0x0224, r24
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    949c:	a1 81       	ldd	r26, Z+1	; 0x01
    949e:	b2 81       	ldd	r27, Z+2	; 0x02
    94a0:	12 96       	adiw	r26, 0x02	; 2
    94a2:	0d 90       	ld	r0, X+
    94a4:	bc 91       	ld	r27, X
    94a6:	a0 2d       	mov	r26, r0
    94a8:	b2 83       	std	Z+2, r27	; 0x02
    94aa:	a1 83       	std	Z+1, r26	; 0x01
    94ac:	29 5b       	subi	r18, 0xB9	; 185
    94ae:	3d 4f       	sbci	r19, 0xFD	; 253
    94b0:	a2 17       	cp	r26, r18
    94b2:	b3 07       	cpc	r27, r19
    94b4:	31 f4       	brne	.+12     	; 0x94c2 <vCoRoutineSchedule+0x1b2>
    94b6:	12 96       	adiw	r26, 0x02	; 2
    94b8:	8d 91       	ld	r24, X+
    94ba:	9c 91       	ld	r25, X
    94bc:	13 97       	sbiw	r26, 0x03	; 3
    94be:	92 83       	std	Z+2, r25	; 0x02
    94c0:	81 83       	std	Z+1, r24	; 0x01
    94c2:	89 e0       	ldi	r24, 0x09	; 9
    94c4:	84 9f       	mul	r24, r20
    94c6:	f0 01       	movw	r30, r0
    94c8:	85 9f       	mul	r24, r21
    94ca:	f0 0d       	add	r31, r0
    94cc:	11 24       	eor	r1, r1
    94ce:	ec 5b       	subi	r30, 0xBC	; 188
    94d0:	fd 4f       	sbci	r31, 0xFD	; 253
    94d2:	01 80       	ldd	r0, Z+1	; 0x01
    94d4:	f2 81       	ldd	r31, Z+2	; 0x02
    94d6:	e0 2d       	mov	r30, r0
    94d8:	86 81       	ldd	r24, Z+6	; 0x06
    94da:	97 81       	ldd	r25, Z+7	; 0x07
    94dc:	90 93 1d 02 	sts	0x021D, r25
    94e0:	80 93 1c 02 	sts	0x021C, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    94e4:	dc 01       	movw	r26, r24
    94e6:	ed 91       	ld	r30, X+
    94e8:	fc 91       	ld	r31, X
    94ea:	11 97       	sbiw	r26, 0x01	; 1
    94ec:	57 96       	adiw	r26, 0x17	; 23
    94ee:	6c 91       	ld	r22, X

	return;
}
    94f0:	df 91       	pop	r29
    94f2:	cf 91       	pop	r28
    94f4:	1f 91       	pop	r17
    94f6:	0f 91       	pop	r16
    94f8:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    94fa:	09 94       	ijmp

000094fc <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    94fc:	0f 93       	push	r16
    94fe:	1f 93       	push	r17
    9500:	cf 93       	push	r28
    9502:	df 93       	push	r29
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    9504:	dc 01       	movw	r26, r24
    9506:	2c 91       	ld	r18, X
    9508:	22 23       	and	r18, r18
    950a:	39 f0       	breq	.+14     	; 0x951a <xCoRoutineRemoveFromEventList+0x1e>
    950c:	15 96       	adiw	r26, 0x05	; 5
    950e:	ed 91       	ld	r30, X+
    9510:	fc 91       	ld	r31, X
    9512:	16 97       	sbiw	r26, 0x06	; 6
    9514:	c6 81       	ldd	r28, Z+6	; 0x06
    9516:	d7 81       	ldd	r29, Z+7	; 0x07
    9518:	02 c0       	rjmp	.+4      	; 0x951e <xCoRoutineRemoveFromEventList+0x22>
    951a:	c0 e0       	ldi	r28, 0x00	; 0
    951c:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    951e:	8e 01       	movw	r16, r28
    9520:	04 5f       	subi	r16, 0xF4	; 244
    9522:	1f 4f       	sbci	r17, 0xFF	; 255
    9524:	c8 01       	movw	r24, r16
    9526:	0e 94 bb 48 	call	0x9176	; 0x9176 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    952a:	b8 01       	movw	r22, r16
    952c:	85 e2       	ldi	r24, 0x25	; 37
    952e:	92 e0       	ldi	r25, 0x02	; 2
    9530:	0e 94 61 48 	call	0x90c2	; 0x90c2 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    9534:	e0 91 1c 02 	lds	r30, 0x021C
    9538:	f0 91 1d 02 	lds	r31, 0x021D
    953c:	81 e0       	ldi	r24, 0x01	; 1
    953e:	2e 89       	ldd	r18, Y+22	; 0x16
    9540:	96 89       	ldd	r25, Z+22	; 0x16
    9542:	29 17       	cp	r18, r25
    9544:	08 f4       	brcc	.+2      	; 0x9548 <xCoRoutineRemoveFromEventList+0x4c>
    9546:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    9548:	df 91       	pop	r29
    954a:	cf 91       	pop	r28
    954c:	1f 91       	pop	r17
    954e:	0f 91       	pop	r16
    9550:	08 95       	ret

00009552 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    9552:	0f 93       	push	r16
    9554:	1f 93       	push	r17
    9556:	cf 93       	push	r28
    9558:	df 93       	push	r29
    955a:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    955c:	0e 94 f3 41 	call	0x83e6	; 0x83e6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    9560:	c0 91 4d 02 	lds	r28, 0x024D
    9564:	d0 91 4e 02 	lds	r29, 0x024E
    9568:	c8 01       	movw	r24, r16
    956a:	8c 0f       	add	r24, r28
    956c:	9d 1f       	adc	r25, r29
    956e:	8c 31       	cpi	r24, 0x1C	; 28
    9570:	2c e0       	ldi	r18, 0x0C	; 12
    9572:	92 07       	cpc	r25, r18
    9574:	50 f4       	brcc	.+20     	; 0x958a <pvPortMalloc+0x38>
    9576:	c8 17       	cp	r28, r24
    9578:	d9 07       	cpc	r29, r25
    957a:	38 f4       	brcc	.+14     	; 0x958a <pvPortMalloc+0x38>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    957c:	c1 5b       	subi	r28, 0xB1	; 177
    957e:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    9580:	90 93 4e 02 	sts	0x024E, r25
    9584:	80 93 4d 02 	sts	0x024D, r24
    9588:	02 c0       	rjmp	.+4      	; 0x958e <pvPortMalloc+0x3c>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    958a:	c0 e0       	ldi	r28, 0x00	; 0
    958c:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    958e:	0e 94 b5 42 	call	0x856a	; 0x856a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    9592:	ce 01       	movw	r24, r28
    9594:	df 91       	pop	r29
    9596:	cf 91       	pop	r28
    9598:	1f 91       	pop	r17
    959a:	0f 91       	pop	r16
    959c:	08 95       	ret

0000959e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    959e:	08 95       	ret

000095a0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    95a0:	10 92 4e 02 	sts	0x024E, r1
    95a4:	10 92 4d 02 	sts	0x024D, r1
    95a8:	08 95       	ret

000095aa <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    95aa:	20 91 4d 02 	lds	r18, 0x024D
    95ae:	30 91 4e 02 	lds	r19, 0x024E
}
    95b2:	8c e1       	ldi	r24, 0x1C	; 28
    95b4:	9c e0       	ldi	r25, 0x0C	; 12
    95b6:	82 1b       	sub	r24, r18
    95b8:	93 0b       	sbc	r25, r19
    95ba:	08 95       	ret

000095bc <pxPortInitialiseStack>:
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    95bc:	31 e1       	ldi	r19, 0x11	; 17
    95be:	fc 01       	movw	r30, r24
    95c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    95c2:	31 97       	sbiw	r30, 0x01	; 1
    95c4:	22 e2       	ldi	r18, 0x22	; 34
    95c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    95c8:	31 97       	sbiw	r30, 0x01	; 1
    95ca:	a3 e3       	ldi	r26, 0x33	; 51
    95cc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    95ce:	31 97       	sbiw	r30, 0x01	; 1
    95d0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    95d2:	31 97       	sbiw	r30, 0x01	; 1
    95d4:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    95d6:	31 97       	sbiw	r30, 0x01	; 1
    95d8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    95da:	31 97       	sbiw	r30, 0x01	; 1
    95dc:	60 e8       	ldi	r22, 0x80	; 128
    95de:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    95e0:	31 97       	sbiw	r30, 0x01	; 1
    95e2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    95e4:	31 97       	sbiw	r30, 0x01	; 1
    95e6:	62 e0       	ldi	r22, 0x02	; 2
    95e8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    95ea:	31 97       	sbiw	r30, 0x01	; 1
    95ec:	63 e0       	ldi	r22, 0x03	; 3
    95ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    95f0:	31 97       	sbiw	r30, 0x01	; 1
    95f2:	64 e0       	ldi	r22, 0x04	; 4
    95f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    95f6:	31 97       	sbiw	r30, 0x01	; 1
    95f8:	65 e0       	ldi	r22, 0x05	; 5
    95fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    95fc:	31 97       	sbiw	r30, 0x01	; 1
    95fe:	66 e0       	ldi	r22, 0x06	; 6
    9600:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    9602:	31 97       	sbiw	r30, 0x01	; 1
    9604:	67 e0       	ldi	r22, 0x07	; 7
    9606:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    9608:	31 97       	sbiw	r30, 0x01	; 1
    960a:	68 e0       	ldi	r22, 0x08	; 8
    960c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    960e:	31 97       	sbiw	r30, 0x01	; 1
    9610:	69 e0       	ldi	r22, 0x09	; 9
    9612:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    9614:	31 97       	sbiw	r30, 0x01	; 1
    9616:	60 e1       	ldi	r22, 0x10	; 16
    9618:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    961a:	31 97       	sbiw	r30, 0x01	; 1
    961c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    961e:	31 97       	sbiw	r30, 0x01	; 1
    9620:	32 e1       	ldi	r19, 0x12	; 18
    9622:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    9624:	31 97       	sbiw	r30, 0x01	; 1
    9626:	33 e1       	ldi	r19, 0x13	; 19
    9628:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    962a:	31 97       	sbiw	r30, 0x01	; 1
    962c:	34 e1       	ldi	r19, 0x14	; 20
    962e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    9630:	31 97       	sbiw	r30, 0x01	; 1
    9632:	35 e1       	ldi	r19, 0x15	; 21
    9634:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    9636:	31 97       	sbiw	r30, 0x01	; 1
    9638:	36 e1       	ldi	r19, 0x16	; 22
    963a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    963c:	31 97       	sbiw	r30, 0x01	; 1
    963e:	37 e1       	ldi	r19, 0x17	; 23
    9640:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    9642:	31 97       	sbiw	r30, 0x01	; 1
    9644:	38 e1       	ldi	r19, 0x18	; 24
    9646:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    9648:	31 97       	sbiw	r30, 0x01	; 1
    964a:	39 e1       	ldi	r19, 0x19	; 25
    964c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    964e:	31 97       	sbiw	r30, 0x01	; 1
    9650:	30 e2       	ldi	r19, 0x20	; 32
    9652:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    9654:	31 97       	sbiw	r30, 0x01	; 1
    9656:	31 e2       	ldi	r19, 0x21	; 33
    9658:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    965a:	31 97       	sbiw	r30, 0x01	; 1
    965c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    965e:	31 97       	sbiw	r30, 0x01	; 1
    9660:	23 e2       	ldi	r18, 0x23	; 35
    9662:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    9664:	31 97       	sbiw	r30, 0x01	; 1
    9666:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    9668:	31 97       	sbiw	r30, 0x01	; 1
    966a:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    966c:	31 97       	sbiw	r30, 0x01	; 1
    966e:	26 e2       	ldi	r18, 0x26	; 38
    9670:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    9672:	31 97       	sbiw	r30, 0x01	; 1
    9674:	27 e2       	ldi	r18, 0x27	; 39
    9676:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    9678:	31 97       	sbiw	r30, 0x01	; 1
    967a:	28 e2       	ldi	r18, 0x28	; 40
    967c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    967e:	31 97       	sbiw	r30, 0x01	; 1
    9680:	29 e2       	ldi	r18, 0x29	; 41
    9682:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    9684:	31 97       	sbiw	r30, 0x01	; 1
    9686:	20 e3       	ldi	r18, 0x30	; 48
    9688:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    968a:	31 97       	sbiw	r30, 0x01	; 1
    968c:	21 e3       	ldi	r18, 0x31	; 49
    968e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    9690:	86 97       	sbiw	r24, 0x26	; 38
    9692:	08 95       	ret

00009694 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
    9694:	83 e1       	ldi	r24, 0x13	; 19
    9696:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
    9698:	87 e8       	ldi	r24, 0x87	; 135
    969a:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    969c:	8b e0       	ldi	r24, 0x0B	; 11
    969e:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    96a0:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    96a2:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    96a4:	87 bf       	out	0x37, r24	; 55
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    96a6:	a0 91 93 01 	lds	r26, 0x0193
    96aa:	b0 91 94 01 	lds	r27, 0x0194
    96ae:	cd 91       	ld	r28, X+
    96b0:	cd bf       	out	0x3d, r28	; 61
    96b2:	dd 91       	ld	r29, X+
    96b4:	de bf       	out	0x3e, r29	; 62
    96b6:	ff 91       	pop	r31
    96b8:	ef 91       	pop	r30
    96ba:	df 91       	pop	r29
    96bc:	cf 91       	pop	r28
    96be:	bf 91       	pop	r27
    96c0:	af 91       	pop	r26
    96c2:	9f 91       	pop	r25
    96c4:	8f 91       	pop	r24
    96c6:	7f 91       	pop	r23
    96c8:	6f 91       	pop	r22
    96ca:	5f 91       	pop	r21
    96cc:	4f 91       	pop	r20
    96ce:	3f 91       	pop	r19
    96d0:	2f 91       	pop	r18
    96d2:	1f 91       	pop	r17
    96d4:	0f 91       	pop	r16
    96d6:	ff 90       	pop	r15
    96d8:	ef 90       	pop	r14
    96da:	df 90       	pop	r13
    96dc:	cf 90       	pop	r12
    96de:	bf 90       	pop	r11
    96e0:	af 90       	pop	r10
    96e2:	9f 90       	pop	r9
    96e4:	8f 90       	pop	r8
    96e6:	7f 90       	pop	r7
    96e8:	6f 90       	pop	r6
    96ea:	5f 90       	pop	r5
    96ec:	4f 90       	pop	r4
    96ee:	3f 90       	pop	r3
    96f0:	2f 90       	pop	r2
    96f2:	1f 90       	pop	r1
    96f4:	0f 90       	pop	r0
    96f6:	0f be       	out	0x3f, r0	; 63
    96f8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    96fa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    96fc:	81 e0       	ldi	r24, 0x01	; 1
    96fe:	08 95       	ret

00009700 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    9700:	08 95       	ret

00009702 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    9702:	0f 92       	push	r0
    9704:	0f b6       	in	r0, 0x3f	; 63
    9706:	f8 94       	cli
    9708:	0f 92       	push	r0
    970a:	1f 92       	push	r1
    970c:	11 24       	eor	r1, r1
    970e:	2f 92       	push	r2
    9710:	3f 92       	push	r3
    9712:	4f 92       	push	r4
    9714:	5f 92       	push	r5
    9716:	6f 92       	push	r6
    9718:	7f 92       	push	r7
    971a:	8f 92       	push	r8
    971c:	9f 92       	push	r9
    971e:	af 92       	push	r10
    9720:	bf 92       	push	r11
    9722:	cf 92       	push	r12
    9724:	df 92       	push	r13
    9726:	ef 92       	push	r14
    9728:	ff 92       	push	r15
    972a:	0f 93       	push	r16
    972c:	1f 93       	push	r17
    972e:	2f 93       	push	r18
    9730:	3f 93       	push	r19
    9732:	4f 93       	push	r20
    9734:	5f 93       	push	r21
    9736:	6f 93       	push	r22
    9738:	7f 93       	push	r23
    973a:	8f 93       	push	r24
    973c:	9f 93       	push	r25
    973e:	af 93       	push	r26
    9740:	bf 93       	push	r27
    9742:	cf 93       	push	r28
    9744:	df 93       	push	r29
    9746:	ef 93       	push	r30
    9748:	ff 93       	push	r31
    974a:	a0 91 93 01 	lds	r26, 0x0193
    974e:	b0 91 94 01 	lds	r27, 0x0194
    9752:	0d b6       	in	r0, 0x3d	; 61
    9754:	0d 92       	st	X+, r0
    9756:	0e b6       	in	r0, 0x3e	; 62
    9758:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    975a:	0e 94 0c 44 	call	0x8818	; 0x8818 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    975e:	a0 91 93 01 	lds	r26, 0x0193
    9762:	b0 91 94 01 	lds	r27, 0x0194
    9766:	cd 91       	ld	r28, X+
    9768:	cd bf       	out	0x3d, r28	; 61
    976a:	dd 91       	ld	r29, X+
    976c:	de bf       	out	0x3e, r29	; 62
    976e:	ff 91       	pop	r31
    9770:	ef 91       	pop	r30
    9772:	df 91       	pop	r29
    9774:	cf 91       	pop	r28
    9776:	bf 91       	pop	r27
    9778:	af 91       	pop	r26
    977a:	9f 91       	pop	r25
    977c:	8f 91       	pop	r24
    977e:	7f 91       	pop	r23
    9780:	6f 91       	pop	r22
    9782:	5f 91       	pop	r21
    9784:	4f 91       	pop	r20
    9786:	3f 91       	pop	r19
    9788:	2f 91       	pop	r18
    978a:	1f 91       	pop	r17
    978c:	0f 91       	pop	r16
    978e:	ff 90       	pop	r15
    9790:	ef 90       	pop	r14
    9792:	df 90       	pop	r13
    9794:	cf 90       	pop	r12
    9796:	bf 90       	pop	r11
    9798:	af 90       	pop	r10
    979a:	9f 90       	pop	r9
    979c:	8f 90       	pop	r8
    979e:	7f 90       	pop	r7
    97a0:	6f 90       	pop	r6
    97a2:	5f 90       	pop	r5
    97a4:	4f 90       	pop	r4
    97a6:	3f 90       	pop	r3
    97a8:	2f 90       	pop	r2
    97aa:	1f 90       	pop	r1
    97ac:	0f 90       	pop	r0
    97ae:	0f be       	out	0x3f, r0	; 63
    97b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    97b2:	08 95       	ret

000097b4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    97b4:	0f 92       	push	r0
    97b6:	0f b6       	in	r0, 0x3f	; 63
    97b8:	f8 94       	cli
    97ba:	0f 92       	push	r0
    97bc:	1f 92       	push	r1
    97be:	11 24       	eor	r1, r1
    97c0:	2f 92       	push	r2
    97c2:	3f 92       	push	r3
    97c4:	4f 92       	push	r4
    97c6:	5f 92       	push	r5
    97c8:	6f 92       	push	r6
    97ca:	7f 92       	push	r7
    97cc:	8f 92       	push	r8
    97ce:	9f 92       	push	r9
    97d0:	af 92       	push	r10
    97d2:	bf 92       	push	r11
    97d4:	cf 92       	push	r12
    97d6:	df 92       	push	r13
    97d8:	ef 92       	push	r14
    97da:	ff 92       	push	r15
    97dc:	0f 93       	push	r16
    97de:	1f 93       	push	r17
    97e0:	2f 93       	push	r18
    97e2:	3f 93       	push	r19
    97e4:	4f 93       	push	r20
    97e6:	5f 93       	push	r21
    97e8:	6f 93       	push	r22
    97ea:	7f 93       	push	r23
    97ec:	8f 93       	push	r24
    97ee:	9f 93       	push	r25
    97f0:	af 93       	push	r26
    97f2:	bf 93       	push	r27
    97f4:	cf 93       	push	r28
    97f6:	df 93       	push	r29
    97f8:	ef 93       	push	r30
    97fa:	ff 93       	push	r31
    97fc:	a0 91 93 01 	lds	r26, 0x0193
    9800:	b0 91 94 01 	lds	r27, 0x0194
    9804:	0d b6       	in	r0, 0x3d	; 61
    9806:	0d 92       	st	X+, r0
    9808:	0e b6       	in	r0, 0x3e	; 62
    980a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    980c:	0e 94 35 42 	call	0x846a	; 0x846a <vTaskIncrementTick>
	vTaskSwitchContext();
    9810:	0e 94 0c 44 	call	0x8818	; 0x8818 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    9814:	a0 91 93 01 	lds	r26, 0x0193
    9818:	b0 91 94 01 	lds	r27, 0x0194
    981c:	cd 91       	ld	r28, X+
    981e:	cd bf       	out	0x3d, r28	; 61
    9820:	dd 91       	ld	r29, X+
    9822:	de bf       	out	0x3e, r29	; 62
    9824:	ff 91       	pop	r31
    9826:	ef 91       	pop	r30
    9828:	df 91       	pop	r29
    982a:	cf 91       	pop	r28
    982c:	bf 91       	pop	r27
    982e:	af 91       	pop	r26
    9830:	9f 91       	pop	r25
    9832:	8f 91       	pop	r24
    9834:	7f 91       	pop	r23
    9836:	6f 91       	pop	r22
    9838:	5f 91       	pop	r21
    983a:	4f 91       	pop	r20
    983c:	3f 91       	pop	r19
    983e:	2f 91       	pop	r18
    9840:	1f 91       	pop	r17
    9842:	0f 91       	pop	r16
    9844:	ff 90       	pop	r15
    9846:	ef 90       	pop	r14
    9848:	df 90       	pop	r13
    984a:	cf 90       	pop	r12
    984c:	bf 90       	pop	r11
    984e:	af 90       	pop	r10
    9850:	9f 90       	pop	r9
    9852:	8f 90       	pop	r8
    9854:	7f 90       	pop	r7
    9856:	6f 90       	pop	r6
    9858:	5f 90       	pop	r5
    985a:	4f 90       	pop	r4
    985c:	3f 90       	pop	r3
    985e:	2f 90       	pop	r2
    9860:	1f 90       	pop	r1
    9862:	0f 90       	pop	r0
    9864:	0f be       	out	0x3f, r0	; 63
    9866:	0f 90       	pop	r0

	asm volatile ( "ret" );
    9868:	08 95       	ret

0000986a <__vector_12>:
    986a:	1f 92       	push	r1
    986c:	0f 92       	push	r0
    986e:	0f b6       	in	r0, 0x3f	; 63
    9870:	0f 92       	push	r0
    9872:	11 24       	eor	r1, r1
    9874:	0b b6       	in	r0, 0x3b	; 59
    9876:	0f 92       	push	r0
    9878:	2f 93       	push	r18
    987a:	3f 93       	push	r19
    987c:	4f 93       	push	r20
    987e:	5f 93       	push	r21
    9880:	6f 93       	push	r22
    9882:	7f 93       	push	r23
    9884:	8f 93       	push	r24
    9886:	9f 93       	push	r25
    9888:	af 93       	push	r26
    988a:	bf 93       	push	r27
    988c:	ef 93       	push	r30
    988e:	ff 93       	push	r31
    9890:	0e 94 35 42 	call	0x846a	; 0x846a <vTaskIncrementTick>
    9894:	ff 91       	pop	r31
    9896:	ef 91       	pop	r30
    9898:	bf 91       	pop	r27
    989a:	af 91       	pop	r26
    989c:	9f 91       	pop	r25
    989e:	8f 91       	pop	r24
    98a0:	7f 91       	pop	r23
    98a2:	6f 91       	pop	r22
    98a4:	5f 91       	pop	r21
    98a6:	4f 91       	pop	r20
    98a8:	3f 91       	pop	r19
    98aa:	2f 91       	pop	r18
    98ac:	0f 90       	pop	r0
    98ae:	0b be       	out	0x3b, r0	; 59
    98b0:	0f 90       	pop	r0
    98b2:	0f be       	out	0x3f, r0	; 63
    98b4:	0f 90       	pop	r0
    98b6:	1f 90       	pop	r1
    98b8:	18 95       	reti

000098ba <main>:
FILE udpStream;

streamBuffers_t udpBuffers;

portSHORT main( void )
{
    98ba:	af 92       	push	r10
    98bc:	bf 92       	push	r11
    98be:	cf 92       	push	r12
    98c0:	df 92       	push	r13
    98c2:	ef 92       	push	r14
    98c4:	ff 92       	push	r15
    98c6:	0f 93       	push	r16
  ramDyskInit();              //Inicjalizacja Ram dysku
    98c8:	0e 94 46 1b 	call	0x368c	; 0x368c <ramDyskInit>
  hardwareInit();
    98cc:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <hardwareInit>
  spiInit(disableAllSpiDevices);
    98d0:	80 e2       	ldi	r24, 0x20	; 32
    98d2:	9f e0       	ldi	r25, 0x0F	; 15
    98d4:	0e 94 15 1a 	call	0x342a	; 0x342a <spiInit>

// VTY on serial
  xSerialPortInitMinimal();
    98d8:	0e 94 9f 0b 	call	0x173e	; 0x173e <xSerialPortInitMinimal>
  CLIStateSerialUsb  = xmalloc(sizeof(cmdState_t));
    98dc:	83 e2       	ldi	r24, 0x23	; 35
    98de:	90 e0       	ldi	r25, 0x00	; 0
    98e0:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <xmalloc>
    98e4:	90 93 9f 0e 	sts	0x0E9F, r25
    98e8:	80 93 9e 0e 	sts	0x0E9E, r24
  CLIStateSerialUdp  = xmalloc(sizeof(cmdState_t));
    98ec:	83 e2       	ldi	r24, 0x23	; 35
    98ee:	90 e0       	ldi	r25, 0x00	; 0
    98f0:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <xmalloc>
    98f4:	90 93 5f 0f 	sts	0x0F5F, r25
    98f8:	80 93 5e 0f 	sts	0x0F5E, r24


//  cmdStateClear(newCmdState);

  sensorsTaskInit();
    98fc:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <sensorsTaskInit>
  loadConfiguration();
    9900:	0e 94 67 0b 	call	0x16ce	; 0x16ce <loadConfiguration>

  initQueueStreamUSB(&usbStream);
    9904:	8b e6       	ldi	r24, 0x6B	; 107
    9906:	9e e0       	ldi	r25, 0x0E	; 14
    9908:	0e 94 91 0b 	call	0x1722	; 0x1722 <initQueueStreamUSB>
  VtyInit(CLIStateSerialUsb, &usbStream);
    990c:	6b e6       	ldi	r22, 0x6B	; 107
    990e:	7e e0       	ldi	r23, 0x0E	; 14
    9910:	80 91 9e 0e 	lds	r24, 0x0E9E
    9914:	90 91 9f 0e 	lds	r25, 0x0E9F
    9918:	0e 94 32 17 	call	0x2e64	; 0x2e64 <VtyInit>

  udpInit_0();
    991c:	0e 94 6c 36 	call	0x6cd8	; 0x6cd8 <udpInit_0>
  socketInit();
    9920:	0e 94 b5 33 	call	0x676a	; 0x676a <socketInit>
  initQueueStream(&udpStream, &udpBuffers, udpSocket->Rx, udpSocket->Tx);
    9924:	e0 91 a2 0e 	lds	r30, 0x0EA2
    9928:	f0 91 a3 0e 	lds	r31, 0x0EA3
    992c:	24 85       	ldd	r18, Z+12	; 0x0c
    992e:	35 85       	ldd	r19, Z+13	; 0x0d
    9930:	42 85       	ldd	r20, Z+10	; 0x0a
    9932:	53 85       	ldd	r21, Z+11	; 0x0b
    9934:	65 ec       	ldi	r22, 0xC5	; 197
    9936:	7e e0       	ldi	r23, 0x0E	; 14
    9938:	8e e8       	ldi	r24, 0x8E	; 142
    993a:	9e e0       	ldi	r25, 0x0E	; 14
    993c:	0e 94 67 2a 	call	0x54ce	; 0x54ce <initQueueStream>
  VtyInit(CLIStateSerialUdp, &udpStream);
    9940:	6e e8       	ldi	r22, 0x8E	; 142
    9942:	7e e0       	ldi	r23, 0x0E	; 14
    9944:	80 91 5e 0f 	lds	r24, 0x0F5E
    9948:	90 91 5f 0f 	lds	r25, 0x0F5F
    994c:	0e 94 32 17 	call	0x2e64	; 0x2e64 <VtyInit>

//xTaskCreate(encTask,        NULL /*"ENC"    */, STACK_SIZE_ENC,       (void *)CLIStateSerialUsb->myStdInOut,  0, &xHandleEnc);
  xTaskCreate(vTaskVTYusb,    NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUsb),            1, &xHandleVTY_USB);
    9950:	20 91 9e 0e 	lds	r18, 0x0E9E
    9954:	30 91 9f 0e 	lds	r19, 0x0E9F
    9958:	a1 2c       	mov	r10, r1
    995a:	b1 2c       	mov	r11, r1
    995c:	c1 2c       	mov	r12, r1
    995e:	d1 2c       	mov	r13, r1
    9960:	8a eb       	ldi	r24, 0xBA	; 186
    9962:	e8 2e       	mov	r14, r24
    9964:	8e e0       	ldi	r24, 0x0E	; 14
    9966:	f8 2e       	mov	r15, r24
    9968:	01 e0       	ldi	r16, 0x01	; 1
    996a:	4c eb       	ldi	r20, 0xBC	; 188
    996c:	52 e0       	ldi	r21, 0x02	; 2
    996e:	60 e0       	ldi	r22, 0x00	; 0
    9970:	70 e0       	ldi	r23, 0x00	; 0
    9972:	8a ed       	ldi	r24, 0xDA	; 218
    9974:	99 e1       	ldi	r25, 0x19	; 25
    9976:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <xTaskGenericCreate>
//xTaskCreate(vTaskVTYsocket, NULL /*"VTY"    */, STACK_SIZE_VTY,       (void *)(CLIStateSerialUdp),            1, &xHandleVTY_UDP);
  xTaskCreate(sensorsTask,    NULL /*"Sensors"*/, STACK_SIZE_SENSORS,   NULL,                                   1, &xHandleSensors);
    997a:	96 ea       	ldi	r25, 0xA6	; 166
    997c:	e9 2e       	mov	r14, r25
    997e:	9e e0       	ldi	r25, 0x0E	; 14
    9980:	f9 2e       	mov	r15, r25
    9982:	20 e0       	ldi	r18, 0x00	; 0
    9984:	30 e0       	ldi	r19, 0x00	; 0
    9986:	44 ef       	ldi	r20, 0xF4	; 244
    9988:	51 e0       	ldi	r21, 0x01	; 1
    998a:	60 e0       	ldi	r22, 0x00	; 0
    998c:	70 e0       	ldi	r23, 0x00	; 0
    998e:	8a e9       	ldi	r24, 0x9A	; 154
    9990:	9f e0       	ldi	r25, 0x0F	; 15
    9992:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <xTaskGenericCreate>
  vTaskStartScheduler();
    9996:	0e 94 bc 41 	call	0x8378	; 0x8378 <vTaskStartScheduler>
  return 0;
}
    999a:	80 e0       	ldi	r24, 0x00	; 0
    999c:	90 e0       	ldi	r25, 0x00	; 0
    999e:	0f 91       	pop	r16
    99a0:	ff 90       	pop	r15
    99a2:	ef 90       	pop	r14
    99a4:	df 90       	pop	r13
    99a6:	cf 90       	pop	r12
    99a8:	bf 90       	pop	r11
    99aa:	af 90       	pop	r10
    99ac:	08 95       	ret

000099ae <__udivmodqi4>:
    99ae:	99 1b       	sub	r25, r25
    99b0:	79 e0       	ldi	r23, 0x09	; 9
    99b2:	04 c0       	rjmp	.+8      	; 0x99bc <__udivmodqi4_ep>

000099b4 <__udivmodqi4_loop>:
    99b4:	99 1f       	adc	r25, r25
    99b6:	96 17       	cp	r25, r22
    99b8:	08 f0       	brcs	.+2      	; 0x99bc <__udivmodqi4_ep>
    99ba:	96 1b       	sub	r25, r22

000099bc <__udivmodqi4_ep>:
    99bc:	88 1f       	adc	r24, r24
    99be:	7a 95       	dec	r23
    99c0:	c9 f7       	brne	.-14     	; 0x99b4 <__udivmodqi4_loop>
    99c2:	80 95       	com	r24
    99c4:	08 95       	ret

000099c6 <__udivmodhi4>:
    99c6:	aa 1b       	sub	r26, r26
    99c8:	bb 1b       	sub	r27, r27
    99ca:	51 e1       	ldi	r21, 0x11	; 17
    99cc:	07 c0       	rjmp	.+14     	; 0x99dc <__udivmodhi4_ep>

000099ce <__udivmodhi4_loop>:
    99ce:	aa 1f       	adc	r26, r26
    99d0:	bb 1f       	adc	r27, r27
    99d2:	a6 17       	cp	r26, r22
    99d4:	b7 07       	cpc	r27, r23
    99d6:	10 f0       	brcs	.+4      	; 0x99dc <__udivmodhi4_ep>
    99d8:	a6 1b       	sub	r26, r22
    99da:	b7 0b       	sbc	r27, r23

000099dc <__udivmodhi4_ep>:
    99dc:	88 1f       	adc	r24, r24
    99de:	99 1f       	adc	r25, r25
    99e0:	5a 95       	dec	r21
    99e2:	a9 f7       	brne	.-22     	; 0x99ce <__udivmodhi4_loop>
    99e4:	80 95       	com	r24
    99e6:	90 95       	com	r25
    99e8:	bc 01       	movw	r22, r24
    99ea:	cd 01       	movw	r24, r26
    99ec:	08 95       	ret

000099ee <__bswapsi2>:
    99ee:	69 27       	eor	r22, r25
    99f0:	96 27       	eor	r25, r22
    99f2:	69 27       	eor	r22, r25
    99f4:	78 27       	eor	r23, r24
    99f6:	87 27       	eor	r24, r23
    99f8:	78 27       	eor	r23, r24
    99fa:	08 95       	ret

000099fc <malloc>:
    99fc:	cf 93       	push	r28
    99fe:	df 93       	push	r29
    9a00:	82 30       	cpi	r24, 0x02	; 2
    9a02:	91 05       	cpc	r25, r1
    9a04:	10 f4       	brcc	.+4      	; 0x9a0a <malloc+0xe>
    9a06:	82 e0       	ldi	r24, 0x02	; 2
    9a08:	90 e0       	ldi	r25, 0x00	; 0
    9a0a:	e0 91 d8 0f 	lds	r30, 0x0FD8
    9a0e:	f0 91 d9 0f 	lds	r31, 0x0FD9
    9a12:	20 e0       	ldi	r18, 0x00	; 0
    9a14:	30 e0       	ldi	r19, 0x00	; 0
    9a16:	c0 e0       	ldi	r28, 0x00	; 0
    9a18:	d0 e0       	ldi	r29, 0x00	; 0
    9a1a:	30 97       	sbiw	r30, 0x00	; 0
    9a1c:	11 f1       	breq	.+68     	; 0x9a62 <malloc+0x66>
    9a1e:	40 81       	ld	r20, Z
    9a20:	51 81       	ldd	r21, Z+1	; 0x01
    9a22:	48 17       	cp	r20, r24
    9a24:	59 07       	cpc	r21, r25
    9a26:	c0 f0       	brcs	.+48     	; 0x9a58 <malloc+0x5c>
    9a28:	48 17       	cp	r20, r24
    9a2a:	59 07       	cpc	r21, r25
    9a2c:	61 f4       	brne	.+24     	; 0x9a46 <malloc+0x4a>
    9a2e:	82 81       	ldd	r24, Z+2	; 0x02
    9a30:	93 81       	ldd	r25, Z+3	; 0x03
    9a32:	20 97       	sbiw	r28, 0x00	; 0
    9a34:	19 f0       	breq	.+6      	; 0x9a3c <malloc+0x40>
    9a36:	9b 83       	std	Y+3, r25	; 0x03
    9a38:	8a 83       	std	Y+2, r24	; 0x02
    9a3a:	2b c0       	rjmp	.+86     	; 0x9a92 <malloc+0x96>
    9a3c:	90 93 d9 0f 	sts	0x0FD9, r25
    9a40:	80 93 d8 0f 	sts	0x0FD8, r24
    9a44:	26 c0       	rjmp	.+76     	; 0x9a92 <malloc+0x96>
    9a46:	21 15       	cp	r18, r1
    9a48:	31 05       	cpc	r19, r1
    9a4a:	19 f0       	breq	.+6      	; 0x9a52 <malloc+0x56>
    9a4c:	42 17       	cp	r20, r18
    9a4e:	53 07       	cpc	r21, r19
    9a50:	18 f4       	brcc	.+6      	; 0x9a58 <malloc+0x5c>
    9a52:	9a 01       	movw	r18, r20
    9a54:	be 01       	movw	r22, r28
    9a56:	df 01       	movw	r26, r30
    9a58:	ef 01       	movw	r28, r30
    9a5a:	02 80       	ldd	r0, Z+2	; 0x02
    9a5c:	f3 81       	ldd	r31, Z+3	; 0x03
    9a5e:	e0 2d       	mov	r30, r0
    9a60:	dc cf       	rjmp	.-72     	; 0x9a1a <malloc+0x1e>
    9a62:	21 15       	cp	r18, r1
    9a64:	31 05       	cpc	r19, r1
    9a66:	09 f1       	breq	.+66     	; 0x9aaa <malloc+0xae>
    9a68:	28 1b       	sub	r18, r24
    9a6a:	39 0b       	sbc	r19, r25
    9a6c:	24 30       	cpi	r18, 0x04	; 4
    9a6e:	31 05       	cpc	r19, r1
    9a70:	90 f4       	brcc	.+36     	; 0x9a96 <malloc+0x9a>
    9a72:	12 96       	adiw	r26, 0x02	; 2
    9a74:	8d 91       	ld	r24, X+
    9a76:	9c 91       	ld	r25, X
    9a78:	13 97       	sbiw	r26, 0x03	; 3
    9a7a:	61 15       	cp	r22, r1
    9a7c:	71 05       	cpc	r23, r1
    9a7e:	21 f0       	breq	.+8      	; 0x9a88 <malloc+0x8c>
    9a80:	fb 01       	movw	r30, r22
    9a82:	93 83       	std	Z+3, r25	; 0x03
    9a84:	82 83       	std	Z+2, r24	; 0x02
    9a86:	04 c0       	rjmp	.+8      	; 0x9a90 <malloc+0x94>
    9a88:	90 93 d9 0f 	sts	0x0FD9, r25
    9a8c:	80 93 d8 0f 	sts	0x0FD8, r24
    9a90:	fd 01       	movw	r30, r26
    9a92:	32 96       	adiw	r30, 0x02	; 2
    9a94:	44 c0       	rjmp	.+136    	; 0x9b1e <malloc+0x122>
    9a96:	fd 01       	movw	r30, r26
    9a98:	e2 0f       	add	r30, r18
    9a9a:	f3 1f       	adc	r31, r19
    9a9c:	81 93       	st	Z+, r24
    9a9e:	91 93       	st	Z+, r25
    9aa0:	22 50       	subi	r18, 0x02	; 2
    9aa2:	31 09       	sbc	r19, r1
    9aa4:	2d 93       	st	X+, r18
    9aa6:	3c 93       	st	X, r19
    9aa8:	3a c0       	rjmp	.+116    	; 0x9b1e <malloc+0x122>
    9aaa:	20 91 d6 0f 	lds	r18, 0x0FD6
    9aae:	30 91 d7 0f 	lds	r19, 0x0FD7
    9ab2:	23 2b       	or	r18, r19
    9ab4:	41 f4       	brne	.+16     	; 0x9ac6 <malloc+0xca>
    9ab6:	20 91 07 01 	lds	r18, 0x0107
    9aba:	30 91 08 01 	lds	r19, 0x0108
    9abe:	30 93 d7 0f 	sts	0x0FD7, r19
    9ac2:	20 93 d6 0f 	sts	0x0FD6, r18
    9ac6:	20 91 05 01 	lds	r18, 0x0105
    9aca:	30 91 06 01 	lds	r19, 0x0106
    9ace:	21 15       	cp	r18, r1
    9ad0:	31 05       	cpc	r19, r1
    9ad2:	41 f4       	brne	.+16     	; 0x9ae4 <malloc+0xe8>
    9ad4:	2d b7       	in	r18, 0x3d	; 61
    9ad6:	3e b7       	in	r19, 0x3e	; 62
    9ad8:	40 91 09 01 	lds	r20, 0x0109
    9adc:	50 91 0a 01 	lds	r21, 0x010A
    9ae0:	24 1b       	sub	r18, r20
    9ae2:	35 0b       	sbc	r19, r21
    9ae4:	e0 91 d6 0f 	lds	r30, 0x0FD6
    9ae8:	f0 91 d7 0f 	lds	r31, 0x0FD7
    9aec:	e2 17       	cp	r30, r18
    9aee:	f3 07       	cpc	r31, r19
    9af0:	a0 f4       	brcc	.+40     	; 0x9b1a <malloc+0x11e>
    9af2:	2e 1b       	sub	r18, r30
    9af4:	3f 0b       	sbc	r19, r31
    9af6:	28 17       	cp	r18, r24
    9af8:	39 07       	cpc	r19, r25
    9afa:	78 f0       	brcs	.+30     	; 0x9b1a <malloc+0x11e>
    9afc:	ac 01       	movw	r20, r24
    9afe:	4e 5f       	subi	r20, 0xFE	; 254
    9b00:	5f 4f       	sbci	r21, 0xFF	; 255
    9b02:	24 17       	cp	r18, r20
    9b04:	35 07       	cpc	r19, r21
    9b06:	48 f0       	brcs	.+18     	; 0x9b1a <malloc+0x11e>
    9b08:	4e 0f       	add	r20, r30
    9b0a:	5f 1f       	adc	r21, r31
    9b0c:	50 93 d7 0f 	sts	0x0FD7, r21
    9b10:	40 93 d6 0f 	sts	0x0FD6, r20
    9b14:	81 93       	st	Z+, r24
    9b16:	91 93       	st	Z+, r25
    9b18:	02 c0       	rjmp	.+4      	; 0x9b1e <malloc+0x122>
    9b1a:	e0 e0       	ldi	r30, 0x00	; 0
    9b1c:	f0 e0       	ldi	r31, 0x00	; 0
    9b1e:	cf 01       	movw	r24, r30
    9b20:	df 91       	pop	r29
    9b22:	cf 91       	pop	r28
    9b24:	08 95       	ret

00009b26 <free>:
    9b26:	0f 93       	push	r16
    9b28:	1f 93       	push	r17
    9b2a:	cf 93       	push	r28
    9b2c:	df 93       	push	r29
    9b2e:	00 97       	sbiw	r24, 0x00	; 0
    9b30:	09 f4       	brne	.+2      	; 0x9b34 <free+0xe>
    9b32:	8c c0       	rjmp	.+280    	; 0x9c4c <free+0x126>
    9b34:	fc 01       	movw	r30, r24
    9b36:	32 97       	sbiw	r30, 0x02	; 2
    9b38:	13 82       	std	Z+3, r1	; 0x03
    9b3a:	12 82       	std	Z+2, r1	; 0x02
    9b3c:	00 91 d8 0f 	lds	r16, 0x0FD8
    9b40:	10 91 d9 0f 	lds	r17, 0x0FD9
    9b44:	01 15       	cp	r16, r1
    9b46:	11 05       	cpc	r17, r1
    9b48:	81 f4       	brne	.+32     	; 0x9b6a <free+0x44>
    9b4a:	20 81       	ld	r18, Z
    9b4c:	31 81       	ldd	r19, Z+1	; 0x01
    9b4e:	82 0f       	add	r24, r18
    9b50:	93 1f       	adc	r25, r19
    9b52:	20 91 d6 0f 	lds	r18, 0x0FD6
    9b56:	30 91 d7 0f 	lds	r19, 0x0FD7
    9b5a:	28 17       	cp	r18, r24
    9b5c:	39 07       	cpc	r19, r25
    9b5e:	79 f5       	brne	.+94     	; 0x9bbe <free+0x98>
    9b60:	f0 93 d7 0f 	sts	0x0FD7, r31
    9b64:	e0 93 d6 0f 	sts	0x0FD6, r30
    9b68:	71 c0       	rjmp	.+226    	; 0x9c4c <free+0x126>
    9b6a:	d8 01       	movw	r26, r16
    9b6c:	40 e0       	ldi	r20, 0x00	; 0
    9b6e:	50 e0       	ldi	r21, 0x00	; 0
    9b70:	ae 17       	cp	r26, r30
    9b72:	bf 07       	cpc	r27, r31
    9b74:	50 f4       	brcc	.+20     	; 0x9b8a <free+0x64>
    9b76:	12 96       	adiw	r26, 0x02	; 2
    9b78:	2d 91       	ld	r18, X+
    9b7a:	3c 91       	ld	r19, X
    9b7c:	13 97       	sbiw	r26, 0x03	; 3
    9b7e:	ad 01       	movw	r20, r26
    9b80:	21 15       	cp	r18, r1
    9b82:	31 05       	cpc	r19, r1
    9b84:	09 f1       	breq	.+66     	; 0x9bc8 <free+0xa2>
    9b86:	d9 01       	movw	r26, r18
    9b88:	f3 cf       	rjmp	.-26     	; 0x9b70 <free+0x4a>
    9b8a:	9d 01       	movw	r18, r26
    9b8c:	da 01       	movw	r26, r20
    9b8e:	33 83       	std	Z+3, r19	; 0x03
    9b90:	22 83       	std	Z+2, r18	; 0x02
    9b92:	60 81       	ld	r22, Z
    9b94:	71 81       	ldd	r23, Z+1	; 0x01
    9b96:	86 0f       	add	r24, r22
    9b98:	97 1f       	adc	r25, r23
    9b9a:	82 17       	cp	r24, r18
    9b9c:	93 07       	cpc	r25, r19
    9b9e:	69 f4       	brne	.+26     	; 0x9bba <free+0x94>
    9ba0:	ec 01       	movw	r28, r24
    9ba2:	28 81       	ld	r18, Y
    9ba4:	39 81       	ldd	r19, Y+1	; 0x01
    9ba6:	26 0f       	add	r18, r22
    9ba8:	37 1f       	adc	r19, r23
    9baa:	2e 5f       	subi	r18, 0xFE	; 254
    9bac:	3f 4f       	sbci	r19, 0xFF	; 255
    9bae:	31 83       	std	Z+1, r19	; 0x01
    9bb0:	20 83       	st	Z, r18
    9bb2:	8a 81       	ldd	r24, Y+2	; 0x02
    9bb4:	9b 81       	ldd	r25, Y+3	; 0x03
    9bb6:	93 83       	std	Z+3, r25	; 0x03
    9bb8:	82 83       	std	Z+2, r24	; 0x02
    9bba:	45 2b       	or	r20, r21
    9bbc:	29 f4       	brne	.+10     	; 0x9bc8 <free+0xa2>
    9bbe:	f0 93 d9 0f 	sts	0x0FD9, r31
    9bc2:	e0 93 d8 0f 	sts	0x0FD8, r30
    9bc6:	42 c0       	rjmp	.+132    	; 0x9c4c <free+0x126>
    9bc8:	13 96       	adiw	r26, 0x03	; 3
    9bca:	fc 93       	st	X, r31
    9bcc:	ee 93       	st	-X, r30
    9bce:	12 97       	sbiw	r26, 0x02	; 2
    9bd0:	ed 01       	movw	r28, r26
    9bd2:	49 91       	ld	r20, Y+
    9bd4:	59 91       	ld	r21, Y+
    9bd6:	9e 01       	movw	r18, r28
    9bd8:	24 0f       	add	r18, r20
    9bda:	35 1f       	adc	r19, r21
    9bdc:	e2 17       	cp	r30, r18
    9bde:	f3 07       	cpc	r31, r19
    9be0:	71 f4       	brne	.+28     	; 0x9bfe <free+0xd8>
    9be2:	80 81       	ld	r24, Z
    9be4:	91 81       	ldd	r25, Z+1	; 0x01
    9be6:	84 0f       	add	r24, r20
    9be8:	95 1f       	adc	r25, r21
    9bea:	02 96       	adiw	r24, 0x02	; 2
    9bec:	11 96       	adiw	r26, 0x01	; 1
    9bee:	9c 93       	st	X, r25
    9bf0:	8e 93       	st	-X, r24
    9bf2:	82 81       	ldd	r24, Z+2	; 0x02
    9bf4:	93 81       	ldd	r25, Z+3	; 0x03
    9bf6:	13 96       	adiw	r26, 0x03	; 3
    9bf8:	9c 93       	st	X, r25
    9bfa:	8e 93       	st	-X, r24
    9bfc:	12 97       	sbiw	r26, 0x02	; 2
    9bfe:	e0 e0       	ldi	r30, 0x00	; 0
    9c00:	f0 e0       	ldi	r31, 0x00	; 0
    9c02:	d8 01       	movw	r26, r16
    9c04:	12 96       	adiw	r26, 0x02	; 2
    9c06:	8d 91       	ld	r24, X+
    9c08:	9c 91       	ld	r25, X
    9c0a:	13 97       	sbiw	r26, 0x03	; 3
    9c0c:	00 97       	sbiw	r24, 0x00	; 0
    9c0e:	19 f0       	breq	.+6      	; 0x9c16 <free+0xf0>
    9c10:	f8 01       	movw	r30, r16
    9c12:	8c 01       	movw	r16, r24
    9c14:	f6 cf       	rjmp	.-20     	; 0x9c02 <free+0xdc>
    9c16:	8d 91       	ld	r24, X+
    9c18:	9c 91       	ld	r25, X
    9c1a:	98 01       	movw	r18, r16
    9c1c:	2e 5f       	subi	r18, 0xFE	; 254
    9c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    9c20:	82 0f       	add	r24, r18
    9c22:	93 1f       	adc	r25, r19
    9c24:	20 91 d6 0f 	lds	r18, 0x0FD6
    9c28:	30 91 d7 0f 	lds	r19, 0x0FD7
    9c2c:	28 17       	cp	r18, r24
    9c2e:	39 07       	cpc	r19, r25
    9c30:	69 f4       	brne	.+26     	; 0x9c4c <free+0x126>
    9c32:	30 97       	sbiw	r30, 0x00	; 0
    9c34:	29 f4       	brne	.+10     	; 0x9c40 <free+0x11a>
    9c36:	10 92 d9 0f 	sts	0x0FD9, r1
    9c3a:	10 92 d8 0f 	sts	0x0FD8, r1
    9c3e:	02 c0       	rjmp	.+4      	; 0x9c44 <free+0x11e>
    9c40:	13 82       	std	Z+3, r1	; 0x03
    9c42:	12 82       	std	Z+2, r1	; 0x02
    9c44:	10 93 d7 0f 	sts	0x0FD7, r17
    9c48:	00 93 d6 0f 	sts	0x0FD6, r16
    9c4c:	df 91       	pop	r29
    9c4e:	cf 91       	pop	r28
    9c50:	1f 91       	pop	r17
    9c52:	0f 91       	pop	r16
    9c54:	08 95       	ret

00009c56 <strtol>:
    9c56:	2f 92       	push	r2
    9c58:	3f 92       	push	r3
    9c5a:	4f 92       	push	r4
    9c5c:	5f 92       	push	r5
    9c5e:	6f 92       	push	r6
    9c60:	7f 92       	push	r7
    9c62:	8f 92       	push	r8
    9c64:	9f 92       	push	r9
    9c66:	af 92       	push	r10
    9c68:	bf 92       	push	r11
    9c6a:	cf 92       	push	r12
    9c6c:	df 92       	push	r13
    9c6e:	ef 92       	push	r14
    9c70:	ff 92       	push	r15
    9c72:	0f 93       	push	r16
    9c74:	1f 93       	push	r17
    9c76:	cf 93       	push	r28
    9c78:	df 93       	push	r29
    9c7a:	5c 01       	movw	r10, r24
    9c7c:	6b 01       	movw	r12, r22
    9c7e:	7a 01       	movw	r14, r20
    9c80:	61 15       	cp	r22, r1
    9c82:	71 05       	cpc	r23, r1
    9c84:	19 f0       	breq	.+6      	; 0x9c8c <strtol+0x36>
    9c86:	fb 01       	movw	r30, r22
    9c88:	91 83       	std	Z+1, r25	; 0x01
    9c8a:	80 83       	st	Z, r24
    9c8c:	e1 14       	cp	r14, r1
    9c8e:	f1 04       	cpc	r15, r1
    9c90:	29 f0       	breq	.+10     	; 0x9c9c <strtol+0x46>
    9c92:	c7 01       	movw	r24, r14
    9c94:	02 97       	sbiw	r24, 0x02	; 2
    9c96:	83 97       	sbiw	r24, 0x23	; 35
    9c98:	08 f0       	brcs	.+2      	; 0x9c9c <strtol+0x46>
    9c9a:	f1 c0       	rjmp	.+482    	; 0x9e7e <strtol+0x228>
    9c9c:	e5 01       	movw	r28, r10
    9c9e:	21 96       	adiw	r28, 0x01	; 1
    9ca0:	f5 01       	movw	r30, r10
    9ca2:	10 81       	ld	r17, Z
    9ca4:	81 2f       	mov	r24, r17
    9ca6:	90 e0       	ldi	r25, 0x00	; 0
    9ca8:	0e 94 56 4f 	call	0x9eac	; 0x9eac <isspace>
    9cac:	89 2b       	or	r24, r25
    9cae:	11 f0       	breq	.+4      	; 0x9cb4 <strtol+0x5e>
    9cb0:	5e 01       	movw	r10, r28
    9cb2:	f4 cf       	rjmp	.-24     	; 0x9c9c <strtol+0x46>
    9cb4:	1d 32       	cpi	r17, 0x2D	; 45
    9cb6:	29 f4       	brne	.+10     	; 0x9cc2 <strtol+0x6c>
    9cb8:	21 96       	adiw	r28, 0x01	; 1
    9cba:	f5 01       	movw	r30, r10
    9cbc:	11 81       	ldd	r17, Z+1	; 0x01
    9cbe:	01 e0       	ldi	r16, 0x01	; 1
    9cc0:	07 c0       	rjmp	.+14     	; 0x9cd0 <strtol+0x7a>
    9cc2:	1b 32       	cpi	r17, 0x2B	; 43
    9cc4:	21 f4       	brne	.+8      	; 0x9cce <strtol+0x78>
    9cc6:	e5 01       	movw	r28, r10
    9cc8:	22 96       	adiw	r28, 0x02	; 2
    9cca:	f5 01       	movw	r30, r10
    9ccc:	11 81       	ldd	r17, Z+1	; 0x01
    9cce:	00 e0       	ldi	r16, 0x00	; 0
    9cd0:	e1 14       	cp	r14, r1
    9cd2:	f1 04       	cpc	r15, r1
    9cd4:	59 f1       	breq	.+86     	; 0x9d2c <strtol+0xd6>
    9cd6:	f0 e1       	ldi	r31, 0x10	; 16
    9cd8:	ef 16       	cp	r14, r31
    9cda:	f1 04       	cpc	r15, r1
    9cdc:	61 f4       	brne	.+24     	; 0x9cf6 <strtol+0xa0>
    9cde:	10 33       	cpi	r17, 0x30	; 48
    9ce0:	e1 f4       	brne	.+56     	; 0x9d1a <strtol+0xc4>
    9ce2:	88 81       	ld	r24, Y
    9ce4:	8f 7d       	andi	r24, 0xDF	; 223
    9ce6:	88 35       	cpi	r24, 0x58	; 88
    9ce8:	69 f5       	brne	.+90     	; 0x9d44 <strtol+0xee>
    9cea:	19 81       	ldd	r17, Y+1	; 0x01
    9cec:	22 96       	adiw	r28, 0x02	; 2
    9cee:	02 60       	ori	r16, 0x02	; 2
    9cf0:	70 e1       	ldi	r23, 0x10	; 16
    9cf2:	e7 2e       	mov	r14, r23
    9cf4:	f1 2c       	mov	r15, r1
    9cf6:	88 e0       	ldi	r24, 0x08	; 8
    9cf8:	e8 16       	cp	r14, r24
    9cfa:	f1 04       	cpc	r15, r1
    9cfc:	39 f1       	breq	.+78     	; 0x9d4c <strtol+0xf6>
    9cfe:	2c f4       	brge	.+10     	; 0x9d0a <strtol+0xb4>
    9d00:	f2 e0       	ldi	r31, 0x02	; 2
    9d02:	ef 16       	cp	r14, r31
    9d04:	f1 04       	cpc	r15, r1
    9d06:	c9 f1       	breq	.+114    	; 0x9d7a <strtol+0x124>
    9d08:	2a c0       	rjmp	.+84     	; 0x9d5e <strtol+0x108>
    9d0a:	8a e0       	ldi	r24, 0x0A	; 10
    9d0c:	e8 16       	cp	r14, r24
    9d0e:	f1 04       	cpc	r15, r1
    9d10:	79 f0       	breq	.+30     	; 0x9d30 <strtol+0xda>
    9d12:	e0 e1       	ldi	r30, 0x10	; 16
    9d14:	ee 16       	cp	r14, r30
    9d16:	f1 04       	cpc	r15, r1
    9d18:	11 f5       	brne	.+68     	; 0x9d5e <strtol+0x108>
    9d1a:	50 e1       	ldi	r21, 0x10	; 16
    9d1c:	e5 2e       	mov	r14, r21
    9d1e:	f1 2c       	mov	r15, r1
    9d20:	81 2c       	mov	r8, r1
    9d22:	91 2c       	mov	r9, r1
    9d24:	a1 2c       	mov	r10, r1
    9d26:	68 e0       	ldi	r22, 0x08	; 8
    9d28:	b6 2e       	mov	r11, r22
    9d2a:	2c c0       	rjmp	.+88     	; 0x9d84 <strtol+0x12e>
    9d2c:	10 33       	cpi	r17, 0x30	; 48
    9d2e:	c9 f2       	breq	.-78     	; 0x9ce2 <strtol+0x8c>
    9d30:	3a e0       	ldi	r19, 0x0A	; 10
    9d32:	e3 2e       	mov	r14, r19
    9d34:	f1 2c       	mov	r15, r1
    9d36:	4c ec       	ldi	r20, 0xCC	; 204
    9d38:	84 2e       	mov	r8, r20
    9d3a:	98 2c       	mov	r9, r8
    9d3c:	a8 2c       	mov	r10, r8
    9d3e:	4c e0       	ldi	r20, 0x0C	; 12
    9d40:	b4 2e       	mov	r11, r20
    9d42:	20 c0       	rjmp	.+64     	; 0x9d84 <strtol+0x12e>
    9d44:	10 e3       	ldi	r17, 0x30	; 48
    9d46:	e1 14       	cp	r14, r1
    9d48:	f1 04       	cpc	r15, r1
    9d4a:	a9 f6       	brne	.-86     	; 0x9cf6 <strtol+0xa0>
    9d4c:	98 e0       	ldi	r25, 0x08	; 8
    9d4e:	e9 2e       	mov	r14, r25
    9d50:	f1 2c       	mov	r15, r1
    9d52:	81 2c       	mov	r8, r1
    9d54:	91 2c       	mov	r9, r1
    9d56:	a1 2c       	mov	r10, r1
    9d58:	20 e1       	ldi	r18, 0x10	; 16
    9d5a:	b2 2e       	mov	r11, r18
    9d5c:	13 c0       	rjmp	.+38     	; 0x9d84 <strtol+0x12e>
    9d5e:	60 e0       	ldi	r22, 0x00	; 0
    9d60:	70 e0       	ldi	r23, 0x00	; 0
    9d62:	80 e0       	ldi	r24, 0x00	; 0
    9d64:	90 e8       	ldi	r25, 0x80	; 128
    9d66:	97 01       	movw	r18, r14
    9d68:	0f 2c       	mov	r0, r15
    9d6a:	00 0c       	add	r0, r0
    9d6c:	44 0b       	sbc	r20, r20
    9d6e:	55 0b       	sbc	r21, r21
    9d70:	0e 94 9c 53 	call	0xa738	; 0xa738 <__udivmodsi4>
    9d74:	49 01       	movw	r8, r18
    9d76:	5a 01       	movw	r10, r20
    9d78:	05 c0       	rjmp	.+10     	; 0x9d84 <strtol+0x12e>
    9d7a:	81 2c       	mov	r8, r1
    9d7c:	91 2c       	mov	r9, r1
    9d7e:	a1 2c       	mov	r10, r1
    9d80:	80 e4       	ldi	r24, 0x40	; 64
    9d82:	b8 2e       	mov	r11, r24
    9d84:	60 e0       	ldi	r22, 0x00	; 0
    9d86:	20 e0       	ldi	r18, 0x00	; 0
    9d88:	30 e0       	ldi	r19, 0x00	; 0
    9d8a:	a9 01       	movw	r20, r18
    9d8c:	27 01       	movw	r4, r14
    9d8e:	0f 2c       	mov	r0, r15
    9d90:	00 0c       	add	r0, r0
    9d92:	66 08       	sbc	r6, r6
    9d94:	77 08       	sbc	r7, r7
    9d96:	1e 01       	movw	r2, r28
    9d98:	e0 ed       	ldi	r30, 0xD0	; 208
    9d9a:	e1 0f       	add	r30, r17
    9d9c:	ea 30       	cpi	r30, 0x0A	; 10
    9d9e:	60 f0       	brcs	.+24     	; 0x9db8 <strtol+0x162>
    9da0:	8f eb       	ldi	r24, 0xBF	; 191
    9da2:	81 0f       	add	r24, r17
    9da4:	8a 31       	cpi	r24, 0x1A	; 26
    9da6:	10 f4       	brcc	.+4      	; 0x9dac <strtol+0x156>
    9da8:	e9 ec       	ldi	r30, 0xC9	; 201
    9daa:	05 c0       	rjmp	.+10     	; 0x9db6 <strtol+0x160>
    9dac:	8f e9       	ldi	r24, 0x9F	; 159
    9dae:	81 0f       	add	r24, r17
    9db0:	8a 31       	cpi	r24, 0x1A	; 26
    9db2:	28 f5       	brcc	.+74     	; 0x9dfe <strtol+0x1a8>
    9db4:	e9 ea       	ldi	r30, 0xA9	; 169
    9db6:	e1 0f       	add	r30, r17
    9db8:	8e 2f       	mov	r24, r30
    9dba:	90 e0       	ldi	r25, 0x00	; 0
    9dbc:	8e 15       	cp	r24, r14
    9dbe:	9f 05       	cpc	r25, r15
    9dc0:	f4 f4       	brge	.+60     	; 0x9dfe <strtol+0x1a8>
    9dc2:	67 fd       	sbrc	r22, 7
    9dc4:	18 c0       	rjmp	.+48     	; 0x9df6 <strtol+0x1a0>
    9dc6:	82 16       	cp	r8, r18
    9dc8:	93 06       	cpc	r9, r19
    9dca:	a4 06       	cpc	r10, r20
    9dcc:	b5 06       	cpc	r11, r21
    9dce:	90 f0       	brcs	.+36     	; 0x9df4 <strtol+0x19e>
    9dd0:	c3 01       	movw	r24, r6
    9dd2:	b2 01       	movw	r22, r4
    9dd4:	0e 94 8c 53 	call	0xa718	; 0xa718 <__mulsi3>
    9dd8:	9b 01       	movw	r18, r22
    9dda:	ac 01       	movw	r20, r24
    9ddc:	2e 0f       	add	r18, r30
    9dde:	31 1d       	adc	r19, r1
    9de0:	41 1d       	adc	r20, r1
    9de2:	51 1d       	adc	r21, r1
    9de4:	21 30       	cpi	r18, 0x01	; 1
    9de6:	31 05       	cpc	r19, r1
    9de8:	41 05       	cpc	r20, r1
    9dea:	f0 e8       	ldi	r31, 0x80	; 128
    9dec:	5f 07       	cpc	r21, r31
    9dee:	10 f4       	brcc	.+4      	; 0x9df4 <strtol+0x19e>
    9df0:	61 e0       	ldi	r22, 0x01	; 1
    9df2:	01 c0       	rjmp	.+2      	; 0x9df6 <strtol+0x1a0>
    9df4:	6f ef       	ldi	r22, 0xFF	; 255
    9df6:	21 96       	adiw	r28, 0x01	; 1
    9df8:	f1 01       	movw	r30, r2
    9dfa:	10 81       	ld	r17, Z
    9dfc:	cc cf       	rjmp	.-104    	; 0x9d96 <strtol+0x140>
    9dfe:	80 2f       	mov	r24, r16
    9e00:	81 70       	andi	r24, 0x01	; 1
    9e02:	c1 14       	cp	r12, r1
    9e04:	d1 04       	cpc	r13, r1
    9e06:	71 f0       	breq	.+28     	; 0x9e24 <strtol+0x1ce>
    9e08:	66 23       	and	r22, r22
    9e0a:	29 f0       	breq	.+10     	; 0x9e16 <strtol+0x1c0>
    9e0c:	21 97       	sbiw	r28, 0x01	; 1
    9e0e:	f6 01       	movw	r30, r12
    9e10:	d1 83       	std	Z+1, r29	; 0x01
    9e12:	c0 83       	st	Z, r28
    9e14:	07 c0       	rjmp	.+14     	; 0x9e24 <strtol+0x1ce>
    9e16:	01 ff       	sbrs	r16, 1
    9e18:	19 c0       	rjmp	.+50     	; 0x9e4c <strtol+0x1f6>
    9e1a:	22 97       	sbiw	r28, 0x02	; 2
    9e1c:	f6 01       	movw	r30, r12
    9e1e:	d1 83       	std	Z+1, r29	; 0x01
    9e20:	c0 83       	st	Z, r28
    9e22:	14 c0       	rjmp	.+40     	; 0x9e4c <strtol+0x1f6>
    9e24:	67 ff       	sbrs	r22, 7
    9e26:	12 c0       	rjmp	.+36     	; 0x9e4c <strtol+0x1f6>
    9e28:	81 11       	cpse	r24, r1
    9e2a:	05 c0       	rjmp	.+10     	; 0x9e36 <strtol+0x1e0>
    9e2c:	2f ef       	ldi	r18, 0xFF	; 255
    9e2e:	3f ef       	ldi	r19, 0xFF	; 255
    9e30:	4f ef       	ldi	r20, 0xFF	; 255
    9e32:	5f e7       	ldi	r21, 0x7F	; 127
    9e34:	04 c0       	rjmp	.+8      	; 0x9e3e <strtol+0x1e8>
    9e36:	20 e0       	ldi	r18, 0x00	; 0
    9e38:	30 e0       	ldi	r19, 0x00	; 0
    9e3a:	40 e0       	ldi	r20, 0x00	; 0
    9e3c:	50 e8       	ldi	r21, 0x80	; 128
    9e3e:	82 e2       	ldi	r24, 0x22	; 34
    9e40:	90 e0       	ldi	r25, 0x00	; 0
    9e42:	90 93 e1 0f 	sts	0x0FE1, r25
    9e46:	80 93 e0 0f 	sts	0x0FE0, r24
    9e4a:	16 c0       	rjmp	.+44     	; 0x9e78 <strtol+0x222>
    9e4c:	88 23       	and	r24, r24
    9e4e:	41 f0       	breq	.+16     	; 0x9e60 <strtol+0x20a>
    9e50:	50 95       	com	r21
    9e52:	40 95       	com	r20
    9e54:	30 95       	com	r19
    9e56:	21 95       	neg	r18
    9e58:	3f 4f       	sbci	r19, 0xFF	; 255
    9e5a:	4f 4f       	sbci	r20, 0xFF	; 255
    9e5c:	5f 4f       	sbci	r21, 0xFF	; 255
    9e5e:	0c c0       	rjmp	.+24     	; 0x9e78 <strtol+0x222>
    9e60:	57 ff       	sbrs	r21, 7
    9e62:	0a c0       	rjmp	.+20     	; 0x9e78 <strtol+0x222>
    9e64:	82 e2       	ldi	r24, 0x22	; 34
    9e66:	90 e0       	ldi	r25, 0x00	; 0
    9e68:	90 93 e1 0f 	sts	0x0FE1, r25
    9e6c:	80 93 e0 0f 	sts	0x0FE0, r24
    9e70:	2f ef       	ldi	r18, 0xFF	; 255
    9e72:	3f ef       	ldi	r19, 0xFF	; 255
    9e74:	4f ef       	ldi	r20, 0xFF	; 255
    9e76:	5f e7       	ldi	r21, 0x7F	; 127
    9e78:	b9 01       	movw	r22, r18
    9e7a:	ca 01       	movw	r24, r20
    9e7c:	04 c0       	rjmp	.+8      	; 0x9e86 <strtol+0x230>
    9e7e:	60 e0       	ldi	r22, 0x00	; 0
    9e80:	70 e0       	ldi	r23, 0x00	; 0
    9e82:	80 e0       	ldi	r24, 0x00	; 0
    9e84:	90 e0       	ldi	r25, 0x00	; 0
    9e86:	df 91       	pop	r29
    9e88:	cf 91       	pop	r28
    9e8a:	1f 91       	pop	r17
    9e8c:	0f 91       	pop	r16
    9e8e:	ff 90       	pop	r15
    9e90:	ef 90       	pop	r14
    9e92:	df 90       	pop	r13
    9e94:	cf 90       	pop	r12
    9e96:	bf 90       	pop	r11
    9e98:	af 90       	pop	r10
    9e9a:	9f 90       	pop	r9
    9e9c:	8f 90       	pop	r8
    9e9e:	7f 90       	pop	r7
    9ea0:	6f 90       	pop	r6
    9ea2:	5f 90       	pop	r5
    9ea4:	4f 90       	pop	r4
    9ea6:	3f 90       	pop	r3
    9ea8:	2f 90       	pop	r2
    9eaa:	08 95       	ret

00009eac <isspace>:
    9eac:	91 11       	cpse	r25, r1
    9eae:	0c 94 c6 52 	jmp	0xa58c	; 0xa58c <__ctype_isfalse>
    9eb2:	80 32       	cpi	r24, 0x20	; 32
    9eb4:	19 f0       	breq	.+6      	; 0x9ebc <isspace+0x10>
    9eb6:	89 50       	subi	r24, 0x09	; 9
    9eb8:	85 50       	subi	r24, 0x05	; 5
    9eba:	c8 f7       	brcc	.-14     	; 0x9eae <isspace+0x2>
    9ebc:	08 95       	ret

00009ebe <memcpy_P>:
    9ebe:	fb 01       	movw	r30, r22
    9ec0:	dc 01       	movw	r26, r24
    9ec2:	02 c0       	rjmp	.+4      	; 0x9ec8 <memcpy_P+0xa>
    9ec4:	05 90       	lpm	r0, Z+
    9ec6:	0d 92       	st	X+, r0
    9ec8:	41 50       	subi	r20, 0x01	; 1
    9eca:	50 40       	sbci	r21, 0x00	; 0
    9ecc:	d8 f7       	brcc	.-10     	; 0x9ec4 <memcpy_P+0x6>
    9ece:	08 95       	ret

00009ed0 <strncmp_P>:
    9ed0:	fb 01       	movw	r30, r22
    9ed2:	dc 01       	movw	r26, r24
    9ed4:	41 50       	subi	r20, 0x01	; 1
    9ed6:	50 40       	sbci	r21, 0x00	; 0
    9ed8:	30 f0       	brcs	.+12     	; 0x9ee6 <strncmp_P+0x16>
    9eda:	8d 91       	ld	r24, X+
    9edc:	05 90       	lpm	r0, Z+
    9ede:	80 19       	sub	r24, r0
    9ee0:	19 f4       	brne	.+6      	; 0x9ee8 <strncmp_P+0x18>
    9ee2:	00 20       	and	r0, r0
    9ee4:	b9 f7       	brne	.-18     	; 0x9ed4 <strncmp_P+0x4>
    9ee6:	88 1b       	sub	r24, r24
    9ee8:	99 0b       	sbc	r25, r25
    9eea:	08 95       	ret

00009eec <memcpy>:
    9eec:	fb 01       	movw	r30, r22
    9eee:	dc 01       	movw	r26, r24
    9ef0:	02 c0       	rjmp	.+4      	; 0x9ef6 <memcpy+0xa>
    9ef2:	01 90       	ld	r0, Z+
    9ef4:	0d 92       	st	X+, r0
    9ef6:	41 50       	subi	r20, 0x01	; 1
    9ef8:	50 40       	sbci	r21, 0x00	; 0
    9efa:	d8 f7       	brcc	.-10     	; 0x9ef2 <memcpy+0x6>
    9efc:	08 95       	ret

00009efe <memset>:
    9efe:	dc 01       	movw	r26, r24
    9f00:	01 c0       	rjmp	.+2      	; 0x9f04 <memset+0x6>
    9f02:	6d 93       	st	X+, r22
    9f04:	41 50       	subi	r20, 0x01	; 1
    9f06:	50 40       	sbci	r21, 0x00	; 0
    9f08:	e0 f7       	brcc	.-8      	; 0x9f02 <memset+0x4>
    9f0a:	08 95       	ret

00009f0c <strcat>:
    9f0c:	fb 01       	movw	r30, r22
    9f0e:	dc 01       	movw	r26, r24
    9f10:	0d 90       	ld	r0, X+
    9f12:	00 20       	and	r0, r0
    9f14:	e9 f7       	brne	.-6      	; 0x9f10 <strcat+0x4>
    9f16:	11 97       	sbiw	r26, 0x01	; 1
    9f18:	01 90       	ld	r0, Z+
    9f1a:	0d 92       	st	X+, r0
    9f1c:	00 20       	and	r0, r0
    9f1e:	e1 f7       	brne	.-8      	; 0x9f18 <strcat+0xc>
    9f20:	08 95       	ret

00009f22 <strcpy>:
    9f22:	fb 01       	movw	r30, r22
    9f24:	dc 01       	movw	r26, r24
    9f26:	01 90       	ld	r0, Z+
    9f28:	0d 92       	st	X+, r0
    9f2a:	00 20       	and	r0, r0
    9f2c:	e1 f7       	brne	.-8      	; 0x9f26 <strcpy+0x4>
    9f2e:	08 95       	ret

00009f30 <strncmp>:
    9f30:	fb 01       	movw	r30, r22
    9f32:	dc 01       	movw	r26, r24
    9f34:	41 50       	subi	r20, 0x01	; 1
    9f36:	50 40       	sbci	r21, 0x00	; 0
    9f38:	30 f0       	brcs	.+12     	; 0x9f46 <strncmp+0x16>
    9f3a:	8d 91       	ld	r24, X+
    9f3c:	01 90       	ld	r0, Z+
    9f3e:	80 19       	sub	r24, r0
    9f40:	19 f4       	brne	.+6      	; 0x9f48 <strncmp+0x18>
    9f42:	00 20       	and	r0, r0
    9f44:	b9 f7       	brne	.-18     	; 0x9f34 <strncmp+0x4>
    9f46:	88 1b       	sub	r24, r24
    9f48:	99 0b       	sbc	r25, r25
    9f4a:	08 95       	ret

00009f4c <strncpy>:
    9f4c:	fb 01       	movw	r30, r22
    9f4e:	dc 01       	movw	r26, r24
    9f50:	41 50       	subi	r20, 0x01	; 1
    9f52:	50 40       	sbci	r21, 0x00	; 0
    9f54:	48 f0       	brcs	.+18     	; 0x9f68 <strncpy+0x1c>
    9f56:	01 90       	ld	r0, Z+
    9f58:	0d 92       	st	X+, r0
    9f5a:	00 20       	and	r0, r0
    9f5c:	c9 f7       	brne	.-14     	; 0x9f50 <strncpy+0x4>
    9f5e:	01 c0       	rjmp	.+2      	; 0x9f62 <strncpy+0x16>
    9f60:	1d 92       	st	X+, r1
    9f62:	41 50       	subi	r20, 0x01	; 1
    9f64:	50 40       	sbci	r21, 0x00	; 0
    9f66:	e0 f7       	brcc	.-8      	; 0x9f60 <strncpy+0x14>
    9f68:	08 95       	ret

00009f6a <fclose>:
    9f6a:	fc 01       	movw	r30, r24
    9f6c:	23 81       	ldd	r18, Z+3	; 0x03
    9f6e:	27 ff       	sbrs	r18, 7
    9f70:	10 c0       	rjmp	.+32     	; 0x9f92 <fclose+0x28>
    9f72:	ea ed       	ldi	r30, 0xDA	; 218
    9f74:	ff e0       	ldi	r31, 0x0F	; 15
    9f76:	20 81       	ld	r18, Z
    9f78:	31 81       	ldd	r19, Z+1	; 0x01
    9f7a:	28 17       	cp	r18, r24
    9f7c:	39 07       	cpc	r19, r25
    9f7e:	11 f4       	brne	.+4      	; 0x9f84 <fclose+0x1a>
    9f80:	11 82       	std	Z+1, r1	; 0x01
    9f82:	10 82       	st	Z, r1
    9f84:	32 96       	adiw	r30, 0x02	; 2
    9f86:	2f e0       	ldi	r18, 0x0F	; 15
    9f88:	e0 3e       	cpi	r30, 0xE0	; 224
    9f8a:	f2 07       	cpc	r31, r18
    9f8c:	a1 f7       	brne	.-24     	; 0x9f76 <fclose+0xc>
    9f8e:	0e 94 93 4d 	call	0x9b26	; 0x9b26 <free>
    9f92:	80 e0       	ldi	r24, 0x00	; 0
    9f94:	90 e0       	ldi	r25, 0x00	; 0
    9f96:	08 95       	ret

00009f98 <fgetc>:
    9f98:	cf 93       	push	r28
    9f9a:	df 93       	push	r29
    9f9c:	ec 01       	movw	r28, r24
    9f9e:	2b 81       	ldd	r18, Y+3	; 0x03
    9fa0:	20 ff       	sbrs	r18, 0
    9fa2:	33 c0       	rjmp	.+102    	; 0xa00a <fgetc+0x72>
    9fa4:	26 ff       	sbrs	r18, 6
    9fa6:	0a c0       	rjmp	.+20     	; 0x9fbc <fgetc+0x24>
    9fa8:	2f 7b       	andi	r18, 0xBF	; 191
    9faa:	2b 83       	std	Y+3, r18	; 0x03
    9fac:	8e 81       	ldd	r24, Y+6	; 0x06
    9fae:	9f 81       	ldd	r25, Y+7	; 0x07
    9fb0:	01 96       	adiw	r24, 0x01	; 1
    9fb2:	9f 83       	std	Y+7, r25	; 0x07
    9fb4:	8e 83       	std	Y+6, r24	; 0x06
    9fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    9fb8:	90 e0       	ldi	r25, 0x00	; 0
    9fba:	29 c0       	rjmp	.+82     	; 0xa00e <fgetc+0x76>
    9fbc:	22 ff       	sbrs	r18, 2
    9fbe:	0f c0       	rjmp	.+30     	; 0x9fde <fgetc+0x46>
    9fc0:	e8 81       	ld	r30, Y
    9fc2:	f9 81       	ldd	r31, Y+1	; 0x01
    9fc4:	80 81       	ld	r24, Z
    9fc6:	08 2e       	mov	r0, r24
    9fc8:	00 0c       	add	r0, r0
    9fca:	99 0b       	sbc	r25, r25
    9fcc:	00 97       	sbiw	r24, 0x00	; 0
    9fce:	19 f4       	brne	.+6      	; 0x9fd6 <fgetc+0x3e>
    9fd0:	20 62       	ori	r18, 0x20	; 32
    9fd2:	2b 83       	std	Y+3, r18	; 0x03
    9fd4:	1a c0       	rjmp	.+52     	; 0xa00a <fgetc+0x72>
    9fd6:	31 96       	adiw	r30, 0x01	; 1
    9fd8:	f9 83       	std	Y+1, r31	; 0x01
    9fda:	e8 83       	st	Y, r30
    9fdc:	0e c0       	rjmp	.+28     	; 0x9ffa <fgetc+0x62>
    9fde:	ea 85       	ldd	r30, Y+10	; 0x0a
    9fe0:	fb 85       	ldd	r31, Y+11	; 0x0b
    9fe2:	09 95       	icall
    9fe4:	97 ff       	sbrs	r25, 7
    9fe6:	09 c0       	rjmp	.+18     	; 0x9ffa <fgetc+0x62>
    9fe8:	2b 81       	ldd	r18, Y+3	; 0x03
    9fea:	01 96       	adiw	r24, 0x01	; 1
    9fec:	11 f0       	breq	.+4      	; 0x9ff2 <fgetc+0x5a>
    9fee:	80 e2       	ldi	r24, 0x20	; 32
    9ff0:	01 c0       	rjmp	.+2      	; 0x9ff4 <fgetc+0x5c>
    9ff2:	80 e1       	ldi	r24, 0x10	; 16
    9ff4:	82 2b       	or	r24, r18
    9ff6:	8b 83       	std	Y+3, r24	; 0x03
    9ff8:	08 c0       	rjmp	.+16     	; 0xa00a <fgetc+0x72>
    9ffa:	2e 81       	ldd	r18, Y+6	; 0x06
    9ffc:	3f 81       	ldd	r19, Y+7	; 0x07
    9ffe:	2f 5f       	subi	r18, 0xFF	; 255
    a000:	3f 4f       	sbci	r19, 0xFF	; 255
    a002:	3f 83       	std	Y+7, r19	; 0x07
    a004:	2e 83       	std	Y+6, r18	; 0x06
    a006:	99 27       	eor	r25, r25
    a008:	02 c0       	rjmp	.+4      	; 0xa00e <fgetc+0x76>
    a00a:	8f ef       	ldi	r24, 0xFF	; 255
    a00c:	9f ef       	ldi	r25, 0xFF	; 255
    a00e:	df 91       	pop	r29
    a010:	cf 91       	pop	r28
    a012:	08 95       	ret

0000a014 <fprintf>:
    a014:	cf 93       	push	r28
    a016:	df 93       	push	r29
    a018:	cd b7       	in	r28, 0x3d	; 61
    a01a:	de b7       	in	r29, 0x3e	; 62
    a01c:	ae 01       	movw	r20, r28
    a01e:	47 5f       	subi	r20, 0xF7	; 247
    a020:	5f 4f       	sbci	r21, 0xFF	; 255
    a022:	6f 81       	ldd	r22, Y+7	; 0x07
    a024:	78 85       	ldd	r23, Y+8	; 0x08
    a026:	8d 81       	ldd	r24, Y+5	; 0x05
    a028:	9e 81       	ldd	r25, Y+6	; 0x06
    a02a:	0e 94 cb 50 	call	0xa196	; 0xa196 <vfprintf>
    a02e:	df 91       	pop	r29
    a030:	cf 91       	pop	r28
    a032:	08 95       	ret

0000a034 <fprintf_P>:
    a034:	0f 93       	push	r16
    a036:	1f 93       	push	r17
    a038:	cf 93       	push	r28
    a03a:	df 93       	push	r29
    a03c:	cd b7       	in	r28, 0x3d	; 61
    a03e:	de b7       	in	r29, 0x3e	; 62
    a040:	0f 81       	ldd	r16, Y+7	; 0x07
    a042:	18 85       	ldd	r17, Y+8	; 0x08
    a044:	f8 01       	movw	r30, r16
    a046:	83 81       	ldd	r24, Z+3	; 0x03
    a048:	88 60       	ori	r24, 0x08	; 8
    a04a:	83 83       	std	Z+3, r24	; 0x03
    a04c:	ae 01       	movw	r20, r28
    a04e:	45 5f       	subi	r20, 0xF5	; 245
    a050:	5f 4f       	sbci	r21, 0xFF	; 255
    a052:	69 85       	ldd	r22, Y+9	; 0x09
    a054:	7a 85       	ldd	r23, Y+10	; 0x0a
    a056:	c8 01       	movw	r24, r16
    a058:	0e 94 cb 50 	call	0xa196	; 0xa196 <vfprintf>
    a05c:	f8 01       	movw	r30, r16
    a05e:	23 81       	ldd	r18, Z+3	; 0x03
    a060:	27 7f       	andi	r18, 0xF7	; 247
    a062:	23 83       	std	Z+3, r18	; 0x03
    a064:	df 91       	pop	r29
    a066:	cf 91       	pop	r28
    a068:	1f 91       	pop	r17
    a06a:	0f 91       	pop	r16
    a06c:	08 95       	ret

0000a06e <fputc>:
    a06e:	0f 93       	push	r16
    a070:	1f 93       	push	r17
    a072:	cf 93       	push	r28
    a074:	df 93       	push	r29
    a076:	fb 01       	movw	r30, r22
    a078:	23 81       	ldd	r18, Z+3	; 0x03
    a07a:	21 fd       	sbrc	r18, 1
    a07c:	03 c0       	rjmp	.+6      	; 0xa084 <fputc+0x16>
    a07e:	8f ef       	ldi	r24, 0xFF	; 255
    a080:	9f ef       	ldi	r25, 0xFF	; 255
    a082:	28 c0       	rjmp	.+80     	; 0xa0d4 <fputc+0x66>
    a084:	22 ff       	sbrs	r18, 2
    a086:	16 c0       	rjmp	.+44     	; 0xa0b4 <fputc+0x46>
    a088:	46 81       	ldd	r20, Z+6	; 0x06
    a08a:	57 81       	ldd	r21, Z+7	; 0x07
    a08c:	24 81       	ldd	r18, Z+4	; 0x04
    a08e:	35 81       	ldd	r19, Z+5	; 0x05
    a090:	42 17       	cp	r20, r18
    a092:	53 07       	cpc	r21, r19
    a094:	44 f4       	brge	.+16     	; 0xa0a6 <fputc+0x38>
    a096:	a0 81       	ld	r26, Z
    a098:	b1 81       	ldd	r27, Z+1	; 0x01
    a09a:	9d 01       	movw	r18, r26
    a09c:	2f 5f       	subi	r18, 0xFF	; 255
    a09e:	3f 4f       	sbci	r19, 0xFF	; 255
    a0a0:	31 83       	std	Z+1, r19	; 0x01
    a0a2:	20 83       	st	Z, r18
    a0a4:	8c 93       	st	X, r24
    a0a6:	26 81       	ldd	r18, Z+6	; 0x06
    a0a8:	37 81       	ldd	r19, Z+7	; 0x07
    a0aa:	2f 5f       	subi	r18, 0xFF	; 255
    a0ac:	3f 4f       	sbci	r19, 0xFF	; 255
    a0ae:	37 83       	std	Z+7, r19	; 0x07
    a0b0:	26 83       	std	Z+6, r18	; 0x06
    a0b2:	10 c0       	rjmp	.+32     	; 0xa0d4 <fputc+0x66>
    a0b4:	eb 01       	movw	r28, r22
    a0b6:	09 2f       	mov	r16, r25
    a0b8:	18 2f       	mov	r17, r24
    a0ba:	00 84       	ldd	r0, Z+8	; 0x08
    a0bc:	f1 85       	ldd	r31, Z+9	; 0x09
    a0be:	e0 2d       	mov	r30, r0
    a0c0:	09 95       	icall
    a0c2:	89 2b       	or	r24, r25
    a0c4:	e1 f6       	brne	.-72     	; 0xa07e <fputc+0x10>
    a0c6:	8e 81       	ldd	r24, Y+6	; 0x06
    a0c8:	9f 81       	ldd	r25, Y+7	; 0x07
    a0ca:	01 96       	adiw	r24, 0x01	; 1
    a0cc:	9f 83       	std	Y+7, r25	; 0x07
    a0ce:	8e 83       	std	Y+6, r24	; 0x06
    a0d0:	81 2f       	mov	r24, r17
    a0d2:	90 2f       	mov	r25, r16
    a0d4:	df 91       	pop	r29
    a0d6:	cf 91       	pop	r28
    a0d8:	1f 91       	pop	r17
    a0da:	0f 91       	pop	r16
    a0dc:	08 95       	ret

0000a0de <fputs>:
    a0de:	ef 92       	push	r14
    a0e0:	ff 92       	push	r15
    a0e2:	0f 93       	push	r16
    a0e4:	1f 93       	push	r17
    a0e6:	cf 93       	push	r28
    a0e8:	df 93       	push	r29
    a0ea:	db 01       	movw	r26, r22
    a0ec:	13 96       	adiw	r26, 0x03	; 3
    a0ee:	2c 91       	ld	r18, X
    a0f0:	21 ff       	sbrs	r18, 1
    a0f2:	18 c0       	rjmp	.+48     	; 0xa124 <fputs+0x46>
    a0f4:	8b 01       	movw	r16, r22
    a0f6:	7c 01       	movw	r14, r24
    a0f8:	d0 e0       	ldi	r29, 0x00	; 0
    a0fa:	c0 e0       	ldi	r28, 0x00	; 0
    a0fc:	f7 01       	movw	r30, r14
    a0fe:	81 91       	ld	r24, Z+
    a100:	7f 01       	movw	r14, r30
    a102:	88 23       	and	r24, r24
    a104:	61 f0       	breq	.+24     	; 0xa11e <fputs+0x40>
    a106:	d8 01       	movw	r26, r16
    a108:	18 96       	adiw	r26, 0x08	; 8
    a10a:	ed 91       	ld	r30, X+
    a10c:	fc 91       	ld	r31, X
    a10e:	19 97       	sbiw	r26, 0x09	; 9
    a110:	b8 01       	movw	r22, r16
    a112:	09 95       	icall
    a114:	89 2b       	or	r24, r25
    a116:	91 f3       	breq	.-28     	; 0xa0fc <fputs+0x1e>
    a118:	df ef       	ldi	r29, 0xFF	; 255
    a11a:	cf ef       	ldi	r28, 0xFF	; 255
    a11c:	ef cf       	rjmp	.-34     	; 0xa0fc <fputs+0x1e>
    a11e:	8d 2f       	mov	r24, r29
    a120:	9c 2f       	mov	r25, r28
    a122:	02 c0       	rjmp	.+4      	; 0xa128 <fputs+0x4a>
    a124:	8f ef       	ldi	r24, 0xFF	; 255
    a126:	9f ef       	ldi	r25, 0xFF	; 255
    a128:	df 91       	pop	r29
    a12a:	cf 91       	pop	r28
    a12c:	1f 91       	pop	r17
    a12e:	0f 91       	pop	r16
    a130:	ff 90       	pop	r15
    a132:	ef 90       	pop	r14
    a134:	08 95       	ret

0000a136 <sprintf>:
    a136:	0f 93       	push	r16
    a138:	1f 93       	push	r17
    a13a:	cf 93       	push	r28
    a13c:	df 93       	push	r29
    a13e:	cd b7       	in	r28, 0x3d	; 61
    a140:	de b7       	in	r29, 0x3e	; 62
    a142:	2e 97       	sbiw	r28, 0x0e	; 14
    a144:	0f b6       	in	r0, 0x3f	; 63
    a146:	f8 94       	cli
    a148:	de bf       	out	0x3e, r29	; 62
    a14a:	0f be       	out	0x3f, r0	; 63
    a14c:	cd bf       	out	0x3d, r28	; 61
    a14e:	0d 89       	ldd	r16, Y+21	; 0x15
    a150:	1e 89       	ldd	r17, Y+22	; 0x16
    a152:	86 e0       	ldi	r24, 0x06	; 6
    a154:	8c 83       	std	Y+4, r24	; 0x04
    a156:	1a 83       	std	Y+2, r17	; 0x02
    a158:	09 83       	std	Y+1, r16	; 0x01
    a15a:	8f ef       	ldi	r24, 0xFF	; 255
    a15c:	9f e7       	ldi	r25, 0x7F	; 127
    a15e:	9e 83       	std	Y+6, r25	; 0x06
    a160:	8d 83       	std	Y+5, r24	; 0x05
    a162:	ae 01       	movw	r20, r28
    a164:	47 5e       	subi	r20, 0xE7	; 231
    a166:	5f 4f       	sbci	r21, 0xFF	; 255
    a168:	6f 89       	ldd	r22, Y+23	; 0x17
    a16a:	78 8d       	ldd	r23, Y+24	; 0x18
    a16c:	ce 01       	movw	r24, r28
    a16e:	01 96       	adiw	r24, 0x01	; 1
    a170:	0e 94 cb 50 	call	0xa196	; 0xa196 <vfprintf>
    a174:	2f 81       	ldd	r18, Y+7	; 0x07
    a176:	38 85       	ldd	r19, Y+8	; 0x08
    a178:	f8 01       	movw	r30, r16
    a17a:	e2 0f       	add	r30, r18
    a17c:	f3 1f       	adc	r31, r19
    a17e:	10 82       	st	Z, r1
    a180:	2e 96       	adiw	r28, 0x0e	; 14
    a182:	0f b6       	in	r0, 0x3f	; 63
    a184:	f8 94       	cli
    a186:	de bf       	out	0x3e, r29	; 62
    a188:	0f be       	out	0x3f, r0	; 63
    a18a:	cd bf       	out	0x3d, r28	; 61
    a18c:	df 91       	pop	r29
    a18e:	cf 91       	pop	r28
    a190:	1f 91       	pop	r17
    a192:	0f 91       	pop	r16
    a194:	08 95       	ret

0000a196 <vfprintf>:
    a196:	2f 92       	push	r2
    a198:	3f 92       	push	r3
    a19a:	4f 92       	push	r4
    a19c:	5f 92       	push	r5
    a19e:	6f 92       	push	r6
    a1a0:	7f 92       	push	r7
    a1a2:	8f 92       	push	r8
    a1a4:	9f 92       	push	r9
    a1a6:	af 92       	push	r10
    a1a8:	bf 92       	push	r11
    a1aa:	cf 92       	push	r12
    a1ac:	df 92       	push	r13
    a1ae:	ef 92       	push	r14
    a1b0:	ff 92       	push	r15
    a1b2:	0f 93       	push	r16
    a1b4:	1f 93       	push	r17
    a1b6:	cf 93       	push	r28
    a1b8:	df 93       	push	r29
    a1ba:	cd b7       	in	r28, 0x3d	; 61
    a1bc:	de b7       	in	r29, 0x3e	; 62
    a1be:	2c 97       	sbiw	r28, 0x0c	; 12
    a1c0:	0f b6       	in	r0, 0x3f	; 63
    a1c2:	f8 94       	cli
    a1c4:	de bf       	out	0x3e, r29	; 62
    a1c6:	0f be       	out	0x3f, r0	; 63
    a1c8:	cd bf       	out	0x3d, r28	; 61
    a1ca:	7c 01       	movw	r14, r24
    a1cc:	6b 01       	movw	r12, r22
    a1ce:	8a 01       	movw	r16, r20
    a1d0:	fc 01       	movw	r30, r24
    a1d2:	17 82       	std	Z+7, r1	; 0x07
    a1d4:	16 82       	std	Z+6, r1	; 0x06
    a1d6:	83 81       	ldd	r24, Z+3	; 0x03
    a1d8:	81 ff       	sbrs	r24, 1
    a1da:	bd c1       	rjmp	.+890    	; 0xa556 <vfprintf+0x3c0>
    a1dc:	ce 01       	movw	r24, r28
    a1de:	01 96       	adiw	r24, 0x01	; 1
    a1e0:	4c 01       	movw	r8, r24
    a1e2:	f7 01       	movw	r30, r14
    a1e4:	93 81       	ldd	r25, Z+3	; 0x03
    a1e6:	f6 01       	movw	r30, r12
    a1e8:	93 fd       	sbrc	r25, 3
    a1ea:	85 91       	lpm	r24, Z+
    a1ec:	93 ff       	sbrs	r25, 3
    a1ee:	81 91       	ld	r24, Z+
    a1f0:	6f 01       	movw	r12, r30
    a1f2:	88 23       	and	r24, r24
    a1f4:	09 f4       	brne	.+2      	; 0xa1f8 <vfprintf+0x62>
    a1f6:	ab c1       	rjmp	.+854    	; 0xa54e <vfprintf+0x3b8>
    a1f8:	85 32       	cpi	r24, 0x25	; 37
    a1fa:	39 f4       	brne	.+14     	; 0xa20a <vfprintf+0x74>
    a1fc:	93 fd       	sbrc	r25, 3
    a1fe:	85 91       	lpm	r24, Z+
    a200:	93 ff       	sbrs	r25, 3
    a202:	81 91       	ld	r24, Z+
    a204:	6f 01       	movw	r12, r30
    a206:	85 32       	cpi	r24, 0x25	; 37
    a208:	29 f4       	brne	.+10     	; 0xa214 <vfprintf+0x7e>
    a20a:	b7 01       	movw	r22, r14
    a20c:	90 e0       	ldi	r25, 0x00	; 0
    a20e:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a212:	e7 cf       	rjmp	.-50     	; 0xa1e2 <vfprintf+0x4c>
    a214:	51 2c       	mov	r5, r1
    a216:	31 2c       	mov	r3, r1
    a218:	20 e0       	ldi	r18, 0x00	; 0
    a21a:	20 32       	cpi	r18, 0x20	; 32
    a21c:	a0 f4       	brcc	.+40     	; 0xa246 <vfprintf+0xb0>
    a21e:	8b 32       	cpi	r24, 0x2B	; 43
    a220:	69 f0       	breq	.+26     	; 0xa23c <vfprintf+0xa6>
    a222:	30 f4       	brcc	.+12     	; 0xa230 <vfprintf+0x9a>
    a224:	80 32       	cpi	r24, 0x20	; 32
    a226:	59 f0       	breq	.+22     	; 0xa23e <vfprintf+0xa8>
    a228:	83 32       	cpi	r24, 0x23	; 35
    a22a:	69 f4       	brne	.+26     	; 0xa246 <vfprintf+0xb0>
    a22c:	20 61       	ori	r18, 0x10	; 16
    a22e:	2c c0       	rjmp	.+88     	; 0xa288 <vfprintf+0xf2>
    a230:	8d 32       	cpi	r24, 0x2D	; 45
    a232:	39 f0       	breq	.+14     	; 0xa242 <vfprintf+0xac>
    a234:	80 33       	cpi	r24, 0x30	; 48
    a236:	39 f4       	brne	.+14     	; 0xa246 <vfprintf+0xb0>
    a238:	21 60       	ori	r18, 0x01	; 1
    a23a:	26 c0       	rjmp	.+76     	; 0xa288 <vfprintf+0xf2>
    a23c:	22 60       	ori	r18, 0x02	; 2
    a23e:	24 60       	ori	r18, 0x04	; 4
    a240:	23 c0       	rjmp	.+70     	; 0xa288 <vfprintf+0xf2>
    a242:	28 60       	ori	r18, 0x08	; 8
    a244:	21 c0       	rjmp	.+66     	; 0xa288 <vfprintf+0xf2>
    a246:	27 fd       	sbrc	r18, 7
    a248:	27 c0       	rjmp	.+78     	; 0xa298 <vfprintf+0x102>
    a24a:	30 ed       	ldi	r19, 0xD0	; 208
    a24c:	38 0f       	add	r19, r24
    a24e:	3a 30       	cpi	r19, 0x0A	; 10
    a250:	78 f4       	brcc	.+30     	; 0xa270 <vfprintf+0xda>
    a252:	26 ff       	sbrs	r18, 6
    a254:	06 c0       	rjmp	.+12     	; 0xa262 <vfprintf+0xcc>
    a256:	fa e0       	ldi	r31, 0x0A	; 10
    a258:	5f 9e       	mul	r5, r31
    a25a:	30 0d       	add	r19, r0
    a25c:	11 24       	eor	r1, r1
    a25e:	53 2e       	mov	r5, r19
    a260:	13 c0       	rjmp	.+38     	; 0xa288 <vfprintf+0xf2>
    a262:	8a e0       	ldi	r24, 0x0A	; 10
    a264:	38 9e       	mul	r3, r24
    a266:	30 0d       	add	r19, r0
    a268:	11 24       	eor	r1, r1
    a26a:	33 2e       	mov	r3, r19
    a26c:	20 62       	ori	r18, 0x20	; 32
    a26e:	0c c0       	rjmp	.+24     	; 0xa288 <vfprintf+0xf2>
    a270:	8e 32       	cpi	r24, 0x2E	; 46
    a272:	21 f4       	brne	.+8      	; 0xa27c <vfprintf+0xe6>
    a274:	26 fd       	sbrc	r18, 6
    a276:	6b c1       	rjmp	.+726    	; 0xa54e <vfprintf+0x3b8>
    a278:	20 64       	ori	r18, 0x40	; 64
    a27a:	06 c0       	rjmp	.+12     	; 0xa288 <vfprintf+0xf2>
    a27c:	8c 36       	cpi	r24, 0x6C	; 108
    a27e:	11 f4       	brne	.+4      	; 0xa284 <vfprintf+0xee>
    a280:	20 68       	ori	r18, 0x80	; 128
    a282:	02 c0       	rjmp	.+4      	; 0xa288 <vfprintf+0xf2>
    a284:	88 36       	cpi	r24, 0x68	; 104
    a286:	41 f4       	brne	.+16     	; 0xa298 <vfprintf+0x102>
    a288:	f6 01       	movw	r30, r12
    a28a:	93 fd       	sbrc	r25, 3
    a28c:	85 91       	lpm	r24, Z+
    a28e:	93 ff       	sbrs	r25, 3
    a290:	81 91       	ld	r24, Z+
    a292:	6f 01       	movw	r12, r30
    a294:	81 11       	cpse	r24, r1
    a296:	c1 cf       	rjmp	.-126    	; 0xa21a <vfprintf+0x84>
    a298:	98 2f       	mov	r25, r24
    a29a:	9f 7d       	andi	r25, 0xDF	; 223
    a29c:	95 54       	subi	r25, 0x45	; 69
    a29e:	93 30       	cpi	r25, 0x03	; 3
    a2a0:	28 f4       	brcc	.+10     	; 0xa2ac <vfprintf+0x116>
    a2a2:	0c 5f       	subi	r16, 0xFC	; 252
    a2a4:	1f 4f       	sbci	r17, 0xFF	; 255
    a2a6:	ff e3       	ldi	r31, 0x3F	; 63
    a2a8:	f9 83       	std	Y+1, r31	; 0x01
    a2aa:	0d c0       	rjmp	.+26     	; 0xa2c6 <vfprintf+0x130>
    a2ac:	83 36       	cpi	r24, 0x63	; 99
    a2ae:	31 f0       	breq	.+12     	; 0xa2bc <vfprintf+0x126>
    a2b0:	83 37       	cpi	r24, 0x73	; 115
    a2b2:	71 f0       	breq	.+28     	; 0xa2d0 <vfprintf+0x13a>
    a2b4:	83 35       	cpi	r24, 0x53	; 83
    a2b6:	09 f0       	breq	.+2      	; 0xa2ba <vfprintf+0x124>
    a2b8:	5b c0       	rjmp	.+182    	; 0xa370 <vfprintf+0x1da>
    a2ba:	22 c0       	rjmp	.+68     	; 0xa300 <vfprintf+0x16a>
    a2bc:	f8 01       	movw	r30, r16
    a2be:	80 81       	ld	r24, Z
    a2c0:	89 83       	std	Y+1, r24	; 0x01
    a2c2:	0e 5f       	subi	r16, 0xFE	; 254
    a2c4:	1f 4f       	sbci	r17, 0xFF	; 255
    a2c6:	44 24       	eor	r4, r4
    a2c8:	43 94       	inc	r4
    a2ca:	51 2c       	mov	r5, r1
    a2cc:	54 01       	movw	r10, r8
    a2ce:	15 c0       	rjmp	.+42     	; 0xa2fa <vfprintf+0x164>
    a2d0:	38 01       	movw	r6, r16
    a2d2:	f2 e0       	ldi	r31, 0x02	; 2
    a2d4:	6f 0e       	add	r6, r31
    a2d6:	71 1c       	adc	r7, r1
    a2d8:	f8 01       	movw	r30, r16
    a2da:	a0 80       	ld	r10, Z
    a2dc:	b1 80       	ldd	r11, Z+1	; 0x01
    a2de:	26 ff       	sbrs	r18, 6
    a2e0:	03 c0       	rjmp	.+6      	; 0xa2e8 <vfprintf+0x152>
    a2e2:	65 2d       	mov	r22, r5
    a2e4:	70 e0       	ldi	r23, 0x00	; 0
    a2e6:	02 c0       	rjmp	.+4      	; 0xa2ec <vfprintf+0x156>
    a2e8:	6f ef       	ldi	r22, 0xFF	; 255
    a2ea:	7f ef       	ldi	r23, 0xFF	; 255
    a2ec:	c5 01       	movw	r24, r10
    a2ee:	2c 87       	std	Y+12, r18	; 0x0c
    a2f0:	0e 94 d4 52 	call	0xa5a8	; 0xa5a8 <strnlen>
    a2f4:	2c 01       	movw	r4, r24
    a2f6:	83 01       	movw	r16, r6
    a2f8:	2c 85       	ldd	r18, Y+12	; 0x0c
    a2fa:	2f 77       	andi	r18, 0x7F	; 127
    a2fc:	22 2e       	mov	r2, r18
    a2fe:	17 c0       	rjmp	.+46     	; 0xa32e <vfprintf+0x198>
    a300:	38 01       	movw	r6, r16
    a302:	f2 e0       	ldi	r31, 0x02	; 2
    a304:	6f 0e       	add	r6, r31
    a306:	71 1c       	adc	r7, r1
    a308:	f8 01       	movw	r30, r16
    a30a:	a0 80       	ld	r10, Z
    a30c:	b1 80       	ldd	r11, Z+1	; 0x01
    a30e:	26 ff       	sbrs	r18, 6
    a310:	03 c0       	rjmp	.+6      	; 0xa318 <vfprintf+0x182>
    a312:	65 2d       	mov	r22, r5
    a314:	70 e0       	ldi	r23, 0x00	; 0
    a316:	02 c0       	rjmp	.+4      	; 0xa31c <vfprintf+0x186>
    a318:	6f ef       	ldi	r22, 0xFF	; 255
    a31a:	7f ef       	ldi	r23, 0xFF	; 255
    a31c:	c5 01       	movw	r24, r10
    a31e:	2c 87       	std	Y+12, r18	; 0x0c
    a320:	0e 94 c9 52 	call	0xa592	; 0xa592 <strnlen_P>
    a324:	2c 01       	movw	r4, r24
    a326:	2c 85       	ldd	r18, Y+12	; 0x0c
    a328:	20 68       	ori	r18, 0x80	; 128
    a32a:	22 2e       	mov	r2, r18
    a32c:	83 01       	movw	r16, r6
    a32e:	23 fc       	sbrc	r2, 3
    a330:	1b c0       	rjmp	.+54     	; 0xa368 <vfprintf+0x1d2>
    a332:	83 2d       	mov	r24, r3
    a334:	90 e0       	ldi	r25, 0x00	; 0
    a336:	48 16       	cp	r4, r24
    a338:	59 06       	cpc	r5, r25
    a33a:	b0 f4       	brcc	.+44     	; 0xa368 <vfprintf+0x1d2>
    a33c:	b7 01       	movw	r22, r14
    a33e:	80 e2       	ldi	r24, 0x20	; 32
    a340:	90 e0       	ldi	r25, 0x00	; 0
    a342:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a346:	3a 94       	dec	r3
    a348:	f4 cf       	rjmp	.-24     	; 0xa332 <vfprintf+0x19c>
    a34a:	f5 01       	movw	r30, r10
    a34c:	27 fc       	sbrc	r2, 7
    a34e:	85 91       	lpm	r24, Z+
    a350:	27 fe       	sbrs	r2, 7
    a352:	81 91       	ld	r24, Z+
    a354:	5f 01       	movw	r10, r30
    a356:	b7 01       	movw	r22, r14
    a358:	90 e0       	ldi	r25, 0x00	; 0
    a35a:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a35e:	31 10       	cpse	r3, r1
    a360:	3a 94       	dec	r3
    a362:	f1 e0       	ldi	r31, 0x01	; 1
    a364:	4f 1a       	sub	r4, r31
    a366:	51 08       	sbc	r5, r1
    a368:	41 14       	cp	r4, r1
    a36a:	51 04       	cpc	r5, r1
    a36c:	71 f7       	brne	.-36     	; 0xa34a <vfprintf+0x1b4>
    a36e:	e5 c0       	rjmp	.+458    	; 0xa53a <vfprintf+0x3a4>
    a370:	84 36       	cpi	r24, 0x64	; 100
    a372:	11 f0       	breq	.+4      	; 0xa378 <vfprintf+0x1e2>
    a374:	89 36       	cpi	r24, 0x69	; 105
    a376:	39 f5       	brne	.+78     	; 0xa3c6 <vfprintf+0x230>
    a378:	f8 01       	movw	r30, r16
    a37a:	27 ff       	sbrs	r18, 7
    a37c:	07 c0       	rjmp	.+14     	; 0xa38c <vfprintf+0x1f6>
    a37e:	60 81       	ld	r22, Z
    a380:	71 81       	ldd	r23, Z+1	; 0x01
    a382:	82 81       	ldd	r24, Z+2	; 0x02
    a384:	93 81       	ldd	r25, Z+3	; 0x03
    a386:	0c 5f       	subi	r16, 0xFC	; 252
    a388:	1f 4f       	sbci	r17, 0xFF	; 255
    a38a:	08 c0       	rjmp	.+16     	; 0xa39c <vfprintf+0x206>
    a38c:	60 81       	ld	r22, Z
    a38e:	71 81       	ldd	r23, Z+1	; 0x01
    a390:	07 2e       	mov	r0, r23
    a392:	00 0c       	add	r0, r0
    a394:	88 0b       	sbc	r24, r24
    a396:	99 0b       	sbc	r25, r25
    a398:	0e 5f       	subi	r16, 0xFE	; 254
    a39a:	1f 4f       	sbci	r17, 0xFF	; 255
    a39c:	2f 76       	andi	r18, 0x6F	; 111
    a39e:	72 2e       	mov	r7, r18
    a3a0:	97 ff       	sbrs	r25, 7
    a3a2:	09 c0       	rjmp	.+18     	; 0xa3b6 <vfprintf+0x220>
    a3a4:	90 95       	com	r25
    a3a6:	80 95       	com	r24
    a3a8:	70 95       	com	r23
    a3aa:	61 95       	neg	r22
    a3ac:	7f 4f       	sbci	r23, 0xFF	; 255
    a3ae:	8f 4f       	sbci	r24, 0xFF	; 255
    a3b0:	9f 4f       	sbci	r25, 0xFF	; 255
    a3b2:	20 68       	ori	r18, 0x80	; 128
    a3b4:	72 2e       	mov	r7, r18
    a3b6:	2a e0       	ldi	r18, 0x0A	; 10
    a3b8:	30 e0       	ldi	r19, 0x00	; 0
    a3ba:	a4 01       	movw	r20, r8
    a3bc:	0e 94 df 52 	call	0xa5be	; 0xa5be <__ultoa_invert>
    a3c0:	a8 2e       	mov	r10, r24
    a3c2:	a8 18       	sub	r10, r8
    a3c4:	44 c0       	rjmp	.+136    	; 0xa44e <vfprintf+0x2b8>
    a3c6:	85 37       	cpi	r24, 0x75	; 117
    a3c8:	29 f4       	brne	.+10     	; 0xa3d4 <vfprintf+0x23e>
    a3ca:	2f 7e       	andi	r18, 0xEF	; 239
    a3cc:	b2 2e       	mov	r11, r18
    a3ce:	2a e0       	ldi	r18, 0x0A	; 10
    a3d0:	30 e0       	ldi	r19, 0x00	; 0
    a3d2:	25 c0       	rjmp	.+74     	; 0xa41e <vfprintf+0x288>
    a3d4:	f2 2f       	mov	r31, r18
    a3d6:	f9 7f       	andi	r31, 0xF9	; 249
    a3d8:	bf 2e       	mov	r11, r31
    a3da:	8f 36       	cpi	r24, 0x6F	; 111
    a3dc:	c1 f0       	breq	.+48     	; 0xa40e <vfprintf+0x278>
    a3de:	18 f4       	brcc	.+6      	; 0xa3e6 <vfprintf+0x250>
    a3e0:	88 35       	cpi	r24, 0x58	; 88
    a3e2:	79 f0       	breq	.+30     	; 0xa402 <vfprintf+0x26c>
    a3e4:	b4 c0       	rjmp	.+360    	; 0xa54e <vfprintf+0x3b8>
    a3e6:	80 37       	cpi	r24, 0x70	; 112
    a3e8:	19 f0       	breq	.+6      	; 0xa3f0 <vfprintf+0x25a>
    a3ea:	88 37       	cpi	r24, 0x78	; 120
    a3ec:	21 f0       	breq	.+8      	; 0xa3f6 <vfprintf+0x260>
    a3ee:	af c0       	rjmp	.+350    	; 0xa54e <vfprintf+0x3b8>
    a3f0:	2f 2f       	mov	r18, r31
    a3f2:	20 61       	ori	r18, 0x10	; 16
    a3f4:	b2 2e       	mov	r11, r18
    a3f6:	b4 fe       	sbrs	r11, 4
    a3f8:	0d c0       	rjmp	.+26     	; 0xa414 <vfprintf+0x27e>
    a3fa:	8b 2d       	mov	r24, r11
    a3fc:	84 60       	ori	r24, 0x04	; 4
    a3fe:	b8 2e       	mov	r11, r24
    a400:	09 c0       	rjmp	.+18     	; 0xa414 <vfprintf+0x27e>
    a402:	24 ff       	sbrs	r18, 4
    a404:	0a c0       	rjmp	.+20     	; 0xa41a <vfprintf+0x284>
    a406:	9f 2f       	mov	r25, r31
    a408:	96 60       	ori	r25, 0x06	; 6
    a40a:	b9 2e       	mov	r11, r25
    a40c:	06 c0       	rjmp	.+12     	; 0xa41a <vfprintf+0x284>
    a40e:	28 e0       	ldi	r18, 0x08	; 8
    a410:	30 e0       	ldi	r19, 0x00	; 0
    a412:	05 c0       	rjmp	.+10     	; 0xa41e <vfprintf+0x288>
    a414:	20 e1       	ldi	r18, 0x10	; 16
    a416:	30 e0       	ldi	r19, 0x00	; 0
    a418:	02 c0       	rjmp	.+4      	; 0xa41e <vfprintf+0x288>
    a41a:	20 e1       	ldi	r18, 0x10	; 16
    a41c:	32 e0       	ldi	r19, 0x02	; 2
    a41e:	f8 01       	movw	r30, r16
    a420:	b7 fe       	sbrs	r11, 7
    a422:	07 c0       	rjmp	.+14     	; 0xa432 <vfprintf+0x29c>
    a424:	60 81       	ld	r22, Z
    a426:	71 81       	ldd	r23, Z+1	; 0x01
    a428:	82 81       	ldd	r24, Z+2	; 0x02
    a42a:	93 81       	ldd	r25, Z+3	; 0x03
    a42c:	0c 5f       	subi	r16, 0xFC	; 252
    a42e:	1f 4f       	sbci	r17, 0xFF	; 255
    a430:	06 c0       	rjmp	.+12     	; 0xa43e <vfprintf+0x2a8>
    a432:	60 81       	ld	r22, Z
    a434:	71 81       	ldd	r23, Z+1	; 0x01
    a436:	80 e0       	ldi	r24, 0x00	; 0
    a438:	90 e0       	ldi	r25, 0x00	; 0
    a43a:	0e 5f       	subi	r16, 0xFE	; 254
    a43c:	1f 4f       	sbci	r17, 0xFF	; 255
    a43e:	a4 01       	movw	r20, r8
    a440:	0e 94 df 52 	call	0xa5be	; 0xa5be <__ultoa_invert>
    a444:	a8 2e       	mov	r10, r24
    a446:	a8 18       	sub	r10, r8
    a448:	fb 2d       	mov	r31, r11
    a44a:	ff 77       	andi	r31, 0x7F	; 127
    a44c:	7f 2e       	mov	r7, r31
    a44e:	76 fe       	sbrs	r7, 6
    a450:	0b c0       	rjmp	.+22     	; 0xa468 <vfprintf+0x2d2>
    a452:	37 2d       	mov	r19, r7
    a454:	3e 7f       	andi	r19, 0xFE	; 254
    a456:	a5 14       	cp	r10, r5
    a458:	50 f4       	brcc	.+20     	; 0xa46e <vfprintf+0x2d8>
    a45a:	74 fe       	sbrs	r7, 4
    a45c:	0a c0       	rjmp	.+20     	; 0xa472 <vfprintf+0x2dc>
    a45e:	72 fc       	sbrc	r7, 2
    a460:	08 c0       	rjmp	.+16     	; 0xa472 <vfprintf+0x2dc>
    a462:	37 2d       	mov	r19, r7
    a464:	3e 7e       	andi	r19, 0xEE	; 238
    a466:	05 c0       	rjmp	.+10     	; 0xa472 <vfprintf+0x2dc>
    a468:	ba 2c       	mov	r11, r10
    a46a:	37 2d       	mov	r19, r7
    a46c:	03 c0       	rjmp	.+6      	; 0xa474 <vfprintf+0x2de>
    a46e:	ba 2c       	mov	r11, r10
    a470:	01 c0       	rjmp	.+2      	; 0xa474 <vfprintf+0x2de>
    a472:	b5 2c       	mov	r11, r5
    a474:	34 ff       	sbrs	r19, 4
    a476:	0d c0       	rjmp	.+26     	; 0xa492 <vfprintf+0x2fc>
    a478:	fe 01       	movw	r30, r28
    a47a:	ea 0d       	add	r30, r10
    a47c:	f1 1d       	adc	r31, r1
    a47e:	80 81       	ld	r24, Z
    a480:	80 33       	cpi	r24, 0x30	; 48
    a482:	11 f4       	brne	.+4      	; 0xa488 <vfprintf+0x2f2>
    a484:	39 7e       	andi	r19, 0xE9	; 233
    a486:	09 c0       	rjmp	.+18     	; 0xa49a <vfprintf+0x304>
    a488:	32 ff       	sbrs	r19, 2
    a48a:	06 c0       	rjmp	.+12     	; 0xa498 <vfprintf+0x302>
    a48c:	b3 94       	inc	r11
    a48e:	b3 94       	inc	r11
    a490:	04 c0       	rjmp	.+8      	; 0xa49a <vfprintf+0x304>
    a492:	83 2f       	mov	r24, r19
    a494:	86 78       	andi	r24, 0x86	; 134
    a496:	09 f0       	breq	.+2      	; 0xa49a <vfprintf+0x304>
    a498:	b3 94       	inc	r11
    a49a:	33 fd       	sbrc	r19, 3
    a49c:	13 c0       	rjmp	.+38     	; 0xa4c4 <vfprintf+0x32e>
    a49e:	30 ff       	sbrs	r19, 0
    a4a0:	06 c0       	rjmp	.+12     	; 0xa4ae <vfprintf+0x318>
    a4a2:	5a 2c       	mov	r5, r10
    a4a4:	b3 14       	cp	r11, r3
    a4a6:	18 f4       	brcc	.+6      	; 0xa4ae <vfprintf+0x318>
    a4a8:	53 0c       	add	r5, r3
    a4aa:	5b 18       	sub	r5, r11
    a4ac:	b3 2c       	mov	r11, r3
    a4ae:	b3 14       	cp	r11, r3
    a4b0:	68 f4       	brcc	.+26     	; 0xa4cc <vfprintf+0x336>
    a4b2:	b7 01       	movw	r22, r14
    a4b4:	80 e2       	ldi	r24, 0x20	; 32
    a4b6:	90 e0       	ldi	r25, 0x00	; 0
    a4b8:	3c 87       	std	Y+12, r19	; 0x0c
    a4ba:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a4be:	b3 94       	inc	r11
    a4c0:	3c 85       	ldd	r19, Y+12	; 0x0c
    a4c2:	f5 cf       	rjmp	.-22     	; 0xa4ae <vfprintf+0x318>
    a4c4:	b3 14       	cp	r11, r3
    a4c6:	10 f4       	brcc	.+4      	; 0xa4cc <vfprintf+0x336>
    a4c8:	3b 18       	sub	r3, r11
    a4ca:	01 c0       	rjmp	.+2      	; 0xa4ce <vfprintf+0x338>
    a4cc:	31 2c       	mov	r3, r1
    a4ce:	34 ff       	sbrs	r19, 4
    a4d0:	12 c0       	rjmp	.+36     	; 0xa4f6 <vfprintf+0x360>
    a4d2:	b7 01       	movw	r22, r14
    a4d4:	80 e3       	ldi	r24, 0x30	; 48
    a4d6:	90 e0       	ldi	r25, 0x00	; 0
    a4d8:	3c 87       	std	Y+12, r19	; 0x0c
    a4da:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a4de:	3c 85       	ldd	r19, Y+12	; 0x0c
    a4e0:	32 ff       	sbrs	r19, 2
    a4e2:	17 c0       	rjmp	.+46     	; 0xa512 <vfprintf+0x37c>
    a4e4:	31 fd       	sbrc	r19, 1
    a4e6:	03 c0       	rjmp	.+6      	; 0xa4ee <vfprintf+0x358>
    a4e8:	88 e7       	ldi	r24, 0x78	; 120
    a4ea:	90 e0       	ldi	r25, 0x00	; 0
    a4ec:	02 c0       	rjmp	.+4      	; 0xa4f2 <vfprintf+0x35c>
    a4ee:	88 e5       	ldi	r24, 0x58	; 88
    a4f0:	90 e0       	ldi	r25, 0x00	; 0
    a4f2:	b7 01       	movw	r22, r14
    a4f4:	0c c0       	rjmp	.+24     	; 0xa50e <vfprintf+0x378>
    a4f6:	83 2f       	mov	r24, r19
    a4f8:	86 78       	andi	r24, 0x86	; 134
    a4fa:	59 f0       	breq	.+22     	; 0xa512 <vfprintf+0x37c>
    a4fc:	31 ff       	sbrs	r19, 1
    a4fe:	02 c0       	rjmp	.+4      	; 0xa504 <vfprintf+0x36e>
    a500:	8b e2       	ldi	r24, 0x2B	; 43
    a502:	01 c0       	rjmp	.+2      	; 0xa506 <vfprintf+0x370>
    a504:	80 e2       	ldi	r24, 0x20	; 32
    a506:	37 fd       	sbrc	r19, 7
    a508:	8d e2       	ldi	r24, 0x2D	; 45
    a50a:	b7 01       	movw	r22, r14
    a50c:	90 e0       	ldi	r25, 0x00	; 0
    a50e:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a512:	a5 14       	cp	r10, r5
    a514:	38 f4       	brcc	.+14     	; 0xa524 <vfprintf+0x38e>
    a516:	b7 01       	movw	r22, r14
    a518:	80 e3       	ldi	r24, 0x30	; 48
    a51a:	90 e0       	ldi	r25, 0x00	; 0
    a51c:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a520:	5a 94       	dec	r5
    a522:	f7 cf       	rjmp	.-18     	; 0xa512 <vfprintf+0x37c>
    a524:	aa 94       	dec	r10
    a526:	f4 01       	movw	r30, r8
    a528:	ea 0d       	add	r30, r10
    a52a:	f1 1d       	adc	r31, r1
    a52c:	80 81       	ld	r24, Z
    a52e:	b7 01       	movw	r22, r14
    a530:	90 e0       	ldi	r25, 0x00	; 0
    a532:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a536:	a1 10       	cpse	r10, r1
    a538:	f5 cf       	rjmp	.-22     	; 0xa524 <vfprintf+0x38e>
    a53a:	33 20       	and	r3, r3
    a53c:	09 f4       	brne	.+2      	; 0xa540 <vfprintf+0x3aa>
    a53e:	51 ce       	rjmp	.-862    	; 0xa1e2 <vfprintf+0x4c>
    a540:	b7 01       	movw	r22, r14
    a542:	80 e2       	ldi	r24, 0x20	; 32
    a544:	90 e0       	ldi	r25, 0x00	; 0
    a546:	0e 94 37 50 	call	0xa06e	; 0xa06e <fputc>
    a54a:	3a 94       	dec	r3
    a54c:	f6 cf       	rjmp	.-20     	; 0xa53a <vfprintf+0x3a4>
    a54e:	f7 01       	movw	r30, r14
    a550:	86 81       	ldd	r24, Z+6	; 0x06
    a552:	97 81       	ldd	r25, Z+7	; 0x07
    a554:	02 c0       	rjmp	.+4      	; 0xa55a <vfprintf+0x3c4>
    a556:	8f ef       	ldi	r24, 0xFF	; 255
    a558:	9f ef       	ldi	r25, 0xFF	; 255
    a55a:	2c 96       	adiw	r28, 0x0c	; 12
    a55c:	0f b6       	in	r0, 0x3f	; 63
    a55e:	f8 94       	cli
    a560:	de bf       	out	0x3e, r29	; 62
    a562:	0f be       	out	0x3f, r0	; 63
    a564:	cd bf       	out	0x3d, r28	; 61
    a566:	df 91       	pop	r29
    a568:	cf 91       	pop	r28
    a56a:	1f 91       	pop	r17
    a56c:	0f 91       	pop	r16
    a56e:	ff 90       	pop	r15
    a570:	ef 90       	pop	r14
    a572:	df 90       	pop	r13
    a574:	cf 90       	pop	r12
    a576:	bf 90       	pop	r11
    a578:	af 90       	pop	r10
    a57a:	9f 90       	pop	r9
    a57c:	8f 90       	pop	r8
    a57e:	7f 90       	pop	r7
    a580:	6f 90       	pop	r6
    a582:	5f 90       	pop	r5
    a584:	4f 90       	pop	r4
    a586:	3f 90       	pop	r3
    a588:	2f 90       	pop	r2
    a58a:	08 95       	ret

0000a58c <__ctype_isfalse>:
    a58c:	99 27       	eor	r25, r25
    a58e:	88 27       	eor	r24, r24

0000a590 <__ctype_istrue>:
    a590:	08 95       	ret

0000a592 <strnlen_P>:
    a592:	fc 01       	movw	r30, r24
    a594:	05 90       	lpm	r0, Z+
    a596:	61 50       	subi	r22, 0x01	; 1
    a598:	70 40       	sbci	r23, 0x00	; 0
    a59a:	01 10       	cpse	r0, r1
    a59c:	d8 f7       	brcc	.-10     	; 0xa594 <strnlen_P+0x2>
    a59e:	80 95       	com	r24
    a5a0:	90 95       	com	r25
    a5a2:	8e 0f       	add	r24, r30
    a5a4:	9f 1f       	adc	r25, r31
    a5a6:	08 95       	ret

0000a5a8 <strnlen>:
    a5a8:	fc 01       	movw	r30, r24
    a5aa:	61 50       	subi	r22, 0x01	; 1
    a5ac:	70 40       	sbci	r23, 0x00	; 0
    a5ae:	01 90       	ld	r0, Z+
    a5b0:	01 10       	cpse	r0, r1
    a5b2:	d8 f7       	brcc	.-10     	; 0xa5aa <strnlen+0x2>
    a5b4:	80 95       	com	r24
    a5b6:	90 95       	com	r25
    a5b8:	8e 0f       	add	r24, r30
    a5ba:	9f 1f       	adc	r25, r31
    a5bc:	08 95       	ret

0000a5be <__ultoa_invert>:
    a5be:	fa 01       	movw	r30, r20
    a5c0:	aa 27       	eor	r26, r26
    a5c2:	28 30       	cpi	r18, 0x08	; 8
    a5c4:	51 f1       	breq	.+84     	; 0xa61a <__ultoa_invert+0x5c>
    a5c6:	20 31       	cpi	r18, 0x10	; 16
    a5c8:	81 f1       	breq	.+96     	; 0xa62a <__ultoa_invert+0x6c>
    a5ca:	e8 94       	clt
    a5cc:	6f 93       	push	r22
    a5ce:	6e 7f       	andi	r22, 0xFE	; 254
    a5d0:	6e 5f       	subi	r22, 0xFE	; 254
    a5d2:	7f 4f       	sbci	r23, 0xFF	; 255
    a5d4:	8f 4f       	sbci	r24, 0xFF	; 255
    a5d6:	9f 4f       	sbci	r25, 0xFF	; 255
    a5d8:	af 4f       	sbci	r26, 0xFF	; 255
    a5da:	b1 e0       	ldi	r27, 0x01	; 1
    a5dc:	3e d0       	rcall	.+124    	; 0xa65a <__ultoa_invert+0x9c>
    a5de:	b4 e0       	ldi	r27, 0x04	; 4
    a5e0:	3c d0       	rcall	.+120    	; 0xa65a <__ultoa_invert+0x9c>
    a5e2:	67 0f       	add	r22, r23
    a5e4:	78 1f       	adc	r23, r24
    a5e6:	89 1f       	adc	r24, r25
    a5e8:	9a 1f       	adc	r25, r26
    a5ea:	a1 1d       	adc	r26, r1
    a5ec:	68 0f       	add	r22, r24
    a5ee:	79 1f       	adc	r23, r25
    a5f0:	8a 1f       	adc	r24, r26
    a5f2:	91 1d       	adc	r25, r1
    a5f4:	a1 1d       	adc	r26, r1
    a5f6:	6a 0f       	add	r22, r26
    a5f8:	71 1d       	adc	r23, r1
    a5fa:	81 1d       	adc	r24, r1
    a5fc:	91 1d       	adc	r25, r1
    a5fe:	a1 1d       	adc	r26, r1
    a600:	20 d0       	rcall	.+64     	; 0xa642 <__ultoa_invert+0x84>
    a602:	09 f4       	brne	.+2      	; 0xa606 <__ultoa_invert+0x48>
    a604:	68 94       	set
    a606:	3f 91       	pop	r19
    a608:	2a e0       	ldi	r18, 0x0A	; 10
    a60a:	26 9f       	mul	r18, r22
    a60c:	11 24       	eor	r1, r1
    a60e:	30 19       	sub	r19, r0
    a610:	30 5d       	subi	r19, 0xD0	; 208
    a612:	31 93       	st	Z+, r19
    a614:	de f6       	brtc	.-74     	; 0xa5cc <__ultoa_invert+0xe>
    a616:	cf 01       	movw	r24, r30
    a618:	08 95       	ret
    a61a:	46 2f       	mov	r20, r22
    a61c:	47 70       	andi	r20, 0x07	; 7
    a61e:	40 5d       	subi	r20, 0xD0	; 208
    a620:	41 93       	st	Z+, r20
    a622:	b3 e0       	ldi	r27, 0x03	; 3
    a624:	0f d0       	rcall	.+30     	; 0xa644 <__ultoa_invert+0x86>
    a626:	c9 f7       	brne	.-14     	; 0xa61a <__ultoa_invert+0x5c>
    a628:	f6 cf       	rjmp	.-20     	; 0xa616 <__ultoa_invert+0x58>
    a62a:	46 2f       	mov	r20, r22
    a62c:	4f 70       	andi	r20, 0x0F	; 15
    a62e:	40 5d       	subi	r20, 0xD0	; 208
    a630:	4a 33       	cpi	r20, 0x3A	; 58
    a632:	18 f0       	brcs	.+6      	; 0xa63a <__ultoa_invert+0x7c>
    a634:	49 5d       	subi	r20, 0xD9	; 217
    a636:	31 fd       	sbrc	r19, 1
    a638:	40 52       	subi	r20, 0x20	; 32
    a63a:	41 93       	st	Z+, r20
    a63c:	02 d0       	rcall	.+4      	; 0xa642 <__ultoa_invert+0x84>
    a63e:	a9 f7       	brne	.-22     	; 0xa62a <__ultoa_invert+0x6c>
    a640:	ea cf       	rjmp	.-44     	; 0xa616 <__ultoa_invert+0x58>
    a642:	b4 e0       	ldi	r27, 0x04	; 4
    a644:	a6 95       	lsr	r26
    a646:	97 95       	ror	r25
    a648:	87 95       	ror	r24
    a64a:	77 95       	ror	r23
    a64c:	67 95       	ror	r22
    a64e:	ba 95       	dec	r27
    a650:	c9 f7       	brne	.-14     	; 0xa644 <__ultoa_invert+0x86>
    a652:	00 97       	sbiw	r24, 0x00	; 0
    a654:	61 05       	cpc	r22, r1
    a656:	71 05       	cpc	r23, r1
    a658:	08 95       	ret
    a65a:	9b 01       	movw	r18, r22
    a65c:	ac 01       	movw	r20, r24
    a65e:	0a 2e       	mov	r0, r26
    a660:	06 94       	lsr	r0
    a662:	57 95       	ror	r21
    a664:	47 95       	ror	r20
    a666:	37 95       	ror	r19
    a668:	27 95       	ror	r18
    a66a:	ba 95       	dec	r27
    a66c:	c9 f7       	brne	.-14     	; 0xa660 <__ultoa_invert+0xa2>
    a66e:	62 0f       	add	r22, r18
    a670:	73 1f       	adc	r23, r19
    a672:	84 1f       	adc	r24, r20
    a674:	95 1f       	adc	r25, r21
    a676:	a0 1d       	adc	r26, r0
    a678:	08 95       	ret

0000a67a <eeprom_read_block>:
    a67a:	dc 01       	movw	r26, r24
    a67c:	cb 01       	movw	r24, r22

0000a67e <eeprom_read_blraw>:
    a67e:	fc 01       	movw	r30, r24
    a680:	e1 99       	sbic	0x1c, 1	; 28
    a682:	fe cf       	rjmp	.-4      	; 0xa680 <eeprom_read_blraw+0x2>
    a684:	06 c0       	rjmp	.+12     	; 0xa692 <eeprom_read_blraw+0x14>
    a686:	ff bb       	out	0x1f, r31	; 31
    a688:	ee bb       	out	0x1e, r30	; 30
    a68a:	e0 9a       	sbi	0x1c, 0	; 28
    a68c:	31 96       	adiw	r30, 0x01	; 1
    a68e:	0d b2       	in	r0, 0x1d	; 29
    a690:	0d 92       	st	X+, r0
    a692:	41 50       	subi	r20, 0x01	; 1
    a694:	50 40       	sbci	r21, 0x00	; 0
    a696:	b8 f7       	brcc	.-18     	; 0xa686 <eeprom_read_blraw+0x8>
    a698:	08 95       	ret

0000a69a <eeprom_read_dword>:
    a69a:	a6 e1       	ldi	r26, 0x16	; 22
    a69c:	b0 e0       	ldi	r27, 0x00	; 0
    a69e:	44 e0       	ldi	r20, 0x04	; 4
    a6a0:	50 e0       	ldi	r21, 0x00	; 0
    a6a2:	0c 94 3f 53 	jmp	0xa67e	; 0xa67e <eeprom_read_blraw>

0000a6a6 <eeprom_read_word>:
    a6a6:	a8 e1       	ldi	r26, 0x18	; 24
    a6a8:	b0 e0       	ldi	r27, 0x00	; 0
    a6aa:	42 e0       	ldi	r20, 0x02	; 2
    a6ac:	50 e0       	ldi	r21, 0x00	; 0
    a6ae:	0c 94 3f 53 	jmp	0xa67e	; 0xa67e <eeprom_read_blraw>

0000a6b2 <eeprom_update_block>:
    a6b2:	dc 01       	movw	r26, r24
    a6b4:	a4 0f       	add	r26, r20
    a6b6:	b5 1f       	adc	r27, r21
    a6b8:	41 50       	subi	r20, 0x01	; 1
    a6ba:	50 40       	sbci	r21, 0x00	; 0
    a6bc:	48 f0       	brcs	.+18     	; 0xa6d0 <eeprom_update_block+0x1e>
    a6be:	cb 01       	movw	r24, r22
    a6c0:	84 0f       	add	r24, r20
    a6c2:	95 1f       	adc	r25, r21
    a6c4:	2e 91       	ld	r18, -X
    a6c6:	0e 94 6a 53 	call	0xa6d4	; 0xa6d4 <eeprom_update_r18>
    a6ca:	41 50       	subi	r20, 0x01	; 1
    a6cc:	50 40       	sbci	r21, 0x00	; 0
    a6ce:	d0 f7       	brcc	.-12     	; 0xa6c4 <eeprom_update_block+0x12>
    a6d0:	08 95       	ret

0000a6d2 <eeprom_update_byte>:
    a6d2:	26 2f       	mov	r18, r22

0000a6d4 <eeprom_update_r18>:
    a6d4:	e1 99       	sbic	0x1c, 1	; 28
    a6d6:	fe cf       	rjmp	.-4      	; 0xa6d4 <eeprom_update_r18>
    a6d8:	9f bb       	out	0x1f, r25	; 31
    a6da:	8e bb       	out	0x1e, r24	; 30
    a6dc:	e0 9a       	sbi	0x1c, 0	; 28
    a6de:	01 97       	sbiw	r24, 0x01	; 1
    a6e0:	0d b2       	in	r0, 0x1d	; 29
    a6e2:	02 16       	cp	r0, r18
    a6e4:	31 f0       	breq	.+12     	; 0xa6f2 <eeprom_update_r18+0x1e>
    a6e6:	2d bb       	out	0x1d, r18	; 29
    a6e8:	0f b6       	in	r0, 0x3f	; 63
    a6ea:	f8 94       	cli
    a6ec:	e2 9a       	sbi	0x1c, 2	; 28
    a6ee:	e1 9a       	sbi	0x1c, 1	; 28
    a6f0:	0f be       	out	0x3f, r0	; 63
    a6f2:	08 95       	ret

0000a6f4 <eeprom_update_dword>:
    a6f4:	03 96       	adiw	r24, 0x03	; 3
    a6f6:	27 2f       	mov	r18, r23
    a6f8:	0e 94 6a 53 	call	0xa6d4	; 0xa6d4 <eeprom_update_r18>
    a6fc:	0e 94 69 53 	call	0xa6d2	; 0xa6d2 <eeprom_update_byte>
    a700:	25 2f       	mov	r18, r21
    a702:	0e 94 6a 53 	call	0xa6d4	; 0xa6d4 <eeprom_update_r18>
    a706:	24 2f       	mov	r18, r20
    a708:	0c 94 6a 53 	jmp	0xa6d4	; 0xa6d4 <eeprom_update_r18>

0000a70c <eeprom_update_word>:
    a70c:	01 96       	adiw	r24, 0x01	; 1
    a70e:	27 2f       	mov	r18, r23
    a710:	0e 94 6a 53 	call	0xa6d4	; 0xa6d4 <eeprom_update_r18>
    a714:	0c 94 69 53 	jmp	0xa6d2	; 0xa6d2 <eeprom_update_byte>

0000a718 <__mulsi3>:
    a718:	db 01       	movw	r26, r22
    a71a:	8f 93       	push	r24
    a71c:	9f 93       	push	r25
    a71e:	0e 94 be 53 	call	0xa77c	; 0xa77c <__muluhisi3>
    a722:	bf 91       	pop	r27
    a724:	af 91       	pop	r26
    a726:	a2 9f       	mul	r26, r18
    a728:	80 0d       	add	r24, r0
    a72a:	91 1d       	adc	r25, r1
    a72c:	a3 9f       	mul	r26, r19
    a72e:	90 0d       	add	r25, r0
    a730:	b2 9f       	mul	r27, r18
    a732:	90 0d       	add	r25, r0
    a734:	11 24       	eor	r1, r1
    a736:	08 95       	ret

0000a738 <__udivmodsi4>:
    a738:	a1 e2       	ldi	r26, 0x21	; 33
    a73a:	1a 2e       	mov	r1, r26
    a73c:	aa 1b       	sub	r26, r26
    a73e:	bb 1b       	sub	r27, r27
    a740:	fd 01       	movw	r30, r26
    a742:	0d c0       	rjmp	.+26     	; 0xa75e <__udivmodsi4_ep>

0000a744 <__udivmodsi4_loop>:
    a744:	aa 1f       	adc	r26, r26
    a746:	bb 1f       	adc	r27, r27
    a748:	ee 1f       	adc	r30, r30
    a74a:	ff 1f       	adc	r31, r31
    a74c:	a2 17       	cp	r26, r18
    a74e:	b3 07       	cpc	r27, r19
    a750:	e4 07       	cpc	r30, r20
    a752:	f5 07       	cpc	r31, r21
    a754:	20 f0       	brcs	.+8      	; 0xa75e <__udivmodsi4_ep>
    a756:	a2 1b       	sub	r26, r18
    a758:	b3 0b       	sbc	r27, r19
    a75a:	e4 0b       	sbc	r30, r20
    a75c:	f5 0b       	sbc	r31, r21

0000a75e <__udivmodsi4_ep>:
    a75e:	66 1f       	adc	r22, r22
    a760:	77 1f       	adc	r23, r23
    a762:	88 1f       	adc	r24, r24
    a764:	99 1f       	adc	r25, r25
    a766:	1a 94       	dec	r1
    a768:	69 f7       	brne	.-38     	; 0xa744 <__udivmodsi4_loop>
    a76a:	60 95       	com	r22
    a76c:	70 95       	com	r23
    a76e:	80 95       	com	r24
    a770:	90 95       	com	r25
    a772:	9b 01       	movw	r18, r22
    a774:	ac 01       	movw	r20, r24
    a776:	bd 01       	movw	r22, r26
    a778:	cf 01       	movw	r24, r30
    a77a:	08 95       	ret

0000a77c <__muluhisi3>:
    a77c:	0e 94 c9 53 	call	0xa792	; 0xa792 <__umulhisi3>
    a780:	a5 9f       	mul	r26, r21
    a782:	90 0d       	add	r25, r0
    a784:	b4 9f       	mul	r27, r20
    a786:	90 0d       	add	r25, r0
    a788:	a4 9f       	mul	r26, r20
    a78a:	80 0d       	add	r24, r0
    a78c:	91 1d       	adc	r25, r1
    a78e:	11 24       	eor	r1, r1
    a790:	08 95       	ret

0000a792 <__umulhisi3>:
    a792:	a2 9f       	mul	r26, r18
    a794:	b0 01       	movw	r22, r0
    a796:	b3 9f       	mul	r27, r19
    a798:	c0 01       	movw	r24, r0
    a79a:	a3 9f       	mul	r26, r19
    a79c:	70 0d       	add	r23, r0
    a79e:	81 1d       	adc	r24, r1
    a7a0:	11 24       	eor	r1, r1
    a7a2:	91 1d       	adc	r25, r1
    a7a4:	b2 9f       	mul	r27, r18
    a7a6:	70 0d       	add	r23, r0
    a7a8:	81 1d       	adc	r24, r1
    a7aa:	11 24       	eor	r1, r1
    a7ac:	91 1d       	adc	r25, r1
    a7ae:	08 95       	ret

0000a7b0 <_exit>:
    a7b0:	f8 94       	cli

0000a7b2 <__stop_program>:
    a7b2:	ff cf       	rjmp	.-2      	; 0xa7b2 <__stop_program>
