
firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  000029b8  00002a4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000029b8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003b4  00800112  00800112  00002a5e  2**0
                  ALLOC
  3 .stab         00008088  00000000  00000000  00002a60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003ac7  00000000  00000000  0000aae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000e5af  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000e5c0  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 b0 07 	jmp	0xf60	; 0xf60 <__vector_18>
      4c:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__vector_19>
      50:	0c 94 29 08 	jmp	0x1052	; 0x1052 <__vector_20>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d4 e0       	ldi	r29, 0x04	; 4
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 eb       	ldi	r30, 0xB8	; 184
      7c:	f9 e2       	ldi	r31, 0x29	; 41
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a2 31       	cpi	r26, 0x12	; 18
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	24 e0       	ldi	r18, 0x04	; 4
      8c:	a2 e1       	ldi	r26, 0x12	; 18
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a6 3c       	cpi	r26, 0xC6	; 198
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 96 14 	call	0x292c	; 0x292c <main>
      9e:	0c 94 da 14 	jmp	0x29b4	; 0x29b4 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vRoleta>:
  }
  crEND();
}

static void vRoleta(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
      a6:	cf 92       	push	r12
      a8:	df 92       	push	r13
      aa:	ff 92       	push	r15
      ac:	0f 93       	push	r16
      ae:	1f 93       	push	r17
      b0:	cf 93       	push	r28
      b2:	df 93       	push	r29
      b4:	6c 01       	movw	r12, r24
      b6:	f6 2e       	mov	r15, r22
  static uint8_t	rozkaz[2];
  static uint16_t	czasAkcji[2];
  czasAkcji[uxIndex]  = portMAX_DELAY;
      b8:	c6 2f       	mov	r28, r22
      ba:	d0 e0       	ldi	r29, 0x00	; 0
      bc:	8e 01       	movw	r16, r28
      be:	00 0f       	add	r16, r16
      c0:	11 1f       	adc	r17, r17
      c2:	f8 01       	movw	r30, r16
      c4:	ef 5d       	subi	r30, 0xDF	; 223
      c6:	fe 4f       	sbci	r31, 0xFE	; 254
      c8:	8f ef       	ldi	r24, 0xFF	; 255
      ca:	9f ef       	ldi	r25, 0xFF	; 255
      cc:	91 83       	std	Z+1, r25	; 0x01
      ce:	80 83       	st	Z, r24
  static portBASE_TYPE xResult[2];
  crSTART( xHandle );
      d0:	f6 01       	movw	r30, r12
      d2:	80 8d       	ldd	r24, Z+24	; 0x18
      d4:	91 8d       	ldd	r25, Z+25	; 0x19
      d6:	84 31       	cpi	r24, 0x14	; 20
      d8:	f1 e0       	ldi	r31, 0x01	; 1
      da:	9f 07       	cpc	r25, r31
      dc:	f9 f0       	breq	.+62     	; 0x11c <vRoleta+0x76>
      de:	85 31       	cpi	r24, 0x15	; 21
      e0:	21 e0       	ldi	r18, 0x01	; 1
      e2:	92 07       	cpc	r25, r18
      e4:	b9 f1       	breq	.+110    	; 0x154 <vRoleta+0xae>
      e6:	89 2b       	or	r24, r25
      e8:	09 f0       	breq	.+2      	; 0xec <vRoleta+0x46>
      ea:	6c c0       	rjmp	.+216    	; 0x1c4 <vRoleta+0x11e>
  for (;;)
  {
    crQUEUE_RECEIVE(xHandle, xRoleta[uxIndex], &rozkaz[uxIndex], czasAkcji[uxIndex], &xResult[uxIndex]);
      ec:	f8 01       	movw	r30, r16
      ee:	ef 5d       	subi	r30, 0xDF	; 223
      f0:	fe 4f       	sbci	r31, 0xFE	; 254
      f2:	40 81       	ld	r20, Z
      f4:	51 81       	ldd	r21, Z+1	; 0x01
      f6:	be 01       	movw	r22, r28
      f8:	61 5e       	subi	r22, 0xE1	; 225
      fa:	7e 4f       	sbci	r23, 0xFE	; 254
      fc:	f8 01       	movw	r30, r16
      fe:	ee 53       	subi	r30, 0x3E	; 62
     100:	fb 4f       	sbci	r31, 0xFB	; 251
     102:	80 81       	ld	r24, Z
     104:	91 81       	ldd	r25, Z+1	; 0x01
     106:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     10a:	fe 01       	movw	r30, r28
     10c:	e3 5e       	subi	r30, 0xE3	; 227
     10e:	fe 4f       	sbci	r31, 0xFE	; 254
     110:	80 83       	st	Z, r24
     112:	8c 3f       	cpi	r24, 0xFC	; 252
     114:	99 f4       	brne	.+38     	; 0x13c <vRoleta+0x96>
     116:	84 e1       	ldi	r24, 0x14	; 20
     118:	91 e0       	ldi	r25, 0x01	; 1
     11a:	18 c0       	rjmp	.+48     	; 0x14c <vRoleta+0xa6>
     11c:	40 e0       	ldi	r20, 0x00	; 0
     11e:	50 e0       	ldi	r21, 0x00	; 0
     120:	be 01       	movw	r22, r28
     122:	61 5e       	subi	r22, 0xE1	; 225
     124:	7e 4f       	sbci	r23, 0xFE	; 254
     126:	f8 01       	movw	r30, r16
     128:	ee 53       	subi	r30, 0x3E	; 62
     12a:	fb 4f       	sbci	r31, 0xFB	; 251
     12c:	80 81       	ld	r24, Z
     12e:	91 81       	ldd	r25, Z+1	; 0x01
     130:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     134:	fe 01       	movw	r30, r28
     136:	e3 5e       	subi	r30, 0xE3	; 227
     138:	fe 4f       	sbci	r31, 0xFE	; 254
     13a:	80 83       	st	Z, r24
     13c:	fe 01       	movw	r30, r28
     13e:	e3 5e       	subi	r30, 0xE3	; 227
     140:	fe 4f       	sbci	r31, 0xFE	; 254
     142:	80 81       	ld	r24, Z
     144:	8b 3f       	cpi	r24, 0xFB	; 251
     146:	59 f4       	brne	.+22     	; 0x15e <vRoleta+0xb8>
     148:	85 e1       	ldi	r24, 0x15	; 21
     14a:	91 e0       	ldi	r25, 0x01	; 1
     14c:	f6 01       	movw	r30, r12
     14e:	91 8f       	std	Z+25, r25	; 0x19
     150:	80 8f       	std	Z+24, r24	; 0x18
     152:	38 c0       	rjmp	.+112    	; 0x1c4 <vRoleta+0x11e>
     154:	81 e0       	ldi	r24, 0x01	; 1
     156:	fe 01       	movw	r30, r28
     158:	e3 5e       	subi	r30, 0xE3	; 227
     15a:	fe 4f       	sbci	r31, 0xFE	; 254
     15c:	80 83       	st	Z, r24

    if (xResult[uxIndex] == pdTRUE)
     15e:	fe 01       	movw	r30, r28
     160:	e3 5e       	subi	r30, 0xE3	; 227
     162:	fe 4f       	sbci	r31, 0xFE	; 254
     164:	80 81       	ld	r24, Z
     166:	81 30       	cpi	r24, 0x01	; 1
     168:	11 f5       	brne	.+68     	; 0x1ae <vRoleta+0x108>
    {
      uint8_t tmp = rozkaz[uxIndex] & 0x3F;
     16a:	fe 01       	movw	r30, r28
     16c:	e1 5e       	subi	r30, 0xE1	; 225
     16e:	fe 4f       	sbci	r31, 0xFE	; 254
     170:	80 81       	ld	r24, Z
     172:	28 2f       	mov	r18, r24
     174:	2f 73       	andi	r18, 0x3F	; 63
      if (tmp == 0)
     176:	31 f4       	brne	.+12     	; 0x184 <vRoleta+0xde>
        czasAkcji[uxIndex] = portMAX_DELAY;
     178:	2f ef       	ldi	r18, 0xFF	; 255
     17a:	3f ef       	ldi	r19, 0xFF	; 255
     17c:	f8 01       	movw	r30, r16
     17e:	ef 5d       	subi	r30, 0xDF	; 223
     180:	fe 4f       	sbci	r31, 0xFE	; 254
     182:	07 c0       	rjmp	.+14     	; 0x192 <vRoleta+0xec>
      else
        czasAkcji[uxIndex] = tmp*20;
     184:	f8 01       	movw	r30, r16
     186:	ef 5d       	subi	r30, 0xDF	; 223
     188:	fe 4f       	sbci	r31, 0xFE	; 254
     18a:	94 e1       	ldi	r25, 0x14	; 20
     18c:	29 9f       	mul	r18, r25
     18e:	90 01       	movw	r18, r0
     190:	11 24       	eor	r1, r1
     192:	31 83       	std	Z+1, r19	; 0x01
     194:	20 83       	st	Z, r18
      if (rozkaz[uxIndex] & 0x40)
     196:	86 fd       	sbrc	r24, 6
     198:	11 c0       	rjmp	.+34     	; 0x1bc <vRoleta+0x116>
      {
        roletaStop(uxIndex);
      }
      else
      {
        if (rozkaz[uxIndex] & 0x80)
     19a:	87 ff       	sbrs	r24, 7
     19c:	04 c0       	rjmp	.+8      	; 0x1a6 <vRoleta+0x100>
          roletawGore(uxIndex);
     19e:	8f 2d       	mov	r24, r15
     1a0:	0e 94 62 08 	call	0x10c4	; 0x10c4 <roletawGore>
     1a4:	a3 cf       	rjmp	.-186    	; 0xec <vRoleta+0x46>
        else
          roletawDol(uxIndex);
     1a6:	8f 2d       	mov	r24, r15
     1a8:	0e 94 6b 08 	call	0x10d6	; 0x10d6 <roletawDol>
     1ac:	9f cf       	rjmp	.-194    	; 0xec <vRoleta+0x46>
      }
    }
    else
    {
      czasAkcji[uxIndex] = portMAX_DELAY;
     1ae:	8f ef       	ldi	r24, 0xFF	; 255
     1b0:	9f ef       	ldi	r25, 0xFF	; 255
     1b2:	f8 01       	movw	r30, r16
     1b4:	ef 5d       	subi	r30, 0xDF	; 223
     1b6:	fe 4f       	sbci	r31, 0xFE	; 254
     1b8:	91 83       	std	Z+1, r25	; 0x01
     1ba:	80 83       	st	Z, r24
      roletaStop(uxIndex);
     1bc:	8f 2d       	mov	r24, r15
     1be:	0e 94 74 08 	call	0x10e8	; 0x10e8 <roletaStop>
     1c2:	94 cf       	rjmp	.-216    	; 0xec <vRoleta+0x46>
    }
  }
  crEND();
}
     1c4:	df 91       	pop	r29
     1c6:	cf 91       	pop	r28
     1c8:	1f 91       	pop	r17
     1ca:	0f 91       	pop	r16
     1cc:	ff 90       	pop	r15
     1ce:	df 90       	pop	r13
     1d0:	cf 90       	pop	r12
     1d2:	08 95       	ret

000001d4 <vKlawisze>:
  return 0;
}
/*-----------------------------------------------------------*/

static void vKlawisze(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
     1d4:	0f 93       	push	r16
     1d6:	1f 93       	push	r17
     1d8:	cf 93       	push	r28
     1da:	df 93       	push	r29
     1dc:	00 d0       	rcall	.+0      	; 0x1de <vKlawisze+0xa>
     1de:	cd b7       	in	r28, 0x3d	; 61
     1e0:	de b7       	in	r29, 0x3e	; 62
     1e2:	8c 01       	movw	r16, r24
  (void) uxIndex;
  static portBASE_TYPE xResult;

  crSTART( xHandle );
     1e4:	fc 01       	movw	r30, r24
     1e6:	20 8d       	ldd	r18, Z+24	; 0x18
     1e8:	31 8d       	ldd	r19, Z+25	; 0x19
     1ea:	2c 3e       	cpi	r18, 0xEC	; 236
     1ec:	31 05       	cpc	r19, r1
     1ee:	09 f4       	brne	.+2      	; 0x1f2 <vKlawisze+0x1e>
     1f0:	4d c0       	rjmp	.+154    	; 0x28c <vKlawisze+0xb8>
     1f2:	38 f4       	brcc	.+14     	; 0x202 <vKlawisze+0x2e>
     1f4:	21 15       	cp	r18, r1
     1f6:	31 05       	cpc	r19, r1
     1f8:	71 f1       	breq	.+92     	; 0x256 <vKlawisze+0x82>
     1fa:	22 3e       	cpi	r18, 0xE2	; 226
     1fc:	31 05       	cpc	r19, r1
     1fe:	89 f0       	breq	.+34     	; 0x222 <vKlawisze+0x4e>
     200:	87 c0       	rjmp	.+270    	; 0x310 <vKlawisze+0x13c>
     202:	26 3f       	cpi	r18, 0xF6	; 246
     204:	31 05       	cpc	r19, r1
     206:	09 f4       	brne	.+2      	; 0x20a <vKlawisze+0x36>
     208:	67 c0       	rjmp	.+206    	; 0x2d8 <vKlawisze+0x104>
     20a:	27 3f       	cpi	r18, 0xF7	; 247
     20c:	31 05       	cpc	r19, r1
     20e:	09 f4       	brne	.+2      	; 0x212 <vKlawisze+0x3e>
     210:	7b c0       	rjmp	.+246    	; 0x308 <vKlawisze+0x134>
     212:	2d 3e       	cpi	r18, 0xED	; 237
     214:	31 05       	cpc	r19, r1
     216:	09 f0       	breq	.+2      	; 0x21a <vKlawisze+0x46>
     218:	7b c0       	rjmp	.+246    	; 0x310 <vKlawisze+0x13c>
    crDELAY( xHandle, 1);
    uint8_t wiadomosc;
    wiadomosc = (uint8_t) (automatStanowKlawiszy(czytKlawiszRol1wGore(), czytKlawiszRol1wDol(), &roleta1));
    if (wiadomosc)
    {
      crQUEUE_SEND(xHandle, xRoleta[0], &wiadomosc, 10, &xResult);
     21a:	81 e0       	ldi	r24, 0x01	; 1
     21c:	80 93 1c 01 	sts	0x011C, r24
     220:	0d c0       	rjmp	.+26     	; 0x23c <vKlawisze+0x68>
  crSTART( xHandle );
  for( ;; )
  {
    crDELAY( xHandle, 1);
    uint8_t wiadomosc;
    wiadomosc = (uint8_t) (automatStanowKlawiszy(czytKlawiszRol1wGore(), czytKlawiszRol1wDol(), &roleta1));
     222:	0e 94 8f 08 	call	0x111e	; 0x111e <czytKlawiszRol1wDol>
     226:	8a 83       	std	Y+2, r24	; 0x02
     228:	0e 94 8c 08 	call	0x1118	; 0x1118 <czytKlawiszRol1wGore>
     22c:	47 e1       	ldi	r20, 0x17	; 23
     22e:	51 e0       	ldi	r21, 0x01	; 1
     230:	6a 81       	ldd	r22, Y+2	; 0x02
     232:	0e 94 98 08 	call	0x1130	; 0x1130 <automatStanowKlawiszy>
     236:	89 83       	std	Y+1, r24	; 0x01
    if (wiadomosc)
     238:	81 11       	cpse	r24, r1
     23a:	16 c0       	rjmp	.+44     	; 0x268 <vKlawisze+0x94>
    {
      crQUEUE_SEND(xHandle, xRoleta[0], &wiadomosc, 10, &xResult);
    }
    wiadomosc = (uint8_t)(automatStanowKlawiszy(czytKlawiszRol2wGore(), czytKlawiszRol2wDol(), &roleta2));
     23c:	0e 94 95 08 	call	0x112a	; 0x112a <czytKlawiszRol2wDol>
     240:	8a 83       	std	Y+2, r24	; 0x02
     242:	0e 94 92 08 	call	0x1124	; 0x1124 <czytKlawiszRol2wGore>
     246:	42 e1       	ldi	r20, 0x12	; 18
     248:	51 e0       	ldi	r21, 0x01	; 1
     24a:	6a 81       	ldd	r22, Y+2	; 0x02
     24c:	0e 94 98 08 	call	0x1130	; 0x1130 <automatStanowKlawiszy>
     250:	89 83       	std	Y+1, r24	; 0x01
    if (wiadomosc)
     252:	81 11       	cpse	r24, r1
     254:	2f c0       	rjmp	.+94     	; 0x2b4 <vKlawisze+0xe0>
  static portBASE_TYPE xResult;

  crSTART( xHandle );
  for( ;; )
  {
    crDELAY( xHandle, 1);
     256:	60 e0       	ldi	r22, 0x00	; 0
     258:	70 e0       	ldi	r23, 0x00	; 0
     25a:	81 e0       	ldi	r24, 0x01	; 1
     25c:	90 e0       	ldi	r25, 0x00	; 0
     25e:	0e 94 9f 11 	call	0x233e	; 0x233e <vCoRoutineAddToDelayedList>
     262:	82 ee       	ldi	r24, 0xE2	; 226
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	4c c0       	rjmp	.+152    	; 0x300 <vKlawisze+0x12c>
    uint8_t wiadomosc;
    wiadomosc = (uint8_t) (automatStanowKlawiszy(czytKlawiszRol1wGore(), czytKlawiszRol1wDol(), &roleta1));
    if (wiadomosc)
    {
      crQUEUE_SEND(xHandle, xRoleta[0], &wiadomosc, 10, &xResult);
     268:	4a e0       	ldi	r20, 0x0A	; 10
     26a:	50 e0       	ldi	r21, 0x00	; 0
     26c:	be 01       	movw	r22, r28
     26e:	6f 5f       	subi	r22, 0xFF	; 255
     270:	7f 4f       	sbci	r23, 0xFF	; 255
     272:	80 91 c2 04 	lds	r24, 0x04C2
     276:	90 91 c3 04 	lds	r25, 0x04C3
     27a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     27e:	80 93 1c 01 	sts	0x011C, r24
     282:	8c 3f       	cpi	r24, 0xFC	; 252
     284:	81 f4       	brne	.+32     	; 0x2a6 <vKlawisze+0xd2>
     286:	8c ee       	ldi	r24, 0xEC	; 236
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	3a c0       	rjmp	.+116    	; 0x300 <vKlawisze+0x12c>
     28c:	40 e0       	ldi	r20, 0x00	; 0
     28e:	50 e0       	ldi	r21, 0x00	; 0
     290:	be 01       	movw	r22, r28
     292:	6f 5f       	subi	r22, 0xFF	; 255
     294:	7f 4f       	sbci	r23, 0xFF	; 255
     296:	80 91 c2 04 	lds	r24, 0x04C2
     29a:	90 91 c3 04 	lds	r25, 0x04C3
     29e:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     2a2:	80 93 1c 01 	sts	0x011C, r24
     2a6:	80 91 1c 01 	lds	r24, 0x011C
     2aa:	8b 3f       	cpi	r24, 0xFB	; 251
     2ac:	39 f6       	brne	.-114    	; 0x23c <vKlawisze+0x68>
     2ae:	8d ee       	ldi	r24, 0xED	; 237
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	26 c0       	rjmp	.+76     	; 0x300 <vKlawisze+0x12c>
    }
    wiadomosc = (uint8_t)(automatStanowKlawiszy(czytKlawiszRol2wGore(), czytKlawiszRol2wDol(), &roleta2));
    if (wiadomosc)
    {
      crQUEUE_SEND(xHandle, xRoleta[1], &wiadomosc, 10, &xResult);
     2b4:	4a e0       	ldi	r20, 0x0A	; 10
     2b6:	50 e0       	ldi	r21, 0x00	; 0
     2b8:	be 01       	movw	r22, r28
     2ba:	6f 5f       	subi	r22, 0xFF	; 255
     2bc:	7f 4f       	sbci	r23, 0xFF	; 255
     2be:	80 91 c4 04 	lds	r24, 0x04C4
     2c2:	90 91 c5 04 	lds	r25, 0x04C5
     2c6:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     2ca:	80 93 1c 01 	sts	0x011C, r24
     2ce:	8c 3f       	cpi	r24, 0xFC	; 252
     2d0:	81 f4       	brne	.+32     	; 0x2f2 <vKlawisze+0x11e>
     2d2:	86 ef       	ldi	r24, 0xF6	; 246
     2d4:	90 e0       	ldi	r25, 0x00	; 0
     2d6:	14 c0       	rjmp	.+40     	; 0x300 <vKlawisze+0x12c>
     2d8:	40 e0       	ldi	r20, 0x00	; 0
     2da:	50 e0       	ldi	r21, 0x00	; 0
     2dc:	be 01       	movw	r22, r28
     2de:	6f 5f       	subi	r22, 0xFF	; 255
     2e0:	7f 4f       	sbci	r23, 0xFF	; 255
     2e2:	80 91 c4 04 	lds	r24, 0x04C4
     2e6:	90 91 c5 04 	lds	r25, 0x04C5
     2ea:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     2ee:	80 93 1c 01 	sts	0x011C, r24
     2f2:	80 91 1c 01 	lds	r24, 0x011C
     2f6:	8b 3f       	cpi	r24, 0xFB	; 251
     2f8:	09 f0       	breq	.+2      	; 0x2fc <vKlawisze+0x128>
     2fa:	ad cf       	rjmp	.-166    	; 0x256 <vKlawisze+0x82>
     2fc:	87 ef       	ldi	r24, 0xF7	; 247
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	f8 01       	movw	r30, r16
     302:	91 8f       	std	Z+25, r25	; 0x19
     304:	80 8f       	std	Z+24, r24	; 0x18
     306:	04 c0       	rjmp	.+8      	; 0x310 <vKlawisze+0x13c>
     308:	81 e0       	ldi	r24, 0x01	; 1
     30a:	80 93 1c 01 	sts	0x011C, r24
    }
  }
     30e:	a3 cf       	rjmp	.-186    	; 0x256 <vKlawisze+0x82>
  crEND();
}
     310:	0f 90       	pop	r0
     312:	0f 90       	pop	r0
     314:	df 91       	pop	r29
     316:	cf 91       	pop	r28
     318:	1f 91       	pop	r17
     31a:	0f 91       	pop	r16
     31c:	08 95       	ret

0000031e <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
  for( ;; )
  {
    vCoRoutineSchedule();
     31e:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vCoRoutineSchedule>
  }
     322:	fd cf       	rjmp	.-6      	; 0x31e <vApplicationIdleHook>

00000324 <_crc_xmodem_update>:
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
     324:	96 27       	eor	r25, r22
     326:	09 2e       	mov	r0, r25
     328:	02 94       	swap	r0
     32a:	20 2d       	mov	r18, r0
     32c:	2f 70       	andi	r18, 0x0F	; 15
     32e:	29 27       	eor	r18, r25
     330:	69 2f       	mov	r22, r25
     332:	60 25       	eor	r22, r0
     334:	66 0f       	add	r22, r22
     336:	60 7e       	andi	r22, 0xE0	; 224
     338:	26 27       	eor	r18, r22
     33a:	60 2d       	mov	r22, r0
     33c:	69 27       	eor	r22, r25
     33e:	60 7f       	andi	r22, 0xF0	; 240
     340:	66 95       	lsr	r22
     342:	09 2e       	mov	r0, r25
     344:	00 0c       	add	r0, r0
     346:	66 1f       	adc	r22, r22
     348:	96 95       	lsr	r25
     34a:	96 95       	lsr	r25
     34c:	96 95       	lsr	r25
     34e:	9f 71       	andi	r25, 0x1F	; 31
     350:	96 27       	eor	r25, r22
     352:	98 27       	eor	r25, r24
     354:	82 2f       	mov	r24, r18
     356:	08 95       	ret

00000358 <vProtocol>:
  }
  return wysylac;
}

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
     358:	ff 92       	push	r15
     35a:	0f 93       	push	r16
     35c:	1f 93       	push	r17
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	1f 92       	push	r1
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
     368:	8c 01       	movw	r16, r24
  (void) uxIndex;

  crSTART( xHandle );
     36a:	fc 01       	movw	r30, r24
     36c:	20 8d       	ldd	r18, Z+24	; 0x18
     36e:	31 8d       	ldd	r19, Z+25	; 0x19
     370:	25 35       	cpi	r18, 0x55	; 85
     372:	f2 e0       	ldi	r31, 0x02	; 2
     374:	3f 07       	cpc	r19, r31
     376:	09 f4       	brne	.+2      	; 0x37a <vProtocol+0x22>
     378:	d1 c3       	rjmp	.+1954   	; 0xb1c <__stack+0x61d>
     37a:	08 f0       	brcs	.+2      	; 0x37e <vProtocol+0x26>
     37c:	a4 c0       	rjmp	.+328    	; 0x4c6 <vProtocol+0x16e>
     37e:	22 3d       	cpi	r18, 0xD2	; 210
     380:	e1 e0       	ldi	r30, 0x01	; 1
     382:	3e 07       	cpc	r19, r30
     384:	09 f4       	brne	.+2      	; 0x388 <vProtocol+0x30>
     386:	64 c2       	rjmp	.+1224   	; 0x850 <__stack+0x351>
     388:	08 f0       	brcs	.+2      	; 0x38c <vProtocol+0x34>
     38a:	4a c0       	rjmp	.+148    	; 0x420 <vProtocol+0xc8>
     38c:	21 36       	cpi	r18, 0x61	; 97
     38e:	81 e0       	ldi	r24, 0x01	; 1
     390:	38 07       	cpc	r19, r24
     392:	09 f4       	brne	.+2      	; 0x396 <vProtocol+0x3e>
     394:	96 c1       	rjmp	.+812    	; 0x6c2 <__stack+0x1c3>
     396:	00 f5       	brcc	.+64     	; 0x3d8 <vProtocol+0x80>
     398:	2c 34       	cpi	r18, 0x4C	; 76
     39a:	f1 e0       	ldi	r31, 0x01	; 1
     39c:	3f 07       	cpc	r19, r31
     39e:	09 f4       	brne	.+2      	; 0x3a2 <vProtocol+0x4a>
     3a0:	4b c1       	rjmp	.+662    	; 0x638 <__stack+0x139>
     3a2:	20 f4       	brcc	.+8      	; 0x3ac <vProtocol+0x54>
     3a4:	23 2b       	or	r18, r19
     3a6:	09 f4       	brne	.+2      	; 0x3aa <vProtocol+0x52>
     3a8:	2e c1       	rjmp	.+604    	; 0x606 <__stack+0x107>
     3aa:	9f c5       	rjmp	.+2878   	; 0xeea <__stack+0x9eb>
     3ac:	2d 34       	cpi	r18, 0x4D	; 77
     3ae:	e1 e0       	ldi	r30, 0x01	; 1
     3b0:	3e 07       	cpc	r19, r30
     3b2:	09 f4       	brne	.+2      	; 0x3b6 <vProtocol+0x5e>
     3b4:	54 c1       	rjmp	.+680    	; 0x65e <__stack+0x15f>
     3b6:	20 36       	cpi	r18, 0x60	; 96
     3b8:	31 40       	sbci	r19, 0x01	; 1
     3ba:	09 f0       	breq	.+2      	; 0x3be <vProtocol+0x66>
     3bc:	96 c5       	rjmp	.+2860   	; 0xeea <__stack+0x9eb>
        crc = _crc_xmodem_update(0, znak);
      }
    }
    if (stan == s_addr)
    {
      crQUEUE_RECEIVE(xHandle, xRxedChars, &znak, 1, &xResult);
     3be:	40 e0       	ldi	r20, 0x00	; 0
     3c0:	50 e0       	ldi	r21, 0x00	; 0
     3c2:	69 e2       	ldi	r22, 0x29	; 41
     3c4:	71 e0       	ldi	r23, 0x01	; 1
     3c6:	80 91 45 01 	lds	r24, 0x0145
     3ca:	90 91 46 01 	lds	r25, 0x0146
     3ce:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     3d2:	80 93 28 01 	sts	0x0128, r24
     3d6:	6e c1       	rjmp	.+732    	; 0x6b4 <__stack+0x1b5>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     3d8:	27 38       	cpi	r18, 0x87	; 135
     3da:	81 e0       	ldi	r24, 0x01	; 1
     3dc:	38 07       	cpc	r19, r24
     3de:	09 f4       	brne	.+2      	; 0x3e2 <vProtocol+0x8a>
     3e0:	b5 c1       	rjmp	.+874    	; 0x74c <__stack+0x24d>
     3e2:	88 f4       	brcc	.+34     	; 0x406 <vProtocol+0xae>
     3e4:	26 38       	cpi	r18, 0x86	; 134
     3e6:	31 40       	sbci	r19, 0x01	; 1
     3e8:	09 f0       	breq	.+2      	; 0x3ec <vProtocol+0x94>
     3ea:	7f c5       	rjmp	.+2814   	; 0xeea <__stack+0x9eb>
    }
    if (stan == s_rozkaz)
    {
      Led1On();
      Led2Off();
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&kodRozkazu), 1, &xResult);
     3ec:	40 e0       	ldi	r20, 0x00	; 0
     3ee:	50 e0       	ldi	r21, 0x00	; 0
     3f0:	62 e4       	ldi	r22, 0x42	; 66
     3f2:	71 e0       	ldi	r23, 0x01	; 1
     3f4:	80 91 45 01 	lds	r24, 0x0145
     3f8:	90 91 46 01 	lds	r25, 0x0146
     3fc:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     400:	80 93 28 01 	sts	0x0128, r24
     404:	9c c1       	rjmp	.+824    	; 0x73e <__stack+0x23f>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     406:	24 3a       	cpi	r18, 0xA4	; 164
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	38 07       	cpc	r19, r24
     40c:	09 f4       	brne	.+2      	; 0x410 <vProtocol+0xb8>
     40e:	d1 c1       	rjmp	.+930    	; 0x7b2 <__stack+0x2b3>
     410:	25 3a       	cpi	r18, 0xA5	; 165
     412:	31 40       	sbci	r19, 0x01	; 1
     414:	09 f0       	breq	.+2      	; 0x418 <vProtocol+0xc0>
     416:	69 c5       	rjmp	.+2770   	; 0xeea <__stack+0x9eb>
    }
    if (stan == s_len)
    {
      Led1Off();
      Led2On();
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&dlDanych), 1, &xResult);
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	80 93 28 01 	sts	0x0128, r24
     41e:	dc c1       	rjmp	.+952    	; 0x7d8 <__stack+0x2d9>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     420:	2f 30       	cpi	r18, 0x0F	; 15
     422:	f2 e0       	ldi	r31, 0x02	; 2
     424:	3f 07       	cpc	r19, r31
     426:	09 f4       	brne	.+2      	; 0x42a <vProtocol+0xd2>
     428:	9c c2       	rjmp	.+1336   	; 0x962 <__stack+0x463>
     42a:	20 f5       	brcc	.+72     	; 0x474 <vProtocol+0x11c>
     42c:	24 3f       	cpi	r18, 0xF4	; 244
     42e:	e1 e0       	ldi	r30, 0x01	; 1
     430:	3e 07       	cpc	r19, r30
     432:	09 f4       	brne	.+2      	; 0x436 <vProtocol+0xde>
     434:	58 c2       	rjmp	.+1200   	; 0x8e6 <__stack+0x3e7>
     436:	40 f4       	brcc	.+16     	; 0x448 <vProtocol+0xf0>
     438:	23 3d       	cpi	r18, 0xD3	; 211
     43a:	31 40       	sbci	r19, 0x01	; 1
     43c:	09 f0       	breq	.+2      	; 0x440 <vProtocol+0xe8>
     43e:	55 c5       	rjmp	.+2730   	; 0xeea <__stack+0x9eb>
        stan = s_CRC_HI;
      }
      else
      {
        //Led2Off();
        crQUEUE_RECEIVE(xHandle, xRxedChars, &znak, 1, &xResult);
     440:	81 e0       	ldi	r24, 0x01	; 1
     442:	80 93 28 01 	sts	0x0128, r24
     446:	17 c2       	rjmp	.+1070   	; 0x876 <__stack+0x377>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     448:	25 3f       	cpi	r18, 0xF5	; 245
     44a:	e1 e0       	ldi	r30, 0x01	; 1
     44c:	3e 07       	cpc	r19, r30
     44e:	09 f4       	brne	.+2      	; 0x452 <vProtocol+0xfa>
     450:	5d c2       	rjmp	.+1210   	; 0x90c <__stack+0x40d>
     452:	2e 30       	cpi	r18, 0x0E	; 14
     454:	32 40       	sbci	r19, 0x02	; 2
     456:	09 f0       	breq	.+2      	; 0x45a <vProtocol+0x102>
     458:	48 c5       	rjmp	.+2704   	; 0xeea <__stack+0x9eb>
        stan = s_sync;
      }    
    }
    if (stan == s_CRC_LO)
    {
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&crcLo), 1, &xResult);
     45a:	40 e0       	ldi	r20, 0x00	; 0
     45c:	50 e0       	ldi	r21, 0x00	; 0
     45e:	6e e2       	ldi	r22, 0x2E	; 46
     460:	71 e0       	ldi	r23, 0x01	; 1
     462:	80 91 45 01 	lds	r24, 0x0145
     466:	90 91 46 01 	lds	r25, 0x0146
     46a:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     46e:	80 93 28 01 	sts	0x0128, r24
     472:	70 c2       	rjmp	.+1248   	; 0x954 <__stack+0x455>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     474:	2c 34       	cpi	r18, 0x4C	; 76
     476:	82 e0       	ldi	r24, 0x02	; 2
     478:	38 07       	cpc	r19, r24
     47a:	09 f4       	brne	.+2      	; 0x47e <vProtocol+0x126>
     47c:	15 c3       	rjmp	.+1578   	; 0xaa8 <__stack+0x5a9>
     47e:	68 f4       	brcc	.+26     	; 0x49a <vProtocol+0x142>
     480:	22 34       	cpi	r18, 0x42	; 66
     482:	f2 e0       	ldi	r31, 0x02	; 2
     484:	3f 07       	cpc	r19, r31
     486:	09 f4       	brne	.+2      	; 0x48a <vProtocol+0x132>
     488:	df c2       	rjmp	.+1470   	; 0xa48 <__stack+0x549>
     48a:	23 34       	cpi	r18, 0x43	; 67
     48c:	32 40       	sbci	r19, 0x02	; 2
     48e:	09 f0       	breq	.+2      	; 0x492 <vProtocol+0x13a>
     490:	2c c5       	rjmp	.+2648   	; 0xeea <__stack+0x9eb>
        if (rezultat == 1)
        {
          //SYNC
          uint8_t temp;
          temp = SYNC;
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 0, &xResult);
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	80 93 28 01 	sts	0x0128, r24
     498:	eb c2       	rjmp	.+1494   	; 0xa70 <__stack+0x571>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     49a:	2d 34       	cpi	r18, 0x4D	; 77
     49c:	e2 e0       	ldi	r30, 0x02	; 2
     49e:	3e 07       	cpc	r19, r30
     4a0:	09 f4       	brne	.+2      	; 0x4a4 <vProtocol+0x14c>
     4a2:	16 c3       	rjmp	.+1580   	; 0xad0 <__stack+0x5d1>
     4a4:	24 35       	cpi	r18, 0x54	; 84
     4a6:	32 40       	sbci	r19, 0x02	; 2
     4a8:	09 f0       	breq	.+2      	; 0x4ac <vProtocol+0x154>
     4aa:	1f c5       	rjmp	.+2622   	; 0xeea <__stack+0x9eb>
          temp = 0x00;
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 0, &xResult);
          crc = _crc_xmodem_update(crc, temp);
            
          //Rozkaz
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&kodRozkazu), 0, &xResult);
     4ac:	40 e0       	ldi	r20, 0x00	; 0
     4ae:	50 e0       	ldi	r21, 0x00	; 0
     4b0:	62 e4       	ldi	r22, 0x42	; 66
     4b2:	71 e0       	ldi	r23, 0x01	; 1
     4b4:	80 91 43 01 	lds	r24, 0x0143
     4b8:	90 91 44 01 	lds	r25, 0x0144
     4bc:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     4c0:	80 93 28 01 	sts	0x0128, r24
     4c4:	24 c3       	rjmp	.+1608   	; 0xb0e <__stack+0x60f>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     4c6:	2e 39       	cpi	r18, 0x9E	; 158
     4c8:	82 e0       	ldi	r24, 0x02	; 2
     4ca:	38 07       	cpc	r19, r24
     4cc:	09 f4       	brne	.+2      	; 0x4d0 <vProtocol+0x178>
     4ce:	1e c4       	rjmp	.+2108   	; 0xd0c <__stack+0x80d>
     4d0:	08 f0       	brcs	.+2      	; 0x4d4 <vProtocol+0x17c>
     4d2:	49 c0       	rjmp	.+146    	; 0x566 <__stack+0x67>
     4d4:	22 37       	cpi	r18, 0x72	; 114
     4d6:	f2 e0       	ldi	r31, 0x02	; 2
     4d8:	3f 07       	cpc	r19, r31
     4da:	09 f4       	brne	.+2      	; 0x4de <vProtocol+0x186>
     4dc:	a6 c3       	rjmp	.+1868   	; 0xc2a <__stack+0x72b>
     4de:	20 f5       	brcc	.+72     	; 0x528 <__stack+0x29>
     4e0:	2d 35       	cpi	r18, 0x5D	; 93
     4e2:	e2 e0       	ldi	r30, 0x02	; 2
     4e4:	3e 07       	cpc	r19, r30
     4e6:	09 f4       	brne	.+2      	; 0x4ea <vProtocol+0x192>
     4e8:	40 c3       	rjmp	.+1664   	; 0xb6a <__stack+0x66b>
     4ea:	88 f4       	brcc	.+34     	; 0x50e <__stack+0xf>
     4ec:	2c 35       	cpi	r18, 0x5C	; 92
     4ee:	32 40       	sbci	r19, 0x02	; 2
     4f0:	09 f0       	breq	.+2      	; 0x4f4 <vProtocol+0x19c>
     4f2:	fb c4       	rjmp	.+2550   	; 0xeea <__stack+0x9eb>
          //Rozkaz
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&kodRozkazu), 0, &xResult);
          crc = _crc_xmodem_update(crc, kodRozkazu);
          
          //Długość danych
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&lOdebrDanych), 0, &xResult);
     4f4:	40 e0       	ldi	r20, 0x00	; 0
     4f6:	50 e0       	ldi	r21, 0x00	; 0
     4f8:	66 e2       	ldi	r22, 0x26	; 38
     4fa:	71 e0       	ldi	r23, 0x01	; 1
     4fc:	80 91 43 01 	lds	r24, 0x0143
     500:	90 91 44 01 	lds	r25, 0x0144
     504:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     508:	80 93 28 01 	sts	0x0128, r24
     50c:	27 c3       	rjmp	.+1614   	; 0xb5c <__stack+0x65d>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     50e:	28 36       	cpi	r18, 0x68	; 104
     510:	e2 e0       	ldi	r30, 0x02	; 2
     512:	3e 07       	cpc	r19, r30
     514:	09 f4       	brne	.+2      	; 0x518 <__stack+0x19>
     516:	3a c3       	rjmp	.+1652   	; 0xb8c <__stack+0x68d>
     518:	29 36       	cpi	r18, 0x69	; 105
     51a:	32 40       	sbci	r19, 0x02	; 2
     51c:	09 f0       	breq	.+2      	; 0x520 <__stack+0x21>
     51e:	e5 c4       	rjmp	.+2506   	; 0xeea <__stack+0x9eb>
          crc = _crc_xmodem_update(crc, lOdebrDanych);
          
          //Dane
          for (temp = 0; temp < lOdebrDanych; temp++)
          {
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bDane[temp]), 1, &xResult);
     520:	81 e0       	ldi	r24, 0x01	; 1
     522:	80 93 28 01 	sts	0x0128, r24
     526:	47 c3       	rjmp	.+1678   	; 0xbb6 <__stack+0x6b7>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     528:	26 37       	cpi	r18, 0x76	; 118
     52a:	82 e0       	ldi	r24, 0x02	; 2
     52c:	38 07       	cpc	r19, r24
     52e:	09 f4       	brne	.+2      	; 0x532 <__stack+0x33>
     530:	a5 c3       	rjmp	.+1866   	; 0xc7c <__stack+0x77d>
     532:	40 f4       	brcc	.+16     	; 0x544 <__stack+0x45>
     534:	23 37       	cpi	r18, 0x73	; 115
     536:	32 40       	sbci	r19, 0x02	; 2
     538:	09 f0       	breq	.+2      	; 0x53c <__stack+0x3d>
     53a:	d7 c4       	rjmp	.+2478   	; 0xeea <__stack+0x9eb>
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bDane[temp]), 1, &xResult);
            crc = _crc_xmodem_update(crc, bDane[temp]);
          }
  
          temp = (uint8_t)(crc>>8);
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 1, &xResult);
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	80 93 28 01 	sts	0x0128, r24
     542:	87 c3       	rjmp	.+1806   	; 0xc52 <__stack+0x753>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     544:	27 37       	cpi	r18, 0x77	; 119
     546:	82 e0       	ldi	r24, 0x02	; 2
     548:	38 07       	cpc	r19, r24
     54a:	09 f4       	brne	.+2      	; 0x54e <__stack+0x4f>
     54c:	ab c3       	rjmp	.+1878   	; 0xca4 <__stack+0x7a5>
     54e:	2e 38       	cpi	r18, 0x8E	; 142
     550:	32 40       	sbci	r19, 0x02	; 2
     552:	09 f0       	breq	.+2      	; 0x556 <__stack+0x57>
     554:	ca c4       	rjmp	.+2452   	; 0xeea <__stack+0x9eb>
          if (kodRozkazu == rFLASH)
          {
            Led1On();
            Led2On();
            crDELAY(xHandle, 10);
            Led1Off();
     556:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
            Led2Off();
     55a:	0e 94 8a 08 	call	0x1114	; 0x1114 <Led2Off>
            (*((void(*)(void))BOOT_START))();            //reboot
     55e:	e0 e0       	ldi	r30, 0x00	; 0
     560:	fc e1       	ldi	r31, 0x1C	; 28
     562:	09 95       	icall
     564:	4c c0       	rjmp	.+152    	; 0x5fe <__stack+0xff>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     566:	2d 3b       	cpi	r18, 0xBD	; 189
     568:	f2 e0       	ldi	r31, 0x02	; 2
     56a:	3f 07       	cpc	r19, r31
     56c:	09 f4       	brne	.+2      	; 0x570 <__stack+0x71>
     56e:	19 c4       	rjmp	.+2098   	; 0xda2 <__stack+0x8a3>
     570:	08 f5       	brcc	.+66     	; 0x5b4 <__stack+0xb5>
     572:	26 3a       	cpi	r18, 0xA6	; 166
     574:	e2 e0       	ldi	r30, 0x02	; 2
     576:	3e 07       	cpc	r19, r30
     578:	09 f4       	brne	.+2      	; 0x57c <__stack+0x7d>
     57a:	ef c3       	rjmp	.+2014   	; 0xd5a <__stack+0x85b>
     57c:	20 f4       	brcc	.+8      	; 0x586 <__stack+0x87>
     57e:	2f 39       	cpi	r18, 0x9F	; 159
     580:	32 40       	sbci	r19, 0x02	; 2
     582:	d1 f1       	breq	.+116    	; 0x5f8 <__stack+0xf9>
     584:	b2 c4       	rjmp	.+2404   	; 0xeea <__stack+0x9eb>
     586:	27 3a       	cpi	r18, 0xA7	; 167
     588:	e2 e0       	ldi	r30, 0x02	; 2
     58a:	3e 07       	cpc	r19, r30
     58c:	a9 f1       	breq	.+106    	; 0x5f8 <__stack+0xf9>
     58e:	2c 3b       	cpi	r18, 0xBC	; 188
     590:	32 40       	sbci	r19, 0x02	; 2
     592:	09 f0       	breq	.+2      	; 0x596 <__stack+0x97>
     594:	aa c4       	rjmp	.+2388   	; 0xeea <__stack+0x9eb>
          uint8_t temp;
          
          //Dane 
          for (temp = 0; temp < 11; temp++)
          {
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bHelloResp[temp]), 1, &xResult);
     596:	69 81       	ldd	r22, Y+1	; 0x01
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	60 50       	subi	r22, 0x00	; 0
     59c:	7f 4f       	sbci	r23, 0xFF	; 255
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	50 e0       	ldi	r21, 0x00	; 0
     5a2:	80 91 43 01 	lds	r24, 0x0143
     5a6:	90 91 44 01 	lds	r25, 0x0144
     5aa:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     5ae:	80 93 28 01 	sts	0x0128, r24
     5b2:	f0 c3       	rjmp	.+2016   	; 0xd94 <__stack+0x895>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     5b4:	2a 3c       	cpi	r18, 0xCA	; 202
     5b6:	82 e0       	ldi	r24, 0x02	; 2
     5b8:	38 07       	cpc	r19, r24
     5ba:	09 f4       	brne	.+2      	; 0x5be <__stack+0xbf>
     5bc:	56 c4       	rjmp	.+2220   	; 0xe6a <__stack+0x96b>
     5be:	68 f4       	brcc	.+26     	; 0x5da <__stack+0xdb>
     5c0:	26 3c       	cpi	r18, 0xC6	; 198
     5c2:	f2 e0       	ldi	r31, 0x02	; 2
     5c4:	3f 07       	cpc	r19, r31
     5c6:	09 f4       	brne	.+2      	; 0x5ca <__stack+0xcb>
     5c8:	27 c4       	rjmp	.+2126   	; 0xe18 <__stack+0x919>
     5ca:	27 3c       	cpi	r18, 0xC7	; 199
     5cc:	32 40       	sbci	r19, 0x02	; 2
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <__stack+0xd3>
     5d0:	8c c4       	rjmp	.+2328   	; 0xeea <__stack+0x9eb>
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bHelloResp[temp]), 1, &xResult);
            crc = _crc_xmodem_update(crc, bHelloResp[temp]);
          }
  
          temp = (uint8_t)(crc>>8);
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 1, &xResult);
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	80 93 28 01 	sts	0x0128, r24
     5d8:	33 c4       	rjmp	.+2150   	; 0xe40 <__stack+0x941>

void vProtocol(xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex)
{
  (void) uxIndex;

  crSTART( xHandle );
     5da:	2b 3c       	cpi	r18, 0xCB	; 203
     5dc:	e2 e0       	ldi	r30, 0x02	; 2
     5de:	3e 07       	cpc	r19, r30
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <__stack+0xe5>
     5e2:	57 c4       	rjmp	.+2222   	; 0xe92 <__stack+0x993>
     5e4:	22 3f       	cpi	r18, 0xF2	; 242
     5e6:	32 40       	sbci	r19, 0x02	; 2
     5e8:	09 f0       	breq	.+2      	; 0x5ec <__stack+0xed>
     5ea:	7f c4       	rjmp	.+2302   	; 0xeea <__stack+0x9eb>
          DISABLE_RX();
          Led1On();
          Led2On();
          //TODO disable RX buffer
          crDELAY(xHandle, 1000);
          ENABLE_RX();
     5ec:	80 91 c1 00 	lds	r24, 0x00C1
     5f0:	80 61       	ori	r24, 0x10	; 16
     5f2:	80 93 c1 00 	sts	0x00C1, r24
     5f6:	76 c4       	rjmp	.+2284   	; 0xee4 <__stack+0x9e5>
        {
          crQUEUE_SEND(xHandle, xRoleta[0], (void *)(&wiadomosc), 0, &xResult); 
        }
        else if (rezultat == 3)
        {
          crQUEUE_SEND(xHandle, xRoleta[1], (void *)(&wiadomosc), 0, &xResult); 
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	80 93 28 01 	sts	0x0128, r24
          {
            TxStart();
          }
          vInterruptOn();  //W przypadku błędu wysyłamy wszystko z bufora przy wyłączonym nadajniku
        }
        Led1Off();
     5fe:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
        Led2Off();
     602:	0e 94 8a 08 	call	0x1114	; 0x1114 <Led2Off>
  static uint8_t         znak;
  static portBASE_TYPE   xResult;
  static uint8_t         dobryAdres;
  static uint8_t         lOdebrDanych;
  static uint8_t         rezultat;
  stan = s_sync;
     606:	10 92 2a 01 	sts	0x012A, r1
    crDELAY(xHandle, 100);
  }
*/
  for( ;; )
  {
    if (stan == s_sync)
     60a:	80 91 2a 01 	lds	r24, 0x012A
     60e:	81 11       	cpse	r24, r1
     610:	3c c0       	rjmp	.+120    	; 0x68a <__stack+0x18b>
    {
      znak=0;
     612:	10 92 29 01 	sts	0x0129, r1
      crQUEUE_RECEIVE(xHandle, xRxedChars, &znak, portMAX_DELAY, &xResult);
     616:	4f ef       	ldi	r20, 0xFF	; 255
     618:	5f ef       	ldi	r21, 0xFF	; 255
     61a:	69 e2       	ldi	r22, 0x29	; 41
     61c:	71 e0       	ldi	r23, 0x01	; 1
     61e:	80 91 45 01 	lds	r24, 0x0145
     622:	90 91 46 01 	lds	r25, 0x0146
     626:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     62a:	80 93 28 01 	sts	0x0128, r24
     62e:	8c 3f       	cpi	r24, 0xFC	; 252
     630:	79 f4       	brne	.+30     	; 0x650 <__stack+0x151>
     632:	8c e4       	ldi	r24, 0x4C	; 76
     634:	91 e0       	ldi	r25, 0x01	; 1
     636:	52 c4       	rjmp	.+2212   	; 0xedc <__stack+0x9dd>
     638:	40 e0       	ldi	r20, 0x00	; 0
     63a:	50 e0       	ldi	r21, 0x00	; 0
     63c:	69 e2       	ldi	r22, 0x29	; 41
     63e:	71 e0       	ldi	r23, 0x01	; 1
     640:	80 91 45 01 	lds	r24, 0x0145
     644:	90 91 46 01 	lds	r25, 0x0146
     648:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     64c:	80 93 28 01 	sts	0x0128, r24
     650:	80 91 28 01 	lds	r24, 0x0128
     654:	8b 3f       	cpi	r24, 0xFB	; 251
     656:	31 f4       	brne	.+12     	; 0x664 <__stack+0x165>
     658:	8d e4       	ldi	r24, 0x4D	; 77
     65a:	91 e0       	ldi	r25, 0x01	; 1
     65c:	3f c4       	rjmp	.+2174   	; 0xedc <__stack+0x9dd>
     65e:	81 e0       	ldi	r24, 0x01	; 1
     660:	80 93 28 01 	sts	0x0128, r24
      if ((xResult == pdPASS) && (znak == SYNC))
     664:	80 91 28 01 	lds	r24, 0x0128
     668:	81 30       	cpi	r24, 0x01	; 1
     66a:	79 f4       	brne	.+30     	; 0x68a <__stack+0x18b>
     66c:	90 91 29 01 	lds	r25, 0x0129
     670:	9a 35       	cpi	r25, 0x5A	; 90
     672:	59 f4       	brne	.+22     	; 0x68a <__stack+0x18b>
      {
        stan = s_addr;
     674:	80 93 2a 01 	sts	0x012A, r24
	//TODO tutaj jest zawsze wartość stała. Lepiej ją przypisać
        crc = _crc_xmodem_update(0, znak);
     678:	6a e5       	ldi	r22, 0x5A	; 90
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     682:	90 93 2c 01 	sts	0x012C, r25
     686:	80 93 2b 01 	sts	0x012B, r24
      }
    }
    if (stan == s_addr)
     68a:	80 91 2a 01 	lds	r24, 0x012A
     68e:	81 30       	cpi	r24, 0x01	; 1
     690:	e9 f5       	brne	.+122    	; 0x70c <__stack+0x20d>
    {
      crQUEUE_RECEIVE(xHandle, xRxedChars, &znak, 1, &xResult);
     692:	41 e0       	ldi	r20, 0x01	; 1
     694:	50 e0       	ldi	r21, 0x00	; 0
     696:	69 e2       	ldi	r22, 0x29	; 41
     698:	71 e0       	ldi	r23, 0x01	; 1
     69a:	80 91 45 01 	lds	r24, 0x0145
     69e:	90 91 46 01 	lds	r25, 0x0146
     6a2:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     6a6:	80 93 28 01 	sts	0x0128, r24
     6aa:	8c 3f       	cpi	r24, 0xFC	; 252
     6ac:	19 f4       	brne	.+6      	; 0x6b4 <__stack+0x1b5>
     6ae:	80 e6       	ldi	r24, 0x60	; 96
     6b0:	91 e0       	ldi	r25, 0x01	; 1
     6b2:	14 c4       	rjmp	.+2088   	; 0xedc <__stack+0x9dd>
     6b4:	80 91 28 01 	lds	r24, 0x0128
     6b8:	8b 3f       	cpi	r24, 0xFB	; 251
     6ba:	31 f4       	brne	.+12     	; 0x6c8 <__stack+0x1c9>
     6bc:	81 e6       	ldi	r24, 0x61	; 97
     6be:	91 e0       	ldi	r25, 0x01	; 1
     6c0:	0d c4       	rjmp	.+2074   	; 0xedc <__stack+0x9dd>
     6c2:	81 e0       	ldi	r24, 0x01	; 1
     6c4:	80 93 28 01 	sts	0x0128, r24
      if (xResult == pdPASS)
     6c8:	f0 90 28 01 	lds	r15, 0x0128
     6cc:	f1 e0       	ldi	r31, 0x01	; 1
     6ce:	ff 12       	cpse	r15, r31
     6d0:	1b c0       	rjmp	.+54     	; 0x708 <__stack+0x209>
      {
        stan = s_rozkaz;
     6d2:	82 e0       	ldi	r24, 0x02	; 2
     6d4:	80 93 2a 01 	sts	0x012A, r24
        crc = _crc_xmodem_update(crc, znak);
     6d8:	60 91 29 01 	lds	r22, 0x0129
     6dc:	80 91 2b 01 	lds	r24, 0x012B
     6e0:	90 91 2c 01 	lds	r25, 0x012C
     6e4:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     6e8:	90 93 2c 01 	sts	0x012C, r25
     6ec:	80 93 2b 01 	sts	0x012B, r24
        if (znak == adres)
     6f0:	90 91 29 01 	lds	r25, 0x0129
     6f4:	80 91 c1 04 	lds	r24, 0x04C1
     6f8:	98 13       	cpse	r25, r24
     6fa:	03 c0       	rjmp	.+6      	; 0x702 <__stack+0x203>
          dobryAdres = 1;
     6fc:	f0 92 27 01 	sts	0x0127, r15
     700:	05 c0       	rjmp	.+10     	; 0x70c <__stack+0x20d>
        else
          dobryAdres = 0;
     702:	10 92 27 01 	sts	0x0127, r1
     706:	02 c0       	rjmp	.+4      	; 0x70c <__stack+0x20d>
      }
      else
      {
        stan = s_sync;
     708:	10 92 2a 01 	sts	0x012A, r1
      }
    }
    if (stan == s_rozkaz)
     70c:	80 91 2a 01 	lds	r24, 0x012A
     710:	82 30       	cpi	r24, 0x02	; 2
     712:	a9 f5       	brne	.+106    	; 0x77e <__stack+0x27f>
    {
      Led1On();
     714:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <Led1On>
      Led2Off();
     718:	0e 94 8a 08 	call	0x1114	; 0x1114 <Led2Off>
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&kodRozkazu), 1, &xResult);
     71c:	41 e0       	ldi	r20, 0x01	; 1
     71e:	50 e0       	ldi	r21, 0x00	; 0
     720:	62 e4       	ldi	r22, 0x42	; 66
     722:	71 e0       	ldi	r23, 0x01	; 1
     724:	80 91 45 01 	lds	r24, 0x0145
     728:	90 91 46 01 	lds	r25, 0x0146
     72c:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     730:	80 93 28 01 	sts	0x0128, r24
     734:	8c 3f       	cpi	r24, 0xFC	; 252
     736:	19 f4       	brne	.+6      	; 0x73e <__stack+0x23f>
     738:	86 e8       	ldi	r24, 0x86	; 134
     73a:	91 e0       	ldi	r25, 0x01	; 1
     73c:	cf c3       	rjmp	.+1950   	; 0xedc <__stack+0x9dd>
     73e:	80 91 28 01 	lds	r24, 0x0128
     742:	8b 3f       	cpi	r24, 0xFB	; 251
     744:	31 f4       	brne	.+12     	; 0x752 <__stack+0x253>
     746:	87 e8       	ldi	r24, 0x87	; 135
     748:	91 e0       	ldi	r25, 0x01	; 1
     74a:	c8 c3       	rjmp	.+1936   	; 0xedc <__stack+0x9dd>
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	80 93 28 01 	sts	0x0128, r24
      if (xResult == pdPASS)
     752:	80 91 28 01 	lds	r24, 0x0128
     756:	81 30       	cpi	r24, 0x01	; 1
     758:	81 f4       	brne	.+32     	; 0x77a <__stack+0x27b>
      {
        crc = _crc_xmodem_update(crc, kodRozkazu);
     75a:	60 91 42 01 	lds	r22, 0x0142
     75e:	80 91 2b 01 	lds	r24, 0x012B
     762:	90 91 2c 01 	lds	r25, 0x012C
     766:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     76a:	90 93 2c 01 	sts	0x012C, r25
     76e:	80 93 2b 01 	sts	0x012B, r24
        stan = s_len;
     772:	83 e0       	ldi	r24, 0x03	; 3
     774:	80 93 2a 01 	sts	0x012A, r24
     778:	02 c0       	rjmp	.+4      	; 0x77e <__stack+0x27f>
      }
      else
      {
        stan = s_sync;
     77a:	10 92 2a 01 	sts	0x012A, r1
      }
    }
    if (stan == s_len)
     77e:	80 91 2a 01 	lds	r24, 0x012A
     782:	83 30       	cpi	r24, 0x03	; 3
     784:	09 f0       	breq	.+2      	; 0x788 <__stack+0x289>
     786:	44 c0       	rjmp	.+136    	; 0x810 <__stack+0x311>
    {
      Led1Off();
     788:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
      Led2On();
     78c:	0e 94 83 08 	call	0x1106	; 0x1106 <Led2On>
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&dlDanych), 1, &xResult);
     790:	41 e0       	ldi	r20, 0x01	; 1
     792:	50 e0       	ldi	r21, 0x00	; 0
     794:	61 e4       	ldi	r22, 0x41	; 65
     796:	71 e0       	ldi	r23, 0x01	; 1
     798:	80 91 45 01 	lds	r24, 0x0145
     79c:	90 91 46 01 	lds	r25, 0x0146
     7a0:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     7a4:	80 93 28 01 	sts	0x0128, r24
     7a8:	8c 3f       	cpi	r24, 0xFC	; 252
     7aa:	79 f4       	brne	.+30     	; 0x7ca <__stack+0x2cb>
     7ac:	84 ea       	ldi	r24, 0xA4	; 164
     7ae:	91 e0       	ldi	r25, 0x01	; 1
     7b0:	95 c3       	rjmp	.+1834   	; 0xedc <__stack+0x9dd>
     7b2:	40 e0       	ldi	r20, 0x00	; 0
     7b4:	50 e0       	ldi	r21, 0x00	; 0
     7b6:	61 e4       	ldi	r22, 0x41	; 65
     7b8:	71 e0       	ldi	r23, 0x01	; 1
     7ba:	80 91 45 01 	lds	r24, 0x0145
     7be:	90 91 46 01 	lds	r25, 0x0146
     7c2:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     7c6:	80 93 28 01 	sts	0x0128, r24
     7ca:	80 91 28 01 	lds	r24, 0x0128
     7ce:	8b 3f       	cpi	r24, 0xFB	; 251
     7d0:	19 f4       	brne	.+6      	; 0x7d8 <__stack+0x2d9>
     7d2:	85 ea       	ldi	r24, 0xA5	; 165
     7d4:	91 e0       	ldi	r25, 0x01	; 1
     7d6:	82 c3       	rjmp	.+1796   	; 0xedc <__stack+0x9dd>
      if (xResult == pdPASS)
     7d8:	80 91 28 01 	lds	r24, 0x0128
     7dc:	81 30       	cpi	r24, 0x01	; 1
     7de:	b1 f4       	brne	.+44     	; 0x80c <__stack+0x30d>
      {
        crc = _crc_xmodem_update(crc, dlDanych);
     7e0:	60 91 41 01 	lds	r22, 0x0141
     7e4:	80 91 2b 01 	lds	r24, 0x012B
     7e8:	90 91 2c 01 	lds	r25, 0x012C
     7ec:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     7f0:	90 93 2c 01 	sts	0x012C, r25
     7f4:	80 93 2b 01 	sts	0x012B, r24
        lOdebrDanych = 0;
     7f8:	10 92 26 01 	sts	0x0126, r1
        stan = s_dane;
     7fc:	84 e0       	ldi	r24, 0x04	; 4
     7fe:	80 93 2a 01 	sts	0x012A, r24
        Led1On();
     802:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <Led1On>
        Led2On();
     806:	0e 94 83 08 	call	0x1106	; 0x1106 <Led2On>
     80a:	02 c0       	rjmp	.+4      	; 0x810 <__stack+0x311>
      }
      else
      {
        stan = s_sync;
     80c:	10 92 2a 01 	sts	0x012A, r1
      }
    }
    if (stan == s_dane)
     810:	80 91 2a 01 	lds	r24, 0x012A
     814:	84 30       	cpi	r24, 0x04	; 4
     816:	09 f0       	breq	.+2      	; 0x81a <__stack+0x31b>
     818:	51 c0       	rjmp	.+162    	; 0x8bc <__stack+0x3bd>
    {
      if (lOdebrDanych == dlDanych)
     81a:	80 91 41 01 	lds	r24, 0x0141
     81e:	90 91 26 01 	lds	r25, 0x0126
     822:	98 13       	cpse	r25, r24
     824:	04 c0       	rjmp	.+8      	; 0x82e <__stack+0x32f>
      {
        stan = s_CRC_HI;
     826:	85 e0       	ldi	r24, 0x05	; 5
     828:	80 93 2a 01 	sts	0x012A, r24
     82c:	47 c0       	rjmp	.+142    	; 0x8bc <__stack+0x3bd>
      }
      else
      {
        //Led2Off();
        crQUEUE_RECEIVE(xHandle, xRxedChars, &znak, 1, &xResult);
     82e:	41 e0       	ldi	r20, 0x01	; 1
     830:	50 e0       	ldi	r21, 0x00	; 0
     832:	69 e2       	ldi	r22, 0x29	; 41
     834:	71 e0       	ldi	r23, 0x01	; 1
     836:	80 91 45 01 	lds	r24, 0x0145
     83a:	90 91 46 01 	lds	r25, 0x0146
     83e:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     842:	80 93 28 01 	sts	0x0128, r24
     846:	8c 3f       	cpi	r24, 0xFC	; 252
     848:	79 f4       	brne	.+30     	; 0x868 <__stack+0x369>
     84a:	82 ed       	ldi	r24, 0xD2	; 210
     84c:	91 e0       	ldi	r25, 0x01	; 1
     84e:	46 c3       	rjmp	.+1676   	; 0xedc <__stack+0x9dd>
     850:	40 e0       	ldi	r20, 0x00	; 0
     852:	50 e0       	ldi	r21, 0x00	; 0
     854:	69 e2       	ldi	r22, 0x29	; 41
     856:	71 e0       	ldi	r23, 0x01	; 1
     858:	80 91 45 01 	lds	r24, 0x0145
     85c:	90 91 46 01 	lds	r25, 0x0146
     860:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     864:	80 93 28 01 	sts	0x0128, r24
     868:	80 91 28 01 	lds	r24, 0x0128
     86c:	8b 3f       	cpi	r24, 0xFB	; 251
     86e:	19 f4       	brne	.+6      	; 0x876 <__stack+0x377>
     870:	83 ed       	ldi	r24, 0xD3	; 211
     872:	91 e0       	ldi	r25, 0x01	; 1
     874:	33 c3       	rjmp	.+1638   	; 0xedc <__stack+0x9dd>
        if (xResult == pdPASS)
     876:	80 91 28 01 	lds	r24, 0x0128
     87a:	81 30       	cpi	r24, 0x01	; 1
     87c:	d9 f4       	brne	.+54     	; 0x8b4 <__stack+0x3b5>
        {
          crc = _crc_xmodem_update(crc, znak);
     87e:	60 91 29 01 	lds	r22, 0x0129
     882:	80 91 2b 01 	lds	r24, 0x012B
     886:	90 91 2c 01 	lds	r25, 0x012C
     88a:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     88e:	90 93 2c 01 	sts	0x012C, r25
     892:	80 93 2b 01 	sts	0x012B, r24
          if (lOdebrDanych < MAX_DATA_LEN)
     896:	80 91 26 01 	lds	r24, 0x0126
     89a:	8e 30       	cpi	r24, 0x0E	; 14
     89c:	38 f4       	brcc	.+14     	; 0x8ac <__stack+0x3ad>
            bDane[lOdebrDanych] = znak;
     89e:	e8 2f       	mov	r30, r24
     8a0:	f0 e0       	ldi	r31, 0x00	; 0
     8a2:	ed 5c       	subi	r30, 0xCD	; 205
     8a4:	fe 4f       	sbci	r31, 0xFE	; 254
     8a6:	90 91 29 01 	lds	r25, 0x0129
     8aa:	90 83       	st	Z, r25
          lOdebrDanych++; 
     8ac:	8f 5f       	subi	r24, 0xFF	; 255
     8ae:	80 93 26 01 	sts	0x0126, r24
     8b2:	04 c0       	rjmp	.+8      	; 0x8bc <__stack+0x3bd>
        }
        else
        {
          Led1Off();
     8b4:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
          stan = s_sync;
     8b8:	10 92 2a 01 	sts	0x012A, r1
        }
      }
    }
    if (stan == s_CRC_HI)
     8bc:	80 91 2a 01 	lds	r24, 0x012A
     8c0:	85 30       	cpi	r24, 0x05	; 5
     8c2:	99 f5       	brne	.+102    	; 0x92a <__stack+0x42b>
    {
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&crcHi), 1, &xResult);
     8c4:	41 e0       	ldi	r20, 0x01	; 1
     8c6:	50 e0       	ldi	r21, 0x00	; 0
     8c8:	6d e2       	ldi	r22, 0x2D	; 45
     8ca:	71 e0       	ldi	r23, 0x01	; 1
     8cc:	80 91 45 01 	lds	r24, 0x0145
     8d0:	90 91 46 01 	lds	r25, 0x0146
     8d4:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     8d8:	80 93 28 01 	sts	0x0128, r24
     8dc:	8c 3f       	cpi	r24, 0xFC	; 252
     8de:	79 f4       	brne	.+30     	; 0x8fe <__stack+0x3ff>
     8e0:	84 ef       	ldi	r24, 0xF4	; 244
     8e2:	91 e0       	ldi	r25, 0x01	; 1
     8e4:	fb c2       	rjmp	.+1526   	; 0xedc <__stack+0x9dd>
     8e6:	40 e0       	ldi	r20, 0x00	; 0
     8e8:	50 e0       	ldi	r21, 0x00	; 0
     8ea:	6d e2       	ldi	r22, 0x2D	; 45
     8ec:	71 e0       	ldi	r23, 0x01	; 1
     8ee:	80 91 45 01 	lds	r24, 0x0145
     8f2:	90 91 46 01 	lds	r25, 0x0146
     8f6:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     8fa:	80 93 28 01 	sts	0x0128, r24
     8fe:	80 91 28 01 	lds	r24, 0x0128
     902:	8b 3f       	cpi	r24, 0xFB	; 251
     904:	31 f4       	brne	.+12     	; 0x912 <__stack+0x413>
     906:	85 ef       	ldi	r24, 0xF5	; 245
     908:	91 e0       	ldi	r25, 0x01	; 1
     90a:	e8 c2       	rjmp	.+1488   	; 0xedc <__stack+0x9dd>
     90c:	81 e0       	ldi	r24, 0x01	; 1
     90e:	80 93 28 01 	sts	0x0128, r24
      if (xResult == pdPASS)
     912:	80 91 28 01 	lds	r24, 0x0128
     916:	81 30       	cpi	r24, 0x01	; 1
     918:	21 f4       	brne	.+8      	; 0x922 <__stack+0x423>
      {
        stan = s_CRC_LO;
     91a:	86 e0       	ldi	r24, 0x06	; 6
     91c:	80 93 2a 01 	sts	0x012A, r24
     920:	04 c0       	rjmp	.+8      	; 0x92a <__stack+0x42b>
      }
      else
      {
        Led1Off();
     922:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
        stan = s_sync;
     926:	10 92 2a 01 	sts	0x012A, r1
      }    
    }
    if (stan == s_CRC_LO)
     92a:	80 91 2a 01 	lds	r24, 0x012A
     92e:	86 30       	cpi	r24, 0x06	; 6
     930:	99 f5       	brne	.+102    	; 0x998 <__stack+0x499>
    {
      crQUEUE_RECEIVE(xHandle, xRxedChars, (void *)(&crcLo), 1, &xResult);
     932:	41 e0       	ldi	r20, 0x01	; 1
     934:	50 e0       	ldi	r21, 0x00	; 0
     936:	6e e2       	ldi	r22, 0x2E	; 46
     938:	71 e0       	ldi	r23, 0x01	; 1
     93a:	80 91 45 01 	lds	r24, 0x0145
     93e:	90 91 46 01 	lds	r25, 0x0146
     942:	0e 94 00 10 	call	0x2000	; 0x2000 <xQueueCRReceive>
     946:	80 93 28 01 	sts	0x0128, r24
     94a:	8c 3f       	cpi	r24, 0xFC	; 252
     94c:	19 f4       	brne	.+6      	; 0x954 <__stack+0x455>
     94e:	8e e0       	ldi	r24, 0x0E	; 14
     950:	92 e0       	ldi	r25, 0x02	; 2
     952:	c4 c2       	rjmp	.+1416   	; 0xedc <__stack+0x9dd>
     954:	80 91 28 01 	lds	r24, 0x0128
     958:	8b 3f       	cpi	r24, 0xFB	; 251
     95a:	31 f4       	brne	.+12     	; 0x968 <__stack+0x469>
     95c:	8f e0       	ldi	r24, 0x0F	; 15
     95e:	92 e0       	ldi	r25, 0x02	; 2
     960:	bd c2       	rjmp	.+1402   	; 0xedc <__stack+0x9dd>
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	80 93 28 01 	sts	0x0128, r24
      if (xResult == pdPASS)
     968:	80 91 28 01 	lds	r24, 0x0128
     96c:	81 30       	cpi	r24, 0x01	; 1
     96e:	a1 f4       	brne	.+40     	; 0x998 <__stack+0x499>
      {
        if ((crcHi != (uint8_t)(crc >> 8)) || (crcLo != (uint8_t)(crc & 0xFF)))
     970:	80 91 2b 01 	lds	r24, 0x012B
     974:	90 91 2c 01 	lds	r25, 0x012C
     978:	20 91 2d 01 	lds	r18, 0x012D
     97c:	29 13       	cpse	r18, r25
     97e:	04 c0       	rjmp	.+8      	; 0x988 <__stack+0x489>
     980:	90 91 2e 01 	lds	r25, 0x012E
     984:	98 17       	cp	r25, r24
     986:	29 f0       	breq	.+10     	; 0x992 <__stack+0x493>
        {
          Led1Off();
     988:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
          stan = s_sync;
     98c:	10 92 2a 01 	sts	0x012A, r1
     990:	03 c0       	rjmp	.+6      	; 0x998 <__stack+0x499>
        }
        else
        {
          stan = s_CRC_OK;
     992:	87 e0       	ldi	r24, 0x07	; 7
     994:	80 93 2a 01 	sts	0x012A, r24
        }
      }
    }
    if (stan == s_CRC_OK)
     998:	80 91 2a 01 	lds	r24, 0x012A
     99c:	87 30       	cpi	r24, 0x07	; 7
     99e:	09 f0       	breq	.+2      	; 0x9a2 <__stack+0x4a3>
     9a0:	34 ce       	rjmp	.-920    	; 0x60a <__stack+0x10b>
    {
      if (dobryAdres == 1)
     9a2:	80 91 27 01 	lds	r24, 0x0127
     9a6:	81 30       	cpi	r24, 0x01	; 1
     9a8:	09 f0       	breq	.+2      	; 0x9ac <__stack+0x4ad>
     9aa:	83 c2       	rjmp	.+1286   	; 0xeb2 <__stack+0x9b3>
      {
        if (lOdebrDanych > MAX_DATA_LEN)
     9ac:	80 91 26 01 	lds	r24, 0x0126
     9b0:	8f 30       	cpi	r24, 0x0F	; 15
     9b2:	18 f0       	brcs	.+6      	; 0x9ba <__stack+0x4bb>
          lOdebrDanych = MAX_DATA_LEN;
     9b4:	8e e0       	ldi	r24, 0x0E	; 14
     9b6:	80 93 26 01 	sts	0x0126, r24
static uint8_t wykonajRozkaz(void)
{
//  static  portBASE_TYPE   xResult;
  uint8_t                 wysylac   = 0;

  switch (kodRozkazu)
     9ba:	80 91 42 01 	lds	r24, 0x0142
     9be:	80 33       	cpi	r24, 0x30	; 48
     9c0:	39 f1       	breq	.+78     	; 0xa10 <__stack+0x511>
     9c2:	68 f4       	brcc	.+26     	; 0x9de <__stack+0x4df>
     9c4:	81 31       	cpi	r24, 0x11	; 17
     9c6:	c9 f0       	breq	.+50     	; 0x9fa <__stack+0x4fb>
     9c8:	20 f4       	brcc	.+8      	; 0x9d2 <__stack+0x4d3>
     9ca:	80 31       	cpi	r24, 0x10	; 16
     9cc:	19 f5       	brne	.+70     	; 0xa14 <__stack+0x515>
  {
    case rOpuscRolete1:
      wiadomosc = 0x3F;
     9ce:	8f e3       	ldi	r24, 0x3F	; 63
     9d0:	17 c0       	rjmp	.+46     	; 0xa00 <__stack+0x501>
static uint8_t wykonajRozkaz(void)
{
//  static  portBASE_TYPE   xResult;
  uint8_t                 wysylac   = 0;

  switch (kodRozkazu)
     9d2:	80 32       	cpi	r24, 0x20	; 32
     9d4:	a1 f0       	breq	.+40     	; 0x9fe <__stack+0x4ff>
     9d6:	81 32       	cpi	r24, 0x21	; 33
     9d8:	e9 f4       	brne	.+58     	; 0xa14 <__stack+0x515>
      wiadomosc = 0xBF;
      wysylac = 2;
      break;

    case rPodniesRolete2:
      wiadomosc = 0xBF;
     9da:	8f eb       	ldi	r24, 0xBF	; 191
     9dc:	15 c0       	rjmp	.+42     	; 0xa08 <__stack+0x509>
static uint8_t wykonajRozkaz(void)
{
//  static  portBASE_TYPE   xResult;
  uint8_t                 wysylac   = 0;

  switch (kodRozkazu)
     9de:	82 38       	cpi	r24, 0x82	; 130
     9e0:	30 f4       	brcc	.+12     	; 0x9ee <__stack+0x4ef>
     9e2:	80 38       	cpi	r24, 0x80	; 128
     9e4:	40 f4       	brcc	.+16     	; 0x9f6 <__stack+0x4f7>
     9e6:	81 33       	cpi	r24, 0x31	; 49
     9e8:	a9 f4       	brne	.+42     	; 0xa14 <__stack+0x515>
      wiadomosc = 0x40;
      wysylac = 2;
      break;

    case rZatrzymajRolete2:
      wiadomosc = 0x40;
     9ea:	80 e4       	ldi	r24, 0x40	; 64
     9ec:	0d c0       	rjmp	.+26     	; 0xa08 <__stack+0x509>
static uint8_t wykonajRozkaz(void)
{
//  static  portBASE_TYPE   xResult;
  uint8_t                 wysylac   = 0;

  switch (kodRozkazu)
     9ee:	82 38       	cpi	r24, 0x82	; 130
     9f0:	89 f4       	brne	.+34     	; 0xa14 <__stack+0x515>

    case rPING:
      wysylac = 1;
      break;
    case rHELLO:
      wysylac = 4;
     9f2:	84 e0       	ldi	r24, 0x04	; 4
     9f4:	10 c0       	rjmp	.+32     	; 0xa16 <__stack+0x517>
      wiadomosc = 0x40;
      wysylac = 3;
      break;

    case rPING:
      wysylac = 1;
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	0e c0       	rjmp	.+28     	; 0xa16 <__stack+0x517>
      wiadomosc = 0x3F;
      wysylac = 2;
      break;

    case rOpuscRolete2:
      wiadomosc = 0x3F;
     9fa:	8f e3       	ldi	r24, 0x3F	; 63
     9fc:	05 c0       	rjmp	.+10     	; 0xa08 <__stack+0x509>
      wysylac = 3;
      break;

    case rPodniesRolete1:
      wiadomosc = 0xBF;
     9fe:	8f eb       	ldi	r24, 0xBF	; 191
     a00:	80 93 32 01 	sts	0x0132, r24
      wysylac = 2;
     a04:	82 e0       	ldi	r24, 0x02	; 2
     a06:	07 c0       	rjmp	.+14     	; 0xa16 <__stack+0x517>
      break;

    case rPodniesRolete2:
      wiadomosc = 0xBF;
     a08:	80 93 32 01 	sts	0x0132, r24
      wysylac = 3;
     a0c:	83 e0       	ldi	r24, 0x03	; 3
     a0e:	03 c0       	rjmp	.+6      	; 0xa16 <__stack+0x517>
      break;

    case rZatrzymajRolete1:
      wiadomosc = 0x40;
     a10:	80 e4       	ldi	r24, 0x40	; 64
     a12:	f6 cf       	rjmp	.-20     	; 0xa00 <__stack+0x501>
static uint16_t crc;

static uint8_t wykonajRozkaz(void)
{
//  static  portBASE_TYPE   xResult;
  uint8_t                 wysylac   = 0;
     a14:	80 e0       	ldi	r24, 0x00	; 0
    {
      if (dobryAdres == 1)
      {
        if (lOdebrDanych > MAX_DATA_LEN)
          lOdebrDanych = MAX_DATA_LEN;
        rezultat = wykonajRozkaz();
     a16:	80 93 25 01 	sts	0x0125, r24
        if (rezultat == 1)
     a1a:	81 30       	cpi	r24, 0x01	; 1
     a1c:	09 f0       	breq	.+2      	; 0xa20 <__stack+0x521>
     a1e:	63 c1       	rjmp	.+710    	; 0xce6 <__stack+0x7e7>
        {
          //SYNC
          uint8_t temp;
          temp = SYNC;
     a20:	8a e5       	ldi	r24, 0x5A	; 90
     a22:	89 83       	std	Y+1, r24	; 0x01
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 0, &xResult);
     a24:	40 e0       	ldi	r20, 0x00	; 0
     a26:	50 e0       	ldi	r21, 0x00	; 0
     a28:	be 01       	movw	r22, r28
     a2a:	6f 5f       	subi	r22, 0xFF	; 255
     a2c:	7f 4f       	sbci	r23, 0xFF	; 255
     a2e:	80 91 43 01 	lds	r24, 0x0143
     a32:	90 91 44 01 	lds	r25, 0x0144
     a36:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     a3a:	80 93 28 01 	sts	0x0128, r24
     a3e:	8c 3f       	cpi	r24, 0xFC	; 252
     a40:	81 f4       	brne	.+32     	; 0xa62 <__stack+0x563>
     a42:	82 e4       	ldi	r24, 0x42	; 66
     a44:	92 e0       	ldi	r25, 0x02	; 2
     a46:	4a c2       	rjmp	.+1172   	; 0xedc <__stack+0x9dd>
     a48:	40 e0       	ldi	r20, 0x00	; 0
     a4a:	50 e0       	ldi	r21, 0x00	; 0
     a4c:	be 01       	movw	r22, r28
     a4e:	6f 5f       	subi	r22, 0xFF	; 255
     a50:	7f 4f       	sbci	r23, 0xFF	; 255
     a52:	80 91 43 01 	lds	r24, 0x0143
     a56:	90 91 44 01 	lds	r25, 0x0144
     a5a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     a5e:	80 93 28 01 	sts	0x0128, r24
     a62:	80 91 28 01 	lds	r24, 0x0128
     a66:	8b 3f       	cpi	r24, 0xFB	; 251
     a68:	19 f4       	brne	.+6      	; 0xa70 <__stack+0x571>
     a6a:	83 e4       	ldi	r24, 0x43	; 67
     a6c:	92 e0       	ldi	r25, 0x02	; 2
     a6e:	36 c2       	rjmp	.+1132   	; 0xedc <__stack+0x9dd>
          crc = _crc_xmodem_update(0, temp);
     a70:	69 81       	ldd	r22, Y+1	; 0x01
     a72:	80 e0       	ldi	r24, 0x00	; 0
     a74:	90 e0       	ldi	r25, 0x00	; 0
     a76:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     a7a:	90 93 2c 01 	sts	0x012C, r25
     a7e:	80 93 2b 01 	sts	0x012B, r24

         //ADRES 0x00 adres mastera
          temp = 0x00;
     a82:	19 82       	std	Y+1, r1	; 0x01
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 0, &xResult);
     a84:	40 e0       	ldi	r20, 0x00	; 0
     a86:	50 e0       	ldi	r21, 0x00	; 0
     a88:	be 01       	movw	r22, r28
     a8a:	6f 5f       	subi	r22, 0xFF	; 255
     a8c:	7f 4f       	sbci	r23, 0xFF	; 255
     a8e:	80 91 43 01 	lds	r24, 0x0143
     a92:	90 91 44 01 	lds	r25, 0x0144
     a96:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     a9a:	80 93 28 01 	sts	0x0128, r24
     a9e:	8c 3f       	cpi	r24, 0xFC	; 252
     aa0:	81 f4       	brne	.+32     	; 0xac2 <__stack+0x5c3>
     aa2:	8c e4       	ldi	r24, 0x4C	; 76
     aa4:	92 e0       	ldi	r25, 0x02	; 2
     aa6:	1a c2       	rjmp	.+1076   	; 0xedc <__stack+0x9dd>
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	be 01       	movw	r22, r28
     aae:	6f 5f       	subi	r22, 0xFF	; 255
     ab0:	7f 4f       	sbci	r23, 0xFF	; 255
     ab2:	80 91 43 01 	lds	r24, 0x0143
     ab6:	90 91 44 01 	lds	r25, 0x0144
     aba:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     abe:	80 93 28 01 	sts	0x0128, r24
     ac2:	80 91 28 01 	lds	r24, 0x0128
     ac6:	8b 3f       	cpi	r24, 0xFB	; 251
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__stack+0x5d7>
     aca:	8d e4       	ldi	r24, 0x4D	; 77
     acc:	92 e0       	ldi	r25, 0x02	; 2
     ace:	06 c2       	rjmp	.+1036   	; 0xedc <__stack+0x9dd>
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	80 93 28 01 	sts	0x0128, r24
          crc = _crc_xmodem_update(crc, temp);
     ad6:	69 81       	ldd	r22, Y+1	; 0x01
     ad8:	80 91 2b 01 	lds	r24, 0x012B
     adc:	90 91 2c 01 	lds	r25, 0x012C
     ae0:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     ae4:	90 93 2c 01 	sts	0x012C, r25
     ae8:	80 93 2b 01 	sts	0x012B, r24
            
          //Rozkaz
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&kodRozkazu), 0, &xResult);
     aec:	40 e0       	ldi	r20, 0x00	; 0
     aee:	50 e0       	ldi	r21, 0x00	; 0
     af0:	62 e4       	ldi	r22, 0x42	; 66
     af2:	71 e0       	ldi	r23, 0x01	; 1
     af4:	80 91 43 01 	lds	r24, 0x0143
     af8:	90 91 44 01 	lds	r25, 0x0144
     afc:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     b00:	80 93 28 01 	sts	0x0128, r24
     b04:	8c 3f       	cpi	r24, 0xFC	; 252
     b06:	19 f4       	brne	.+6      	; 0xb0e <__stack+0x60f>
     b08:	84 e5       	ldi	r24, 0x54	; 84
     b0a:	92 e0       	ldi	r25, 0x02	; 2
     b0c:	e7 c1       	rjmp	.+974    	; 0xedc <__stack+0x9dd>
     b0e:	80 91 28 01 	lds	r24, 0x0128
     b12:	8b 3f       	cpi	r24, 0xFB	; 251
     b14:	31 f4       	brne	.+12     	; 0xb22 <__stack+0x623>
     b16:	85 e5       	ldi	r24, 0x55	; 85
     b18:	92 e0       	ldi	r25, 0x02	; 2
     b1a:	e0 c1       	rjmp	.+960    	; 0xedc <__stack+0x9dd>
     b1c:	81 e0       	ldi	r24, 0x01	; 1
     b1e:	80 93 28 01 	sts	0x0128, r24
          crc = _crc_xmodem_update(crc, kodRozkazu);
     b22:	60 91 42 01 	lds	r22, 0x0142
     b26:	80 91 2b 01 	lds	r24, 0x012B
     b2a:	90 91 2c 01 	lds	r25, 0x012C
     b2e:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     b32:	90 93 2c 01 	sts	0x012C, r25
     b36:	80 93 2b 01 	sts	0x012B, r24
          
          //Długość danych
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&lOdebrDanych), 0, &xResult);
     b3a:	40 e0       	ldi	r20, 0x00	; 0
     b3c:	50 e0       	ldi	r21, 0x00	; 0
     b3e:	66 e2       	ldi	r22, 0x26	; 38
     b40:	71 e0       	ldi	r23, 0x01	; 1
     b42:	80 91 43 01 	lds	r24, 0x0143
     b46:	90 91 44 01 	lds	r25, 0x0144
     b4a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     b4e:	80 93 28 01 	sts	0x0128, r24
     b52:	8c 3f       	cpi	r24, 0xFC	; 252
     b54:	19 f4       	brne	.+6      	; 0xb5c <__stack+0x65d>
     b56:	8c e5       	ldi	r24, 0x5C	; 92
     b58:	92 e0       	ldi	r25, 0x02	; 2
     b5a:	c0 c1       	rjmp	.+896    	; 0xedc <__stack+0x9dd>
     b5c:	80 91 28 01 	lds	r24, 0x0128
     b60:	8b 3f       	cpi	r24, 0xFB	; 251
     b62:	31 f4       	brne	.+12     	; 0xb70 <__stack+0x671>
     b64:	8d e5       	ldi	r24, 0x5D	; 93
     b66:	92 e0       	ldi	r25, 0x02	; 2
     b68:	b9 c1       	rjmp	.+882    	; 0xedc <__stack+0x9dd>
     b6a:	81 e0       	ldi	r24, 0x01	; 1
     b6c:	80 93 28 01 	sts	0x0128, r24
          crc = _crc_xmodem_update(crc, lOdebrDanych);
     b70:	60 91 26 01 	lds	r22, 0x0126
     b74:	80 91 2b 01 	lds	r24, 0x012B
     b78:	90 91 2c 01 	lds	r25, 0x012C
     b7c:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     b80:	90 93 2c 01 	sts	0x012C, r25
     b84:	80 93 2b 01 	sts	0x012B, r24
          
          //Dane
          for (temp = 0; temp < lOdebrDanych; temp++)
     b88:	19 82       	std	Y+1, r1	; 0x01
     b8a:	27 c0       	rjmp	.+78     	; 0xbda <__stack+0x6db>
          {
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bDane[temp]), 1, &xResult);
     b8c:	69 81       	ldd	r22, Y+1	; 0x01
     b8e:	70 e0       	ldi	r23, 0x00	; 0
     b90:	6d 5c       	subi	r22, 0xCD	; 205
     b92:	7e 4f       	sbci	r23, 0xFE	; 254
     b94:	40 e0       	ldi	r20, 0x00	; 0
     b96:	50 e0       	ldi	r21, 0x00	; 0
     b98:	80 91 43 01 	lds	r24, 0x0143
     b9c:	90 91 44 01 	lds	r25, 0x0144
     ba0:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     ba4:	80 93 28 01 	sts	0x0128, r24
     ba8:	80 91 28 01 	lds	r24, 0x0128
     bac:	8b 3f       	cpi	r24, 0xFB	; 251
     bae:	19 f4       	brne	.+6      	; 0xbb6 <__stack+0x6b7>
     bb0:	89 e6       	ldi	r24, 0x69	; 105
     bb2:	92 e0       	ldi	r25, 0x02	; 2
     bb4:	93 c1       	rjmp	.+806    	; 0xedc <__stack+0x9dd>
            crc = _crc_xmodem_update(crc, bDane[temp]);
     bb6:	e9 81       	ldd	r30, Y+1	; 0x01
     bb8:	f0 e0       	ldi	r31, 0x00	; 0
     bba:	ed 5c       	subi	r30, 0xCD	; 205
     bbc:	fe 4f       	sbci	r31, 0xFE	; 254
     bbe:	60 81       	ld	r22, Z
     bc0:	80 91 2b 01 	lds	r24, 0x012B
     bc4:	90 91 2c 01 	lds	r25, 0x012C
     bc8:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     bcc:	90 93 2c 01 	sts	0x012C, r25
     bd0:	80 93 2b 01 	sts	0x012B, r24
          //Długość danych
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&lOdebrDanych), 0, &xResult);
          crc = _crc_xmodem_update(crc, lOdebrDanych);
          
          //Dane
          for (temp = 0; temp < lOdebrDanych; temp++)
     bd4:	89 81       	ldd	r24, Y+1	; 0x01
     bd6:	8f 5f       	subi	r24, 0xFF	; 255
     bd8:	89 83       	std	Y+1, r24	; 0x01
     bda:	69 81       	ldd	r22, Y+1	; 0x01
     bdc:	20 91 26 01 	lds	r18, 0x0126
     be0:	80 91 43 01 	lds	r24, 0x0143
     be4:	90 91 44 01 	lds	r25, 0x0144
     be8:	62 17       	cp	r22, r18
     bea:	70 f4       	brcc	.+28     	; 0xc08 <__stack+0x709>
          {
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bDane[temp]), 1, &xResult);
     bec:	70 e0       	ldi	r23, 0x00	; 0
     bee:	6d 5c       	subi	r22, 0xCD	; 205
     bf0:	7e 4f       	sbci	r23, 0xFE	; 254
     bf2:	41 e0       	ldi	r20, 0x01	; 1
     bf4:	50 e0       	ldi	r21, 0x00	; 0
     bf6:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     bfa:	80 93 28 01 	sts	0x0128, r24
     bfe:	8c 3f       	cpi	r24, 0xFC	; 252
     c00:	99 f6       	brne	.-90     	; 0xba8 <__stack+0x6a9>
     c02:	88 e6       	ldi	r24, 0x68	; 104
     c04:	92 e0       	ldi	r25, 0x02	; 2
     c06:	6a c1       	rjmp	.+724    	; 0xedc <__stack+0x9dd>
            crc = _crc_xmodem_update(crc, bDane[temp]);
          }
  
          temp = (uint8_t)(crc>>8);
     c08:	20 91 2c 01 	lds	r18, 0x012C
     c0c:	29 83       	std	Y+1, r18	; 0x01
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 1, &xResult);
     c0e:	41 e0       	ldi	r20, 0x01	; 1
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	be 01       	movw	r22, r28
     c14:	6f 5f       	subi	r22, 0xFF	; 255
     c16:	7f 4f       	sbci	r23, 0xFF	; 255
     c18:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     c1c:	80 93 28 01 	sts	0x0128, r24
     c20:	8c 3f       	cpi	r24, 0xFC	; 252
     c22:	81 f4       	brne	.+32     	; 0xc44 <__stack+0x745>
     c24:	82 e7       	ldi	r24, 0x72	; 114
     c26:	92 e0       	ldi	r25, 0x02	; 2
     c28:	59 c1       	rjmp	.+690    	; 0xedc <__stack+0x9dd>
     c2a:	40 e0       	ldi	r20, 0x00	; 0
     c2c:	50 e0       	ldi	r21, 0x00	; 0
     c2e:	be 01       	movw	r22, r28
     c30:	6f 5f       	subi	r22, 0xFF	; 255
     c32:	7f 4f       	sbci	r23, 0xFF	; 255
     c34:	80 91 43 01 	lds	r24, 0x0143
     c38:	90 91 44 01 	lds	r25, 0x0144
     c3c:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     c40:	80 93 28 01 	sts	0x0128, r24
     c44:	80 91 28 01 	lds	r24, 0x0128
     c48:	8b 3f       	cpi	r24, 0xFB	; 251
     c4a:	19 f4       	brne	.+6      	; 0xc52 <__stack+0x753>
     c4c:	83 e7       	ldi	r24, 0x73	; 115
     c4e:	92 e0       	ldi	r25, 0x02	; 2
     c50:	45 c1       	rjmp	.+650    	; 0xedc <__stack+0x9dd>
          temp = (uint8_t)(crc & 0xFF);
     c52:	80 91 2b 01 	lds	r24, 0x012B
     c56:	89 83       	std	Y+1, r24	; 0x01
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 1, &xResult);
     c58:	41 e0       	ldi	r20, 0x01	; 1
     c5a:	50 e0       	ldi	r21, 0x00	; 0
     c5c:	be 01       	movw	r22, r28
     c5e:	6f 5f       	subi	r22, 0xFF	; 255
     c60:	7f 4f       	sbci	r23, 0xFF	; 255
     c62:	80 91 43 01 	lds	r24, 0x0143
     c66:	90 91 44 01 	lds	r25, 0x0144
     c6a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     c6e:	80 93 28 01 	sts	0x0128, r24
     c72:	8c 3f       	cpi	r24, 0xFC	; 252
     c74:	81 f4       	brne	.+32     	; 0xc96 <__stack+0x797>
     c76:	86 e7       	ldi	r24, 0x76	; 118
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	30 c1       	rjmp	.+608    	; 0xedc <__stack+0x9dd>
     c7c:	40 e0       	ldi	r20, 0x00	; 0
     c7e:	50 e0       	ldi	r21, 0x00	; 0
     c80:	be 01       	movw	r22, r28
     c82:	6f 5f       	subi	r22, 0xFF	; 255
     c84:	7f 4f       	sbci	r23, 0xFF	; 255
     c86:	80 91 43 01 	lds	r24, 0x0143
     c8a:	90 91 44 01 	lds	r25, 0x0144
     c8e:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     c92:	80 93 28 01 	sts	0x0128, r24
     c96:	80 91 28 01 	lds	r24, 0x0128
     c9a:	8b 3f       	cpi	r24, 0xFB	; 251
     c9c:	31 f4       	brne	.+12     	; 0xcaa <__stack+0x7ab>
     c9e:	87 e7       	ldi	r24, 0x77	; 119
     ca0:	92 e0       	ldi	r25, 0x02	; 2
     ca2:	1c c1       	rjmp	.+568    	; 0xedc <__stack+0x9dd>
     ca4:	81 e0       	ldi	r24, 0x01	; 1
     ca6:	80 93 28 01 	sts	0x0128, r24

          if (xResult == pdPASS)
     caa:	80 91 28 01 	lds	r24, 0x0128
     cae:	81 30       	cpi	r24, 0x01	; 1
     cb0:	19 f4       	brne	.+6      	; 0xcb8 <__stack+0x7b9>
          {
            TxStart();
     cb2:	8b b1       	in	r24, 0x0b	; 11
     cb4:	8c 60       	ori	r24, 0x0C	; 12
     cb6:	8b b9       	out	0x0b, r24	; 11
          }
          vInterruptOn();  //W przypadku błędu wysyłamy wszystko z bufora przy wyłączonym nadajniku
     cb8:	80 91 c1 00 	lds	r24, 0x00C1
     cbc:	80 62       	ori	r24, 0x20	; 32
     cbe:	80 93 c1 00 	sts	0x00C1, r24
        
          if (kodRozkazu == rFLASH)
     cc2:	80 91 42 01 	lds	r24, 0x0142
     cc6:	81 38       	cpi	r24, 0x81	; 129
     cc8:	09 f0       	breq	.+2      	; 0xccc <__stack+0x7cd>
     cca:	99 cc       	rjmp	.-1742   	; 0x5fe <__stack+0xff>
          {
            Led1On();
     ccc:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <Led1On>
            Led2On();
     cd0:	0e 94 83 08 	call	0x1106	; 0x1106 <Led2On>
            crDELAY(xHandle, 10);
     cd4:	60 e0       	ldi	r22, 0x00	; 0
     cd6:	70 e0       	ldi	r23, 0x00	; 0
     cd8:	8a e0       	ldi	r24, 0x0A	; 10
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	0e 94 9f 11 	call	0x233e	; 0x233e <vCoRoutineAddToDelayedList>
     ce0:	8e e8       	ldi	r24, 0x8E	; 142
     ce2:	92 e0       	ldi	r25, 0x02	; 2
     ce4:	fb c0       	rjmp	.+502    	; 0xedc <__stack+0x9dd>
            Led1Off();
            Led2Off();
            (*((void(*)(void))BOOT_START))();            //reboot
          }
        }
        else if (rezultat == 2)
     ce6:	82 30       	cpi	r24, 0x02	; 2
     ce8:	29 f5       	brne	.+74     	; 0xd34 <__stack+0x835>
        {
          crQUEUE_SEND(xHandle, xRoleta[0], (void *)(&wiadomosc), 0, &xResult); 
     cea:	40 e0       	ldi	r20, 0x00	; 0
     cec:	50 e0       	ldi	r21, 0x00	; 0
     cee:	62 e3       	ldi	r22, 0x32	; 50
     cf0:	71 e0       	ldi	r23, 0x01	; 1
     cf2:	80 91 c2 04 	lds	r24, 0x04C2
     cf6:	90 91 c3 04 	lds	r25, 0x04C3
     cfa:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     cfe:	80 93 28 01 	sts	0x0128, r24
     d02:	8c 3f       	cpi	r24, 0xFC	; 252
     d04:	79 f4       	brne	.+30     	; 0xd24 <__stack+0x825>
     d06:	8e e9       	ldi	r24, 0x9E	; 158
     d08:	92 e0       	ldi	r25, 0x02	; 2
     d0a:	e8 c0       	rjmp	.+464    	; 0xedc <__stack+0x9dd>
     d0c:	40 e0       	ldi	r20, 0x00	; 0
     d0e:	50 e0       	ldi	r21, 0x00	; 0
     d10:	62 e3       	ldi	r22, 0x32	; 50
     d12:	71 e0       	ldi	r23, 0x01	; 1
     d14:	80 91 c2 04 	lds	r24, 0x04C2
     d18:	90 91 c3 04 	lds	r25, 0x04C3
     d1c:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     d20:	80 93 28 01 	sts	0x0128, r24
     d24:	80 91 28 01 	lds	r24, 0x0128
     d28:	8b 3f       	cpi	r24, 0xFB	; 251
     d2a:	09 f0       	breq	.+2      	; 0xd2e <__stack+0x82f>
     d2c:	68 cc       	rjmp	.-1840   	; 0x5fe <__stack+0xff>
     d2e:	8f e9       	ldi	r24, 0x9F	; 159
     d30:	92 e0       	ldi	r25, 0x02	; 2
     d32:	d4 c0       	rjmp	.+424    	; 0xedc <__stack+0x9dd>
        }
        else if (rezultat == 3)
     d34:	83 30       	cpi	r24, 0x03	; 3
     d36:	29 f5       	brne	.+74     	; 0xd82 <__stack+0x883>
        {
          crQUEUE_SEND(xHandle, xRoleta[1], (void *)(&wiadomosc), 0, &xResult); 
     d38:	40 e0       	ldi	r20, 0x00	; 0
     d3a:	50 e0       	ldi	r21, 0x00	; 0
     d3c:	62 e3       	ldi	r22, 0x32	; 50
     d3e:	71 e0       	ldi	r23, 0x01	; 1
     d40:	80 91 c4 04 	lds	r24, 0x04C4
     d44:	90 91 c5 04 	lds	r25, 0x04C5
     d48:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     d4c:	80 93 28 01 	sts	0x0128, r24
     d50:	8c 3f       	cpi	r24, 0xFC	; 252
     d52:	79 f4       	brne	.+30     	; 0xd72 <__stack+0x873>
     d54:	86 ea       	ldi	r24, 0xA6	; 166
     d56:	92 e0       	ldi	r25, 0x02	; 2
     d58:	c1 c0       	rjmp	.+386    	; 0xedc <__stack+0x9dd>
     d5a:	40 e0       	ldi	r20, 0x00	; 0
     d5c:	50 e0       	ldi	r21, 0x00	; 0
     d5e:	62 e3       	ldi	r22, 0x32	; 50
     d60:	71 e0       	ldi	r23, 0x01	; 1
     d62:	80 91 c4 04 	lds	r24, 0x04C4
     d66:	90 91 c5 04 	lds	r25, 0x04C5
     d6a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     d6e:	80 93 28 01 	sts	0x0128, r24
     d72:	80 91 28 01 	lds	r24, 0x0128
     d76:	8b 3f       	cpi	r24, 0xFB	; 251
     d78:	09 f0       	breq	.+2      	; 0xd7c <__stack+0x87d>
     d7a:	41 cc       	rjmp	.-1918   	; 0x5fe <__stack+0xff>
     d7c:	87 ea       	ldi	r24, 0xA7	; 167
     d7e:	92 e0       	ldi	r25, 0x02	; 2
     d80:	ad c0       	rjmp	.+346    	; 0xedc <__stack+0x9dd>
        }
        else if (rezultat == 4)
     d82:	84 30       	cpi	r24, 0x04	; 4
     d84:	09 f0       	breq	.+2      	; 0xd88 <__stack+0x889>
     d86:	3b cc       	rjmp	.-1930   	; 0x5fe <__stack+0xff>
        {
          //SYNC
          crc = 0;
     d88:	10 92 2c 01 	sts	0x012C, r1
     d8c:	10 92 2b 01 	sts	0x012B, r1
          uint8_t temp;
          
          //Dane 
          for (temp = 0; temp < 11; temp++)
     d90:	19 82       	std	Y+1, r1	; 0x01
     d92:	1c c0       	rjmp	.+56     	; 0xdcc <__stack+0x8cd>
          {
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bHelloResp[temp]), 1, &xResult);
     d94:	80 91 28 01 	lds	r24, 0x0128
     d98:	8b 3f       	cpi	r24, 0xFB	; 251
     d9a:	31 f4       	brne	.+12     	; 0xda8 <__stack+0x8a9>
     d9c:	8d eb       	ldi	r24, 0xBD	; 189
     d9e:	92 e0       	ldi	r25, 0x02	; 2
     da0:	9d c0       	rjmp	.+314    	; 0xedc <__stack+0x9dd>
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	80 93 28 01 	sts	0x0128, r24
            crc = _crc_xmodem_update(crc, bHelloResp[temp]);
     da8:	e9 81       	ldd	r30, Y+1	; 0x01
     daa:	f0 e0       	ldi	r31, 0x00	; 0
     dac:	e0 50       	subi	r30, 0x00	; 0
     dae:	ff 4f       	sbci	r31, 0xFF	; 255
     db0:	60 81       	ld	r22, Z
     db2:	80 91 2b 01 	lds	r24, 0x012B
     db6:	90 91 2c 01 	lds	r25, 0x012C
     dba:	0e 94 92 01 	call	0x324	; 0x324 <_crc_xmodem_update>
     dbe:	90 93 2c 01 	sts	0x012C, r25
     dc2:	80 93 2b 01 	sts	0x012B, r24
          //SYNC
          crc = 0;
          uint8_t temp;
          
          //Dane 
          for (temp = 0; temp < 11; temp++)
     dc6:	89 81       	ldd	r24, Y+1	; 0x01
     dc8:	8f 5f       	subi	r24, 0xFF	; 255
     dca:	89 83       	std	Y+1, r24	; 0x01
     dcc:	69 81       	ldd	r22, Y+1	; 0x01
     dce:	80 91 43 01 	lds	r24, 0x0143
     dd2:	90 91 44 01 	lds	r25, 0x0144
     dd6:	6b 30       	cpi	r22, 0x0B	; 11
     dd8:	70 f4       	brcc	.+28     	; 0xdf6 <__stack+0x8f7>
          {
            crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&bHelloResp[temp]), 1, &xResult);
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	60 50       	subi	r22, 0x00	; 0
     dde:	7f 4f       	sbci	r23, 0xFF	; 255
     de0:	41 e0       	ldi	r20, 0x01	; 1
     de2:	50 e0       	ldi	r21, 0x00	; 0
     de4:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     de8:	80 93 28 01 	sts	0x0128, r24
     dec:	8c 3f       	cpi	r24, 0xFC	; 252
     dee:	91 f6       	brne	.-92     	; 0xd94 <__stack+0x895>
     df0:	8c eb       	ldi	r24, 0xBC	; 188
     df2:	92 e0       	ldi	r25, 0x02	; 2
     df4:	73 c0       	rjmp	.+230    	; 0xedc <__stack+0x9dd>
            crc = _crc_xmodem_update(crc, bHelloResp[temp]);
          }
  
          temp = (uint8_t)(crc>>8);
     df6:	20 91 2c 01 	lds	r18, 0x012C
     dfa:	29 83       	std	Y+1, r18	; 0x01
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 1, &xResult);
     dfc:	41 e0       	ldi	r20, 0x01	; 1
     dfe:	50 e0       	ldi	r21, 0x00	; 0
     e00:	be 01       	movw	r22, r28
     e02:	6f 5f       	subi	r22, 0xFF	; 255
     e04:	7f 4f       	sbci	r23, 0xFF	; 255
     e06:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     e0a:	80 93 28 01 	sts	0x0128, r24
     e0e:	8c 3f       	cpi	r24, 0xFC	; 252
     e10:	81 f4       	brne	.+32     	; 0xe32 <__stack+0x933>
     e12:	86 ec       	ldi	r24, 0xC6	; 198
     e14:	92 e0       	ldi	r25, 0x02	; 2
     e16:	62 c0       	rjmp	.+196    	; 0xedc <__stack+0x9dd>
     e18:	40 e0       	ldi	r20, 0x00	; 0
     e1a:	50 e0       	ldi	r21, 0x00	; 0
     e1c:	be 01       	movw	r22, r28
     e1e:	6f 5f       	subi	r22, 0xFF	; 255
     e20:	7f 4f       	sbci	r23, 0xFF	; 255
     e22:	80 91 43 01 	lds	r24, 0x0143
     e26:	90 91 44 01 	lds	r25, 0x0144
     e2a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     e2e:	80 93 28 01 	sts	0x0128, r24
     e32:	80 91 28 01 	lds	r24, 0x0128
     e36:	8b 3f       	cpi	r24, 0xFB	; 251
     e38:	19 f4       	brne	.+6      	; 0xe40 <__stack+0x941>
     e3a:	87 ec       	ldi	r24, 0xC7	; 199
     e3c:	92 e0       	ldi	r25, 0x02	; 2
     e3e:	4e c0       	rjmp	.+156    	; 0xedc <__stack+0x9dd>
          temp = (uint8_t)(crc & 0xFF);
     e40:	80 91 2b 01 	lds	r24, 0x012B
     e44:	89 83       	std	Y+1, r24	; 0x01
          crQUEUE_SEND(xHandle, xCharsForTx, (void *)(&temp), 1, &xResult);
     e46:	41 e0       	ldi	r20, 0x01	; 1
     e48:	50 e0       	ldi	r21, 0x00	; 0
     e4a:	be 01       	movw	r22, r28
     e4c:	6f 5f       	subi	r22, 0xFF	; 255
     e4e:	7f 4f       	sbci	r23, 0xFF	; 255
     e50:	80 91 43 01 	lds	r24, 0x0143
     e54:	90 91 44 01 	lds	r25, 0x0144
     e58:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     e5c:	80 93 28 01 	sts	0x0128, r24
     e60:	8c 3f       	cpi	r24, 0xFC	; 252
     e62:	81 f4       	brne	.+32     	; 0xe84 <__stack+0x985>
     e64:	8a ec       	ldi	r24, 0xCA	; 202
     e66:	92 e0       	ldi	r25, 0x02	; 2
     e68:	39 c0       	rjmp	.+114    	; 0xedc <__stack+0x9dd>
     e6a:	40 e0       	ldi	r20, 0x00	; 0
     e6c:	50 e0       	ldi	r21, 0x00	; 0
     e6e:	be 01       	movw	r22, r28
     e70:	6f 5f       	subi	r22, 0xFF	; 255
     e72:	7f 4f       	sbci	r23, 0xFF	; 255
     e74:	80 91 43 01 	lds	r24, 0x0143
     e78:	90 91 44 01 	lds	r25, 0x0144
     e7c:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xQueueCRSend>
     e80:	80 93 28 01 	sts	0x0128, r24
     e84:	80 91 28 01 	lds	r24, 0x0128
     e88:	8b 3f       	cpi	r24, 0xFB	; 251
     e8a:	31 f4       	brne	.+12     	; 0xe98 <__stack+0x999>
     e8c:	8b ec       	ldi	r24, 0xCB	; 203
     e8e:	92 e0       	ldi	r25, 0x02	; 2
     e90:	25 c0       	rjmp	.+74     	; 0xedc <__stack+0x9dd>
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	80 93 28 01 	sts	0x0128, r24

          if (xResult == pdPASS)
     e98:	80 91 28 01 	lds	r24, 0x0128
     e9c:	81 30       	cpi	r24, 0x01	; 1
     e9e:	19 f4       	brne	.+6      	; 0xea6 <__stack+0x9a7>
          {
            TxStart();
     ea0:	8b b1       	in	r24, 0x0b	; 11
     ea2:	8c 60       	ori	r24, 0x0C	; 12
     ea4:	8b b9       	out	0x0b, r24	; 11
          }
          vInterruptOn();  //W przypadku błędu wysyłamy wszystko z bufora przy wyłączonym nadajniku
     ea6:	80 91 c1 00 	lds	r24, 0x00C1
     eaa:	80 62       	ori	r24, 0x20	; 32
     eac:	80 93 c1 00 	sts	0x00C1, r24
     eb0:	a6 cb       	rjmp	.-2228   	; 0x5fe <__stack+0xff>
        Led2Off();
        stan = s_sync;
      }
      else //Zły adres
      {
        if (kodRozkazu == rFLASH)
     eb2:	80 91 42 01 	lds	r24, 0x0142
     eb6:	81 38       	cpi	r24, 0x81	; 129
     eb8:	a9 f4       	brne	.+42     	; 0xee4 <__stack+0x9e5>
        {
          DISABLE_RX();
     eba:	80 91 c1 00 	lds	r24, 0x00C1
     ebe:	8f 7e       	andi	r24, 0xEF	; 239
     ec0:	80 93 c1 00 	sts	0x00C1, r24
          Led1On();
     ec4:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <Led1On>
          Led2On();
     ec8:	0e 94 83 08 	call	0x1106	; 0x1106 <Led2On>
          //TODO disable RX buffer
          crDELAY(xHandle, 1000);
     ecc:	60 e0       	ldi	r22, 0x00	; 0
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	88 ee       	ldi	r24, 0xE8	; 232
     ed2:	93 e0       	ldi	r25, 0x03	; 3
     ed4:	0e 94 9f 11 	call	0x233e	; 0x233e <vCoRoutineAddToDelayedList>
     ed8:	82 ef       	ldi	r24, 0xF2	; 242
     eda:	92 e0       	ldi	r25, 0x02	; 2
     edc:	f8 01       	movw	r30, r16
     ede:	91 8f       	std	Z+25, r25	; 0x19
     ee0:	80 8f       	std	Z+24, r24	; 0x18
     ee2:	03 c0       	rjmp	.+6      	; 0xeea <__stack+0x9eb>
          ENABLE_RX();
        }
        Led1Off();
     ee4:	0e 94 81 08 	call	0x1102	; 0x1102 <Led1Off>
     ee8:	8e cb       	rjmp	.-2276   	; 0x606 <__stack+0x107>
        stan = s_sync;
      }
    }
  }
  crEND();
}
     eea:	0f 90       	pop	r0
     eec:	df 91       	pop	r29
     eee:	cf 91       	pop	r28
     ef0:	1f 91       	pop	r17
     ef2:	0f 91       	pop	r16
     ef4:	ff 90       	pop	r15
     ef6:	08 95       	ret

00000ef8 <xSerialPortInitMinimal>:

void xSerialPortInitMinimal(unsigned portBASE_TYPE uxQueueLength )
{
     ef8:	cf 93       	push	r28
     efa:	c8 2f       	mov	r28, r24
  portENTER_CRITICAL();
     efc:	0f b6       	in	r0, 0x3f	; 63
     efe:	f8 94       	cli
     f00:	0f 92       	push	r0
  {
    /* Create the queues used by the com test task. */
    xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
     f02:	61 e0       	ldi	r22, 0x01	; 1
     f04:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueCreate>
     f08:	90 93 46 01 	sts	0x0146, r25
     f0c:	80 93 45 01 	sts	0x0145, r24
    xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed portCHAR ) );
     f10:	61 e0       	ldi	r22, 0x01	; 1
     f12:	8c 2f       	mov	r24, r28
     f14:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueCreate>
     f18:	90 93 44 01 	sts	0x0144, r25
     f1c:	80 93 43 01 	sts	0x0143, r24

    UBRR0L = 3;
     f20:	83 e0       	ldi	r24, 0x03	; 3
     f22:	80 93 c4 00 	sts	0x00C4, r24
    UBRR0H = 0;
     f26:	10 92 c5 00 	sts	0x00C5, r1

    /* Enable the Rx interrupt.  The Tx interrupt will get enabled later. Also enable the Rx and Tx. */
    UCSR0B = ((1<<RXCIE0)|(1<<TXCIE0)|(1<<TXEN0)|(1<<RXEN0));
     f2a:	88 ed       	ldi	r24, 0xD8	; 216
     f2c:	80 93 c1 00 	sts	0x00C1, r24

    /* Set the data bits to 8. */
    UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     f30:	86 e8       	ldi	r24, 0x86	; 134
     f32:	80 93 c2 00 	sts	0x00C2, r24
    
    vSemaphoreCreateBinary( xSemaphore );
     f36:	60 e0       	ldi	r22, 0x00	; 0
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueCreate>
     f3e:	90 93 31 01 	sts	0x0131, r25
     f42:	80 93 30 01 	sts	0x0130, r24
     f46:	00 97       	sbiw	r24, 0x00	; 0
     f48:	39 f0       	breq	.+14     	; 0xf58 <xSerialPortInitMinimal+0x60>
     f4a:	20 e0       	ldi	r18, 0x00	; 0
     f4c:	40 e0       	ldi	r20, 0x00	; 0
     f4e:	50 e0       	ldi	r21, 0x00	; 0
     f50:	60 e0       	ldi	r22, 0x00	; 0
     f52:	70 e0       	ldi	r23, 0x00	; 0
     f54:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <xQueueGenericSend>
  }
  portEXIT_CRITICAL();
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
  return;
}
     f5c:	cf 91       	pop	r28
     f5e:	08 95       	ret

00000f60 <__vector_18>:

/*-----------------------------------------------------------*/
ISR(USART_RX_vect)
{
     f60:	1f 92       	push	r1
     f62:	0f 92       	push	r0
     f64:	0f b6       	in	r0, 0x3f	; 63
     f66:	0f 92       	push	r0
     f68:	11 24       	eor	r1, r1
     f6a:	2f 93       	push	r18
     f6c:	3f 93       	push	r19
     f6e:	4f 93       	push	r20
     f70:	5f 93       	push	r21
     f72:	6f 93       	push	r22
     f74:	7f 93       	push	r23
     f76:	8f 93       	push	r24
     f78:	9f 93       	push	r25
     f7a:	af 93       	push	r26
     f7c:	bf 93       	push	r27
     f7e:	ef 93       	push	r30
     f80:	ff 93       	push	r31
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	1f 92       	push	r1
     f88:	cd b7       	in	r28, 0x3d	; 61
     f8a:	de b7       	in	r29, 0x3e	; 62
  signed portCHAR cChar;
  cChar = UDR0;
     f8c:	80 91 c6 00 	lds	r24, 0x00C6
     f90:	89 83       	std	Y+1, r24	; 0x01
//  Led2Toggle();
  crQUEUE_SEND_FROM_ISR( xRxedChars, &cChar, pdFALSE );
     f92:	40 e0       	ldi	r20, 0x00	; 0
     f94:	be 01       	movw	r22, r28
     f96:	6f 5f       	subi	r22, 0xFF	; 255
     f98:	7f 4f       	sbci	r23, 0xFF	; 255
     f9a:	80 91 45 01 	lds	r24, 0x0145
     f9e:	90 91 46 01 	lds	r25, 0x0146
     fa2:	0e 94 48 10 	call	0x2090	; 0x2090 <xQueueCRSendFromISR>
}
     fa6:	0f 90       	pop	r0
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	ff 91       	pop	r31
     fae:	ef 91       	pop	r30
     fb0:	bf 91       	pop	r27
     fb2:	af 91       	pop	r26
     fb4:	9f 91       	pop	r25
     fb6:	8f 91       	pop	r24
     fb8:	7f 91       	pop	r23
     fba:	6f 91       	pop	r22
     fbc:	5f 91       	pop	r21
     fbe:	4f 91       	pop	r20
     fc0:	3f 91       	pop	r19
     fc2:	2f 91       	pop	r18
     fc4:	0f 90       	pop	r0
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	0f 90       	pop	r0
     fca:	1f 90       	pop	r1
     fcc:	18 95       	reti

00000fce <__vector_19>:
/*-----------------------------------------------------------*/

ISR(USART_UDRE_vect)
{
     fce:	1f 92       	push	r1
     fd0:	0f 92       	push	r0
     fd2:	0f b6       	in	r0, 0x3f	; 63
     fd4:	0f 92       	push	r0
     fd6:	11 24       	eor	r1, r1
     fd8:	2f 93       	push	r18
     fda:	3f 93       	push	r19
     fdc:	4f 93       	push	r20
     fde:	5f 93       	push	r21
     fe0:	6f 93       	push	r22
     fe2:	7f 93       	push	r23
     fe4:	8f 93       	push	r24
     fe6:	9f 93       	push	r25
     fe8:	af 93       	push	r26
     fea:	bf 93       	push	r27
     fec:	ef 93       	push	r30
     fee:	ff 93       	push	r31
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	00 d0       	rcall	.+0      	; 0xff6 <__vector_19+0x28>
     ff6:	cd b7       	in	r28, 0x3d	; 61
     ff8:	de b7       	in	r29, 0x3e	; 62
  signed portCHAR cChar, cTaskWoken;

  if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     ffa:	ae 01       	movw	r20, r28
     ffc:	4f 5f       	subi	r20, 0xFF	; 255
     ffe:	5f 4f       	sbci	r21, 0xFF	; 255
    1000:	be 01       	movw	r22, r28
    1002:	6e 5f       	subi	r22, 0xFE	; 254
    1004:	7f 4f       	sbci	r23, 0xFF	; 255
    1006:	80 91 43 01 	lds	r24, 0x0143
    100a:	90 91 44 01 	lds	r25, 0x0144
    100e:	0e 94 7b 0f 	call	0x1ef6	; 0x1ef6 <xQueueReceiveFromISR>
    1012:	81 30       	cpi	r24, 0x01	; 1
    1014:	21 f4       	brne	.+8      	; 0x101e <__vector_19+0x50>
  {
    /* Send the next character queued for Tx. */
    UDR0 = cChar;
    1016:	8a 81       	ldd	r24, Y+2	; 0x02
    1018:	80 93 c6 00 	sts	0x00C6, r24
    101c:	05 c0       	rjmp	.+10     	; 0x1028 <__vector_19+0x5a>
  }
  else
  {
    /* Queue empty, nothing to send. */
    vInterruptOff();
    101e:	80 91 c1 00 	lds	r24, 0x00C1
    1022:	8f 7d       	andi	r24, 0xDF	; 223
    1024:	80 93 c1 00 	sts	0x00C1, r24
  }
}
    1028:	0f 90       	pop	r0
    102a:	0f 90       	pop	r0
    102c:	df 91       	pop	r29
    102e:	cf 91       	pop	r28
    1030:	ff 91       	pop	r31
    1032:	ef 91       	pop	r30
    1034:	bf 91       	pop	r27
    1036:	af 91       	pop	r26
    1038:	9f 91       	pop	r25
    103a:	8f 91       	pop	r24
    103c:	7f 91       	pop	r23
    103e:	6f 91       	pop	r22
    1040:	5f 91       	pop	r21
    1042:	4f 91       	pop	r20
    1044:	3f 91       	pop	r19
    1046:	2f 91       	pop	r18
    1048:	0f 90       	pop	r0
    104a:	0f be       	out	0x3f, r0	; 63
    104c:	0f 90       	pop	r0
    104e:	1f 90       	pop	r1
    1050:	18 95       	reti

00001052 <__vector_20>:

ISR(USART_TX_vect)
{
    1052:	1f 92       	push	r1
    1054:	0f 92       	push	r0
    1056:	0f b6       	in	r0, 0x3f	; 63
    1058:	0f 92       	push	r0
    105a:	11 24       	eor	r1, r1
    105c:	8f 93       	push	r24
  if (!vIsInterruptOn())
    105e:	80 91 c1 00 	lds	r24, 0x00C1
    1062:	85 fd       	sbrc	r24, 5
    1064:	05 c0       	rjmp	.+10     	; 0x1070 <__vector_20+0x1e>
  {
      TxStop();
    1066:	8b b1       	in	r24, 0x0b	; 11
    1068:	83 7f       	andi	r24, 0xF3	; 243
    106a:	8b b9       	out	0x0b, r24	; 11
      xHigherPriorityTaskWoken = pdFALSE;
    106c:	10 92 2f 01 	sts	0x012F, r1
//      xSemaphoreGiveFromISR( xSemaphore, &xHigherPriorityTaskWoken);
  }
}
    1070:	8f 91       	pop	r24
    1072:	0f 90       	pop	r0
    1074:	0f be       	out	0x3f, r0	; 63
    1076:	0f 90       	pop	r0
    1078:	1f 90       	pop	r1
    107a:	18 95       	reti

0000107c <hardwareInit>:
#include "hardware.h"


void hardwareInit(void)
{
  DDRB  = 0x07; //0 - P3  , 1 - P2  , 2 - P1
    107c:	87 e0       	ldi	r24, 0x07	; 7
    107e:	84 b9       	out	0x04, r24	; 4
  PORTB = 0x38; //3 - Adr3, 4 - Adr4, 5 - Adr5
    1080:	88 e3       	ldi	r24, 0x38	; 56
    1082:	85 b9       	out	0x05, r24	; 5
  DDRC  = 0x00; //0 - Adr0, 1 - Adr1, 2 - KlRolety1Up, 3 - klRolety1Down
    1084:	17 b8       	out	0x07, r1	; 7
  PORTC = 0x3F; //4 - KlRolety2Up, 5 - KlRolety2Down
    1086:	8f e3       	ldi	r24, 0x3F	; 63
    1088:	88 b9       	out	0x08, r24	; 8
  DDRD  = 0xEE; //0 - RXD, 1 - TXD, 2 - !RxEn, 3 - TxEn, 
    108a:	8e ee       	ldi	r24, 0xEE	; 238
    108c:	8a b9       	out	0x0a, r24	; 10
  PORTD = 0x00; //5 - Led1, 6 - Led2, 7 - P4)
    108e:	1b b8       	out	0x0b, r1	; 11
  /*Ustalanie adresu
    bit 7, 6 = 0 dla sterowników rolet i światła
   */
  adres =  (PINB & 0x38) >> 1;
    1090:	83 b1       	in	r24, 0x03	; 3
    1092:	88 73       	andi	r24, 0x38	; 56
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	95 95       	asr	r25
    1098:	87 95       	ror	r24
    109a:	80 93 c1 04 	sts	0x04C1, r24
  adres |= (PINC & 0x03);
    109e:	96 b1       	in	r25, 0x06	; 6
    10a0:	93 70       	andi	r25, 0x03	; 3
    10a2:	89 2b       	or	r24, r25
    10a4:	80 93 c1 04 	sts	0x04C1, r24
    10a8:	08 95       	ret

000010aa <roleta1wGore>:
    roleta2Stop();
}

inline void roleta1wGore(void)
{
  PORTB &= ~0x02;
    10aa:	29 98       	cbi	0x05, 1	; 5
  PORTB |=  0x04;
    10ac:	2a 9a       	sbi	0x05, 2	; 5
    10ae:	08 95       	ret

000010b0 <roleta1wDol>:
}

inline void roleta1wDol(void)
{
  PORTB &= ~0x04;
    10b0:	2a 98       	cbi	0x05, 2	; 5
  PORTB |=  0x02;	
    10b2:	29 9a       	sbi	0x05, 1	; 5
    10b4:	08 95       	ret

000010b6 <roleta1Stop>:
}

inline void roleta1Stop(void)
{
  PORTB &= ~0x06;
    10b6:	85 b1       	in	r24, 0x05	; 5
    10b8:	89 7f       	andi	r24, 0xF9	; 249
    10ba:	85 b9       	out	0x05, r24	; 5
    10bc:	08 95       	ret

000010be <roleta2wGore>:
}

inline void roleta2wGore(void)
{
  PORTD &= ~0x80;
    10be:	5f 98       	cbi	0x0b, 7	; 11
  PORTB |=  0x01;
    10c0:	28 9a       	sbi	0x05, 0	; 5
    10c2:	08 95       	ret

000010c4 <roletawGore>:
  adres |= (PINC & 0x03);
}

void roletawGore(uint8_t nrRolety)
{
  if (nrRolety == 0)
    10c4:	81 11       	cpse	r24, r1
    10c6:	02 c0       	rjmp	.+4      	; 0x10cc <roletawGore+0x8>
    roleta1wGore();
    10c8:	0c 94 55 08 	jmp	0x10aa	; 0x10aa <roleta1wGore>
  else
    roleta2wGore();
    10cc:	0c 94 5f 08 	jmp	0x10be	; 0x10be <roleta2wGore>

000010d0 <roleta2wDol>:
  PORTB |=  0x01;
}

inline void roleta2wDol(void)
{
  PORTB &= ~0x01;
    10d0:	28 98       	cbi	0x05, 0	; 5
  PORTD |=  0x80;
    10d2:	5f 9a       	sbi	0x0b, 7	; 11
    10d4:	08 95       	ret

000010d6 <roletawDol>:
    roleta2wGore();
}

void roletawDol(uint8_t nrRolety)
{
  if (nrRolety == 0)
    10d6:	81 11       	cpse	r24, r1
    10d8:	02 c0       	rjmp	.+4      	; 0x10de <roletawDol+0x8>
    roleta1wDol();
    10da:	0c 94 58 08 	jmp	0x10b0	; 0x10b0 <roleta1wDol>
  else
    roleta2wDol();
    10de:	0c 94 68 08 	jmp	0x10d0	; 0x10d0 <roleta2wDol>

000010e2 <roleta2Stop>:
  PORTD |=  0x80;
}

inline void roleta2Stop(void)
{
  PORTB &= ~0x01;
    10e2:	28 98       	cbi	0x05, 0	; 5
  PORTD &= ~0x80;
    10e4:	5f 98       	cbi	0x0b, 7	; 11
    10e6:	08 95       	ret

000010e8 <roletaStop>:
    roleta2wDol();
}

void roletaStop(uint8_t nrRolety)
{
  if (nrRolety == 0)
    10e8:	81 11       	cpse	r24, r1
    10ea:	02 c0       	rjmp	.+4      	; 0x10f0 <roletaStop+0x8>
    roleta1Stop();
    10ec:	0c 94 5b 08 	jmp	0x10b6	; 0x10b6 <roleta1Stop>
  else
    roleta2Stop();
    10f0:	0c 94 71 08 	jmp	0x10e2	; 0x10e2 <roleta2Stop>

000010f4 <Led1On>:
  PORTD &= ~0x80;
}

inline void Led1On(void)
{
  PORTD |= 0x20;
    10f4:	5d 9a       	sbi	0x0b, 5	; 11
    10f6:	08 95       	ret

000010f8 <Led1Toggle>:
}

inline void Led1Toggle(void)
{
  PORTD ^= 0x20;
    10f8:	9b b1       	in	r25, 0x0b	; 11
    10fa:	80 e2       	ldi	r24, 0x20	; 32
    10fc:	89 27       	eor	r24, r25
    10fe:	8b b9       	out	0x0b, r24	; 11
    1100:	08 95       	ret

00001102 <Led1Off>:
}

inline void Led1Off(void)
{
  PORTD &= ~0x20;
    1102:	5d 98       	cbi	0x0b, 5	; 11
    1104:	08 95       	ret

00001106 <Led2On>:
}

inline void Led2On(void)
{
  PORTD |= 0x40;	
    1106:	5e 9a       	sbi	0x0b, 6	; 11
    1108:	08 95       	ret

0000110a <Led2Toggle>:
}

inline void Led2Toggle(void)
{
  PORTD ^= 0x40;
    110a:	9b b1       	in	r25, 0x0b	; 11
    110c:	80 e4       	ldi	r24, 0x40	; 64
    110e:	89 27       	eor	r24, r25
    1110:	8b b9       	out	0x0b, r24	; 11
    1112:	08 95       	ret

00001114 <Led2Off>:
}

inline void Led2Off(void)
{
  PORTD &= ~0x40;	
    1114:	5e 98       	cbi	0x0b, 6	; 11
    1116:	08 95       	ret

00001118 <czytKlawiszRol1wGore>:
}

inline char czytKlawiszRol1wGore(void)
{
  return PINC & 0x04;
    1118:	86 b1       	in	r24, 0x06	; 6
}
    111a:	84 70       	andi	r24, 0x04	; 4
    111c:	08 95       	ret

0000111e <czytKlawiszRol1wDol>:

inline char czytKlawiszRol1wDol(void)
{
  return PINC & 0x08;
    111e:	86 b1       	in	r24, 0x06	; 6
}
    1120:	88 70       	andi	r24, 0x08	; 8
    1122:	08 95       	ret

00001124 <czytKlawiszRol2wGore>:

inline char czytKlawiszRol2wGore(void)
{
  return PINC & 0x10;
    1124:	86 b1       	in	r24, 0x06	; 6
}
    1126:	80 71       	andi	r24, 0x10	; 16
    1128:	08 95       	ret

0000112a <czytKlawiszRol2wDol>:

inline char czytKlawiszRol2wDol(void)
{
  return PINC & 0x20;
    112a:	86 b1       	in	r24, 0x06	; 6
}
    112c:	80 72       	andi	r24, 0x20	; 32
    112e:	08 95       	ret

00001130 <automatStanowKlawiszy>:
#define T_START       5
#define T_START_CONT  40
#define T_STOP        5

uint8_t automatStanowKlawiszy(uint8_t klGoraOff, uint8_t klDolOff, t_stan_klawiszy *stan)
{
    1130:	fa 01       	movw	r30, r20
  uint8_t wiadomosc = 0;

  if (klGoraOff)
    1132:	88 23       	and	r24, r24
    1134:	71 f0       	breq	.+28     	; 0x1152 <automatStanowKlawiszy+0x22>
  {
    if ((stan->czynnosc == w_gore) && (stan->klGora_off == T_STOP))
    1136:	84 81       	ldd	r24, Z+4	; 0x04
    1138:	92 81       	ldd	r25, Z+2	; 0x02
    113a:	83 30       	cpi	r24, 0x03	; 3
    113c:	29 f4       	brne	.+10     	; 0x1148 <automatStanowKlawiszy+0x18>
    113e:	95 30       	cpi	r25, 0x05	; 5
    1140:	19 f4       	brne	.+6      	; 0x1148 <automatStanowKlawiszy+0x18>
    {
      stan->czynnosc = bezczynny;
    1142:	14 82       	std	Z+4, r1	; 0x04
      wiadomosc = 0x40;
    1144:	80 e4       	ldi	r24, 0x40	; 64
    1146:	01 c0       	rjmp	.+2      	; 0x114a <automatStanowKlawiszy+0x1a>
#define T_START_CONT  40
#define T_STOP        5

uint8_t automatStanowKlawiszy(uint8_t klGoraOff, uint8_t klDolOff, t_stan_klawiszy *stan)
{
  uint8_t wiadomosc = 0;
    1148:	80 e0       	ldi	r24, 0x00	; 0
    if ((stan->czynnosc == w_gore) && (stan->klGora_off == T_STOP))
    {
      stan->czynnosc = bezczynny;
      wiadomosc = 0x40;
    }
    stan->klGora_on = 0;
    114a:	10 82       	st	Z, r1
    stan->klGora_off++;
    114c:	9f 5f       	subi	r25, 0xFF	; 255
    114e:	92 83       	std	Z+2, r25	; 0x02
    1150:	15 c0       	rjmp	.+42     	; 0x117c <automatStanowKlawiszy+0x4c>
  }
  else
  {
    if (stan->klGora_on == T_START)
    1152:	90 81       	ld	r25, Z
    1154:	95 30       	cpi	r25, 0x05	; 5
    1156:	51 f4       	brne	.+20     	; 0x116c <automatStanowKlawiszy+0x3c>
    {
      if (stan->czynnosc != bezczynny)
    1158:	84 81       	ldd	r24, Z+4	; 0x04
    115a:	88 23       	and	r24, r24
    115c:	19 f0       	breq	.+6      	; 0x1164 <automatStanowKlawiszy+0x34>
      {
        stan->czynnosc = bezczynny;
    115e:	14 82       	std	Z+4, r1	; 0x04
        wiadomosc = 0x40;
    1160:	80 e4       	ldi	r24, 0x40	; 64
    1162:	09 c0       	rjmp	.+18     	; 0x1176 <automatStanowKlawiszy+0x46>
      }
      else
      {
        stan->czynnosc = do_konca_w_gore;
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	84 83       	std	Z+4, r24	; 0x04
        wiadomosc = 0xBF;
    1168:	8f eb       	ldi	r24, 0xBF	; 191
    116a:	05 c0       	rjmp	.+10     	; 0x1176 <automatStanowKlawiszy+0x46>
      }
    }
    if (stan->klGora_on == T_START_CONT)
    116c:	98 32       	cpi	r25, 0x28	; 40
    116e:	11 f4       	brne	.+4      	; 0x1174 <automatStanowKlawiszy+0x44>
    {
      stan->czynnosc = w_gore;
    1170:	83 e0       	ldi	r24, 0x03	; 3
    1172:	84 83       	std	Z+4, r24	; 0x04
#define T_START_CONT  40
#define T_STOP        5

uint8_t automatStanowKlawiszy(uint8_t klGoraOff, uint8_t klDolOff, t_stan_klawiszy *stan)
{
  uint8_t wiadomosc = 0;
    1174:	80 e0       	ldi	r24, 0x00	; 0
    }
    if (stan->klGora_on == T_START_CONT)
    {
      stan->czynnosc = w_gore;
    }
    stan->klGora_on++;
    1176:	9f 5f       	subi	r25, 0xFF	; 255
    1178:	90 83       	st	Z, r25
    stan->klGora_off = 0;
    117a:	12 82       	std	Z+2, r1	; 0x02
  }

  if (klDolOff)
    117c:	66 23       	and	r22, r22
    117e:	61 f0       	breq	.+24     	; 0x1198 <automatStanowKlawiszy+0x68>
  {
    if ((stan->czynnosc == w_dol) && (stan->klDol_off == T_STOP))
    1180:	24 81       	ldd	r18, Z+4	; 0x04
    1182:	93 81       	ldd	r25, Z+3	; 0x03
    1184:	24 30       	cpi	r18, 0x04	; 4
    1186:	21 f4       	brne	.+8      	; 0x1190 <automatStanowKlawiszy+0x60>
    1188:	95 30       	cpi	r25, 0x05	; 5
    118a:	11 f4       	brne	.+4      	; 0x1190 <automatStanowKlawiszy+0x60>
    {
      stan->czynnosc = bezczynny;
    118c:	14 82       	std	Z+4, r1	; 0x04
      wiadomosc = 0x40;
    118e:	80 e4       	ldi	r24, 0x40	; 64
    }
    stan->klDol_on = 0;
    1190:	11 82       	std	Z+1, r1	; 0x01
    stan->klDol_off++;
    1192:	9f 5f       	subi	r25, 0xFF	; 255
    1194:	93 83       	std	Z+3, r25	; 0x03
    1196:	14 c0       	rjmp	.+40     	; 0x11c0 <automatStanowKlawiszy+0x90>
  }
  else
  {
    if (stan->klDol_on == T_START)
    1198:	91 81       	ldd	r25, Z+1	; 0x01
    119a:	95 30       	cpi	r25, 0x05	; 5
    119c:	51 f4       	brne	.+20     	; 0x11b2 <automatStanowKlawiszy+0x82>
    {
      if (stan->czynnosc != bezczynny)
    119e:	84 81       	ldd	r24, Z+4	; 0x04
    11a0:	88 23       	and	r24, r24
    11a2:	19 f0       	breq	.+6      	; 0x11aa <automatStanowKlawiszy+0x7a>
      {
        stan->czynnosc = bezczynny;
    11a4:	14 82       	std	Z+4, r1	; 0x04
        wiadomosc = 0x40;
    11a6:	80 e4       	ldi	r24, 0x40	; 64
    11a8:	08 c0       	rjmp	.+16     	; 0x11ba <automatStanowKlawiszy+0x8a>
      }
      else
      {
        stan->czynnosc = do_konca_w_dol;
    11aa:	82 e0       	ldi	r24, 0x02	; 2
    11ac:	84 83       	std	Z+4, r24	; 0x04
        wiadomosc = 0x3F;
    11ae:	8f e3       	ldi	r24, 0x3F	; 63
    11b0:	04 c0       	rjmp	.+8      	; 0x11ba <automatStanowKlawiszy+0x8a>
      }
    }
    if (stan->klDol_on == T_START_CONT)
    11b2:	98 32       	cpi	r25, 0x28	; 40
    11b4:	11 f4       	brne	.+4      	; 0x11ba <automatStanowKlawiszy+0x8a>
    {
      stan->czynnosc = w_dol;
    11b6:	24 e0       	ldi	r18, 0x04	; 4
    11b8:	24 83       	std	Z+4, r18	; 0x04
    }
    stan->klDol_on++;
    11ba:	9f 5f       	subi	r25, 0xFF	; 255
    11bc:	91 83       	std	Z+1, r25	; 0x01
    stan->klDol_off = 0;
    11be:	13 82       	std	Z+3, r1	; 0x03
  }
  
  if (stan->klDol_on == 255)
    11c0:	91 81       	ldd	r25, Z+1	; 0x01
    11c2:	9f 3f       	cpi	r25, 0xFF	; 255
    11c4:	11 f4       	brne	.+4      	; 0x11ca <automatStanowKlawiszy+0x9a>
	  stan->klDol_on = 254;
    11c6:	9e ef       	ldi	r25, 0xFE	; 254
    11c8:	91 83       	std	Z+1, r25	; 0x01
  if (stan->klGora_on == 255)
    11ca:	90 81       	ld	r25, Z
    11cc:	9f 3f       	cpi	r25, 0xFF	; 255
    11ce:	11 f4       	brne	.+4      	; 0x11d4 <automatStanowKlawiszy+0xa4>
	  stan->klGora_on = 254;
    11d0:	9e ef       	ldi	r25, 0xFE	; 254
    11d2:	90 83       	st	Z, r25
  
  if (stan->klDol_off == 255)
    11d4:	93 81       	ldd	r25, Z+3	; 0x03
    11d6:	9f 3f       	cpi	r25, 0xFF	; 255
    11d8:	11 f4       	brne	.+4      	; 0x11de <automatStanowKlawiszy+0xae>
	  stan->klDol_off = 254;
    11da:	9e ef       	ldi	r25, 0xFE	; 254
    11dc:	93 83       	std	Z+3, r25	; 0x03
  if (stan->klGora_off == 255)
    11de:	92 81       	ldd	r25, Z+2	; 0x02
    11e0:	9f 3f       	cpi	r25, 0xFF	; 255
    11e2:	11 f4       	brne	.+4      	; 0x11e8 <automatStanowKlawiszy+0xb8>
	  stan->klGora_off = 254;
    11e4:	9e ef       	ldi	r25, 0xFE	; 254
    11e6:	92 83       	std	Z+2, r25	; 0x02

  return wiadomosc;
}
    11e8:	08 95       	ret

000011ea <prvIdleTask>:
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    11ea:	0e 94 8f 01 	call	0x31e	; 0x31e <vApplicationIdleHook>
		}
		#endif
	}
    11ee:	fd cf       	rjmp	.-6      	; 0x11ea <prvIdleTask>

000011f0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    11f0:	6f 92       	push	r6
    11f2:	7f 92       	push	r7
    11f4:	8f 92       	push	r8
    11f6:	9f 92       	push	r9
    11f8:	af 92       	push	r10
    11fa:	bf 92       	push	r11
    11fc:	cf 92       	push	r12
    11fe:	df 92       	push	r13
    1200:	ef 92       	push	r14
    1202:	ff 92       	push	r15
    1204:	0f 93       	push	r16
    1206:	1f 93       	push	r17
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	4c 01       	movw	r8, r24
    120e:	5a 01       	movw	r10, r20
    1210:	39 01       	movw	r6, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1212:	8a e1       	ldi	r24, 0x1A	; 26
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	0e 94 02 13 	call	0x2604	; 0x2604 <pvPortMalloc>
    121a:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
    121c:	89 2b       	or	r24, r25
    121e:	09 f4       	brne	.+2      	; 0x1222 <xTaskGenericCreate+0x32>
    1220:	bc c0       	rjmp	.+376    	; 0x139a <xTaskGenericCreate+0x1aa>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1222:	c1 14       	cp	r12, r1
    1224:	d1 04       	cpc	r13, r1
    1226:	21 f4       	brne	.+8      	; 0x1230 <xTaskGenericCreate+0x40>
    1228:	c5 01       	movw	r24, r10
    122a:	0e 94 02 13 	call	0x2604	; 0x2604 <pvPortMalloc>
    122e:	01 c0       	rjmp	.+2      	; 0x1232 <xTaskGenericCreate+0x42>
    1230:	c6 01       	movw	r24, r12
    1232:	98 8f       	std	Y+24, r25	; 0x18
    1234:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1236:	00 97       	sbiw	r24, 0x00	; 0
    1238:	21 f4       	brne	.+8      	; 0x1242 <xTaskGenericCreate+0x52>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    123a:	ce 01       	movw	r24, r28
    123c:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortFree>
    1240:	ac c0       	rjmp	.+344    	; 0x139a <xTaskGenericCreate+0x1aa>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    1242:	a5 01       	movw	r20, r10
    1244:	65 ea       	ldi	r22, 0xA5	; 165
    1246:	70 e0       	ldi	r23, 0x00	; 0
    1248:	0e 94 d3 14 	call	0x29a6	; 0x29a6 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    124c:	21 e0       	ldi	r18, 0x01	; 1
    124e:	a2 1a       	sub	r10, r18
    1250:	b1 08       	sbc	r11, r1
    1252:	cf 88       	ldd	r12, Y+23	; 0x17
    1254:	d8 8c       	ldd	r13, Y+24	; 0x18
    1256:	ca 0c       	add	r12, r10
    1258:	db 1c       	adc	r13, r11
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    125a:	19 8e       	std	Y+25, r1	; 0x19
    125c:	10 2f       	mov	r17, r16
    125e:	04 30       	cpi	r16, 0x04	; 4
    1260:	08 f0       	brcs	.+2      	; 0x1264 <xTaskGenericCreate+0x74>
    1262:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    1264:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1266:	5e 01       	movw	r10, r28
    1268:	82 e0       	ldi	r24, 0x02	; 2
    126a:	a8 0e       	add	r10, r24
    126c:	b1 1c       	adc	r11, r1
    126e:	c5 01       	movw	r24, r10
    1270:	0e 94 b6 10 	call	0x216c	; 0x216c <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1274:	ce 01       	movw	r24, r28
    1276:	0c 96       	adiw	r24, 0x0c	; 12
    1278:	0e 94 b6 10 	call	0x216c	; 0x216c <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    127c:	d9 87       	std	Y+9, r29	; 0x09
    127e:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1280:	84 e0       	ldi	r24, 0x04	; 4
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	81 1b       	sub	r24, r17
    1286:	91 09       	sbc	r25, r1
    1288:	9d 87       	std	Y+13, r25	; 0x0d
    128a:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    128c:	db 8b       	std	Y+19, r29	; 0x13
    128e:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1290:	a3 01       	movw	r20, r6
    1292:	b4 01       	movw	r22, r8
    1294:	c6 01       	movw	r24, r12
    1296:	0e 94 37 13 	call	0x266e	; 0x266e <pxPortInitialiseStack>
    129a:	99 83       	std	Y+1, r25	; 0x01
    129c:	88 83       	st	Y, r24
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    129e:	0f b6       	in	r0, 0x3f	; 63
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    12a4:	80 91 53 01 	lds	r24, 0x0153
    12a8:	8f 5f       	subi	r24, 0xFF	; 255
    12aa:	80 93 53 01 	sts	0x0153, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    12ae:	80 91 53 01 	lds	r24, 0x0153
    12b2:	81 30       	cpi	r24, 0x01	; 1
    12b4:	89 f5       	brne	.+98     	; 0x1318 <xTaskGenericCreate+0x128>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    12b6:	d0 93 48 01 	sts	0x0148, r29
    12ba:	c0 93 47 01 	sts	0x0147, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12be:	8c e7       	ldi	r24, 0x7C	; 124
    12c0:	91 e0       	ldi	r25, 0x01	; 1
    12c2:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
    12c6:	85 e8       	ldi	r24, 0x85	; 133
    12c8:	91 e0       	ldi	r25, 0x01	; 1
    12ca:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
    12ce:	8e e8       	ldi	r24, 0x8E	; 142
    12d0:	91 e0       	ldi	r25, 0x01	; 1
    12d2:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
    12d6:	87 e9       	ldi	r24, 0x97	; 151
    12d8:	91 e0       	ldi	r25, 0x01	; 1
    12da:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12de:	83 e7       	ldi	r24, 0x73	; 115
    12e0:	91 e0       	ldi	r25, 0x01	; 1
    12e2:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12e6:	8a e6       	ldi	r24, 0x6A	; 106
    12e8:	91 e0       	ldi	r25, 0x01	; 1
    12ea:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    12ee:	8d e5       	ldi	r24, 0x5D	; 93
    12f0:	91 e0       	ldi	r25, 0x01	; 1
    12f2:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    12f6:	84 e5       	ldi	r24, 0x54	; 84
    12f8:	91 e0       	ldi	r25, 0x01	; 1
    12fa:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    12fe:	83 e7       	ldi	r24, 0x73	; 115
    1300:	91 e0       	ldi	r25, 0x01	; 1
    1302:	90 93 69 01 	sts	0x0169, r25
    1306:	80 93 68 01 	sts	0x0168, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    130a:	8a e6       	ldi	r24, 0x6A	; 106
    130c:	91 e0       	ldi	r25, 0x01	; 1
    130e:	90 93 67 01 	sts	0x0167, r25
    1312:	80 93 66 01 	sts	0x0166, r24
    1316:	0f c0       	rjmp	.+30     	; 0x1336 <xTaskGenericCreate+0x146>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1318:	80 91 4e 01 	lds	r24, 0x014E
    131c:	81 11       	cpse	r24, r1
    131e:	0b c0       	rjmp	.+22     	; 0x1336 <xTaskGenericCreate+0x146>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1320:	e0 91 47 01 	lds	r30, 0x0147
    1324:	f0 91 48 01 	lds	r31, 0x0148
    1328:	86 89       	ldd	r24, Z+22	; 0x16
    132a:	08 17       	cp	r16, r24
    132c:	20 f0       	brcs	.+8      	; 0x1336 <xTaskGenericCreate+0x146>
					{
						pxCurrentTCB = pxNewTCB;
    132e:	d0 93 48 01 	sts	0x0148, r29
    1332:	c0 93 47 01 	sts	0x0147, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1336:	8e 89       	ldd	r24, Y+22	; 0x16
    1338:	90 91 50 01 	lds	r25, 0x0150
    133c:	98 17       	cp	r25, r24
    133e:	10 f4       	brcc	.+4      	; 0x1344 <xTaskGenericCreate+0x154>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1340:	80 93 50 01 	sts	0x0150, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1344:	90 91 49 01 	lds	r25, 0x0149
    1348:	9f 5f       	subi	r25, 0xFF	; 255
    134a:	90 93 49 01 	sts	0x0149, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    134e:	90 91 4f 01 	lds	r25, 0x014F
    1352:	98 17       	cp	r25, r24
    1354:	10 f4       	brcc	.+4      	; 0x135a <xTaskGenericCreate+0x16a>
    1356:	80 93 4f 01 	sts	0x014F, r24
    135a:	e9 e0       	ldi	r30, 0x09	; 9
    135c:	8e 9f       	mul	r24, r30
    135e:	c0 01       	movw	r24, r0
    1360:	11 24       	eor	r1, r1
    1362:	b5 01       	movw	r22, r10
    1364:	84 58       	subi	r24, 0x84	; 132
    1366:	9e 4f       	sbci	r25, 0xFE	; 254
    1368:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    136c:	0f 90       	pop	r0
    136e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
    1370:	e1 14       	cp	r14, r1
    1372:	f1 04       	cpc	r15, r1
    1374:	19 f0       	breq	.+6      	; 0x137c <xTaskGenericCreate+0x18c>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1376:	f7 01       	movw	r30, r14
    1378:	d1 83       	std	Z+1, r29	; 0x01
    137a:	c0 83       	st	Z, r28
		}

		if( xSchedulerRunning != pdFALSE )
    137c:	80 91 4e 01 	lds	r24, 0x014E
    1380:	88 23       	and	r24, r24
    1382:	49 f0       	breq	.+18     	; 0x1396 <xTaskGenericCreate+0x1a6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1384:	e0 91 47 01 	lds	r30, 0x0147
    1388:	f0 91 48 01 	lds	r31, 0x0148
    138c:	86 89       	ldd	r24, Z+22	; 0x16
    138e:	80 17       	cp	r24, r16
    1390:	10 f4       	brcc	.+4      	; 0x1396 <xTaskGenericCreate+0x1a6>
			{
				portYIELD_WITHIN_API();
    1392:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	01 c0       	rjmp	.+2      	; 0x139c <xTaskGenericCreate+0x1ac>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    139a:	8f ef       	ldi	r24, 0xFF	; 255
			}
		}
	}

	return xReturn;
}
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	1f 91       	pop	r17
    13a2:	0f 91       	pop	r16
    13a4:	ff 90       	pop	r15
    13a6:	ef 90       	pop	r14
    13a8:	df 90       	pop	r13
    13aa:	cf 90       	pop	r12
    13ac:	bf 90       	pop	r11
    13ae:	af 90       	pop	r10
    13b0:	9f 90       	pop	r9
    13b2:	8f 90       	pop	r8
    13b4:	7f 90       	pop	r7
    13b6:	6f 90       	pop	r6
    13b8:	08 95       	ret

000013ba <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    13ba:	ef 92       	push	r14
    13bc:	ff 92       	push	r15
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	cf 93       	push	r28
    13c4:	df 93       	push	r29
    13c6:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    13c8:	0f b6       	in	r0, 0x3f	; 63
    13ca:	f8 94       	cli
    13cc:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    13ce:	80 91 47 01 	lds	r24, 0x0147
    13d2:	90 91 48 01 	lds	r25, 0x0148
    13d6:	c8 17       	cp	r28, r24
    13d8:	d9 07       	cpc	r29, r25
    13da:	11 f0       	breq	.+4      	; 0x13e0 <vTaskSuspend+0x26>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    13dc:	20 97       	sbiw	r28, 0x00	; 0
    13de:	39 f4       	brne	.+14     	; 0x13ee <vTaskSuspend+0x34>
    13e0:	00 91 47 01 	lds	r16, 0x0147
    13e4:	10 91 48 01 	lds	r17, 0x0148
    13e8:	c0 e0       	ldi	r28, 0x00	; 0
    13ea:	d0 e0       	ldi	r29, 0x00	; 0
    13ec:	01 c0       	rjmp	.+2      	; 0x13f0 <vTaskSuspend+0x36>
    13ee:	8e 01       	movw	r16, r28

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    13f0:	78 01       	movw	r14, r16
    13f2:	82 e0       	ldi	r24, 0x02	; 2
    13f4:	e8 0e       	add	r14, r24
    13f6:	f1 1c       	adc	r15, r1
    13f8:	c7 01       	movw	r24, r14
    13fa:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    13fe:	f8 01       	movw	r30, r16
    1400:	84 89       	ldd	r24, Z+20	; 0x14
    1402:	95 89       	ldd	r25, Z+21	; 0x15
    1404:	89 2b       	or	r24, r25
    1406:	21 f0       	breq	.+8      	; 0x1410 <vTaskSuspend+0x56>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1408:	c8 01       	movw	r24, r16
    140a:	0c 96       	adiw	r24, 0x0c	; 12
    140c:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1410:	b7 01       	movw	r22, r14
    1412:	84 e5       	ldi	r24, 0x54	; 84
    1414:	91 e0       	ldi	r25, 0x01	; 1
    1416:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>
		}
		portEXIT_CRITICAL();
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
    141e:	cd 2b       	or	r28, r29
    1420:	11 f4       	brne	.+4      	; 0x1426 <vTaskSuspend+0x6c>
		{
			portYIELD_WITHIN_API();
    1422:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
		}
	}
    1426:	df 91       	pop	r29
    1428:	cf 91       	pop	r28
    142a:	1f 91       	pop	r17
    142c:	0f 91       	pop	r16
    142e:	ff 90       	pop	r15
    1430:	ef 90       	pop	r14
    1432:	08 95       	ret

00001434 <xTaskIsTaskSuspended>:
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1434:	fc 01       	movw	r30, r24
    1436:	22 85       	ldd	r18, Z+10	; 0x0a
    1438:	33 85       	ldd	r19, Z+11	; 0x0b
    143a:	24 55       	subi	r18, 0x54	; 84
    143c:	31 40       	sbci	r19, 0x01	; 1
    143e:	51 f4       	brne	.+20     	; 0x1454 <xTaskIsTaskSuspended+0x20>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    1440:	fc 01       	movw	r30, r24
    1442:	24 89       	ldd	r18, Z+20	; 0x14
    1444:	35 89       	ldd	r19, Z+21	; 0x15
    1446:	f1 e0       	ldi	r31, 0x01	; 1
    1448:	2d 35       	cpi	r18, 0x5D	; 93
    144a:	3f 07       	cpc	r19, r31
    144c:	19 f0       	breq	.+6      	; 0x1454 <xTaskIsTaskSuspended+0x20>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    144e:	81 e0       	ldi	r24, 0x01	; 1
    1450:	23 2b       	or	r18, r19
    1452:	09 f0       	breq	.+2      	; 0x1456 <xTaskIsTaskSuspended+0x22>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    1454:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    1456:	08 95       	ret

00001458 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1460:	00 97       	sbiw	r24, 0x00	; 0
    1462:	89 f1       	breq	.+98     	; 0x14c6 <vTaskResume+0x6e>
    1464:	20 91 47 01 	lds	r18, 0x0147
    1468:	30 91 48 01 	lds	r19, 0x0148
    146c:	82 17       	cp	r24, r18
    146e:	93 07       	cpc	r25, r19
    1470:	51 f1       	breq	.+84     	; 0x14c6 <vTaskResume+0x6e>
    1472:	ec 01       	movw	r28, r24
		{
			portENTER_CRITICAL();
    1474:	0f b6       	in	r0, 0x3f	; 63
    1476:	f8 94       	cli
    1478:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    147a:	0e 94 1a 0a 	call	0x1434	; 0x1434 <xTaskIsTaskSuspended>
    147e:	81 30       	cpi	r24, 0x01	; 1
    1480:	01 f5       	brne	.+64     	; 0x14c2 <vTaskResume+0x6a>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    1482:	8e 01       	movw	r16, r28
    1484:	0e 5f       	subi	r16, 0xFE	; 254
    1486:	1f 4f       	sbci	r17, 0xFF	; 255
    1488:	c8 01       	movw	r24, r16
    148a:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    148e:	9e 89       	ldd	r25, Y+22	; 0x16
    1490:	80 91 4f 01 	lds	r24, 0x014F
    1494:	89 17       	cp	r24, r25
    1496:	10 f4       	brcc	.+4      	; 0x149c <vTaskResume+0x44>
    1498:	90 93 4f 01 	sts	0x014F, r25
    149c:	29 e0       	ldi	r18, 0x09	; 9
    149e:	92 9f       	mul	r25, r18
    14a0:	c0 01       	movw	r24, r0
    14a2:	11 24       	eor	r1, r1
    14a4:	b8 01       	movw	r22, r16
    14a6:	84 58       	subi	r24, 0x84	; 132
    14a8:	9e 4f       	sbci	r25, 0xFE	; 254
    14aa:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    14ae:	e0 91 47 01 	lds	r30, 0x0147
    14b2:	f0 91 48 01 	lds	r31, 0x0148
    14b6:	9e 89       	ldd	r25, Y+22	; 0x16
    14b8:	86 89       	ldd	r24, Z+22	; 0x16
    14ba:	98 17       	cp	r25, r24
    14bc:	10 f0       	brcs	.+4      	; 0x14c2 <vTaskResume+0x6a>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    14be:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
					}
				}
			}
			portEXIT_CRITICAL();
    14c2:	0f 90       	pop	r0
    14c4:	0f be       	out	0x3f, r0	; 63
		}
	}
    14c6:	df 91       	pop	r29
    14c8:	cf 91       	pop	r28
    14ca:	1f 91       	pop	r17
    14cc:	0f 91       	pop	r16
    14ce:	08 95       	ret

000014d0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    14d0:	ef 92       	push	r14
    14d2:	ff 92       	push	r15
    14d4:	1f 93       	push	r17
    14d6:	cf 93       	push	r28
    14d8:	df 93       	push	r29
    14da:	ec 01       	movw	r28, r24
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    14dc:	0e 94 1a 0a 	call	0x1434	; 0x1434 <xTaskIsTaskSuspended>
    14e0:	81 30       	cpi	r24, 0x01	; 1
    14e2:	69 f5       	brne	.+90     	; 0x153e <xTaskResumeFromISR+0x6e>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    14e4:	80 91 4d 01 	lds	r24, 0x014D
    14e8:	81 11       	cpse	r24, r1
    14ea:	22 c0       	rjmp	.+68     	; 0x1530 <xTaskResumeFromISR+0x60>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    14ec:	e0 91 47 01 	lds	r30, 0x0147
    14f0:	f0 91 48 01 	lds	r31, 0x0148
    14f4:	11 e0       	ldi	r17, 0x01	; 1
    14f6:	9e 89       	ldd	r25, Y+22	; 0x16
    14f8:	86 89       	ldd	r24, Z+22	; 0x16
    14fa:	98 17       	cp	r25, r24
    14fc:	08 f4       	brcc	.+2      	; 0x1500 <xTaskResumeFromISR+0x30>
    14fe:	10 e0       	ldi	r17, 0x00	; 0
				vListRemove(  &( pxTCB->xGenericListItem ) );
    1500:	7e 01       	movw	r14, r28
    1502:	32 e0       	ldi	r19, 0x02	; 2
    1504:	e3 0e       	add	r14, r19
    1506:	f1 1c       	adc	r15, r1
    1508:	c7 01       	movw	r24, r14
    150a:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    150e:	2e 89       	ldd	r18, Y+22	; 0x16
    1510:	80 91 4f 01 	lds	r24, 0x014F
    1514:	82 17       	cp	r24, r18
    1516:	10 f4       	brcc	.+4      	; 0x151c <xTaskResumeFromISR+0x4c>
    1518:	20 93 4f 01 	sts	0x014F, r18
    151c:	39 e0       	ldi	r19, 0x09	; 9
    151e:	23 9f       	mul	r18, r19
    1520:	c0 01       	movw	r24, r0
    1522:	11 24       	eor	r1, r1
    1524:	b7 01       	movw	r22, r14
    1526:	84 58       	subi	r24, 0x84	; 132
    1528:	9e 4f       	sbci	r25, 0xFE	; 254
    152a:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>
    152e:	08 c0       	rjmp	.+16     	; 0x1540 <xTaskResumeFromISR+0x70>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1530:	be 01       	movw	r22, r28
    1532:	64 5f       	subi	r22, 0xF4	; 244
    1534:	7f 4f       	sbci	r23, 0xFF	; 255
    1536:	8d e5       	ldi	r24, 0x5D	; 93
    1538:	91 e0       	ldi	r25, 0x01	; 1
    153a:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    153e:	10 e0       	ldi	r17, 0x00	; 0
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
    1540:	81 2f       	mov	r24, r17
    1542:	df 91       	pop	r29
    1544:	cf 91       	pop	r28
    1546:	1f 91       	pop	r17
    1548:	ff 90       	pop	r15
    154a:	ef 90       	pop	r14
    154c:	08 95       	ret

0000154e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    154e:	af 92       	push	r10
    1550:	bf 92       	push	r11
    1552:	cf 92       	push	r12
    1554:	df 92       	push	r13
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    155c:	a1 2c       	mov	r10, r1
    155e:	b1 2c       	mov	r11, r1
    1560:	c1 2c       	mov	r12, r1
    1562:	d1 2c       	mov	r13, r1
    1564:	e1 2c       	mov	r14, r1
    1566:	f1 2c       	mov	r15, r1
    1568:	00 e0       	ldi	r16, 0x00	; 0
    156a:	20 e0       	ldi	r18, 0x00	; 0
    156c:	30 e0       	ldi	r19, 0x00	; 0
    156e:	45 e5       	ldi	r20, 0x55	; 85
    1570:	50 e0       	ldi	r21, 0x00	; 0
    1572:	6c e0       	ldi	r22, 0x0C	; 12
    1574:	71 e0       	ldi	r23, 0x01	; 1
    1576:	85 ef       	ldi	r24, 0xF5	; 245
    1578:	98 e0       	ldi	r25, 0x08	; 8
    157a:	0e 94 f8 08 	call	0x11f0	; 0x11f0 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    157e:	81 30       	cpi	r24, 0x01	; 1
    1580:	81 f4       	brne	.+32     	; 0x15a2 <vTaskStartScheduler+0x54>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1582:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1584:	80 93 4e 01 	sts	0x014E, r24
		xTickCount = ( portTickType ) 0;
    1588:	10 92 52 01 	sts	0x0152, r1
    158c:	10 92 51 01 	sts	0x0151, r1
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    1590:	0f 91       	pop	r16
    1592:	ff 90       	pop	r15
    1594:	ef 90       	pop	r14
    1596:	df 90       	pop	r13
    1598:	cf 90       	pop	r12
    159a:	bf 90       	pop	r11
    159c:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    159e:	0c 94 a3 13 	jmp	0x2746	; 0x2746 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    15a2:	0f 91       	pop	r16
    15a4:	ff 90       	pop	r15
    15a6:	ef 90       	pop	r14
    15a8:	df 90       	pop	r13
    15aa:	cf 90       	pop	r12
    15ac:	bf 90       	pop	r11
    15ae:	af 90       	pop	r10
    15b0:	08 95       	ret

000015b2 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    15b2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    15b4:	10 92 4e 01 	sts	0x014E, r1
	vPortEndScheduler();
    15b8:	0c 94 de 13 	jmp	0x27bc	; 0x27bc <vPortEndScheduler>

000015bc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    15bc:	80 91 4d 01 	lds	r24, 0x014D
    15c0:	8f 5f       	subi	r24, 0xFF	; 255
    15c2:	80 93 4d 01 	sts	0x014D, r24
    15c6:	08 95       	ret

000015c8 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    15c8:	0f b6       	in	r0, 0x3f	; 63
    15ca:	f8 94       	cli
    15cc:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    15ce:	80 91 51 01 	lds	r24, 0x0151
    15d2:	90 91 52 01 	lds	r25, 0x0152
	}
	portEXIT_CRITICAL();
    15d6:	0f 90       	pop	r0
    15d8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    15da:	08 95       	ret

000015dc <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    15dc:	80 91 53 01 	lds	r24, 0x0153
}
    15e0:	08 95       	ret

000015e2 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    15e2:	ff 92       	push	r15
    15e4:	0f 93       	push	r16
    15e6:	1f 93       	push	r17
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    15ec:	80 91 4d 01 	lds	r24, 0x014D
    15f0:	81 11       	cpse	r24, r1
    15f2:	5f c0       	rjmp	.+190    	; 0x16b2 <vTaskIncrementTick+0xd0>
	{
		++xTickCount;
    15f4:	80 91 51 01 	lds	r24, 0x0151
    15f8:	90 91 52 01 	lds	r25, 0x0152
    15fc:	01 96       	adiw	r24, 0x01	; 1
    15fe:	90 93 52 01 	sts	0x0152, r25
    1602:	80 93 51 01 	sts	0x0151, r24
		if( xTickCount == ( portTickType ) 0 )
    1606:	80 91 51 01 	lds	r24, 0x0151
    160a:	90 91 52 01 	lds	r25, 0x0152
    160e:	89 2b       	or	r24, r25
    1610:	a9 f4       	brne	.+42     	; 0x163c <vTaskIncrementTick+0x5a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    1612:	80 91 68 01 	lds	r24, 0x0168
    1616:	90 91 69 01 	lds	r25, 0x0169
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    161a:	20 91 66 01 	lds	r18, 0x0166
    161e:	30 91 67 01 	lds	r19, 0x0167
    1622:	30 93 69 01 	sts	0x0169, r19
    1626:	20 93 68 01 	sts	0x0168, r18
			pxOverflowDelayedTaskList = pxTemp;
    162a:	90 93 67 01 	sts	0x0167, r25
    162e:	80 93 66 01 	sts	0x0166, r24
			xNumOfOverflows++;
    1632:	80 91 4a 01 	lds	r24, 0x014A
    1636:	8f 5f       	subi	r24, 0xFF	; 255
    1638:	80 93 4a 01 	sts	0x014A, r24
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    163c:	89 e0       	ldi	r24, 0x09	; 9
    163e:	f8 2e       	mov	r15, r24
    1640:	e0 91 68 01 	lds	r30, 0x0168
    1644:	f0 91 69 01 	lds	r31, 0x0169
    1648:	80 81       	ld	r24, Z
    164a:	88 23       	and	r24, r24
    164c:	b9 f1       	breq	.+110    	; 0x16bc <vTaskIncrementTick+0xda>
    164e:	e0 91 68 01 	lds	r30, 0x0168
    1652:	f0 91 69 01 	lds	r31, 0x0169
    1656:	05 80       	ldd	r0, Z+5	; 0x05
    1658:	f6 81       	ldd	r31, Z+6	; 0x06
    165a:	e0 2d       	mov	r30, r0
    165c:	c6 81       	ldd	r28, Z+6	; 0x06
    165e:	d7 81       	ldd	r29, Z+7	; 0x07
    1660:	20 97       	sbiw	r28, 0x00	; 0
    1662:	61 f1       	breq	.+88     	; 0x16bc <vTaskIncrementTick+0xda>
    1664:	20 91 51 01 	lds	r18, 0x0151
    1668:	30 91 52 01 	lds	r19, 0x0152
    166c:	8a 81       	ldd	r24, Y+2	; 0x02
    166e:	9b 81       	ldd	r25, Y+3	; 0x03
    1670:	28 17       	cp	r18, r24
    1672:	39 07       	cpc	r19, r25
    1674:	18 f1       	brcs	.+70     	; 0x16bc <vTaskIncrementTick+0xda>
    1676:	8e 01       	movw	r16, r28
    1678:	0e 5f       	subi	r16, 0xFE	; 254
    167a:	1f 4f       	sbci	r17, 0xFF	; 255
    167c:	c8 01       	movw	r24, r16
    167e:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
    1682:	8c 89       	ldd	r24, Y+20	; 0x14
    1684:	9d 89       	ldd	r25, Y+21	; 0x15
    1686:	89 2b       	or	r24, r25
    1688:	21 f0       	breq	.+8      	; 0x1692 <vTaskIncrementTick+0xb0>
    168a:	ce 01       	movw	r24, r28
    168c:	0c 96       	adiw	r24, 0x0c	; 12
    168e:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
    1692:	9e 89       	ldd	r25, Y+22	; 0x16
    1694:	80 91 4f 01 	lds	r24, 0x014F
    1698:	89 17       	cp	r24, r25
    169a:	10 f4       	brcc	.+4      	; 0x16a0 <vTaskIncrementTick+0xbe>
    169c:	90 93 4f 01 	sts	0x014F, r25
    16a0:	f9 9e       	mul	r15, r25
    16a2:	c0 01       	movw	r24, r0
    16a4:	11 24       	eor	r1, r1
    16a6:	b8 01       	movw	r22, r16
    16a8:	84 58       	subi	r24, 0x84	; 132
    16aa:	9e 4f       	sbci	r25, 0xFE	; 254
    16ac:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>
    16b0:	c7 cf       	rjmp	.-114    	; 0x1640 <vTaskIncrementTick+0x5e>
	}
	else
	{
		++uxMissedTicks;
    16b2:	80 91 4c 01 	lds	r24, 0x014C
    16b6:	8f 5f       	subi	r24, 0xFF	; 255
    16b8:	80 93 4c 01 	sts	0x014C, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    16bc:	df 91       	pop	r29
    16be:	cf 91       	pop	r28
    16c0:	1f 91       	pop	r17
    16c2:	0f 91       	pop	r16
    16c4:	ff 90       	pop	r15
    16c6:	08 95       	ret

000016c8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    16c8:	ef 92       	push	r14
    16ca:	ff 92       	push	r15
    16cc:	0f 93       	push	r16
    16ce:	1f 93       	push	r17
    16d0:	cf 93       	push	r28
    16d2:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    16d4:	0f b6       	in	r0, 0x3f	; 63
    16d6:	f8 94       	cli
    16d8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    16da:	80 91 4d 01 	lds	r24, 0x014D
    16de:	81 50       	subi	r24, 0x01	; 1
    16e0:	80 93 4d 01 	sts	0x014D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16e4:	80 91 4d 01 	lds	r24, 0x014D
    16e8:	88 23       	and	r24, r24
    16ea:	11 f0       	breq	.+4      	; 0x16f0 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    16ec:	80 e0       	ldi	r24, 0x00	; 0
    16ee:	55 c0       	rjmp	.+170    	; 0x179a <xTaskResumeAll+0xd2>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    16f0:	80 91 53 01 	lds	r24, 0x0153
    16f4:	88 23       	and	r24, r24
    16f6:	d1 f3       	breq	.-12     	; 0x16ec <xTaskResumeAll+0x24>
    16f8:	10 e0       	ldi	r17, 0x00	; 0
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    16fa:	09 e0       	ldi	r16, 0x09	; 9
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    16fc:	80 91 5d 01 	lds	r24, 0x015D
    1700:	81 11       	cpse	r24, r1
    1702:	05 c0       	rjmp	.+10     	; 0x170e <xTaskResumeAll+0x46>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1704:	80 91 4c 01 	lds	r24, 0x014C
    1708:	81 11       	cpse	r24, r1
    170a:	2d c0       	rjmp	.+90     	; 0x1766 <xTaskResumeAll+0x9e>
    170c:	38 c0       	rjmp	.+112    	; 0x177e <xTaskResumeAll+0xb6>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    170e:	e0 91 62 01 	lds	r30, 0x0162
    1712:	f0 91 63 01 	lds	r31, 0x0163
    1716:	c6 81       	ldd	r28, Z+6	; 0x06
    1718:	d7 81       	ldd	r29, Z+7	; 0x07
    171a:	20 97       	sbiw	r28, 0x00	; 0
    171c:	99 f3       	breq	.-26     	; 0x1704 <xTaskResumeAll+0x3c>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    171e:	ce 01       	movw	r24, r28
    1720:	0c 96       	adiw	r24, 0x0c	; 12
    1722:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1726:	7e 01       	movw	r14, r28
    1728:	82 e0       	ldi	r24, 0x02	; 2
    172a:	e8 0e       	add	r14, r24
    172c:	f1 1c       	adc	r15, r1
    172e:	c7 01       	movw	r24, r14
    1730:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1734:	9e 89       	ldd	r25, Y+22	; 0x16
    1736:	80 91 4f 01 	lds	r24, 0x014F
    173a:	89 17       	cp	r24, r25
    173c:	10 f4       	brcc	.+4      	; 0x1742 <xTaskResumeAll+0x7a>
    173e:	90 93 4f 01 	sts	0x014F, r25
    1742:	09 9f       	mul	r16, r25
    1744:	c0 01       	movw	r24, r0
    1746:	11 24       	eor	r1, r1
    1748:	b7 01       	movw	r22, r14
    174a:	84 58       	subi	r24, 0x84	; 132
    174c:	9e 4f       	sbci	r25, 0xFE	; 254
    174e:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1752:	e0 91 47 01 	lds	r30, 0x0147
    1756:	f0 91 48 01 	lds	r31, 0x0148
    175a:	9e 89       	ldd	r25, Y+22	; 0x16
    175c:	86 89       	ldd	r24, Z+22	; 0x16
    175e:	98 17       	cp	r25, r24
    1760:	68 f2       	brcs	.-102    	; 0x16fc <xTaskResumeAll+0x34>
					{
						xYieldRequired = pdTRUE;
    1762:	11 e0       	ldi	r17, 0x01	; 1
    1764:	cb cf       	rjmp	.-106    	; 0x16fc <xTaskResumeAll+0x34>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1766:	80 91 4c 01 	lds	r24, 0x014C
    176a:	88 23       	and	r24, r24
    176c:	51 f0       	breq	.+20     	; 0x1782 <xTaskResumeAll+0xba>
					{
						vTaskIncrementTick();
    176e:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <vTaskIncrementTick>
						--uxMissedTicks;
    1772:	80 91 4c 01 	lds	r24, 0x014C
    1776:	81 50       	subi	r24, 0x01	; 1
    1778:	80 93 4c 01 	sts	0x014C, r24
    177c:	f4 cf       	rjmp	.-24     	; 0x1766 <xTaskResumeAll+0x9e>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    177e:	11 30       	cpi	r17, 0x01	; 1
    1780:	31 f4       	brne	.+12     	; 0x178e <xTaskResumeAll+0xc6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1782:	10 92 4b 01 	sts	0x014B, r1
					portYIELD_WITHIN_API();
    1786:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    178a:	81 e0       	ldi	r24, 0x01	; 1
    178c:	06 c0       	rjmp	.+12     	; 0x179a <xTaskResumeAll+0xd2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    178e:	80 91 4b 01 	lds	r24, 0x014B
    1792:	81 30       	cpi	r24, 0x01	; 1
    1794:	09 f0       	breq	.+2      	; 0x1798 <xTaskResumeAll+0xd0>
    1796:	aa cf       	rjmp	.-172    	; 0x16ec <xTaskResumeAll+0x24>
    1798:	f4 cf       	rjmp	.-24     	; 0x1782 <xTaskResumeAll+0xba>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	portEXIT_CRITICAL();
    179a:	0f 90       	pop	r0
    179c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    179e:	df 91       	pop	r29
    17a0:	cf 91       	pop	r28
    17a2:	1f 91       	pop	r17
    17a4:	0f 91       	pop	r16
    17a6:	ff 90       	pop	r15
    17a8:	ef 90       	pop	r14
    17aa:	08 95       	ret

000017ac <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    17ac:	80 91 4d 01 	lds	r24, 0x014D
    17b0:	88 23       	and	r24, r24
    17b2:	21 f0       	breq	.+8      	; 0x17bc <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    17b4:	81 e0       	ldi	r24, 0x01	; 1
    17b6:	80 93 4b 01 	sts	0x014B, r24
		return;
    17ba:	08 95       	ret

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    17bc:	99 e0       	ldi	r25, 0x09	; 9
    17be:	e0 91 4f 01 	lds	r30, 0x014F
    17c2:	9e 9f       	mul	r25, r30
    17c4:	f0 01       	movw	r30, r0
    17c6:	11 24       	eor	r1, r1
    17c8:	e4 58       	subi	r30, 0x84	; 132
    17ca:	fe 4f       	sbci	r31, 0xFE	; 254
    17cc:	80 81       	ld	r24, Z
    17ce:	81 11       	cpse	r24, r1
    17d0:	06 c0       	rjmp	.+12     	; 0x17de <vTaskSwitchContext+0x32>
	{
		--uxTopReadyPriority;
    17d2:	80 91 4f 01 	lds	r24, 0x014F
    17d6:	81 50       	subi	r24, 0x01	; 1
    17d8:	80 93 4f 01 	sts	0x014F, r24
    17dc:	f0 cf       	rjmp	.-32     	; 0x17be <vTaskSwitchContext+0x12>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    17de:	80 91 4f 01 	lds	r24, 0x014F
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	49 e0       	ldi	r20, 0x09	; 9
    17e6:	48 9f       	mul	r20, r24
    17e8:	90 01       	movw	r18, r0
    17ea:	49 9f       	mul	r20, r25
    17ec:	30 0d       	add	r19, r0
    17ee:	11 24       	eor	r1, r1
    17f0:	f9 01       	movw	r30, r18
    17f2:	e4 58       	subi	r30, 0x84	; 132
    17f4:	fe 4f       	sbci	r31, 0xFE	; 254
    17f6:	a1 81       	ldd	r26, Z+1	; 0x01
    17f8:	b2 81       	ldd	r27, Z+2	; 0x02
    17fa:	12 96       	adiw	r26, 0x02	; 2
    17fc:	0d 90       	ld	r0, X+
    17fe:	bc 91       	ld	r27, X
    1800:	a0 2d       	mov	r26, r0
    1802:	b2 83       	std	Z+2, r27	; 0x02
    1804:	a1 83       	std	Z+1, r26	; 0x01
    1806:	21 58       	subi	r18, 0x81	; 129
    1808:	3e 4f       	sbci	r19, 0xFE	; 254
    180a:	a2 17       	cp	r26, r18
    180c:	b3 07       	cpc	r27, r19
    180e:	31 f4       	brne	.+12     	; 0x181c <vTaskSwitchContext+0x70>
    1810:	12 96       	adiw	r26, 0x02	; 2
    1812:	2d 91       	ld	r18, X+
    1814:	3c 91       	ld	r19, X
    1816:	13 97       	sbiw	r26, 0x03	; 3
    1818:	32 83       	std	Z+2, r19	; 0x02
    181a:	21 83       	std	Z+1, r18	; 0x01
    181c:	29 e0       	ldi	r18, 0x09	; 9
    181e:	28 9f       	mul	r18, r24
    1820:	f0 01       	movw	r30, r0
    1822:	29 9f       	mul	r18, r25
    1824:	f0 0d       	add	r31, r0
    1826:	11 24       	eor	r1, r1
    1828:	e4 58       	subi	r30, 0x84	; 132
    182a:	fe 4f       	sbci	r31, 0xFE	; 254
    182c:	01 80       	ldd	r0, Z+1	; 0x01
    182e:	f2 81       	ldd	r31, Z+2	; 0x02
    1830:	e0 2d       	mov	r30, r0
    1832:	86 81       	ldd	r24, Z+6	; 0x06
    1834:	97 81       	ldd	r25, Z+7	; 0x07
    1836:	90 93 48 01 	sts	0x0148, r25
    183a:	80 93 47 01 	sts	0x0147, r24
    183e:	08 95       	ret

00001840 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1840:	cf 93       	push	r28
    1842:	df 93       	push	r29
    1844:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1846:	20 91 47 01 	lds	r18, 0x0147
    184a:	30 91 48 01 	lds	r19, 0x0148
    184e:	b9 01       	movw	r22, r18
    1850:	64 5f       	subi	r22, 0xF4	; 244
    1852:	7f 4f       	sbci	r23, 0xFF	; 255
    1854:	0e 94 dd 10 	call	0x21ba	; 0x21ba <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1858:	80 91 47 01 	lds	r24, 0x0147
    185c:	90 91 48 01 	lds	r25, 0x0148
    1860:	02 96       	adiw	r24, 0x02	; 2
    1862:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    1866:	cf 3f       	cpi	r28, 0xFF	; 255
    1868:	8f ef       	ldi	r24, 0xFF	; 255
    186a:	d8 07       	cpc	r29, r24
    186c:	61 f4       	brne	.+24     	; 0x1886 <vTaskPlaceOnEventList+0x46>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    186e:	60 91 47 01 	lds	r22, 0x0147
    1872:	70 91 48 01 	lds	r23, 0x0148
    1876:	6e 5f       	subi	r22, 0xFE	; 254
    1878:	7f 4f       	sbci	r23, 0xFF	; 255
    187a:	84 e5       	ldi	r24, 0x54	; 84
    187c:	91 e0       	ldi	r25, 0x01	; 1
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    187e:	df 91       	pop	r29
    1880:	cf 91       	pop	r28
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1882:	0c 94 ba 10 	jmp	0x2174	; 0x2174 <vListInsertEnd>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1886:	80 91 51 01 	lds	r24, 0x0151
    188a:	90 91 52 01 	lds	r25, 0x0152
    188e:	be 01       	movw	r22, r28
    1890:	68 0f       	add	r22, r24
    1892:	79 1f       	adc	r23, r25

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1894:	e0 91 47 01 	lds	r30, 0x0147
    1898:	f0 91 48 01 	lds	r31, 0x0148
    189c:	73 83       	std	Z+3, r23	; 0x03
    189e:	62 83       	std	Z+2, r22	; 0x02

			if( xTimeToWake < xTickCount )
    18a0:	80 91 51 01 	lds	r24, 0x0151
    18a4:	90 91 52 01 	lds	r25, 0x0152
    18a8:	68 17       	cp	r22, r24
    18aa:	79 07       	cpc	r23, r25
    18ac:	48 f4       	brcc	.+18     	; 0x18c0 <vTaskPlaceOnEventList+0x80>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    18ae:	60 91 47 01 	lds	r22, 0x0147
    18b2:	70 91 48 01 	lds	r23, 0x0148
    18b6:	80 91 66 01 	lds	r24, 0x0166
    18ba:	90 91 67 01 	lds	r25, 0x0167
    18be:	08 c0       	rjmp	.+16     	; 0x18d0 <vTaskPlaceOnEventList+0x90>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    18c0:	60 91 47 01 	lds	r22, 0x0147
    18c4:	70 91 48 01 	lds	r23, 0x0148
    18c8:	80 91 68 01 	lds	r24, 0x0168
    18cc:	90 91 69 01 	lds	r25, 0x0169
    18d0:	6e 5f       	subi	r22, 0xFE	; 254
    18d2:	7f 4f       	sbci	r23, 0xFF	; 255
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
    18d4:	df 91       	pop	r29
    18d6:	cf 91       	pop	r28
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    18d8:	0c 94 dd 10 	jmp	0x21ba	; 0x21ba <vListInsert>

000018dc <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    18dc:	0f 93       	push	r16
    18de:	1f 93       	push	r17
    18e0:	cf 93       	push	r28
    18e2:	df 93       	push	r29
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    18e4:	dc 01       	movw	r26, r24
    18e6:	2c 91       	ld	r18, X
    18e8:	22 23       	and	r18, r18
    18ea:	39 f0       	breq	.+14     	; 0x18fa <xTaskRemoveFromEventList+0x1e>
    18ec:	15 96       	adiw	r26, 0x05	; 5
    18ee:	ed 91       	ld	r30, X+
    18f0:	fc 91       	ld	r31, X
    18f2:	16 97       	sbiw	r26, 0x06	; 6
    18f4:	c6 81       	ldd	r28, Z+6	; 0x06
    18f6:	d7 81       	ldd	r29, Z+7	; 0x07
    18f8:	02 c0       	rjmp	.+4      	; 0x18fe <xTaskRemoveFromEventList+0x22>
    18fa:	c0 e0       	ldi	r28, 0x00	; 0
    18fc:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    18fe:	8e 01       	movw	r16, r28
    1900:	04 5f       	subi	r16, 0xF4	; 244
    1902:	1f 4f       	sbci	r17, 0xFF	; 255
    1904:	c8 01       	movw	r24, r16
    1906:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    190a:	80 91 4d 01 	lds	r24, 0x014D
    190e:	81 11       	cpse	r24, r1
    1910:	14 c0       	rjmp	.+40     	; 0x193a <xTaskRemoveFromEventList+0x5e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1912:	0a 50       	subi	r16, 0x0A	; 10
    1914:	11 09       	sbc	r17, r1
    1916:	c8 01       	movw	r24, r16
    1918:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    191c:	9e 89       	ldd	r25, Y+22	; 0x16
    191e:	80 91 4f 01 	lds	r24, 0x014F
    1922:	89 17       	cp	r24, r25
    1924:	10 f4       	brcc	.+4      	; 0x192a <xTaskRemoveFromEventList+0x4e>
    1926:	90 93 4f 01 	sts	0x014F, r25
    192a:	b9 e0       	ldi	r27, 0x09	; 9
    192c:	9b 9f       	mul	r25, r27
    192e:	c0 01       	movw	r24, r0
    1930:	11 24       	eor	r1, r1
    1932:	b8 01       	movw	r22, r16
    1934:	84 58       	subi	r24, 0x84	; 132
    1936:	9e 4f       	sbci	r25, 0xFE	; 254
    1938:	03 c0       	rjmp	.+6      	; 0x1940 <xTaskRemoveFromEventList+0x64>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    193a:	b8 01       	movw	r22, r16
    193c:	8d e5       	ldi	r24, 0x5D	; 93
    193e:	91 e0       	ldi	r25, 0x01	; 1
    1940:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1944:	e0 91 47 01 	lds	r30, 0x0147
    1948:	f0 91 48 01 	lds	r31, 0x0148
    194c:	81 e0       	ldi	r24, 0x01	; 1
    194e:	2e 89       	ldd	r18, Y+22	; 0x16
    1950:	96 89       	ldd	r25, Z+22	; 0x16
    1952:	29 17       	cp	r18, r25
    1954:	08 f4       	brcc	.+2      	; 0x1958 <xTaskRemoveFromEventList+0x7c>
    1956:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1958:	df 91       	pop	r29
    195a:	cf 91       	pop	r28
    195c:	1f 91       	pop	r17
    195e:	0f 91       	pop	r16
    1960:	08 95       	ret

00001962 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1962:	20 91 4a 01 	lds	r18, 0x014A
    1966:	fc 01       	movw	r30, r24
    1968:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    196a:	20 91 51 01 	lds	r18, 0x0151
    196e:	30 91 52 01 	lds	r19, 0x0152
    1972:	32 83       	std	Z+2, r19	; 0x02
    1974:	21 83       	std	Z+1, r18	; 0x01
    1976:	08 95       	ret

00001978 <xTaskCheckForTimeOut>:

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	f8 94       	cli
    197c:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    197e:	db 01       	movw	r26, r22
    1980:	2d 91       	ld	r18, X+
    1982:	3c 91       	ld	r19, X
    1984:	2f 3f       	cpi	r18, 0xFF	; 255
    1986:	bf ef       	ldi	r27, 0xFF	; 255
    1988:	3b 07       	cpc	r19, r27
    198a:	31 f1       	breq	.+76     	; 0x19d8 <xTaskCheckForTimeOut+0x60>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    198c:	50 91 4a 01 	lds	r21, 0x014A
    1990:	fc 01       	movw	r30, r24
    1992:	40 81       	ld	r20, Z
    1994:	01 80       	ldd	r0, Z+1	; 0x01
    1996:	f2 81       	ldd	r31, Z+2	; 0x02
    1998:	e0 2d       	mov	r30, r0
    199a:	54 17       	cp	r21, r20
    199c:	39 f0       	breq	.+14     	; 0x19ac <xTaskCheckForTimeOut+0x34>
    199e:	40 91 51 01 	lds	r20, 0x0151
    19a2:	50 91 52 01 	lds	r21, 0x0152
    19a6:	4e 17       	cp	r20, r30
    19a8:	5f 07       	cpc	r21, r31
    19aa:	c0 f4       	brcc	.+48     	; 0x19dc <xTaskCheckForTimeOut+0x64>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    19ac:	40 91 51 01 	lds	r20, 0x0151
    19b0:	50 91 52 01 	lds	r21, 0x0152
    19b4:	4e 1b       	sub	r20, r30
    19b6:	5f 0b       	sbc	r21, r31
    19b8:	42 17       	cp	r20, r18
    19ba:	53 07       	cpc	r21, r19
    19bc:	78 f4       	brcc	.+30     	; 0x19dc <xTaskCheckForTimeOut+0x64>
    19be:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    19c0:	40 91 51 01 	lds	r20, 0x0151
    19c4:	50 91 52 01 	lds	r21, 0x0152
    19c8:	4e 1b       	sub	r20, r30
    19ca:	5f 0b       	sbc	r21, r31
    19cc:	24 1b       	sub	r18, r20
    19ce:	35 0b       	sbc	r19, r21
    19d0:	2d 93       	st	X+, r18
    19d2:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    19d4:	0e 94 b1 0c 	call	0x1962	; 0x1962 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    19d8:	80 e0       	ldi	r24, 0x00	; 0
    19da:	01 c0       	rjmp	.+2      	; 0x19de <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    19dc:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    19de:	0f 90       	pop	r0
    19e0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    19e2:	08 95       	ret

000019e4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	80 93 4b 01 	sts	0x014B, r24
    19ea:	08 95       	ret

000019ec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    19ec:	cf 93       	push	r28
    19ee:	df 93       	push	r29
    19f0:	ec 01       	movw	r28, r24
    19f2:	94 2f       	mov	r25, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    19f4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    19f6:	88 23       	and	r24, r24
    19f8:	99 f1       	breq	.+102    	; 0x1a60 <prvCopyDataToQueue+0x74>
    19fa:	48 2f       	mov	r20, r24
    19fc:	50 e0       	ldi	r21, 0x00	; 0
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    19fe:	91 11       	cpse	r25, r1
    1a00:	15 c0       	rjmp	.+42     	; 0x1a2c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1a02:	8c 81       	ldd	r24, Y+4	; 0x04
    1a04:	9d 81       	ldd	r25, Y+5	; 0x05
    1a06:	0e 94 ca 14 	call	0x2994	; 0x2994 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1a0a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a0c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a0e:	9d 81       	ldd	r25, Y+5	; 0x05
    1a10:	82 0f       	add	r24, r18
    1a12:	91 1d       	adc	r25, r1
    1a14:	9d 83       	std	Y+5, r25	; 0x05
    1a16:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1a18:	2a 81       	ldd	r18, Y+2	; 0x02
    1a1a:	3b 81       	ldd	r19, Y+3	; 0x03
    1a1c:	82 17       	cp	r24, r18
    1a1e:	93 07       	cpc	r25, r19
    1a20:	f8 f0       	brcs	.+62     	; 0x1a60 <prvCopyDataToQueue+0x74>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1a22:	88 81       	ld	r24, Y
    1a24:	99 81       	ldd	r25, Y+1	; 0x01
    1a26:	9d 83       	std	Y+5, r25	; 0x05
    1a28:	8c 83       	std	Y+4, r24	; 0x04
    1a2a:	1a c0       	rjmp	.+52     	; 0x1a60 <prvCopyDataToQueue+0x74>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1a2c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a2e:	9f 81       	ldd	r25, Y+7	; 0x07
    1a30:	0e 94 ca 14 	call	0x2994	; 0x2994 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1a34:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	91 95       	neg	r25
    1a3a:	81 95       	neg	r24
    1a3c:	91 09       	sbc	r25, r1
    1a3e:	2e 81       	ldd	r18, Y+6	; 0x06
    1a40:	3f 81       	ldd	r19, Y+7	; 0x07
    1a42:	28 0f       	add	r18, r24
    1a44:	39 1f       	adc	r19, r25
    1a46:	3f 83       	std	Y+7, r19	; 0x07
    1a48:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1a4a:	48 81       	ld	r20, Y
    1a4c:	59 81       	ldd	r21, Y+1	; 0x01
    1a4e:	24 17       	cp	r18, r20
    1a50:	35 07       	cpc	r19, r21
    1a52:	30 f4       	brcc	.+12     	; 0x1a60 <prvCopyDataToQueue+0x74>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1a54:	2a 81       	ldd	r18, Y+2	; 0x02
    1a56:	3b 81       	ldd	r19, Y+3	; 0x03
    1a58:	82 0f       	add	r24, r18
    1a5a:	93 1f       	adc	r25, r19
    1a5c:	9f 83       	std	Y+7, r25	; 0x07
    1a5e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1a60:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a62:	8f 5f       	subi	r24, 0xFF	; 255
    1a64:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	08 95       	ret

00001a6c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	cb 01       	movw	r24, r22
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1a70:	a0 81       	ld	r26, Z
    1a72:	b1 81       	ldd	r27, Z+1	; 0x01
    1a74:	10 97       	sbiw	r26, 0x00	; 0
    1a76:	99 f0       	breq	.+38     	; 0x1a9e <prvCopyDataFromQueue+0x32>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1a78:	44 8d       	ldd	r20, Z+28	; 0x1c
    1a7a:	50 e0       	ldi	r21, 0x00	; 0
    1a7c:	26 81       	ldd	r18, Z+6	; 0x06
    1a7e:	37 81       	ldd	r19, Z+7	; 0x07
    1a80:	24 0f       	add	r18, r20
    1a82:	35 1f       	adc	r19, r21
    1a84:	37 83       	std	Z+7, r19	; 0x07
    1a86:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1a88:	62 81       	ldd	r22, Z+2	; 0x02
    1a8a:	73 81       	ldd	r23, Z+3	; 0x03
    1a8c:	26 17       	cp	r18, r22
    1a8e:	37 07       	cpc	r19, r23
    1a90:	10 f0       	brcs	.+4      	; 0x1a96 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1a92:	b7 83       	std	Z+7, r27	; 0x07
    1a94:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a96:	66 81       	ldd	r22, Z+6	; 0x06
    1a98:	77 81       	ldd	r23, Z+7	; 0x07
    1a9a:	0c 94 ca 14 	jmp	0x2994	; 0x2994 <memcpy>
    1a9e:	08 95       	ret

00001aa0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1aa0:	0f 93       	push	r16
    1aa2:	1f 93       	push	r17
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
    1aa8:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1aaa:	0f b6       	in	r0, 0x3f	; 63
    1aac:	f8 94       	cli
    1aae:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ab0:	8c 01       	movw	r16, r24
    1ab2:	0f 5e       	subi	r16, 0xEF	; 239
    1ab4:	1f 4f       	sbci	r17, 0xFF	; 255
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1ab6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1ab8:	19 16       	cp	r1, r25
    1aba:	6c f4       	brge	.+26     	; 0x1ad6 <prvUnlockQueue+0x36>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1abc:	89 89       	ldd	r24, Y+17	; 0x11
    1abe:	88 23       	and	r24, r24
    1ac0:	51 f0       	breq	.+20     	; 0x1ad6 <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ac2:	c8 01       	movw	r24, r16
    1ac4:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1ac8:	81 11       	cpse	r24, r1
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1aca:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1ace:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1ad0:	91 50       	subi	r25, 0x01	; 1
    1ad2:	9e 8f       	std	Y+30, r25	; 0x1e
    1ad4:	f0 cf       	rjmp	.-32     	; 0x1ab6 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1ad6:	8f ef       	ldi	r24, 0xFF	; 255
    1ad8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1ade:	0f b6       	in	r0, 0x3f	; 63
    1ae0:	f8 94       	cli
    1ae2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ae4:	8e 01       	movw	r16, r28
    1ae6:	08 5f       	subi	r16, 0xF8	; 248
    1ae8:	1f 4f       	sbci	r17, 0xFF	; 255
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1aea:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1aec:	19 16       	cp	r1, r25
    1aee:	6c f4       	brge	.+26     	; 0x1b0a <prvUnlockQueue+0x6a>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1af0:	88 85       	ldd	r24, Y+8	; 0x08
    1af2:	88 23       	and	r24, r24
    1af4:	51 f0       	breq	.+20     	; 0x1b0a <prvUnlockQueue+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1af6:	c8 01       	movw	r24, r16
    1af8:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1afc:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1afe:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1b02:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1b04:	91 50       	subi	r25, 0x01	; 1
    1b06:	9d 8f       	std	Y+29, r25	; 0x1d
    1b08:	f0 cf       	rjmp	.-32     	; 0x1aea <prvUnlockQueue+0x4a>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1b0a:	8f ef       	ldi	r24, 0xFF	; 255
    1b0c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1b0e:	0f 90       	pop	r0
    1b10:	0f be       	out	0x3f, r0	; 63
}
    1b12:	df 91       	pop	r29
    1b14:	cf 91       	pop	r28
    1b16:	1f 91       	pop	r17
    1b18:	0f 91       	pop	r16
    1b1a:	08 95       	ret

00001b1c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1b1c:	cf 92       	push	r12
    1b1e:	df 92       	push	r13
    1b20:	ef 92       	push	r14
    1b22:	ff 92       	push	r15
    1b24:	0f 93       	push	r16
    1b26:	1f 93       	push	r17
    1b28:	cf 93       	push	r28
    1b2a:	df 93       	push	r29
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1b2c:	88 23       	and	r24, r24
    1b2e:	b1 f1       	breq	.+108    	; 0x1b9c <xQueueCreate+0x80>
    1b30:	f6 2e       	mov	r15, r22
    1b32:	e8 2e       	mov	r14, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1b34:	8f e1       	ldi	r24, 0x1F	; 31
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	0e 94 02 13 	call	0x2604	; 0x2604 <pvPortMalloc>
    1b3c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1b3e:	89 2b       	or	r24, r25
    1b40:	69 f1       	breq	.+90     	; 0x1b9c <xQueueCreate+0x80>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1b42:	cf 2c       	mov	r12, r15
    1b44:	d1 2c       	mov	r13, r1
    1b46:	ef 9c       	mul	r14, r15
    1b48:	80 01       	movw	r16, r0
    1b4a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1b4c:	c8 01       	movw	r24, r16
    1b4e:	01 96       	adiw	r24, 0x01	; 1
    1b50:	0e 94 02 13 	call	0x2604	; 0x2604 <pvPortMalloc>
    1b54:	99 83       	std	Y+1, r25	; 0x01
    1b56:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1b58:	00 97       	sbiw	r24, 0x00	; 0
    1b5a:	e9 f0       	breq	.+58     	; 0x1b96 <xQueueCreate+0x7a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1b5c:	9c 01       	movw	r18, r24
    1b5e:	20 0f       	add	r18, r16
    1b60:	31 1f       	adc	r19, r17
    1b62:	3b 83       	std	Y+3, r19	; 0x03
    1b64:	2a 83       	std	Y+2, r18	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    1b66:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1b68:	9d 83       	std	Y+5, r25	; 0x05
    1b6a:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    1b6c:	0c 19       	sub	r16, r12
    1b6e:	1d 09       	sbc	r17, r13
    1b70:	08 0f       	add	r16, r24
    1b72:	19 1f       	adc	r17, r25
    1b74:	1f 83       	std	Y+7, r17	; 0x07
    1b76:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1b78:	eb 8e       	std	Y+27, r14	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1b7a:	fc 8e       	std	Y+28, r15	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1b7c:	8f ef       	ldi	r24, 0xFF	; 255
    1b7e:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1b80:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1b82:	ce 01       	movw	r24, r28
    1b84:	08 96       	adiw	r24, 0x08	; 8
    1b86:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	41 96       	adiw	r24, 0x11	; 17
    1b8e:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    1b92:	ce 01       	movw	r24, r28
    1b94:	05 c0       	rjmp	.+10     	; 0x1ba0 <xQueueCreate+0x84>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1b96:	ce 01       	movw	r24, r28
    1b98:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    1b9c:	80 e0       	ldi	r24, 0x00	; 0
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
}
    1ba0:	df 91       	pop	r29
    1ba2:	cf 91       	pop	r28
    1ba4:	1f 91       	pop	r17
    1ba6:	0f 91       	pop	r16
    1ba8:	ff 90       	pop	r15
    1baa:	ef 90       	pop	r14
    1bac:	df 90       	pop	r13
    1bae:	cf 90       	pop	r12
    1bb0:	08 95       	ret

00001bb2 <xQueueCreateExternal>:

xQueueHandle xQueueCreateExternal( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, void *address )
{
    1bb2:	ef 92       	push	r14
    1bb4:	ff 92       	push	r15
    1bb6:	0f 93       	push	r16
    1bb8:	1f 93       	push	r17
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    xQUEUE *pxNewQueue;
    //size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1bbe:	88 23       	and	r24, r24
    1bc0:	89 f1       	breq	.+98     	; 0x1c24 <xQueueCreateExternal+0x72>
    1bc2:	8a 01       	movw	r16, r20
    1bc4:	f6 2e       	mov	r15, r22
    1bc6:	e8 2e       	mov	r14, r24
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1bc8:	8f e1       	ldi	r24, 0x1F	; 31
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	0e 94 02 13 	call	0x2604	; 0x2604 <pvPortMalloc>
    1bd0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1bd2:	00 97       	sbiw	r24, 0x00	; 0
    1bd4:	39 f1       	breq	.+78     	; 0x1c24 <xQueueCreateExternal+0x72>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			//xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) (address);
    1bd6:	19 83       	std	Y+1, r17	; 0x01
    1bd8:	08 83       	st	Y, r16
			if( pxNewQueue->pcHead != NULL )
    1bda:	01 15       	cp	r16, r1
    1bdc:	11 05       	cpc	r17, r1
    1bde:	01 f1       	breq	.+64     	; 0x1c20 <xQueueCreateExternal+0x6e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1be0:	ef 9c       	mul	r14, r15
    1be2:	a0 01       	movw	r20, r0
    1be4:	11 24       	eor	r1, r1
    1be6:	c8 01       	movw	r24, r16
    1be8:	84 0f       	add	r24, r20
    1bea:	95 1f       	adc	r25, r21
    1bec:	9b 83       	std	Y+3, r25	; 0x03
    1bee:	8a 83       	std	Y+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    1bf0:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1bf2:	1d 83       	std	Y+5, r17	; 0x05
    1bf4:	0c 83       	std	Y+4, r16	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    1bf6:	4f 19       	sub	r20, r15
    1bf8:	51 09       	sbc	r21, r1
    1bfa:	04 0f       	add	r16, r20
    1bfc:	15 1f       	adc	r17, r21
    1bfe:	1f 83       	std	Y+7, r17	; 0x07
    1c00:	0e 83       	std	Y+6, r16	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1c02:	eb 8e       	std	Y+27, r14	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1c04:	fc 8e       	std	Y+28, r15	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1c06:	8f ef       	ldi	r24, 0xFF	; 255
    1c08:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1c0a:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1c0c:	ce 01       	movw	r24, r28
    1c0e:	08 96       	adiw	r24, 0x08	; 8
    1c10:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1c14:	ce 01       	movw	r24, r28
    1c16:	41 96       	adiw	r24, 0x11	; 17
    1c18:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    1c1c:	ce 01       	movw	r24, r28
    1c1e:	04 c0       	rjmp	.+8      	; 0x1c28 <xQueueCreateExternal+0x76>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1c20:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    1c24:	80 e0       	ldi	r24, 0x00	; 0
    1c26:	90 e0       	ldi	r25, 0x00	; 0
}
    1c28:	df 91       	pop	r29
    1c2a:	cf 91       	pop	r28
    1c2c:	1f 91       	pop	r17
    1c2e:	0f 91       	pop	r16
    1c30:	ff 90       	pop	r15
    1c32:	ef 90       	pop	r14
    1c34:	08 95       	ret

00001c36 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1c36:	af 92       	push	r10
    1c38:	bf 92       	push	r11
    1c3a:	df 92       	push	r13
    1c3c:	ef 92       	push	r14
    1c3e:	ff 92       	push	r15
    1c40:	0f 93       	push	r16
    1c42:	1f 93       	push	r17
    1c44:	cf 93       	push	r28
    1c46:	df 93       	push	r29
    1c48:	00 d0       	rcall	.+0      	; 0x1c4a <xQueueGenericSend+0x14>
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <xQueueGenericSend+0x16>
    1c4c:	1f 92       	push	r1
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
    1c52:	8c 01       	movw	r16, r24
    1c54:	7b 01       	movw	r14, r22
    1c56:	5d 83       	std	Y+5, r21	; 0x05
    1c58:	4c 83       	std	Y+4, r20	; 0x04
    1c5a:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1c5e:	58 01       	movw	r10, r16
    1c60:	88 e0       	ldi	r24, 0x08	; 8
    1c62:	a8 0e       	add	r10, r24
    1c64:	b1 1c       	adc	r11, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c66:	0f b6       	in	r0, 0x3f	; 63
    1c68:	f8 94       	cli
    1c6a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c6c:	f8 01       	movw	r30, r16
    1c6e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1c70:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c72:	28 17       	cp	r18, r24
    1c74:	a8 f4       	brcc	.+42     	; 0x1ca0 <xQueueGenericSend+0x6a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c76:	4d 2d       	mov	r20, r13
    1c78:	b7 01       	movw	r22, r14
    1c7a:	c8 01       	movw	r24, r16
    1c7c:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c80:	f8 01       	movw	r30, r16
    1c82:	81 89       	ldd	r24, Z+17	; 0x11
    1c84:	88 23       	and	r24, r24
    1c86:	41 f0       	breq	.+16     	; 0x1c98 <xQueueGenericSend+0x62>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1c88:	c8 01       	movw	r24, r16
    1c8a:	41 96       	adiw	r24, 0x11	; 17
    1c8c:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1c90:	81 30       	cpi	r24, 0x01	; 1
    1c92:	11 f4       	brne	.+4      	; 0x1c98 <xQueueGenericSend+0x62>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1c94:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1c98:	0f 90       	pop	r0
    1c9a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1c9c:	81 e0       	ldi	r24, 0x01	; 1
    1c9e:	50 c0       	rjmp	.+160    	; 0x1d40 <xQueueGenericSend+0x10a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ca0:	2c 81       	ldd	r18, Y+4	; 0x04
    1ca2:	3d 81       	ldd	r19, Y+5	; 0x05
    1ca4:	23 2b       	or	r18, r19
    1ca6:	19 f4       	brne	.+6      	; 0x1cae <xQueueGenericSend+0x78>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	48 c0       	rjmp	.+144    	; 0x1d3e <xQueueGenericSend+0x108>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1cae:	91 11       	cpse	r25, r1
    1cb0:	04 c0       	rjmp	.+8      	; 0x1cba <xQueueGenericSend+0x84>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1cb2:	ce 01       	movw	r24, r28
    1cb4:	01 96       	adiw	r24, 0x01	; 1
    1cb6:	0e 94 b1 0c 	call	0x1962	; 0x1962 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1cba:	0f 90       	pop	r0
    1cbc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1cbe:	0e 94 de 0a 	call	0x15bc	; 0x15bc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1cc2:	0f b6       	in	r0, 0x3f	; 63
    1cc4:	f8 94       	cli
    1cc6:	0f 92       	push	r0
    1cc8:	f8 01       	movw	r30, r16
    1cca:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ccc:	8f 3f       	cpi	r24, 0xFF	; 255
    1cce:	09 f4       	brne	.+2      	; 0x1cd2 <xQueueGenericSend+0x9c>
    1cd0:	15 8e       	std	Z+29, r1	; 0x1d
    1cd2:	f8 01       	movw	r30, r16
    1cd4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd6:	8f 3f       	cpi	r24, 0xFF	; 255
    1cd8:	09 f4       	brne	.+2      	; 0x1cdc <xQueueGenericSend+0xa6>
    1cda:	16 8e       	std	Z+30, r1	; 0x1e
    1cdc:	0f 90       	pop	r0
    1cde:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ce0:	be 01       	movw	r22, r28
    1ce2:	6c 5f       	subi	r22, 0xFC	; 252
    1ce4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce6:	ce 01       	movw	r24, r28
    1ce8:	01 96       	adiw	r24, 0x01	; 1
    1cea:	0e 94 bc 0c 	call	0x1978	; 0x1978 <xTaskCheckForTimeOut>
    1cee:	81 11       	cpse	r24, r1
    1cf0:	21 c0       	rjmp	.+66     	; 0x1d34 <xQueueGenericSend+0xfe>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1cf8:	f8 01       	movw	r30, r16
    1cfa:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
    1d00:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d02:	98 13       	cpse	r25, r24
    1d04:	11 c0       	rjmp	.+34     	; 0x1d28 <xQueueGenericSend+0xf2>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d06:	6c 81       	ldd	r22, Y+4	; 0x04
    1d08:	7d 81       	ldd	r23, Y+5	; 0x05
    1d0a:	c5 01       	movw	r24, r10
    1d0c:	0e 94 20 0c 	call	0x1840	; 0x1840 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d10:	c8 01       	movw	r24, r16
    1d12:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    1d16:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>
    1d1a:	88 23       	and	r24, r24
    1d1c:	11 f0       	breq	.+4      	; 0x1d22 <xQueueGenericSend+0xec>
    1d1e:	91 e0       	ldi	r25, 0x01	; 1
    1d20:	a2 cf       	rjmp	.-188    	; 0x1c66 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1d22:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
    1d26:	fb cf       	rjmp	.-10     	; 0x1d1e <xQueueGenericSend+0xe8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d28:	c8 01       	movw	r24, r16
    1d2a:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d2e:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>
    1d32:	f5 cf       	rjmp	.-22     	; 0x1d1e <xQueueGenericSend+0xe8>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d34:	c8 01       	movw	r24, r16
    1d36:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d3a:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d3e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1d40:	0f 90       	pop	r0
    1d42:	0f 90       	pop	r0
    1d44:	0f 90       	pop	r0
    1d46:	0f 90       	pop	r0
    1d48:	0f 90       	pop	r0
    1d4a:	df 91       	pop	r29
    1d4c:	cf 91       	pop	r28
    1d4e:	1f 91       	pop	r17
    1d50:	0f 91       	pop	r16
    1d52:	ff 90       	pop	r15
    1d54:	ef 90       	pop	r14
    1d56:	df 90       	pop	r13
    1d58:	bf 90       	pop	r11
    1d5a:	af 90       	pop	r10
    1d5c:	08 95       	ret

00001d5e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1d5e:	0f 93       	push	r16
    1d60:	1f 93       	push	r17
    1d62:	cf 93       	push	r28
    1d64:	df 93       	push	r29
    1d66:	ec 01       	movw	r28, r24
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d68:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d6a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d6c:	98 17       	cp	r25, r24
    1d6e:	c8 f4       	brcc	.+50     	; 0x1da2 <xQueueGenericSendFromISR+0x44>
    1d70:	8a 01       	movw	r16, r20
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d72:	42 2f       	mov	r20, r18
    1d74:	ce 01       	movw	r24, r28
    1d76:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1d7a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d7c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d7e:	69 f4       	brne	.+26     	; 0x1d9a <xQueueGenericSendFromISR+0x3c>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1d80:	89 89       	ldd	r24, Y+17	; 0x11
    1d82:	88 23       	and	r24, r24
    1d84:	61 f0       	breq	.+24     	; 0x1d9e <xQueueGenericSendFromISR+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d86:	ce 01       	movw	r24, r28
    1d88:	41 96       	adiw	r24, 0x11	; 17
    1d8a:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1d8e:	88 23       	and	r24, r24
    1d90:	31 f0       	breq	.+12     	; 0x1d9e <xQueueGenericSendFromISR+0x40>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	f8 01       	movw	r30, r16
    1d96:	80 83       	st	Z, r24
    1d98:	05 c0       	rjmp	.+10     	; 0x1da4 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1d9a:	8f 5f       	subi	r24, 0xFF	; 255
    1d9c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	01 c0       	rjmp	.+2      	; 0x1da4 <xQueueGenericSendFromISR+0x46>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1da2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1da4:	df 91       	pop	r29
    1da6:	cf 91       	pop	r28
    1da8:	1f 91       	pop	r17
    1daa:	0f 91       	pop	r16
    1dac:	08 95       	ret

00001dae <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1dae:	af 92       	push	r10
    1db0:	bf 92       	push	r11
    1db2:	df 92       	push	r13
    1db4:	ef 92       	push	r14
    1db6:	ff 92       	push	r15
    1db8:	0f 93       	push	r16
    1dba:	1f 93       	push	r17
    1dbc:	cf 93       	push	r28
    1dbe:	df 93       	push	r29
    1dc0:	00 d0       	rcall	.+0      	; 0x1dc2 <xQueueGenericReceive+0x14>
    1dc2:	00 d0       	rcall	.+0      	; 0x1dc4 <xQueueGenericReceive+0x16>
    1dc4:	1f 92       	push	r1
    1dc6:	cd b7       	in	r28, 0x3d	; 61
    1dc8:	de b7       	in	r29, 0x3e	; 62
    1dca:	8c 01       	movw	r16, r24
    1dcc:	7b 01       	movw	r14, r22
    1dce:	5d 83       	std	Y+5, r21	; 0x05
    1dd0:	4c 83       	std	Y+4, r20	; 0x04
    1dd2:	d2 2e       	mov	r13, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1dd4:	90 e0       	ldi	r25, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1dd6:	58 01       	movw	r10, r16
    1dd8:	81 e1       	ldi	r24, 0x11	; 17
    1dda:	a8 0e       	add	r10, r24
    1ddc:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1dde:	0f b6       	in	r0, 0x3f	; 63
    1de0:	f8 94       	cli
    1de2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1de4:	f8 01       	movw	r30, r16
    1de6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1de8:	88 23       	and	r24, r24
    1dea:	39 f1       	breq	.+78     	; 0x1e3a <xQueueGenericReceive+0x8c>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1dec:	a6 80       	ldd	r10, Z+6	; 0x06
    1dee:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1df0:	b7 01       	movw	r22, r14
    1df2:	c8 01       	movw	r24, r16
    1df4:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1df8:	f8 01       	movw	r30, r16
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1dfa:	d1 10       	cpse	r13, r1
    1dfc:	0f c0       	rjmp	.+30     	; 0x1e1c <xQueueGenericReceive+0x6e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1dfe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e00:	81 50       	subi	r24, 0x01	; 1
    1e02:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e04:	80 85       	ldd	r24, Z+8	; 0x08
    1e06:	88 23       	and	r24, r24
    1e08:	a1 f0       	breq	.+40     	; 0x1e32 <xQueueGenericReceive+0x84>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1e0a:	c8 01       	movw	r24, r16
    1e0c:	08 96       	adiw	r24, 0x08	; 8
    1e0e:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1e12:	81 30       	cpi	r24, 0x01	; 1
    1e14:	71 f4       	brne	.+28     	; 0x1e32 <xQueueGenericReceive+0x84>
						{
							portYIELD_WITHIN_API();
    1e16:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
    1e1a:	0b c0       	rjmp	.+22     	; 0x1e32 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1e1c:	b7 82       	std	Z+7, r11	; 0x07
    1e1e:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1e20:	81 89       	ldd	r24, Z+17	; 0x11
    1e22:	88 23       	and	r24, r24
    1e24:	31 f0       	breq	.+12     	; 0x1e32 <xQueueGenericReceive+0x84>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e26:	c8 01       	movw	r24, r16
    1e28:	41 96       	adiw	r24, 0x11	; 17
    1e2a:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1e2e:	81 11       	cpse	r24, r1
    1e30:	f2 cf       	rjmp	.-28     	; 0x1e16 <xQueueGenericReceive+0x68>
						}
					}

				}

				taskEXIT_CRITICAL();
    1e32:	0f 90       	pop	r0
    1e34:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e36:	81 e0       	ldi	r24, 0x01	; 1
    1e38:	4f c0       	rjmp	.+158    	; 0x1ed8 <xQueueGenericReceive+0x12a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1e3a:	2c 81       	ldd	r18, Y+4	; 0x04
    1e3c:	3d 81       	ldd	r19, Y+5	; 0x05
    1e3e:	23 2b       	or	r18, r19
    1e40:	19 f4       	brne	.+6      	; 0x1e48 <xQueueGenericReceive+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e42:	0f 90       	pop	r0
    1e44:	0f be       	out	0x3f, r0	; 63
    1e46:	47 c0       	rjmp	.+142    	; 0x1ed6 <xQueueGenericReceive+0x128>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1e48:	91 11       	cpse	r25, r1
    1e4a:	04 c0       	rjmp	.+8      	; 0x1e54 <xQueueGenericReceive+0xa6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e4c:	ce 01       	movw	r24, r28
    1e4e:	01 96       	adiw	r24, 0x01	; 1
    1e50:	0e 94 b1 0c 	call	0x1962	; 0x1962 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1e54:	0f 90       	pop	r0
    1e56:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e58:	0e 94 de 0a 	call	0x15bc	; 0x15bc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	0f 92       	push	r0
    1e62:	f8 01       	movw	r30, r16
    1e64:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e66:	8f 3f       	cpi	r24, 0xFF	; 255
    1e68:	09 f4       	brne	.+2      	; 0x1e6c <xQueueGenericReceive+0xbe>
    1e6a:	15 8e       	std	Z+29, r1	; 0x1d
    1e6c:	f8 01       	movw	r30, r16
    1e6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e70:	8f 3f       	cpi	r24, 0xFF	; 255
    1e72:	09 f4       	brne	.+2      	; 0x1e76 <xQueueGenericReceive+0xc8>
    1e74:	16 8e       	std	Z+30, r1	; 0x1e
    1e76:	0f 90       	pop	r0
    1e78:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e7a:	be 01       	movw	r22, r28
    1e7c:	6c 5f       	subi	r22, 0xFC	; 252
    1e7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e80:	ce 01       	movw	r24, r28
    1e82:	01 96       	adiw	r24, 0x01	; 1
    1e84:	0e 94 bc 0c 	call	0x1978	; 0x1978 <xTaskCheckForTimeOut>
    1e88:	81 11       	cpse	r24, r1
    1e8a:	20 c0       	rjmp	.+64     	; 0x1ecc <xQueueGenericReceive+0x11e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1e8c:	0f b6       	in	r0, 0x3f	; 63
    1e8e:	f8 94       	cli
    1e90:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1e92:	f8 01       	movw	r30, r16
    1e94:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1e96:	0f 90       	pop	r0
    1e98:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
    1e9a:	81 11       	cpse	r24, r1
    1e9c:	11 c0       	rjmp	.+34     	; 0x1ec0 <xQueueGenericReceive+0x112>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e9e:	6c 81       	ldd	r22, Y+4	; 0x04
    1ea0:	7d 81       	ldd	r23, Y+5	; 0x05
    1ea2:	c5 01       	movw	r24, r10
    1ea4:	0e 94 20 0c 	call	0x1840	; 0x1840 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ea8:	c8 01       	movw	r24, r16
    1eaa:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <prvUnlockQueue>
				if( !xTaskResumeAll() )
    1eae:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>
    1eb2:	88 23       	and	r24, r24
    1eb4:	11 f0       	breq	.+4      	; 0x1eba <xQueueGenericReceive+0x10c>
    1eb6:	91 e0       	ldi	r25, 0x01	; 1
    1eb8:	92 cf       	rjmp	.-220    	; 0x1dde <xQueueGenericReceive+0x30>
				{
					portYIELD_WITHIN_API();
    1eba:	0e 94 df 13 	call	0x27be	; 0x27be <vPortYield>
    1ebe:	fb cf       	rjmp	.-10     	; 0x1eb6 <xQueueGenericReceive+0x108>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ec0:	c8 01       	movw	r24, r16
    1ec2:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1ec6:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>
    1eca:	f5 cf       	rjmp	.-22     	; 0x1eb6 <xQueueGenericReceive+0x108>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ecc:	c8 01       	movw	r24, r16
    1ece:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ed2:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1ed6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1ed8:	0f 90       	pop	r0
    1eda:	0f 90       	pop	r0
    1edc:	0f 90       	pop	r0
    1ede:	0f 90       	pop	r0
    1ee0:	0f 90       	pop	r0
    1ee2:	df 91       	pop	r29
    1ee4:	cf 91       	pop	r28
    1ee6:	1f 91       	pop	r17
    1ee8:	0f 91       	pop	r16
    1eea:	ff 90       	pop	r15
    1eec:	ef 90       	pop	r14
    1eee:	df 90       	pop	r13
    1ef0:	bf 90       	pop	r11
    1ef2:	af 90       	pop	r10
    1ef4:	08 95       	ret

00001ef6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1ef6:	0f 93       	push	r16
    1ef8:	1f 93       	push	r17
    1efa:	cf 93       	push	r28
    1efc:	df 93       	push	r29
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1efe:	fc 01       	movw	r30, r24
    1f00:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f02:	22 23       	and	r18, r18
    1f04:	d9 f0       	breq	.+54     	; 0x1f3c <xQueueReceiveFromISR+0x46>
    1f06:	8a 01       	movw	r16, r20
    1f08:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f0a:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1f0e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f10:	81 50       	subi	r24, 0x01	; 1
    1f12:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1f14:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1f16:	8f 3f       	cpi	r24, 0xFF	; 255
    1f18:	69 f4       	brne	.+26     	; 0x1f34 <xQueueReceiveFromISR+0x3e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1f1a:	88 85       	ldd	r24, Y+8	; 0x08
    1f1c:	88 23       	and	r24, r24
    1f1e:	61 f0       	breq	.+24     	; 0x1f38 <xQueueReceiveFromISR+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f20:	ce 01       	movw	r24, r28
    1f22:	08 96       	adiw	r24, 0x08	; 8
    1f24:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xTaskRemoveFromEventList>
    1f28:	88 23       	and	r24, r24
    1f2a:	31 f0       	breq	.+12     	; 0x1f38 <xQueueReceiveFromISR+0x42>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1f2c:	81 e0       	ldi	r24, 0x01	; 1
    1f2e:	f8 01       	movw	r30, r16
    1f30:	80 83       	st	Z, r24
    1f32:	05 c0       	rjmp	.+10     	; 0x1f3e <xQueueReceiveFromISR+0x48>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1f34:	8f 5f       	subi	r24, 0xFF	; 255
    1f36:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1f38:	81 e0       	ldi	r24, 0x01	; 1
    1f3a:	01 c0       	rjmp	.+2      	; 0x1f3e <xQueueReceiveFromISR+0x48>
		}
		else
		{
			xReturn = pdFAIL;
    1f3c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f3e:	df 91       	pop	r29
    1f40:	cf 91       	pop	r28
    1f42:	1f 91       	pop	r17
    1f44:	0f 91       	pop	r16
    1f46:	08 95       	ret

00001f48 <uxQueueMessagesWaiting>:

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    1f48:	0f b6       	in	r0, 0x3f	; 63
    1f4a:	f8 94       	cli
    1f4c:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1f4e:	fc 01       	movw	r30, r24
    1f50:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1f52:	0f 90       	pop	r0
    1f54:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1f56:	08 95       	ret

00001f58 <uxQueueMessagesWaitingFromISR>:

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1f58:	fc 01       	movw	r30, r24
    1f5a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1f5c:	08 95       	ret

00001f5e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1f5e:	cf 93       	push	r28
    1f60:	df 93       	push	r29
    1f62:	ec 01       	movw	r28, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1f64:	88 81       	ld	r24, Y
    1f66:	99 81       	ldd	r25, Y+1	; 0x01
    1f68:	0e 94 28 13 	call	0x2650	; 0x2650 <vPortFree>
	vPortFree( pxQueue );
    1f6c:	ce 01       	movw	r24, r28
}
    1f6e:	df 91       	pop	r29
    1f70:	cf 91       	pop	r28
void vQueueDelete( xQueueHandle pxQueue )
{
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
    1f72:	0c 94 28 13 	jmp	0x2650	; 0x2650 <vPortFree>

00001f76 <xQueueIsQueueEmptyFromISR>:

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1f76:	fc 01       	movw	r30, r24
    1f78:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f7a:	81 e0       	ldi	r24, 0x01	; 1
    1f7c:	91 11       	cpse	r25, r1
    1f7e:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1f80:	08 95       	ret

00001f82 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1f82:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1f84:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	93 8d       	ldd	r25, Z+27	; 0x1b
    1f8a:	29 13       	cpse	r18, r25
    1f8c:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    1f8e:	08 95       	ret

00001f90 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
{
    1f90:	cf 93       	push	r28
    1f92:	df 93       	push	r29
    1f94:	ec 01       	movw	r28, r24
signed portBASE_TYPE xReturn;

	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    1f96:	f8 94       	cli

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1f98:	0f b6       	in	r0, 0x3f	; 63
    1f9a:	f8 94       	cli
    1f9c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1f9e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fa0:	9b 8d       	ldd	r25, Y+27	; 0x1b
	taskEXIT_CRITICAL();
    1fa2:	0f 90       	pop	r0
    1fa4:	0f be       	out	0x3f, r0	; 63
	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
	{
		if( prvIsQueueFull( pxQueue ) )
    1fa6:	89 13       	cpse	r24, r25
    1fa8:	0f c0       	rjmp	.+30     	; 0x1fc8 <xQueueCRSend+0x38>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
    1faa:	41 15       	cp	r20, r1
    1fac:	51 05       	cpc	r21, r1
    1fae:	49 f0       	breq	.+18     	; 0x1fc2 <xQueueCRSend+0x32>
			{
				/* As this is called from a coroutine we cannot block directly, but
				return indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1fb0:	be 01       	movw	r22, r28
    1fb2:	68 5f       	subi	r22, 0xF8	; 248
    1fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fb6:	ca 01       	movw	r24, r20
    1fb8:	0e 94 9f 11 	call	0x233e	; 0x233e <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    1fbc:	78 94       	sei
				return errQUEUE_BLOCKED;
    1fbe:	8c ef       	ldi	r24, 0xFC	; 252
    1fc0:	1c c0       	rjmp	.+56     	; 0x1ffa <xQueueCRSend+0x6a>
			}
			else
			{
				portENABLE_INTERRUPTS();
    1fc2:	78 94       	sei
				return errQUEUE_FULL;
    1fc4:	80 e0       	ldi	r24, 0x00	; 0
    1fc6:	19 c0       	rjmp	.+50     	; 0x1ffa <xQueueCRSend+0x6a>
			}
		}
	}
	portENABLE_INTERRUPTS();
    1fc8:	78 94       	sei

	portNOP();
    1fca:	00 00       	nop

	portDISABLE_INTERRUPTS();
    1fcc:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1fce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fd0:	89 17       	cp	r24, r25
    1fd2:	88 f4       	brcc	.+34     	; 0x1ff6 <xQueueCRSend+0x66>
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1fd4:	40 e0       	ldi	r20, 0x00	; 0
    1fd6:	ce 01       	movw	r24, r28
    1fd8:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <prvCopyDataToQueue>
			xReturn = pdPASS;

			/* Were any co-routines waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1fdc:	89 89       	ldd	r24, Y+17	; 0x11
    1fde:	81 11       	cpse	r24, r1
    1fe0:	02 c0       	rjmp	.+4      	; 0x1fe6 <xQueueCRSend+0x56>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
			xReturn = pdPASS;
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	09 c0       	rjmp	.+18     	; 0x1ff8 <xQueueCRSend+0x68>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fe6:	ce 01       	movw	r24, r28
    1fe8:	41 96       	adiw	r24, 0x11	; 17
    1fea:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xCoRoutineRemoveFromEventList>
    1fee:	88 23       	and	r24, r24
    1ff0:	c1 f3       	breq	.-16     	; 0x1fe2 <xQueueCRSend+0x52>
				{
					/* The co-routine waiting has a higher priority so record
					that a yield might be appropriate. */
					xReturn = errQUEUE_YIELD;
    1ff2:	8b ef       	ldi	r24, 0xFB	; 251
    1ff4:	01 c0       	rjmp	.+2      	; 0x1ff8 <xQueueCRSend+0x68>
				}
			}
		}
		else
		{
			xReturn = errQUEUE_FULL;
    1ff6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portENABLE_INTERRUPTS();
    1ff8:	78 94       	sei

	return xReturn;
}
    1ffa:	df 91       	pop	r29
    1ffc:	cf 91       	pop	r28
    1ffe:	08 95       	ret

00002000 <xQueueCRReceive>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
{
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
    2004:	ec 01       	movw	r28, r24
    2006:	fb 01       	movw	r30, r22
signed portBASE_TYPE xReturn;

	/* If the queue is already empty we may have to block.  A critical section
	is required to prevent an interrupt adding something to the queue
	between the check to see if the queue is empty and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    2008:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    200a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    200c:	81 11       	cpse	r24, r1
    200e:	0f c0       	rjmp	.+30     	; 0x202e <xQueueCRReceive+0x2e>
		{
			/* There are no messages in the queue, do we want to block or just
			leave with nothing? */
			if( xTicksToWait > ( portTickType ) 0 )
    2010:	41 15       	cp	r20, r1
    2012:	51 05       	cpc	r21, r1
    2014:	49 f0       	breq	.+18     	; 0x2028 <xQueueCRReceive+0x28>
			{
				/* As this is a co-routine we cannot block directly, but return
				indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2016:	be 01       	movw	r22, r28
    2018:	6f 5e       	subi	r22, 0xEF	; 239
    201a:	7f 4f       	sbci	r23, 0xFF	; 255
    201c:	ca 01       	movw	r24, r20
    201e:	0e 94 9f 11 	call	0x233e	; 0x233e <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    2022:	78 94       	sei
				return errQUEUE_BLOCKED;
    2024:	8c ef       	ldi	r24, 0xFC	; 252
    2026:	31 c0       	rjmp	.+98     	; 0x208a <xQueueCRReceive+0x8a>
			}
			else
			{
				portENABLE_INTERRUPTS();
    2028:	78 94       	sei
				return errQUEUE_FULL;
    202a:	80 e0       	ldi	r24, 0x00	; 0
    202c:	2e c0       	rjmp	.+92     	; 0x208a <xQueueCRReceive+0x8a>
			}
		}
	}
	portENABLE_INTERRUPTS();
    202e:	78 94       	sei

	portNOP();
    2030:	00 00       	nop

	portDISABLE_INTERRUPTS();
    2032:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2034:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2036:	88 23       	and	r24, r24
    2038:	31 f1       	breq	.+76     	; 0x2086 <xQueueCRReceive+0x86>
		{
			/* Data is available from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
    203a:	4c 8d       	ldd	r20, Y+28	; 0x1c
    203c:	50 e0       	ldi	r21, 0x00	; 0
    203e:	2e 81       	ldd	r18, Y+6	; 0x06
    2040:	3f 81       	ldd	r19, Y+7	; 0x07
    2042:	24 0f       	add	r18, r20
    2044:	35 1f       	adc	r19, r21
    2046:	3f 83       	std	Y+7, r19	; 0x07
    2048:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    204a:	8a 81       	ldd	r24, Y+2	; 0x02
    204c:	9b 81       	ldd	r25, Y+3	; 0x03
    204e:	28 17       	cp	r18, r24
    2050:	39 07       	cpc	r19, r25
    2052:	20 f0       	brcs	.+8      	; 0x205c <xQueueCRReceive+0x5c>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
    2054:	88 81       	ld	r24, Y
    2056:	99 81       	ldd	r25, Y+1	; 0x01
    2058:	9f 83       	std	Y+7, r25	; 0x07
    205a:	8e 83       	std	Y+6, r24	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    205c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    205e:	91 50       	subi	r25, 0x01	; 1
    2060:	9a 8f       	std	Y+26, r25	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2062:	6e 81       	ldd	r22, Y+6	; 0x06
    2064:	7f 81       	ldd	r23, Y+7	; 0x07
    2066:	cf 01       	movw	r24, r30
    2068:	0e 94 ca 14 	call	0x2994	; 0x2994 <memcpy>

			xReturn = pdPASS;

			/* Were any co-routines waiting for space to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    206c:	88 85       	ldd	r24, Y+8	; 0x08
    206e:	81 11       	cpse	r24, r1
    2070:	02 c0       	rjmp	.+4      	; 0x2076 <xQueueCRReceive+0x76>
				pxQueue->pcReadFrom = pxQueue->pcHead;
			}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			xReturn = pdPASS;
    2072:	81 e0       	ldi	r24, 0x01	; 1
    2074:	09 c0       	rjmp	.+18     	; 0x2088 <xQueueCRReceive+0x88>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2076:	ce 01       	movw	r24, r28
    2078:	08 96       	adiw	r24, 0x08	; 8
    207a:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xCoRoutineRemoveFromEventList>
    207e:	88 23       	and	r24, r24
    2080:	c1 f3       	breq	.-16     	; 0x2072 <xQueueCRReceive+0x72>
				{
					xReturn = errQUEUE_YIELD;
    2082:	8b ef       	ldi	r24, 0xFB	; 251
    2084:	01 c0       	rjmp	.+2      	; 0x2088 <xQueueCRReceive+0x88>
				}
			}
		}
		else
		{
			xReturn = pdFAIL;
    2086:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portENABLE_INTERRUPTS();
    2088:	78 94       	sei

	return xReturn;
}
    208a:	df 91       	pop	r29
    208c:	cf 91       	pop	r28
    208e:	08 95       	ret

00002090 <xQueueCRSendFromISR>:



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
{
    2090:	0f 93       	push	r16
    2092:	1f 93       	push	r17
    2094:	cf 93       	push	r28
    2096:	8c 01       	movw	r16, r24
    2098:	c4 2f       	mov	r28, r20
	/* Cannot block within an ISR so if there is no space on the queue then
	exit without doing anything. */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    209a:	fc 01       	movw	r30, r24
    209c:	92 8d       	ldd	r25, Z+26	; 0x1a
    209e:	83 8d       	ldd	r24, Z+27	; 0x1b
    20a0:	98 17       	cp	r25, r24
    20a2:	10 f0       	brcs	.+4      	; 0x20a8 <xQueueCRSendFromISR+0x18>
    20a4:	4c 2f       	mov	r20, r28
    20a6:	12 c0       	rjmp	.+36     	; 0x20cc <xQueueCRSendFromISR+0x3c>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    20a8:	40 e0       	ldi	r20, 0x00	; 0
    20aa:	c8 01       	movw	r24, r16
    20ac:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <prvCopyDataToQueue>

		/* We only want to wake one co-routine per ISR, so check that a
		co-routine has not already been woken. */
		if( !xCoRoutinePreviouslyWoken )
    20b0:	c1 11       	cpse	r28, r1
    20b2:	f8 cf       	rjmp	.-16     	; 0x20a4 <xQueueCRSendFromISR+0x14>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    20b4:	f8 01       	movw	r30, r16
    20b6:	81 89       	ldd	r24, Z+17	; 0x11
    20b8:	88 23       	and	r24, r24
    20ba:	39 f0       	breq	.+14     	; 0x20ca <xQueueCRSendFromISR+0x3a>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20bc:	c8 01       	movw	r24, r16
    20be:	41 96       	adiw	r24, 0x11	; 17
    20c0:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xCoRoutineRemoveFromEventList>
    20c4:	41 e0       	ldi	r20, 0x01	; 1
    20c6:	81 11       	cpse	r24, r1
    20c8:	01 c0       	rjmp	.+2      	; 0x20cc <xQueueCRSendFromISR+0x3c>
    20ca:	40 e0       	ldi	r20, 0x00	; 0
			}
		}
	}

	return xCoRoutinePreviouslyWoken;
}
    20cc:	84 2f       	mov	r24, r20
    20ce:	cf 91       	pop	r28
    20d0:	1f 91       	pop	r17
    20d2:	0f 91       	pop	r16
    20d4:	08 95       	ret

000020d6 <xQueueCRReceiveFromISR>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
{
    20d6:	0f 93       	push	r16
    20d8:	1f 93       	push	r17
    20da:	cf 93       	push	r28
    20dc:	df 93       	push	r29
    20de:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. If
	not then just leave without doing anything. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    20e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20e2:	88 23       	and	r24, r24
    20e4:	79 f1       	breq	.+94     	; 0x2144 <xQueueCRReceiveFromISR+0x6e>
	{
		/* Copy the data from the queue. */
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    20e6:	24 8d       	ldd	r18, Z+28	; 0x1c
    20e8:	30 e0       	ldi	r19, 0x00	; 0
    20ea:	a6 81       	ldd	r26, Z+6	; 0x06
    20ec:	b7 81       	ldd	r27, Z+7	; 0x07
    20ee:	a2 0f       	add	r26, r18
    20f0:	b3 1f       	adc	r27, r19
    20f2:	b7 83       	std	Z+7, r27	; 0x07
    20f4:	a6 83       	std	Z+6, r26	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    20f6:	82 81       	ldd	r24, Z+2	; 0x02
    20f8:	93 81       	ldd	r25, Z+3	; 0x03
    20fa:	a8 17       	cp	r26, r24
    20fc:	b9 07       	cpc	r27, r25
    20fe:	20 f0       	brcs	.+8      	; 0x2108 <xQueueCRReceiveFromISR+0x32>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2100:	80 81       	ld	r24, Z
    2102:	91 81       	ldd	r25, Z+1	; 0x01
    2104:	97 83       	std	Z+7, r25	; 0x07
    2106:	86 83       	std	Z+6, r24	; 0x06
    2108:	8a 01       	movw	r16, r20
    210a:	cb 01       	movw	r24, r22
    210c:	ef 01       	movw	r28, r30
		}
		--( pxQueue->uxMessagesWaiting );
    210e:	42 8d       	ldd	r20, Z+26	; 0x1a
    2110:	41 50       	subi	r20, 0x01	; 1
    2112:	42 8f       	std	Z+26, r20	; 0x1a
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2114:	66 81       	ldd	r22, Z+6	; 0x06
    2116:	77 81       	ldd	r23, Z+7	; 0x07
    2118:	a9 01       	movw	r20, r18
    211a:	0e 94 ca 14 	call	0x2994	; 0x2994 <memcpy>

		if( !( *pxCoRoutineWoken ) )
    211e:	f8 01       	movw	r30, r16
    2120:	80 81       	ld	r24, Z
    2122:	88 23       	and	r24, r24
    2124:	11 f0       	breq	.+4      	; 0x212a <xQueueCRReceiveFromISR+0x54>
					*pxCoRoutineWoken = pdTRUE;
				}
			}
		}

		xReturn = pdPASS;
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	0e c0       	rjmp	.+28     	; 0x2146 <xQueueCRReceiveFromISR+0x70>
		--( pxQueue->uxMessagesWaiting );
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

		if( !( *pxCoRoutineWoken ) )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    212a:	88 85       	ldd	r24, Y+8	; 0x08
    212c:	88 23       	and	r24, r24
    212e:	d9 f3       	breq	.-10     	; 0x2126 <xQueueCRReceiveFromISR+0x50>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2130:	ce 01       	movw	r24, r28
    2132:	08 96       	adiw	r24, 0x08	; 8
    2134:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xCoRoutineRemoveFromEventList>
    2138:	88 23       	and	r24, r24
    213a:	a9 f3       	breq	.-22     	; 0x2126 <xQueueCRReceiveFromISR+0x50>
				{
					*pxCoRoutineWoken = pdTRUE;
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	f8 01       	movw	r30, r16
    2140:	80 83       	st	Z, r24
    2142:	01 c0       	rjmp	.+2      	; 0x2146 <xQueueCRReceiveFromISR+0x70>

		xReturn = pdPASS;
	}
	else
	{
		xReturn = pdFAIL;
    2144:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2146:	df 91       	pop	r29
    2148:	cf 91       	pop	r28
    214a:	1f 91       	pop	r17
    214c:	0f 91       	pop	r16
    214e:	08 95       	ret

00002150 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2150:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2152:	03 96       	adiw	r24, 0x03	; 3
    2154:	92 83       	std	Z+2, r25	; 0x02
    2156:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2158:	2f ef       	ldi	r18, 0xFF	; 255
    215a:	3f ef       	ldi	r19, 0xFF	; 255
    215c:	34 83       	std	Z+4, r19	; 0x04
    215e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2160:	96 83       	std	Z+6, r25	; 0x06
    2162:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2164:	90 87       	std	Z+8, r25	; 0x08
    2166:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = 0;
    2168:	10 82       	st	Z, r1
    216a:	08 95       	ret

0000216c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    216c:	fc 01       	movw	r30, r24
    216e:	11 86       	std	Z+9, r1	; 0x09
    2170:	10 86       	std	Z+8, r1	; 0x08
    2172:	08 95       	ret

00002174 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2174:	cf 93       	push	r28
    2176:	df 93       	push	r29
    2178:	dc 01       	movw	r26, r24
    217a:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    217c:	11 96       	adiw	r26, 0x01	; 1
    217e:	2d 91       	ld	r18, X+
    2180:	3c 91       	ld	r19, X
    2182:	12 97       	sbiw	r26, 0x02	; 2

	pxNewListItem->pxNext = pxIndex->pxNext;
    2184:	e9 01       	movw	r28, r18
    2186:	8a 81       	ldd	r24, Y+2	; 0x02
    2188:	9b 81       	ldd	r25, Y+3	; 0x03
    218a:	93 83       	std	Z+3, r25	; 0x03
    218c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    218e:	35 83       	std	Z+5, r19	; 0x05
    2190:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2192:	8a 81       	ldd	r24, Y+2	; 0x02
    2194:	9b 81       	ldd	r25, Y+3	; 0x03
    2196:	ec 01       	movw	r28, r24
    2198:	7d 83       	std	Y+5, r23	; 0x05
    219a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    219c:	e9 01       	movw	r28, r18
    219e:	7b 83       	std	Y+3, r23	; 0x03
    21a0:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    21a2:	12 96       	adiw	r26, 0x02	; 2
    21a4:	7c 93       	st	X, r23
    21a6:	6e 93       	st	-X, r22
    21a8:	11 97       	sbiw	r26, 0x01	; 1

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    21aa:	b1 87       	std	Z+9, r27	; 0x09
    21ac:	a0 87       	std	Z+8, r26	; 0x08

	( pxList->uxNumberOfItems )++;
    21ae:	8c 91       	ld	r24, X
    21b0:	8f 5f       	subi	r24, 0xFF	; 255
    21b2:	8c 93       	st	X, r24
}
    21b4:	df 91       	pop	r29
    21b6:	cf 91       	pop	r28
    21b8:	08 95       	ret

000021ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    21ba:	cf 93       	push	r28
    21bc:	df 93       	push	r29
    21be:	ac 01       	movw	r20, r24
    21c0:	db 01       	movw	r26, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    21c2:	8d 91       	ld	r24, X+
    21c4:	9c 91       	ld	r25, X
    21c6:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    21c8:	8f 3f       	cpi	r24, 0xFF	; 255
    21ca:	2f ef       	ldi	r18, 0xFF	; 255
    21cc:	92 07       	cpc	r25, r18
    21ce:	21 f4       	brne	.+8      	; 0x21d8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    21d0:	ea 01       	movw	r28, r20
    21d2:	ef 81       	ldd	r30, Y+7	; 0x07
    21d4:	f8 85       	ldd	r31, Y+8	; 0x08
    21d6:	0e c0       	rjmp	.+28     	; 0x21f4 <vListInsert+0x3a>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    21d8:	fa 01       	movw	r30, r20
    21da:	33 96       	adiw	r30, 0x03	; 3
    21dc:	22 81       	ldd	r18, Z+2	; 0x02
    21de:	33 81       	ldd	r19, Z+3	; 0x03
    21e0:	e9 01       	movw	r28, r18
    21e2:	28 81       	ld	r18, Y
    21e4:	39 81       	ldd	r19, Y+1	; 0x01
    21e6:	82 17       	cp	r24, r18
    21e8:	93 07       	cpc	r25, r19
    21ea:	20 f0       	brcs	.+8      	; 0x21f4 <vListInsert+0x3a>
    21ec:	02 80       	ldd	r0, Z+2	; 0x02
    21ee:	f3 81       	ldd	r31, Z+3	; 0x03
    21f0:	e0 2d       	mov	r30, r0
    21f2:	f4 cf       	rjmp	.-24     	; 0x21dc <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    21f4:	82 81       	ldd	r24, Z+2	; 0x02
    21f6:	93 81       	ldd	r25, Z+3	; 0x03
    21f8:	13 96       	adiw	r26, 0x03	; 3
    21fa:	9c 93       	st	X, r25
    21fc:	8e 93       	st	-X, r24
    21fe:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2200:	ec 01       	movw	r28, r24
    2202:	bd 83       	std	Y+5, r27	; 0x05
    2204:	ac 83       	std	Y+4, r26	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2206:	15 96       	adiw	r26, 0x05	; 5
    2208:	fc 93       	st	X, r31
    220a:	ee 93       	st	-X, r30
    220c:	14 97       	sbiw	r26, 0x04	; 4
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    220e:	b3 83       	std	Z+3, r27	; 0x03
    2210:	a2 83       	std	Z+2, r26	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2212:	19 96       	adiw	r26, 0x09	; 9
    2214:	5c 93       	st	X, r21
    2216:	4e 93       	st	-X, r20
    2218:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    221a:	fa 01       	movw	r30, r20
    221c:	80 81       	ld	r24, Z
    221e:	8f 5f       	subi	r24, 0xFF	; 255
    2220:	80 83       	st	Z, r24
}
    2222:	df 91       	pop	r29
    2224:	cf 91       	pop	r28
    2226:	08 95       	ret

00002228 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2228:	cf 93       	push	r28
    222a:	df 93       	push	r29
    222c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    222e:	a2 81       	ldd	r26, Z+2	; 0x02
    2230:	b3 81       	ldd	r27, Z+3	; 0x03
    2232:	84 81       	ldd	r24, Z+4	; 0x04
    2234:	95 81       	ldd	r25, Z+5	; 0x05
    2236:	15 96       	adiw	r26, 0x05	; 5
    2238:	9c 93       	st	X, r25
    223a:	8e 93       	st	-X, r24
    223c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    223e:	c4 81       	ldd	r28, Z+4	; 0x04
    2240:	d5 81       	ldd	r29, Z+5	; 0x05
    2242:	bb 83       	std	Y+3, r27	; 0x03
    2244:	aa 83       	std	Y+2, r26	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2246:	a0 85       	ldd	r26, Z+8	; 0x08
    2248:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    224a:	11 96       	adiw	r26, 0x01	; 1
    224c:	8d 91       	ld	r24, X+
    224e:	9c 91       	ld	r25, X
    2250:	12 97       	sbiw	r26, 0x02	; 2
    2252:	8e 17       	cp	r24, r30
    2254:	9f 07       	cpc	r25, r31
    2256:	21 f4       	brne	.+8      	; 0x2260 <vListRemove+0x38>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2258:	12 96       	adiw	r26, 0x02	; 2
    225a:	dc 93       	st	X, r29
    225c:	ce 93       	st	-X, r28
    225e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    2260:	11 86       	std	Z+9, r1	; 0x09
    2262:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2264:	8c 91       	ld	r24, X
    2266:	81 50       	subi	r24, 0x01	; 1
    2268:	8c 93       	st	X, r24
}
    226a:	df 91       	pop	r29
    226c:	cf 91       	pop	r28
    226e:	08 95       	ret

00002270 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2270:	ef 92       	push	r14
    2272:	ff 92       	push	r15
    2274:	0f 93       	push	r16
    2276:	1f 93       	push	r17
    2278:	cf 93       	push	r28
    227a:	df 93       	push	r29
    227c:	7c 01       	movw	r14, r24
    227e:	14 2f       	mov	r17, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2280:	8a e1       	ldi	r24, 0x1A	; 26
    2282:	90 e0       	ldi	r25, 0x00	; 0
    2284:	0e 94 02 13 	call	0x2604	; 0x2604 <pvPortMalloc>
    2288:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    228a:	89 2b       	or	r24, r25
    228c:	09 f4       	brne	.+2      	; 0x2290 <xCoRoutineCreate+0x20>
    228e:	4f c0       	rjmp	.+158    	; 0x232e <xCoRoutineCreate+0xbe>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2290:	80 91 a0 01 	lds	r24, 0x01A0
    2294:	90 91 a1 01 	lds	r25, 0x01A1
    2298:	89 2b       	or	r24, r25
    229a:	01 f5       	brne	.+64     	; 0x22dc <xCoRoutineCreate+0x6c>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    229c:	d0 93 a1 01 	sts	0x01A1, r29
    22a0:	c0 93 a0 01 	sts	0x01A0, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    22a4:	88 ec       	ldi	r24, 0xC8	; 200
    22a6:	91 e0       	ldi	r25, 0x01	; 1
    22a8:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    22ac:	8f eb       	ldi	r24, 0xBF	; 191
    22ae:	91 e0       	ldi	r25, 0x01	; 1
    22b0:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    22b4:	86 eb       	ldi	r24, 0xB6	; 182
    22b6:	91 e0       	ldi	r25, 0x01	; 1
    22b8:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    22bc:	89 ea       	ldi	r24, 0xA9	; 169
    22be:	91 e0       	ldi	r25, 0x01	; 1
    22c0:	0e 94 a8 10 	call	0x2150	; 0x2150 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    22c4:	8f eb       	ldi	r24, 0xBF	; 191
    22c6:	91 e0       	ldi	r25, 0x01	; 1
    22c8:	90 93 b5 01 	sts	0x01B5, r25
    22cc:	80 93 b4 01 	sts	0x01B4, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    22d0:	86 eb       	ldi	r24, 0xB6	; 182
    22d2:	91 e0       	ldi	r25, 0x01	; 1
    22d4:	90 93 b3 01 	sts	0x01B3, r25
    22d8:	80 93 b2 01 	sts	0x01B2, r24
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    22dc:	19 8e       	std	Y+25, r1	; 0x19
    22de:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    22e0:	1e 8a       	std	Y+22, r1	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    22e2:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    22e4:	fe 01       	movw	r30, r28
    22e6:	e1 92       	st	Z+, r14
    22e8:	f1 92       	st	Z+, r15
    22ea:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    22ec:	cf 01       	movw	r24, r30
    22ee:	0e 94 b6 10 	call	0x216c	; 0x216c <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    22f2:	ce 01       	movw	r24, r28
    22f4:	0c 96       	adiw	r24, 0x0c	; 12
    22f6:	0e 94 b6 10 	call	0x216c	; 0x216c <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    22fa:	d9 87       	std	Y+9, r29	; 0x09
    22fc:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    22fe:	db 8b       	std	Y+19, r29	; 0x13
    2300:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2302:	84 e0       	ldi	r24, 0x04	; 4
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	9d 87       	std	Y+13, r25	; 0x0d
    2308:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    230a:	9e 89       	ldd	r25, Y+22	; 0x16
    230c:	80 91 a8 01 	lds	r24, 0x01A8
    2310:	89 17       	cp	r24, r25
    2312:	10 f4       	brcc	.+4      	; 0x2318 <xCoRoutineCreate+0xa8>
    2314:	90 93 a8 01 	sts	0x01A8, r25
    2318:	f9 e0       	ldi	r31, 0x09	; 9
    231a:	9f 9f       	mul	r25, r31
    231c:	c0 01       	movw	r24, r0
    231e:	11 24       	eor	r1, r1
    2320:	b8 01       	movw	r22, r16
    2322:	88 53       	subi	r24, 0x38	; 56
    2324:	9e 4f       	sbci	r25, 0xFE	; 254
    2326:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>

		xReturn = pdPASS;
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	01 c0       	rjmp	.+2      	; 0x2330 <xCoRoutineCreate+0xc0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    232e:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	08 95       	ret

0000233e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	cf 93       	push	r28
    2344:	df 93       	push	r29
    2346:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2348:	c0 91 a6 01 	lds	r28, 0x01A6
    234c:	d0 91 a7 01 	lds	r29, 0x01A7
    2350:	c8 0f       	add	r28, r24
    2352:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2354:	80 91 a0 01 	lds	r24, 0x01A0
    2358:	90 91 a1 01 	lds	r25, 0x01A1
    235c:	02 96       	adiw	r24, 0x02	; 2
    235e:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2362:	e0 91 a0 01 	lds	r30, 0x01A0
    2366:	f0 91 a1 01 	lds	r31, 0x01A1
    236a:	d3 83       	std	Z+3, r29	; 0x03
    236c:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    236e:	80 91 a6 01 	lds	r24, 0x01A6
    2372:	90 91 a7 01 	lds	r25, 0x01A7
    2376:	bf 01       	movw	r22, r30
    2378:	6e 5f       	subi	r22, 0xFE	; 254
    237a:	7f 4f       	sbci	r23, 0xFF	; 255
    237c:	c8 17       	cp	r28, r24
    237e:	d9 07       	cpc	r29, r25
    2380:	28 f4       	brcc	.+10     	; 0x238c <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2382:	80 91 b2 01 	lds	r24, 0x01B2
    2386:	90 91 b3 01 	lds	r25, 0x01B3
    238a:	04 c0       	rjmp	.+8      	; 0x2394 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    238c:	80 91 b4 01 	lds	r24, 0x01B4
    2390:	90 91 b5 01 	lds	r25, 0x01B5
    2394:	0e 94 dd 10 	call	0x21ba	; 0x21ba <vListInsert>
	}

	if( pxEventList )
    2398:	01 15       	cp	r16, r1
    239a:	11 05       	cpc	r17, r1
    239c:	69 f0       	breq	.+26     	; 0x23b8 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    239e:	60 91 a0 01 	lds	r22, 0x01A0
    23a2:	70 91 a1 01 	lds	r23, 0x01A1
    23a6:	64 5f       	subi	r22, 0xF4	; 244
    23a8:	7f 4f       	sbci	r23, 0xFF	; 255
    23aa:	c8 01       	movw	r24, r16
	}
}
    23ac:	df 91       	pop	r29
    23ae:	cf 91       	pop	r28
    23b0:	1f 91       	pop	r17
    23b2:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    23b4:	0c 94 dd 10 	jmp	0x21ba	; 0x21ba <vListInsert>
	}
}
    23b8:	df 91       	pop	r29
    23ba:	cf 91       	pop	r28
    23bc:	1f 91       	pop	r17
    23be:	0f 91       	pop	r16
    23c0:	08 95       	ret

000023c2 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    23c2:	ff 92       	push	r15
    23c4:	0f 93       	push	r16
    23c6:	1f 93       	push	r17
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    23cc:	99 e0       	ldi	r25, 0x09	; 9
    23ce:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    23d0:	80 91 a9 01 	lds	r24, 0x01A9
    23d4:	88 23       	and	r24, r24
    23d6:	49 f1       	breq	.+82     	; 0x242a <vCoRoutineSchedule+0x68>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    23d8:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    23da:	80 91 a9 01 	lds	r24, 0x01A9
    23de:	88 23       	and	r24, r24
    23e0:	39 f0       	breq	.+14     	; 0x23f0 <vCoRoutineSchedule+0x2e>
    23e2:	e0 91 ae 01 	lds	r30, 0x01AE
    23e6:	f0 91 af 01 	lds	r31, 0x01AF
    23ea:	c6 81       	ldd	r28, Z+6	; 0x06
    23ec:	d7 81       	ldd	r29, Z+7	; 0x07
    23ee:	02 c0       	rjmp	.+4      	; 0x23f4 <vCoRoutineSchedule+0x32>
    23f0:	c0 e0       	ldi	r28, 0x00	; 0
    23f2:	d0 e0       	ldi	r29, 0x00	; 0
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    23f4:	ce 01       	movw	r24, r28
    23f6:	0c 96       	adiw	r24, 0x0c	; 12
    23f8:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    23fc:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    23fe:	8e 01       	movw	r16, r28
    2400:	0e 5f       	subi	r16, 0xFE	; 254
    2402:	1f 4f       	sbci	r17, 0xFF	; 255
    2404:	c8 01       	movw	r24, r16
    2406:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    240a:	9e 89       	ldd	r25, Y+22	; 0x16
    240c:	80 91 a8 01 	lds	r24, 0x01A8
    2410:	89 17       	cp	r24, r25
    2412:	10 f4       	brcc	.+4      	; 0x2418 <vCoRoutineSchedule+0x56>
    2414:	90 93 a8 01 	sts	0x01A8, r25
    2418:	f9 9e       	mul	r15, r25
    241a:	c0 01       	movw	r24, r0
    241c:	11 24       	eor	r1, r1
    241e:	b8 01       	movw	r22, r16
    2420:	88 53       	subi	r24, 0x38	; 56
    2422:	9e 4f       	sbci	r25, 0xFE	; 254
    2424:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>
    2428:	d3 cf       	rjmp	.-90     	; 0x23d0 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    242a:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <xTaskGetTickCount>
    242e:	20 91 a4 01 	lds	r18, 0x01A4
    2432:	30 91 a5 01 	lds	r19, 0x01A5
    2436:	82 1b       	sub	r24, r18
    2438:	93 0b       	sbc	r25, r19
    243a:	90 93 a3 01 	sts	0x01A3, r25
    243e:	80 93 a2 01 	sts	0x01A2, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2442:	89 e0       	ldi	r24, 0x09	; 9
    2444:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2446:	20 91 a2 01 	lds	r18, 0x01A2
    244a:	30 91 a3 01 	lds	r19, 0x01A3
    244e:	80 91 a6 01 	lds	r24, 0x01A6
    2452:	90 91 a7 01 	lds	r25, 0x01A7
    2456:	21 15       	cp	r18, r1
    2458:	31 05       	cpc	r19, r1
    245a:	09 f4       	brne	.+2      	; 0x245e <vCoRoutineSchedule+0x9c>
    245c:	56 c0       	rjmp	.+172    	; 0x250a <vCoRoutineSchedule+0x148>
	{
		xCoRoutineTickCount++;
    245e:	01 96       	adiw	r24, 0x01	; 1
    2460:	90 93 a7 01 	sts	0x01A7, r25
    2464:	80 93 a6 01 	sts	0x01A6, r24
		xPassedTicks--;
    2468:	21 50       	subi	r18, 0x01	; 1
    246a:	31 09       	sbc	r19, r1
    246c:	30 93 a3 01 	sts	0x01A3, r19
    2470:	20 93 a2 01 	sts	0x01A2, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2474:	89 2b       	or	r24, r25
    2476:	09 f0       	breq	.+2      	; 0x247a <vCoRoutineSchedule+0xb8>
    2478:	40 c0       	rjmp	.+128    	; 0x24fa <vCoRoutineSchedule+0x138>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    247a:	80 91 b4 01 	lds	r24, 0x01B4
    247e:	90 91 b5 01 	lds	r25, 0x01B5
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2482:	20 91 b2 01 	lds	r18, 0x01B2
    2486:	30 91 b3 01 	lds	r19, 0x01B3
    248a:	30 93 b5 01 	sts	0x01B5, r19
    248e:	20 93 b4 01 	sts	0x01B4, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    2492:	90 93 b3 01 	sts	0x01B3, r25
    2496:	80 93 b2 01 	sts	0x01B2, r24
    249a:	2f c0       	rjmp	.+94     	; 0x24fa <vCoRoutineSchedule+0x138>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    249c:	05 80       	ldd	r0, Z+5	; 0x05
    249e:	f6 81       	ldd	r31, Z+6	; 0x06
    24a0:	e0 2d       	mov	r30, r0
    24a2:	c6 81       	ldd	r28, Z+6	; 0x06
    24a4:	d7 81       	ldd	r29, Z+7	; 0x07
    24a6:	20 97       	sbiw	r28, 0x00	; 0
    24a8:	71 f2       	breq	.-100    	; 0x2446 <vCoRoutineSchedule+0x84>
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    24aa:	20 91 a6 01 	lds	r18, 0x01A6
    24ae:	30 91 a7 01 	lds	r19, 0x01A7
    24b2:	8a 81       	ldd	r24, Y+2	; 0x02
    24b4:	9b 81       	ldd	r25, Y+3	; 0x03
    24b6:	28 17       	cp	r18, r24
    24b8:	39 07       	cpc	r19, r25
    24ba:	28 f2       	brcs	.-118    	; 0x2446 <vCoRoutineSchedule+0x84>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    24bc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    24be:	8e 01       	movw	r16, r28
    24c0:	0e 5f       	subi	r16, 0xFE	; 254
    24c2:	1f 4f       	sbci	r17, 0xFF	; 255
    24c4:	c8 01       	movw	r24, r16
    24c6:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    24ca:	8c 89       	ldd	r24, Y+20	; 0x14
    24cc:	9d 89       	ldd	r25, Y+21	; 0x15
    24ce:	89 2b       	or	r24, r25
    24d0:	21 f0       	breq	.+8      	; 0x24da <vCoRoutineSchedule+0x118>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    24d2:	ce 01       	movw	r24, r28
    24d4:	0c 96       	adiw	r24, 0x0c	; 12
    24d6:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    24da:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    24dc:	9e 89       	ldd	r25, Y+22	; 0x16
    24de:	80 91 a8 01 	lds	r24, 0x01A8
    24e2:	89 17       	cp	r24, r25
    24e4:	10 f4       	brcc	.+4      	; 0x24ea <vCoRoutineSchedule+0x128>
    24e6:	90 93 a8 01 	sts	0x01A8, r25
    24ea:	f9 9e       	mul	r15, r25
    24ec:	c0 01       	movw	r24, r0
    24ee:	11 24       	eor	r1, r1
    24f0:	b8 01       	movw	r22, r16
    24f2:	88 53       	subi	r24, 0x38	; 56
    24f4:	9e 4f       	sbci	r25, 0xFE	; 254
    24f6:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    24fa:	e0 91 b4 01 	lds	r30, 0x01B4
    24fe:	f0 91 b5 01 	lds	r31, 0x01B5
    2502:	80 81       	ld	r24, Z
    2504:	81 11       	cpse	r24, r1
    2506:	ca cf       	rjmp	.-108    	; 0x249c <vCoRoutineSchedule+0xda>
    2508:	9e cf       	rjmp	.-196    	; 0x2446 <vCoRoutineSchedule+0x84>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    250a:	90 93 a5 01 	sts	0x01A5, r25
    250e:	80 93 a4 01 	sts	0x01A4, r24
    2512:	80 91 a8 01 	lds	r24, 0x01A8

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2516:	69 e0       	ldi	r22, 0x09	; 9
    2518:	48 2f       	mov	r20, r24
    251a:	50 e0       	ldi	r21, 0x00	; 0
    251c:	64 9f       	mul	r22, r20
    251e:	90 01       	movw	r18, r0
    2520:	65 9f       	mul	r22, r21
    2522:	30 0d       	add	r19, r0
    2524:	11 24       	eor	r1, r1
    2526:	f9 01       	movw	r30, r18
    2528:	e8 53       	subi	r30, 0x38	; 56
    252a:	fe 4f       	sbci	r31, 0xFE	; 254
    252c:	90 81       	ld	r25, Z
    252e:	91 11       	cpse	r25, r1
    2530:	0c c0       	rjmp	.+24     	; 0x254a <vCoRoutineSchedule+0x188>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2532:	81 11       	cpse	r24, r1
    2534:	08 c0       	rjmp	.+16     	; 0x2546 <vCoRoutineSchedule+0x184>
    2536:	10 92 a8 01 	sts	0x01A8, r1

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    253a:	df 91       	pop	r29
    253c:	cf 91       	pop	r28
    253e:	1f 91       	pop	r17
    2540:	0f 91       	pop	r16
    2542:	ff 90       	pop	r15
    2544:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2546:	81 50       	subi	r24, 0x01	; 1
    2548:	e7 cf       	rjmp	.-50     	; 0x2518 <vCoRoutineSchedule+0x156>
    254a:	80 93 a8 01 	sts	0x01A8, r24
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    254e:	a1 81       	ldd	r26, Z+1	; 0x01
    2550:	b2 81       	ldd	r27, Z+2	; 0x02
    2552:	12 96       	adiw	r26, 0x02	; 2
    2554:	0d 90       	ld	r0, X+
    2556:	bc 91       	ld	r27, X
    2558:	a0 2d       	mov	r26, r0
    255a:	b2 83       	std	Z+2, r27	; 0x02
    255c:	a1 83       	std	Z+1, r26	; 0x01
    255e:	25 53       	subi	r18, 0x35	; 53
    2560:	3e 4f       	sbci	r19, 0xFE	; 254
    2562:	a2 17       	cp	r26, r18
    2564:	b3 07       	cpc	r27, r19
    2566:	31 f4       	brne	.+12     	; 0x2574 <vCoRoutineSchedule+0x1b2>
    2568:	12 96       	adiw	r26, 0x02	; 2
    256a:	8d 91       	ld	r24, X+
    256c:	9c 91       	ld	r25, X
    256e:	13 97       	sbiw	r26, 0x03	; 3
    2570:	92 83       	std	Z+2, r25	; 0x02
    2572:	81 83       	std	Z+1, r24	; 0x01
    2574:	89 e0       	ldi	r24, 0x09	; 9
    2576:	84 9f       	mul	r24, r20
    2578:	f0 01       	movw	r30, r0
    257a:	85 9f       	mul	r24, r21
    257c:	f0 0d       	add	r31, r0
    257e:	11 24       	eor	r1, r1
    2580:	e8 53       	subi	r30, 0x38	; 56
    2582:	fe 4f       	sbci	r31, 0xFE	; 254
    2584:	01 80       	ldd	r0, Z+1	; 0x01
    2586:	f2 81       	ldd	r31, Z+2	; 0x02
    2588:	e0 2d       	mov	r30, r0
    258a:	86 81       	ldd	r24, Z+6	; 0x06
    258c:	97 81       	ldd	r25, Z+7	; 0x07
    258e:	90 93 a1 01 	sts	0x01A1, r25
    2592:	80 93 a0 01 	sts	0x01A0, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2596:	dc 01       	movw	r26, r24
    2598:	ed 91       	ld	r30, X+
    259a:	fc 91       	ld	r31, X
    259c:	11 97       	sbiw	r26, 0x01	; 1
    259e:	57 96       	adiw	r26, 0x17	; 23
    25a0:	6c 91       	ld	r22, X

	return;
}
    25a2:	df 91       	pop	r29
    25a4:	cf 91       	pop	r28
    25a6:	1f 91       	pop	r17
    25a8:	0f 91       	pop	r16
    25aa:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    25ac:	09 94       	ijmp

000025ae <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    25ae:	0f 93       	push	r16
    25b0:	1f 93       	push	r17
    25b2:	cf 93       	push	r28
    25b4:	df 93       	push	r29
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    25b6:	dc 01       	movw	r26, r24
    25b8:	2c 91       	ld	r18, X
    25ba:	22 23       	and	r18, r18
    25bc:	39 f0       	breq	.+14     	; 0x25cc <xCoRoutineRemoveFromEventList+0x1e>
    25be:	15 96       	adiw	r26, 0x05	; 5
    25c0:	ed 91       	ld	r30, X+
    25c2:	fc 91       	ld	r31, X
    25c4:	16 97       	sbiw	r26, 0x06	; 6
    25c6:	c6 81       	ldd	r28, Z+6	; 0x06
    25c8:	d7 81       	ldd	r29, Z+7	; 0x07
    25ca:	02 c0       	rjmp	.+4      	; 0x25d0 <xCoRoutineRemoveFromEventList+0x22>
    25cc:	c0 e0       	ldi	r28, 0x00	; 0
    25ce:	d0 e0       	ldi	r29, 0x00	; 0
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    25d0:	8e 01       	movw	r16, r28
    25d2:	04 5f       	subi	r16, 0xF4	; 244
    25d4:	1f 4f       	sbci	r17, 0xFF	; 255
    25d6:	c8 01       	movw	r24, r16
    25d8:	0e 94 14 11 	call	0x2228	; 0x2228 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    25dc:	b8 01       	movw	r22, r16
    25de:	89 ea       	ldi	r24, 0xA9	; 169
    25e0:	91 e0       	ldi	r25, 0x01	; 1
    25e2:	0e 94 ba 10 	call	0x2174	; 0x2174 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    25e6:	e0 91 a0 01 	lds	r30, 0x01A0
    25ea:	f0 91 a1 01 	lds	r31, 0x01A1
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	2e 89       	ldd	r18, Y+22	; 0x16
    25f2:	96 89       	ldd	r25, Z+22	; 0x16
    25f4:	29 17       	cp	r18, r25
    25f6:	08 f4       	brcc	.+2      	; 0x25fa <xCoRoutineRemoveFromEventList+0x4c>
    25f8:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    25fa:	df 91       	pop	r29
    25fc:	cf 91       	pop	r28
    25fe:	1f 91       	pop	r17
    2600:	0f 91       	pop	r16
    2602:	08 95       	ret

00002604 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2604:	0f 93       	push	r16
    2606:	1f 93       	push	r17
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
    260c:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    260e:	0e 94 de 0a 	call	0x15bc	; 0x15bc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2612:	c0 91 d1 01 	lds	r28, 0x01D1
    2616:	d0 91 d2 01 	lds	r29, 0x01D2
    261a:	c8 01       	movw	r24, r16
    261c:	8c 0f       	add	r24, r28
    261e:	9d 1f       	adc	r25, r29
    2620:	8e 3e       	cpi	r24, 0xEE	; 238
    2622:	22 e0       	ldi	r18, 0x02	; 2
    2624:	92 07       	cpc	r25, r18
    2626:	50 f4       	brcc	.+20     	; 0x263c <pvPortMalloc+0x38>
    2628:	c8 17       	cp	r28, r24
    262a:	d9 07       	cpc	r29, r25
    262c:	38 f4       	brcc	.+14     	; 0x263c <pvPortMalloc+0x38>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    262e:	cd 52       	subi	r28, 0x2D	; 45
    2630:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
    2632:	90 93 d2 01 	sts	0x01D2, r25
    2636:	80 93 d1 01 	sts	0x01D1, r24
    263a:	02 c0       	rjmp	.+4      	; 0x2640 <pvPortMalloc+0x3c>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    263c:	c0 e0       	ldi	r28, 0x00	; 0
    263e:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    2640:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    2644:	ce 01       	movw	r24, r28
    2646:	df 91       	pop	r29
    2648:	cf 91       	pop	r28
    264a:	1f 91       	pop	r17
    264c:	0f 91       	pop	r16
    264e:	08 95       	ret

00002650 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2650:	08 95       	ret

00002652 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2652:	10 92 d2 01 	sts	0x01D2, r1
    2656:	10 92 d1 01 	sts	0x01D1, r1
    265a:	08 95       	ret

0000265c <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    265c:	20 91 d1 01 	lds	r18, 0x01D1
    2660:	30 91 d2 01 	lds	r19, 0x01D2
}
    2664:	8e ee       	ldi	r24, 0xEE	; 238
    2666:	92 e0       	ldi	r25, 0x02	; 2
    2668:	82 1b       	sub	r24, r18
    266a:	93 0b       	sbc	r25, r19
    266c:	08 95       	ret

0000266e <pxPortInitialiseStack>:
unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    266e:	31 e1       	ldi	r19, 0x11	; 17
    2670:	fc 01       	movw	r30, r24
    2672:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    2674:	31 97       	sbiw	r30, 0x01	; 1
    2676:	22 e2       	ldi	r18, 0x22	; 34
    2678:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    267a:	31 97       	sbiw	r30, 0x01	; 1
    267c:	a3 e3       	ldi	r26, 0x33	; 51
    267e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2680:	31 97       	sbiw	r30, 0x01	; 1
    2682:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2684:	31 97       	sbiw	r30, 0x01	; 1
    2686:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2688:	31 97       	sbiw	r30, 0x01	; 1
    268a:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    268c:	31 97       	sbiw	r30, 0x01	; 1
    268e:	60 e8       	ldi	r22, 0x80	; 128
    2690:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2692:	31 97       	sbiw	r30, 0x01	; 1
    2694:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2696:	31 97       	sbiw	r30, 0x01	; 1
    2698:	62 e0       	ldi	r22, 0x02	; 2
    269a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    269c:	31 97       	sbiw	r30, 0x01	; 1
    269e:	63 e0       	ldi	r22, 0x03	; 3
    26a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    26a2:	31 97       	sbiw	r30, 0x01	; 1
    26a4:	64 e0       	ldi	r22, 0x04	; 4
    26a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    26a8:	31 97       	sbiw	r30, 0x01	; 1
    26aa:	65 e0       	ldi	r22, 0x05	; 5
    26ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    26ae:	31 97       	sbiw	r30, 0x01	; 1
    26b0:	66 e0       	ldi	r22, 0x06	; 6
    26b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    26b4:	31 97       	sbiw	r30, 0x01	; 1
    26b6:	67 e0       	ldi	r22, 0x07	; 7
    26b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    26ba:	31 97       	sbiw	r30, 0x01	; 1
    26bc:	68 e0       	ldi	r22, 0x08	; 8
    26be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    26c0:	31 97       	sbiw	r30, 0x01	; 1
    26c2:	69 e0       	ldi	r22, 0x09	; 9
    26c4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    26c6:	31 97       	sbiw	r30, 0x01	; 1
    26c8:	60 e1       	ldi	r22, 0x10	; 16
    26ca:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    26cc:	31 97       	sbiw	r30, 0x01	; 1
    26ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    26d0:	31 97       	sbiw	r30, 0x01	; 1
    26d2:	32 e1       	ldi	r19, 0x12	; 18
    26d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    26d6:	31 97       	sbiw	r30, 0x01	; 1
    26d8:	33 e1       	ldi	r19, 0x13	; 19
    26da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    26dc:	31 97       	sbiw	r30, 0x01	; 1
    26de:	34 e1       	ldi	r19, 0x14	; 20
    26e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    26e2:	31 97       	sbiw	r30, 0x01	; 1
    26e4:	35 e1       	ldi	r19, 0x15	; 21
    26e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    26e8:	31 97       	sbiw	r30, 0x01	; 1
    26ea:	36 e1       	ldi	r19, 0x16	; 22
    26ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    26ee:	31 97       	sbiw	r30, 0x01	; 1
    26f0:	37 e1       	ldi	r19, 0x17	; 23
    26f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    26f4:	31 97       	sbiw	r30, 0x01	; 1
    26f6:	38 e1       	ldi	r19, 0x18	; 24
    26f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    26fa:	31 97       	sbiw	r30, 0x01	; 1
    26fc:	39 e1       	ldi	r19, 0x19	; 25
    26fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2700:	31 97       	sbiw	r30, 0x01	; 1
    2702:	30 e2       	ldi	r19, 0x20	; 32
    2704:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2706:	31 97       	sbiw	r30, 0x01	; 1
    2708:	31 e2       	ldi	r19, 0x21	; 33
    270a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    270c:	31 97       	sbiw	r30, 0x01	; 1
    270e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2710:	31 97       	sbiw	r30, 0x01	; 1
    2712:	23 e2       	ldi	r18, 0x23	; 35
    2714:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    2716:	31 97       	sbiw	r30, 0x01	; 1
    2718:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    271a:	31 97       	sbiw	r30, 0x01	; 1
    271c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    271e:	31 97       	sbiw	r30, 0x01	; 1
    2720:	26 e2       	ldi	r18, 0x26	; 38
    2722:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2724:	31 97       	sbiw	r30, 0x01	; 1
    2726:	27 e2       	ldi	r18, 0x27	; 39
    2728:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    272a:	31 97       	sbiw	r30, 0x01	; 1
    272c:	28 e2       	ldi	r18, 0x28	; 40
    272e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2730:	31 97       	sbiw	r30, 0x01	; 1
    2732:	29 e2       	ldi	r18, 0x29	; 41
    2734:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2736:	31 97       	sbiw	r30, 0x01	; 1
    2738:	20 e3       	ldi	r18, 0x30	; 48
    273a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    273c:	31 97       	sbiw	r30, 0x01	; 1
    273e:	21 e3       	ldi	r18, 0x31	; 49
    2740:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    2742:	86 97       	sbiw	r24, 0x26	; 38
    2744:	08 95       	ret

00002746 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
	OCR1AH = ucHighByte;
    2746:	88 e0       	ldi	r24, 0x08	; 8
    2748:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = ucLowByte;
    274c:	8f ef       	ldi	r24, 0xFF	; 255
    274e:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    2752:	8b e0       	ldi	r24, 0x0B	; 11
    2754:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    2758:	ef e6       	ldi	r30, 0x6F	; 111
    275a:	f0 e0       	ldi	r31, 0x00	; 0
    275c:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    275e:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    2760:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2762:	a0 91 47 01 	lds	r26, 0x0147
    2766:	b0 91 48 01 	lds	r27, 0x0148
    276a:	cd 91       	ld	r28, X+
    276c:	cd bf       	out	0x3d, r28	; 61
    276e:	dd 91       	ld	r29, X+
    2770:	de bf       	out	0x3e, r29	; 62
    2772:	ff 91       	pop	r31
    2774:	ef 91       	pop	r30
    2776:	df 91       	pop	r29
    2778:	cf 91       	pop	r28
    277a:	bf 91       	pop	r27
    277c:	af 91       	pop	r26
    277e:	9f 91       	pop	r25
    2780:	8f 91       	pop	r24
    2782:	7f 91       	pop	r23
    2784:	6f 91       	pop	r22
    2786:	5f 91       	pop	r21
    2788:	4f 91       	pop	r20
    278a:	3f 91       	pop	r19
    278c:	2f 91       	pop	r18
    278e:	1f 91       	pop	r17
    2790:	0f 91       	pop	r16
    2792:	ff 90       	pop	r15
    2794:	ef 90       	pop	r14
    2796:	df 90       	pop	r13
    2798:	cf 90       	pop	r12
    279a:	bf 90       	pop	r11
    279c:	af 90       	pop	r10
    279e:	9f 90       	pop	r9
    27a0:	8f 90       	pop	r8
    27a2:	7f 90       	pop	r7
    27a4:	6f 90       	pop	r6
    27a6:	5f 90       	pop	r5
    27a8:	4f 90       	pop	r4
    27aa:	3f 90       	pop	r3
    27ac:	2f 90       	pop	r2
    27ae:	1f 90       	pop	r1
    27b0:	0f 90       	pop	r0
    27b2:	0f be       	out	0x3f, r0	; 63
    27b4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    27b6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	08 95       	ret

000027bc <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    27bc:	08 95       	ret

000027be <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    27be:	0f 92       	push	r0
    27c0:	0f b6       	in	r0, 0x3f	; 63
    27c2:	f8 94       	cli
    27c4:	0f 92       	push	r0
    27c6:	1f 92       	push	r1
    27c8:	11 24       	eor	r1, r1
    27ca:	2f 92       	push	r2
    27cc:	3f 92       	push	r3
    27ce:	4f 92       	push	r4
    27d0:	5f 92       	push	r5
    27d2:	6f 92       	push	r6
    27d4:	7f 92       	push	r7
    27d6:	8f 92       	push	r8
    27d8:	9f 92       	push	r9
    27da:	af 92       	push	r10
    27dc:	bf 92       	push	r11
    27de:	cf 92       	push	r12
    27e0:	df 92       	push	r13
    27e2:	ef 92       	push	r14
    27e4:	ff 92       	push	r15
    27e6:	0f 93       	push	r16
    27e8:	1f 93       	push	r17
    27ea:	2f 93       	push	r18
    27ec:	3f 93       	push	r19
    27ee:	4f 93       	push	r20
    27f0:	5f 93       	push	r21
    27f2:	6f 93       	push	r22
    27f4:	7f 93       	push	r23
    27f6:	8f 93       	push	r24
    27f8:	9f 93       	push	r25
    27fa:	af 93       	push	r26
    27fc:	bf 93       	push	r27
    27fe:	cf 93       	push	r28
    2800:	df 93       	push	r29
    2802:	ef 93       	push	r30
    2804:	ff 93       	push	r31
    2806:	a0 91 47 01 	lds	r26, 0x0147
    280a:	b0 91 48 01 	lds	r27, 0x0148
    280e:	0d b6       	in	r0, 0x3d	; 61
    2810:	0d 92       	st	X+, r0
    2812:	0e b6       	in	r0, 0x3e	; 62
    2814:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2816:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    281a:	a0 91 47 01 	lds	r26, 0x0147
    281e:	b0 91 48 01 	lds	r27, 0x0148
    2822:	cd 91       	ld	r28, X+
    2824:	cd bf       	out	0x3d, r28	; 61
    2826:	dd 91       	ld	r29, X+
    2828:	de bf       	out	0x3e, r29	; 62
    282a:	ff 91       	pop	r31
    282c:	ef 91       	pop	r30
    282e:	df 91       	pop	r29
    2830:	cf 91       	pop	r28
    2832:	bf 91       	pop	r27
    2834:	af 91       	pop	r26
    2836:	9f 91       	pop	r25
    2838:	8f 91       	pop	r24
    283a:	7f 91       	pop	r23
    283c:	6f 91       	pop	r22
    283e:	5f 91       	pop	r21
    2840:	4f 91       	pop	r20
    2842:	3f 91       	pop	r19
    2844:	2f 91       	pop	r18
    2846:	1f 91       	pop	r17
    2848:	0f 91       	pop	r16
    284a:	ff 90       	pop	r15
    284c:	ef 90       	pop	r14
    284e:	df 90       	pop	r13
    2850:	cf 90       	pop	r12
    2852:	bf 90       	pop	r11
    2854:	af 90       	pop	r10
    2856:	9f 90       	pop	r9
    2858:	8f 90       	pop	r8
    285a:	7f 90       	pop	r7
    285c:	6f 90       	pop	r6
    285e:	5f 90       	pop	r5
    2860:	4f 90       	pop	r4
    2862:	3f 90       	pop	r3
    2864:	2f 90       	pop	r2
    2866:	1f 90       	pop	r1
    2868:	0f 90       	pop	r0
    286a:	0f be       	out	0x3f, r0	; 63
    286c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    286e:	08 95       	ret

00002870 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2870:	0f 92       	push	r0
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	0f 92       	push	r0
    2878:	1f 92       	push	r1
    287a:	11 24       	eor	r1, r1
    287c:	2f 92       	push	r2
    287e:	3f 92       	push	r3
    2880:	4f 92       	push	r4
    2882:	5f 92       	push	r5
    2884:	6f 92       	push	r6
    2886:	7f 92       	push	r7
    2888:	8f 92       	push	r8
    288a:	9f 92       	push	r9
    288c:	af 92       	push	r10
    288e:	bf 92       	push	r11
    2890:	cf 92       	push	r12
    2892:	df 92       	push	r13
    2894:	ef 92       	push	r14
    2896:	ff 92       	push	r15
    2898:	0f 93       	push	r16
    289a:	1f 93       	push	r17
    289c:	2f 93       	push	r18
    289e:	3f 93       	push	r19
    28a0:	4f 93       	push	r20
    28a2:	5f 93       	push	r21
    28a4:	6f 93       	push	r22
    28a6:	7f 93       	push	r23
    28a8:	8f 93       	push	r24
    28aa:	9f 93       	push	r25
    28ac:	af 93       	push	r26
    28ae:	bf 93       	push	r27
    28b0:	cf 93       	push	r28
    28b2:	df 93       	push	r29
    28b4:	ef 93       	push	r30
    28b6:	ff 93       	push	r31
    28b8:	a0 91 47 01 	lds	r26, 0x0147
    28bc:	b0 91 48 01 	lds	r27, 0x0148
    28c0:	0d b6       	in	r0, 0x3d	; 61
    28c2:	0d 92       	st	X+, r0
    28c4:	0e b6       	in	r0, 0x3e	; 62
    28c6:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    28c8:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <vTaskIncrementTick>
	vTaskSwitchContext();
    28cc:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    28d0:	a0 91 47 01 	lds	r26, 0x0147
    28d4:	b0 91 48 01 	lds	r27, 0x0148
    28d8:	cd 91       	ld	r28, X+
    28da:	cd bf       	out	0x3d, r28	; 61
    28dc:	dd 91       	ld	r29, X+
    28de:	de bf       	out	0x3e, r29	; 62
    28e0:	ff 91       	pop	r31
    28e2:	ef 91       	pop	r30
    28e4:	df 91       	pop	r29
    28e6:	cf 91       	pop	r28
    28e8:	bf 91       	pop	r27
    28ea:	af 91       	pop	r26
    28ec:	9f 91       	pop	r25
    28ee:	8f 91       	pop	r24
    28f0:	7f 91       	pop	r23
    28f2:	6f 91       	pop	r22
    28f4:	5f 91       	pop	r21
    28f6:	4f 91       	pop	r20
    28f8:	3f 91       	pop	r19
    28fa:	2f 91       	pop	r18
    28fc:	1f 91       	pop	r17
    28fe:	0f 91       	pop	r16
    2900:	ff 90       	pop	r15
    2902:	ef 90       	pop	r14
    2904:	df 90       	pop	r13
    2906:	cf 90       	pop	r12
    2908:	bf 90       	pop	r11
    290a:	af 90       	pop	r10
    290c:	9f 90       	pop	r9
    290e:	8f 90       	pop	r8
    2910:	7f 90       	pop	r7
    2912:	6f 90       	pop	r6
    2914:	5f 90       	pop	r5
    2916:	4f 90       	pop	r4
    2918:	3f 90       	pop	r3
    291a:	2f 90       	pop	r2
    291c:	1f 90       	pop	r1
    291e:	0f 90       	pop	r0
    2920:	0f be       	out	0x3f, r0	; 63
    2922:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2924:	08 95       	ret

00002926 <__vector_11>:
    2926:	0e 94 38 14 	call	0x2870	; 0x2870 <vPortYieldFromTick>
    292a:	18 95       	reti

0000292c <main>:
extern xQueueHandle xCharsForTx; 

xQueueHandle xRoleta[2];

portSHORT main( void )
{
    292c:	cf 93       	push	r28
    292e:	df 93       	push	r29
//prvIncrementResetCount();

  hardwareInit();
    2930:	0e 94 3e 08 	call	0x107c	; 0x107c <hardwareInit>
  xSerialPortInitMinimal(16);
    2934:	80 e1       	ldi	r24, 0x10	; 16
    2936:	0e 94 7c 07 	call	0xef8	; 0xef8 <xSerialPortInitMinimal>

  xRoleta[0] = xQueueCreate(4, 1);
    293a:	61 e0       	ldi	r22, 0x01	; 1
    293c:	84 e0       	ldi	r24, 0x04	; 4
    293e:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueCreate>
    2942:	c2 ec       	ldi	r28, 0xC2	; 194
    2944:	d4 e0       	ldi	r29, 0x04	; 4
    2946:	99 83       	std	Y+1, r25	; 0x01
    2948:	88 83       	st	Y, r24
  xRoleta[1] = xQueueCreate(4, 1);
    294a:	61 e0       	ldi	r22, 0x01	; 1
    294c:	84 e0       	ldi	r24, 0x04	; 4
    294e:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <xQueueCreate>
    2952:	9b 83       	std	Y+3, r25	; 0x03
    2954:	8a 83       	std	Y+2, r24	; 0x02

  xCoRoutineCreate(vProtocol, 0, 0);
    2956:	40 e0       	ldi	r20, 0x00	; 0
    2958:	60 e0       	ldi	r22, 0x00	; 0
    295a:	8c ea       	ldi	r24, 0xAC	; 172
    295c:	91 e0       	ldi	r25, 0x01	; 1
    295e:	0e 94 38 11 	call	0x2270	; 0x2270 <xCoRoutineCreate>
  xCoRoutineCreate(vKlawisze, 0, 0);
    2962:	40 e0       	ldi	r20, 0x00	; 0
    2964:	60 e0       	ldi	r22, 0x00	; 0
    2966:	8a ee       	ldi	r24, 0xEA	; 234
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	0e 94 38 11 	call	0x2270	; 0x2270 <xCoRoutineCreate>
  xCoRoutineCreate(vRoleta, 0, 0);
    296e:	40 e0       	ldi	r20, 0x00	; 0
    2970:	60 e0       	ldi	r22, 0x00	; 0
    2972:	83 e5       	ldi	r24, 0x53	; 83
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	0e 94 38 11 	call	0x2270	; 0x2270 <xCoRoutineCreate>
  xCoRoutineCreate(vRoleta, 0, 1);
    297a:	41 e0       	ldi	r20, 0x01	; 1
    297c:	60 e0       	ldi	r22, 0x00	; 0
    297e:	83 e5       	ldi	r24, 0x53	; 83
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	0e 94 38 11 	call	0x2270	; 0x2270 <xCoRoutineCreate>

  vTaskStartScheduler();
    2986:	0e 94 a7 0a 	call	0x154e	; 0x154e <vTaskStartScheduler>
  return 0;
}
    298a:	80 e0       	ldi	r24, 0x00	; 0
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	08 95       	ret

00002994 <memcpy>:
    2994:	fb 01       	movw	r30, r22
    2996:	dc 01       	movw	r26, r24
    2998:	02 c0       	rjmp	.+4      	; 0x299e <memcpy+0xa>
    299a:	01 90       	ld	r0, Z+
    299c:	0d 92       	st	X+, r0
    299e:	41 50       	subi	r20, 0x01	; 1
    29a0:	50 40       	sbci	r21, 0x00	; 0
    29a2:	d8 f7       	brcc	.-10     	; 0x299a <memcpy+0x6>
    29a4:	08 95       	ret

000029a6 <memset>:
    29a6:	dc 01       	movw	r26, r24
    29a8:	01 c0       	rjmp	.+2      	; 0x29ac <memset+0x6>
    29aa:	6d 93       	st	X+, r22
    29ac:	41 50       	subi	r20, 0x01	; 1
    29ae:	50 40       	sbci	r21, 0x00	; 0
    29b0:	e0 f7       	brcc	.-8      	; 0x29aa <memset+0x4>
    29b2:	08 95       	ret

000029b4 <_exit>:
    29b4:	f8 94       	cli

000029b6 <__stop_program>:
    29b6:	ff cf       	rjmp	.-2      	; 0x29b6 <__stop_program>
