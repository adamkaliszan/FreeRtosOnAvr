   1               		.file	"vty.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 275               	enableFunction:
 276               		.stabd	46,0,0
   1:vty.c         **** #include "main.h"
   2:vty.c         **** #include "vty.h"
   3:vty.c         **** #include "ramdysk.h"
   4:vty.c         **** #include "protocol1.h"
   5:vty.c         **** #include "mpc23s17.h"
   6:vty.c         **** #include "mcp3008.h"
   7:vty.c         **** #include "ds1305.h"
   8:vty.c         **** #include "hardwareConfig.h"
   9:vty.c         **** #include "configuration.h"
  10:vty.c         **** #include "Rs485_prot.h"
  11:vty.c         **** #include "net.h"
  12:vty.c         **** #include "ip.h"
  13:vty.c         **** #include "arp.h"
  14:vty.c         **** #include "softwareConfig.h"
  15:vty.c         **** #include "mcp4150.h"
  16:vty.c         **** 
  17:vty.c         **** #if LANG_EN
  18:vty.c         **** #include "vty_en.h"
  19:vty.c         **** #endif
  20:vty.c         **** 
  21:vty.c         **** #if LANG_PL
  22:vty.c         **** #include "vty_pl.h"
  23:vty.c         **** #endif
  24:vty.c         **** 
  25:vty.c         **** #ifndef LANG_VTY
  26:vty.c         **** #error "Vty Language not defined"
  27:vty.c         **** #endif
  28:vty.c         **** 
  29:vty.c         **** 
  30:vty.c         **** static cliExRes_t helpFunction           (cmdState_t *state);
  31:vty.c         **** static cliExRes_t statusFunction         (cmdState_t *state);
  32:vty.c         **** static cliExRes_t statusEncFunction      (cmdState_t *state);
  33:vty.c         **** static cliExRes_t curtainDownFunction    (cmdState_t *state);
  34:vty.c         **** static cliExRes_t curtainUpFunction      (cmdState_t *state);
  35:vty.c         **** static cliExRes_t rpingFunction          (cmdState_t *state);
  36:vty.c         **** static cliExRes_t pingFunction           (cmdState_t *state);
  37:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state);
  38:vty.c         **** static cliExRes_t goXmodemWyslijFunction (cmdState_t *state);
  39:vty.c         **** static cliExRes_t dodajRamPlikFunction   (cmdState_t *state);
  40:vty.c         **** static cliExRes_t eraseRamFileFunction   (cmdState_t *state);
  41:vty.c         **** static cliExRes_t flashExModuleFunction  (cmdState_t *state);
  42:vty.c         **** static cliExRes_t writeRamFileFunction   (cmdState_t *state);
  43:vty.c         **** static cliExRes_t editRamFileFunction    (cmdState_t *state);
  44:vty.c         **** static cliExRes_t readRamFIleFunction    (cmdState_t *state);
  45:vty.c         **** 
  46:vty.c         **** static cliExRes_t ustawPortExtAFunction  (cmdState_t *state);
  47:vty.c         **** static cliExRes_t ustawPortExtBFunction  (cmdState_t *state);
  48:vty.c         **** static cliExRes_t ustawPortRezystor      (cmdState_t *state);
  49:vty.c         **** 
  50:vty.c         **** static cliExRes_t ustawModWykFunction    (cmdState_t *state);
  51:vty.c         **** static cliExRes_t zapiszModWykFunction   (cmdState_t *state);
  52:vty.c         **** 
  53:vty.c         **** static cliExRes_t pokazCzasFunction      (cmdState_t *state);
  54:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state);
  55:vty.c         **** static cliExRes_t czytajAC_Function      (cmdState_t *state);
  56:vty.c         **** 
  57:vty.c         **** static cliExRes_t enableFunction         (cmdState_t *state);
  58:vty.c         **** static cliExRes_t disableFunction        (cmdState_t *state);
  59:vty.c         **** static cliExRes_t configureModeFunction  (cmdState_t *state);
  60:vty.c         **** 
  61:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state);
  62:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state);
  63:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state);
  64:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state);
  65:vty.c         **** 
  66:vty.c         **** static cliExRes_t setMacAddrFunction     (cmdState_t *state);
  67:vty.c         **** static cliExRes_t setTimeFunction        (cmdState_t *state);
  68:vty.c         **** 
  69:vty.c         **** static cliExRes_t saveConfigFunction     (cmdState_t *state);
  70:vty.c         **** 
  71:vty.c         **** #ifdef testZewPamiec
  72:vty.c         **** static cliExRes_t testPamZewFunction     (cmdState_t *state);
  73:vty.c         **** #endif
  74:vty.c         **** 
  75:vty.c         **** struct ramPlikFd    fdVty;  //TODO move it to CLI struct
  76:vty.c         **** 
  77:vty.c         **** const char okStr[]                        PROGMEM = "OK\r\n";
  78:vty.c         **** const char nlStr[]                        PROGMEM = "\r\n";
  79:vty.c         **** const char BladBuforaPozostaloBajtowStr[] PROGMEM = "!!! W budorze Rs485 pozostalo %d bajtow\r\n";
  80:vty.c         **** 
  81:vty.c         **** 
  82:vty.c         **** const  char * const errorStrings[] PROGMEM = {
  83:vty.c         ****   errorOK,
  84:vty.c         ****   errorNoFile,
  85:vty.c         ****   errorxModemFrameStartTimeout,
  86:vty.c         ****   errorxModemByteSendTimeout,
  87:vty.c         ****   errorxModemWrongFrameNo,
  88:vty.c         ****   errorxModemFrameFrameNoCorrectionNotMatch,
  89:vty.c         ****   errorxModemFrameCrc,
  90:vty.c         ****   errorxModemRemoteSideCan,
  91:vty.c         ****   errorxModemUnknownResponse,
  92:vty.c         ****   errorNoRemoteDevice,
  93:vty.c         ****   errorBootloaderNotResponding,
  94:vty.c         ****   errorOpenFile
  95:vty.c         **** };
  96:vty.c         **** 
  97:vty.c         **** const command_t cmdListNormal[] PROGMEM =
  98:vty.c         **** {
  99:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
 100:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
 101:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},
 102:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 103:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 104:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 105:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 106:vty.c         ****   {cmd_enable,    cmd_help_enable,    enableFunction},
 107:vty.c         ****   {NULL, NULL, NULL}
 108:vty.c         **** };
 109:vty.c         **** 
 110:vty.c         **** const command_t cmdListEnable[] PROGMEM =
 111:vty.c         **** {
 112:vty.c         ****   {cmd_help,      cmd_help_help,      helpFunction},
 113:vty.c         ****   {cmd_status,    cmd_help_status,    statusFunction},
 114:vty.c         ****   {cmd_enc_stat,  cmd_help_enc_stat,  statusEncFunction},
 115:vty.c         ****   {cmd_time,      cmd_help_time,      pokazCzasFunction},
 116:vty.c         ****   {cmd_net_dbg,   cmd_help_net_dbg,   debugFunction},
 117:vty.c         **** 
 118:vty.c         ****   {cmd_rping,     cmd_help_rping,     rpingFunction},
 119:vty.c         ****   {cmd_ping,      cmd_help_ping,      pingFunction},
 120:vty.c         ****   {cmd_xRec,      cmd_help_xRec,      goXmodemOdbierzFunction},
 121:vty.c         ****   {cmd_xSend,     cmd_help_xSend,     goXmodemWyslijFunction},
 122:vty.c         ****   {cmd_xflash,    cmd_help_xflash,    flashExModuleFunction},
 123:vty.c         **** #ifdef testZewPamiec
 124:vty.c         ****   {cmd_rtest,     cmd_help_rtest,     testPamZewFunction},
 125:vty.c         **** #endif
 126:vty.c         ****   {cmd_dir_rf,    cmd_help_dir_rf,    writeRamFileFunction},
 127:vty.c         ****   {cmd_create_rf, cmd_help_create_rf, dodajRamPlikFunction},
 128:vty.c         ****   {cmd_erase_rf,  cmd_help_erase_rf,  eraseRamFileFunction},
 129:vty.c         ****   {cmd_edit_rf,   cmd_help_edit_rf,   editRamFileFunction},
 130:vty.c         ****   {cmd_read_rf,   cmd_help_read_rf,   readRamFIleFunction},
 131:vty.c         **** 
 132:vty.c         ****   {cmd_up,        cmd_help_up,        curtainUpFunction},
 133:vty.c         ****   {cmd_down,      cmd_help_down,      curtainDownFunction},
 134:vty.c         **** 
 135:vty.c         ****   {cmd_spa,       cmd_help_spa,       ustawPortExtAFunction},
 136:vty.c         ****   {cmd_spb,       cmd_help_spb,       ustawPortExtBFunction},
 137:vty.c         ****   {cmd_ustawR,    cmd_help_ustawR,    ustawPortRezystor},
 138:vty.c         ****   {cmd_settime,   cmd_help_settime,   setTimeFunction},
 139:vty.c         ****   {cmd_ac,        cmd_help_ac,        czytajAC_Function},
 140:vty.c         ****   {cmd_disable,   cmd_help_disable,   disableFunction},
 141:vty.c         ****   {cmd_configure, cmd_help_configure, configureModeFunction},
 142:vty.c         ****   {cmd_ustawMW,   cmd_help_ustawMW,   ustawModWykFunction},
 143:vty.c         ****   {cmd_zapiszMW,  cmd_help_zapiszMW,  zapiszModWykFunction},
 144:vty.c         ****   {NULL, NULL, NULL}
 145:vty.c         **** };
 146:vty.c         **** 
 147:vty.c         **** const command_t cmdListConfigure[] PROGMEM =
 148:vty.c         **** {
 149:vty.c         ****   {cmd_help,         cmd_help_help,         helpFunction},
 150:vty.c         ****   {cmd_status,       cmd_help_status,       statusFunction},
 151:vty.c         ****   {cmd_time,         cmd_help_time,         pokazCzasFunction},
 152:vty.c         ****   {cmd_settime,      cmd_help_settime,      setTimeFunction},
 153:vty.c         ****   {cmd_conf_ip,      cmd_help_conf_ip,      setIpFunction},
 154:vty.c         ****   {cmd_conf_ip_mask, cmd_conf_ip_mask_help, setIpMaskFunction},
 155:vty.c         ****   {cmd_conf_ip_gw,   cmd_conf_ip_gw_help,   setIpGwFunction},
 156:vty.c         ****   {cmd_conf_udp,     cmd_help_conf_udp,     setUdpFunction},
 157:vty.c         ****   {cmd_conf_mac,     cmd_help_conf_mac,     setMacAddrFunction},
 158:vty.c         ****   {cmd_conf_save,    cmd_help_conf_save,    saveConfigFunction},
 159:vty.c         ****   {cmd_enable,       cmd_help_enable,       enableFunction},
 160:vty.c         ****   {cmd_disable,      cmd_help_disable,      disableFunction},
 161:vty.c         ****   {NULL, NULL, NULL}
 162:vty.c         **** };
 163:vty.c         **** 
 164:vty.c         **** void VtyInit(cmdState_t* state, FILE *stream)
 165:vty.c         **** {
 166:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 167:vty.c         **** }
 168:vty.c         **** 
 169:vty.c         **** void printErrorInfo(cmdState_t *state)
 170:vty.c         **** {
 171:vty.c         ****   if (state->errno != 0)
 172:vty.c         ****   {
 173:vty.c         ****     fprintf_P(state->myStdInOut, (const char*)(pgm_read_word(errorStrings + state->errno)), state->
 174:vty.c         ****   }
 175:vty.c         ****   state->errno = 0;
 176:vty.c         ****   state->err1 = 0;
 177:vty.c         ****   state->err2 = 0;
 178:vty.c         **** }
 179:vty.c         **** 
 180:vty.c         **** static cliExRes_t enableFunction(cmdState_t *state)
 181:vty.c         **** {
 278               	.LM0:
 279               	.LFBB1:
 280               	/* prologue: function */
 281               	/* frame size = 0 */
 282               	/* stack size = 0 */
 283               	.L__stack_usage = 0
 284 0000 FC01      		movw r30,r24
 182:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 286               	.LM1:
 287 0002 80A1      		ldd r24,Z+32
 288 0004 8330      		cpi r24,lo8(3)
 289 0006 01F0      		breq .L3
 183:vty.c         ****   {
 184:vty.c         ****     state->cmdList = cmdListEnable;
 291               	.LM2:
 292 0008 80E0      		ldi r24,lo8(cmdListEnable)
 293 000a 90E0      		ldi r25,hi8(cmdListEnable)
 294 000c 92A3      		std Z+34,r25
 295 000e 81A3      		std Z+33,r24
 185:vty.c         ****     state->cliMode = NR_ENABLE;
 297               	.LM3:
 298 0010 81E0      		ldi r24,lo8(1)
 299 0012 80A3      		std Z+32,r24
 186:vty.c         ****     return OK_SILENT;
 301               	.LM4:
 302 0014 80E0      		ldi r24,0
 303 0016 90E0      		ldi r25,0
 304 0018 0895      		ret
 305               	.L3:
 187:vty.c         ****   }
 188:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 307               	.LM5:
 308 001a 85E0      		ldi r24,lo8(5)
 309 001c 90E0      		ldi r25,0
 189:vty.c         **** }
 311               	.LM6:
 312 001e 0895      		ret
 314               	.Lscope1:
 316               		.stabd	78,0,0
 320               	disableFunction:
 321               		.stabd	46,0,0
 190:vty.c         **** static cliExRes_t disableFunction(cmdState_t *state)
 191:vty.c         **** {
 323               	.LM7:
 324               	.LFBB2:
 325               	/* prologue: function */
 326               	/* frame size = 0 */
 327               	/* stack size = 0 */
 328               	.L__stack_usage = 0
 329 0020 FC01      		movw r30,r24
 192:vty.c         ****   state->cmdList = cmdListNormal;
 331               	.LM8:
 332 0022 80E0      		ldi r24,lo8(cmdListNormal)
 333 0024 90E0      		ldi r25,hi8(cmdListNormal)
 334 0026 92A3      		std Z+34,r25
 335 0028 81A3      		std Z+33,r24
 193:vty.c         ****   if (state->cliMode != RESTRICTED_NORMAL)
 337               	.LM9:
 338 002a 80A1      		ldd r24,Z+32
 339 002c 8330      		cpi r24,lo8(3)
 340 002e 01F0      		breq .L6
 194:vty.c         ****   {
 195:vty.c         ****     state->cliMode = NR_NORMAL;
 342               	.LM10:
 343 0030 10A2      		std Z+32,__zero_reg__
 344               	.L6:
 196:vty.c         ****   }
 197:vty.c         ****   return OK_SILENT;
 198:vty.c         **** }
 346               	.LM11:
 347 0032 80E0      		ldi r24,0
 348 0034 90E0      		ldi r25,0
 349 0036 0895      		ret
 351               	.Lscope2:
 353               		.stabd	78,0,0
 357               	configureModeFunction:
 358               		.stabd	46,0,0
 199:vty.c         **** static cliExRes_t configureModeFunction(cmdState_t *state)
 200:vty.c         **** {
 360               	.LM12:
 361               	.LFBB3:
 362               	/* prologue: function */
 363               	/* frame size = 0 */
 364               	/* stack size = 0 */
 365               	.L__stack_usage = 0
 366 0038 FC01      		movw r30,r24
 201:vty.c         ****   if (state->cliMode == NR_ENABLE)
 368               	.LM13:
 369 003a 80A1      		ldd r24,Z+32
 370 003c 8130      		cpi r24,lo8(1)
 371 003e 01F4      		brne .L12
 202:vty.c         ****   {
 203:vty.c         ****     state->cmdList = cmdListConfigure;
 373               	.LM14:
 374 0040 80E0      		ldi r24,lo8(cmdListConfigure)
 375 0042 90E0      		ldi r25,hi8(cmdListConfigure)
 376 0044 92A3      		std Z+34,r25
 377 0046 81A3      		std Z+33,r24
 204:vty.c         ****     state->cliMode = NR_CONFIGURE;
 379               	.LM15:
 380 0048 82E0      		ldi r24,lo8(2)
 381 004a 80A3      		std Z+32,r24
 205:vty.c         ****     return OK_SILENT;
 383               	.LM16:
 384 004c 80E0      		ldi r24,0
 385 004e 90E0      		ldi r25,0
 386 0050 0895      		ret
 387               	.L12:
 206:vty.c         ****   }
 207:vty.c         ****   return ERROR_OPERATION_NOT_ALLOWED;
 389               	.LM17:
 390 0052 85E0      		ldi r24,lo8(5)
 391 0054 90E0      		ldi r25,0
 208:vty.c         **** }
 393               	.LM18:
 394 0056 0895      		ret
 396               	.Lscope3:
 398               		.stabd	78,0,0
 402               	pingFunction:
 403               		.stabd	46,0,0
 209:vty.c         **** 
 210:vty.c         **** // ************************** VTY API *************************************************************
 211:vty.c         **** void printStatus(FILE *stream)
 212:vty.c         **** {
 213:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n"));
 214:vty.c         ****   //Print system state
 215:vty.c         ****   fprintf_P(stream, systemStateStr);
 216:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 217:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 218:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 219:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature);
 220:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage);
 221:vty.c         **** 
 222:vty.c         ****   uint8_t tmp = ramDyskLiczbaWolnychKlastrow();
 223:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 224:vty.c         **** //  printErrorInfo(state); //TODO fix and uncomment
 225:vty.c         **** 
 226:vty.c         ****   //Print system configuration
 227:vty.c         ****   fprintf_P(stream, systemRamConfigStr);
 228:vty.c         **** 
 229:vty.c         ****   fprintf_P(stream, statusMacStr);
 230:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 231:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 232:vty.c         **** 
 233:vty.c         ****   fprintf_P(stream, statusIpStr);
 234:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 235:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 236:vty.c         **** 
 237:vty.c         ****   fprintf_P(stream, statusIpMaskStr);
 238:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 239:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 240:vty.c         **** 
 241:vty.c         ****   fprintf_P(stream, statusIpGwStr);
 242:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 243:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 244:vty.c         **** 
 245:vty.c         ****   //Print Rs485 Execitive modules
 246:vty.c         ****   fprintf_P(stream, statusRs485listStr);
 247:vty.c         **** //  tmp = printRs485devices(stream);
 248:vty.c         **** //  if (tmp == 0)
 249:vty.c         **** //    fprintf_P(stream, statusNoRs485Dev);
 250:vty.c         **** 
 251:vty.c         ****   //Print locker sensors
 252:vty.c         ****   fprintf_P(stream, statusLockerSensorsStr);
 253:vty.c         ****   tmp = printLockers(stream);
 254:vty.c         ****   if (tmp == 0)
 255:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 256:vty.c         **** 
 257:vty.c         ****   //Print time FIXME deadlock problem
 258:vty.c         **** /*  readTimeDecoded((timeDecoded_t *)(&czasRtc));
 259:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
 260:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 261:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 262:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("%d:%d:%d\r\n"), godzina, minuta, sekunda);*/
 263:vty.c         **** 
 264:vty.c         ****   udpPrintStatus(stream);
 265:vty.c         **** //  arpPrintTable(stream);
 266:vty.c         **** }
 267:vty.c         **** 
 268:vty.c         **** 
 269:vty.c         **** // ************************** CLI Functions *******************************************************
 270:vty.c         **** 
 271:vty.c         **** static cliExRes_t statusFunction(cmdState_t *state)
 272:vty.c         **** {
 273:vty.c         ****   if (state->argc < 1)
 274:vty.c         ****   {
 275:vty.c         ****     printStatus(state->myStdInOut);
 276:vty.c         ****     return OK_SILENT;
 277:vty.c         ****   }
 278:vty.c         **** 
 279:vty.c         ****   FILE stream;
 280:vty.c         ****   if (ramDyskOtworzPlikStdIo(cmdlineGetArgStr(1, state), &fdVty, &stream, __SWR | __SRD) != 0)
 281:vty.c         ****   {
 282:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 283:vty.c         ****     return ERROR_INFORM;
 284:vty.c         ****   }
 285:vty.c         **** 
 286:vty.c         ****   printStatus(&stream);
 287:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 288:vty.c         ****   return OK_SILENT;
 289:vty.c         **** }
 290:vty.c         **** 
 291:vty.c         **** static cliExRes_t statusEncFunction(cmdState_t *state)
 292:vty.c         **** {
 293:vty.c         ****   nicRegDump(state->myStdInOut);
 294:vty.c         ****   return OK_SILENT;
 295:vty.c         **** }
 296:vty.c         **** 
 297:vty.c         **** static cliExRes_t pokazCzasFunction(cmdState_t *state)
 298:vty.c         **** {
 299:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 300:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
 301:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 302:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 303:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 304:vty.c         ****   return OK_SILENT;
 305:vty.c         **** }
 306:vty.c         **** 
 307:vty.c         **** static cliExRes_t debugFunction          (cmdState_t *state)
 308:vty.c         **** {
 309:vty.c         ****   if (state->argc < 2)
 310:vty.c         ****     return SYNTAX_ERROR;
 311:vty.c         **** 
 312:vty.c         ****   uint8_t level = cmdlineGetArgInt(2, state);
 313:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 314:vty.c         ****   if (level == 0)
 315:vty.c         ****   {
 316:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 317:vty.c         ****     {
 318:vty.c         ****       setArpDebug(NULL, 0);
 319:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 320:vty.c         ****       return OK_SILENT;
 321:vty.c         ****     }
 322:vty.c         **** 
 323:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 324:vty.c         ****     {
 325:vty.c         ****       setIpDebug(NULL, 0);
 326:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 327:vty.c         ****       return OK_SILENT;
 328:vty.c         ****     }
 329:vty.c         **** 
 330:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 331:vty.c         ****     {
 332:vty.c         ****       setIcmpDebug(NULL, 0);
 333:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 334:vty.c         ****       return OK_SILENT;
 335:vty.c         ****     }
 336:vty.c         **** 
 337:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 338:vty.c         ****     {
 339:vty.c         ****       setTcpDebug(NULL, 0);
 340:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 341:vty.c         ****       return OK_SILENT;
 342:vty.c         ****     }
 343:vty.c         **** 
 344:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 345:vty.c         ****     {
 346:vty.c         ****       setUdpDebug(NULL, 0);
 347:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 348:vty.c         ****       return OK_SILENT;
 349:vty.c         ****     }
 350:vty.c         **** 
 351:vty.c         **** 
 352:vty.c         ****   }
 353:vty.c         ****   else                   //level > 0
 354:vty.c         ****   {
 355:vty.c         ****     if (strncmp_P(str, PSTR("arp"), 3) == 0)
 356:vty.c         ****     {
 357:vty.c         ****       setArpDebug(state->myStdInOut, level);
 358:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 359:vty.c         ****       return OK_SILENT;
 360:vty.c         ****     }
 361:vty.c         **** 
 362:vty.c         ****     if (strncmp_P(str, PSTR("ip"), 2) == 0)
 363:vty.c         ****     {
 364:vty.c         ****       setIpDebug(state->myStdInOut, level);
 365:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 366:vty.c         ****       return OK_SILENT;
 367:vty.c         ****     }
 368:vty.c         **** 
 369:vty.c         ****     if (strncmp_P(str, PSTR("icmp"), 2) == 0)
 370:vty.c         ****     {
 371:vty.c         ****       setIcmpDebug(state->myStdInOut, level);
 372:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 373:vty.c         ****       return OK_SILENT;
 374:vty.c         ****     }
 375:vty.c         **** 
 376:vty.c         ****     if (strncmp_P(str, PSTR("tcp"), 2) == 0)
 377:vty.c         ****     {
 378:vty.c         ****       setTcpDebug(state->myStdInOut, level);
 379:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 380:vty.c         ****       return OK_SILENT;
 381:vty.c         ****     }
 382:vty.c         **** 
 383:vty.c         ****     if (strncmp_P(str, PSTR("udp"), 2) == 0)
 384:vty.c         ****     {
 385:vty.c         ****       setUdpDebug(state->myStdInOut, level);
 386:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 387:vty.c         ****       return OK_SILENT;
 388:vty.c         ****     }
 389:vty.c         ****   }
 390:vty.c         **** 
 391:vty.c         ****   return SYNTAX_ERROR;
 392:vty.c         **** }
 393:vty.c         **** 
 394:vty.c         **** 
 395:vty.c         **** static cliExRes_t setTimeFunction(cmdState_t *state)
 396:vty.c         **** {
 397:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 398:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 399:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 400:vty.c         **** 
 401:vty.c         ****   ds1305start();
 402:vty.c         **** 
 403:vty.c         ****   uint8_t cDzies = godzina/10;
 404:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 405:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 406:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 407:vty.c         **** 
 408:vty.c         ****   cDzies = minuta/10;
 409:vty.c         ****   cJedn = minuta - cDzies * 10;
 410:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 411:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 412:vty.c         **** 
 413:vty.c         ****   cDzies = sekunda/10;
 414:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 415:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 416:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 417:vty.c         **** 
 418:vty.c         ****   setTimeDecoded((timeDecoded_t *)(&czasRtc));
 419:vty.c         ****   return OK_SILENT;
 420:vty.c         **** }
 421:vty.c         **** 
 422:vty.c         **** static cliExRes_t setIpFunction(cmdState_t *state)
 423:vty.c         **** {
 424:vty.c         ****   if (state->argc < 4)
 425:vty.c         ****     return SYNTAX_ERROR;
 426:vty.c         **** 
 427:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) +
 428:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 429:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 430:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 431:vty.c         **** 
 432:vty.c         ****   ipSetConfigIp(ip);
 433:vty.c         ****   return OK_SILENT;
 434:vty.c         **** }
 435:vty.c         **** 
 436:vty.c         **** static cliExRes_t setUdpFunction(cmdState_t *state)
 437:vty.c         **** {
 438:vty.c         ****   if (state->argc < 5)
 439:vty.c         ****     return SYNTAX_ERROR;
 440:vty.c         **** 
 441:vty.c         ****   uint32_t ip = cmdlineGetArgInt(1, state) +
 442:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 443:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 444:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 445:vty.c         ****   udpSocket->dstIp = ip;
 446:vty.c         **** 
 447:vty.c         ****   uint16_t port = cmdlineGetArgInt(5, state);
 448:vty.c         ****   udpSocket->srcPort = htons(port);
 449:vty.c         **** 
 450:vty.c         ****   if (state->argc > 5)
 451:vty.c         ****   {
 452:vty.c         ****     port = cmdlineGetArgInt(6, state);
 453:vty.c         ****     udpSocket->dstPort = htons(port);
 454:vty.c         ****   }
 455:vty.c         ****   return OK_SILENT;
 456:vty.c         **** }
 457:vty.c         **** 
 458:vty.c         **** 
 459:vty.c         **** static cliExRes_t setIpMaskFunction(cmdState_t *state)
 460:vty.c         **** {
 461:vty.c         ****   if (state->argc < 1)
 462:vty.c         ****     return SYNTAX_ERROR;
 463:vty.c         **** 
 464:vty.c         ****   uint32_t mask = ((uint32_t)(0xFFFFFFFF))>>(32-cmdlineGetArgInt(1, state));
 465:vty.c         **** 
 466:vty.c         ****   ipSetConfigMask(mask);
 467:vty.c         ****   return OK_SILENT;
 468:vty.c         **** }
 469:vty.c         **** 
 470:vty.c         **** 
 471:vty.c         **** static cliExRes_t setIpGwFunction(cmdState_t *state)
 472:vty.c         **** {
 473:vty.c         ****   if (state->argc < 4)
 474:vty.c         ****     return SYNTAX_ERROR;
 475:vty.c         **** 
 476:vty.c         ****   uint32_t gw = cmdlineGetArgInt(1, state) +
 477:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 478:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 479:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 480:vty.c         ****   ipSetConfigGw(gw);
 481:vty.c         ****   return OK_SILENT;
 482:vty.c         **** }
 483:vty.c         **** 
 484:vty.c         **** static cliExRes_t ustawModWykFunction(cmdState_t *state)
 485:vty.c         **** {
 486:vty.c         ****   if (state->argc < 2)
 487:vty.c         ****     return SYNTAX_ERROR;
 488:vty.c         **** 
 489:vty.c         ****   uint8_t adres =   cmdlineGetArgInt(1, state);
 490:vty.c         ****   uint8_t wartosc = cmdlineGetArgHex(2, state);
 491:vty.c         **** 
 492:vty.c         ****   sendSettings(adres, wartosc);
 493:vty.c         **** 
 494:vty.c         ****   return OK_SILENT;
 495:vty.c         **** }
 496:vty.c         **** static cliExRes_t zapiszModWykFunction(cmdState_t *state)
 497:vty.c         **** {
 498:vty.c         ****   if (state->argc < 1)
 499:vty.c         ****     return SYNTAX_ERROR;
 500:vty.c         **** 
 501:vty.c         ****   uint8_t adres =  cmdlineGetArgInt(1, state);
 502:vty.c         ****   saveSettings(adres);
 503:vty.c         ****   return OK_SILENT;
 504:vty.c         **** }
 505:vty.c         **** 
 506:vty.c         **** static cliExRes_t setMacAddrFunction(cmdState_t *state)
 507:vty.c         **** {
 508:vty.c         ****   if (state->argc < 6)
 509:vty.c         ****     return SYNTAX_ERROR;
 510:vty.c         **** 
 511:vty.c         ****   nicState.mac.addr[0] = cmdlineGetArgHex(1, state);
 512:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 513:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 514:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 515:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 516:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 517:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 518:vty.c         ****   return OK_SILENT;
 519:vty.c         **** }
 520:vty.c         **** 
 521:vty.c         **** static cliExRes_t czytajAC_Function(cmdState_t *state)
 522:vty.c         **** {
 523:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 524:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 525:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);
 526:vty.c         ****   return OK_SILENT;
 527:vty.c         **** }
 528:vty.c         **** 
 529:vty.c         **** static cliExRes_t helpFunction(cmdState_t *state)
 530:vty.c         **** {
 531:vty.c         ****   cmdPrintHelp(state);
 532:vty.c         ****   return OK_SILENT;
 533:vty.c         **** }
 534:vty.c         **** 
 535:vty.c         **** static cliExRes_t curtainDownFunction(cmdState_t *state)
 536:vty.c         **** {
 537:vty.c         ****   uint8_t nrRolety;
 538:vty.c         ****   uint8_t nrSterownika;
 539:vty.c         ****   uint8_t wartosc;
 540:vty.c         **** 
 541:vty.c         ****   nrSterownika = cmdlineGetArgInt(1, state);
 542:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 543:vty.c         ****   nrRolety &= 0x01;
 544:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 545:vty.c         **** 
 546:vty.c         ****   fprintf_P(state->myStdInOut,movingCurtainDownStr, nrSterownika, nrRolety+1);
 547:vty.c         **** 
 548:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 549:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 550:vty.c         **** 
 551:vty.c         ****   uint8_t result = rs485curtainDown(nrSterownika, nrRolety, wartosc);
 552:vty.c         **** 
 553:vty.c         ****   if (result == 0)
 554:vty.c         ****     return OK_INFORM;
 555:vty.c         **** 
 556:vty.c         ****   return ERROR_SILENT;
 557:vty.c         **** }
 558:vty.c         **** 
 559:vty.c         **** static cliExRes_t curtainUpFunction(cmdState_t *state)
 560:vty.c         **** {
 561:vty.c         ****   if (state->argc < 2)
 562:vty.c         ****     return SYNTAX_ERROR;
 563:vty.c         **** 
 564:vty.c         ****   uint8_t nrSterownika = (cmdlineGetArgInt(1, state) & 0x3F);
 565:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 566:vty.c         ****   uint8_t wartosc = 255;
 567:vty.c         ****   if (state->argc > 2)
 568:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 569:vty.c         **** 
 570:vty.c         ****   fprintf_P(state->myStdInOut,   movingCurtainUpStr, nrSterownika, nrRolety+1);
 571:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 572:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 573:vty.c         **** 
 574:vty.c         ****   uint8_t result = rs485curtainUp(nrSterownika, nrRolety, wartosc);
 575:vty.c         **** 
 576:vty.c         ****   if (result == 0)
 577:vty.c         ****     return OK_INFORM;
 578:vty.c         **** 
 579:vty.c         ****   return ERROR_SILENT;
 580:vty.c         **** }
 581:vty.c         **** 
 582:vty.c         **** static cliExRes_t ustawPortExtAFunction(cmdState_t *state)
 583:vty.c         **** {
 584:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 585:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 586:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 587:vty.c         ****   return OK_SILENT;
 588:vty.c         **** }
 589:vty.c         **** 
 590:vty.c         **** static cliExRes_t ustawPortExtBFunction(cmdState_t *state)
 591:vty.c         **** {
 592:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 593:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 594:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 595:vty.c         ****   return OK_SILENT;
 596:vty.c         **** }
 597:vty.c         **** 
 598:vty.c         **** static cliExRes_t ustawPortRezystor(cmdState_t *state)
 599:vty.c         **** {
 600:vty.c         ****   if (state->argc < 1)
 601:vty.c         ****     return SYNTAX_ERROR;
 602:vty.c         **** 
 603:vty.c         ****   uint8_t wartosc = cmdlineGetArgInt(1, state);
 604:vty.c         **** 
 605:vty.c         ****   MCP4150_setValue(wartosc);
 606:vty.c         **** 
 607:vty.c         ****   return OK_SILENT;
 608:vty.c         **** }
 609:vty.c         **** 
 610:vty.c         **** static cliExRes_t rpingFunction(cmdState_t *state)
 611:vty.c         **** {
 612:vty.c         ****   if (state->argc < 1)
 613:vty.c         ****     return SYNTAX_ERROR;
 614:vty.c         **** 
 615:vty.c         ****   uint8_t nrSterownika = (uint8_t)(cmdlineGetArgInt(1, state));
 616:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 617:vty.c         ****     return OK_INFORM;
 618:vty.c         **** 
 619:vty.c         ****   state->errno = noRemoteDevice;
 620:vty.c         ****   state->err1 = nrSterownika;
 621:vty.c         ****   printErrorInfo(state);
 622:vty.c         ****   return OK_SILENT;
 623:vty.c         **** }
 624:vty.c         **** 
 625:vty.c         **** static cliExRes_t pingFunction(cmdState_t *state)
 626:vty.c         **** {
 405               	.LM19:
 406               	.LFBB4:
 407               	/* prologue: function */
 408               	/* frame size = 0 */
 409               	/* stack size = 0 */
 410               	.L__stack_usage = 0
 627:vty.c         ****   if (state->argc < 4)
 412               	.LM20:
 413 0058 FC01      		movw r30,r24
 414 005a 818D      		ldd r24,Z+25
 415 005c 8430      		cpi r24,lo8(4)
 416 005e 00F0      		brlo .L15
 628:vty.c         ****     return SYNTAX_ERROR;
 629:vty.c         **** 
 630:vty.c         ****   //uint8_t ip[4];
 631:vty.c         ****   //ip[0] = (uint8_t)(cmdlineGetArgInt(1, state));
 632:vty.c         ****   //ip[1] = (uint8_t)(cmdlineGetArgInt(2, state));
 633:vty.c         ****   //ip[2] = (uint8_t)(cmdlineGetArgInt(3, state));
 634:vty.c         ****   //ip[3] = (uint8_t)(cmdlineGetArgInt(4, state));
 635:vty.c         ****   //Ipv4Ping(*((uint32_t *)(ip)));
 636:vty.c         **** 
 637:vty.c         ****   return OK_SILENT;
 418               	.LM21:
 419 0060 80E0      		ldi r24,0
 420 0062 90E0      		ldi r25,0
 421 0064 0895      		ret
 422               	.L15:
 628:vty.c         ****     return SYNTAX_ERROR;
 424               	.LM22:
 425 0066 82E0      		ldi r24,lo8(2)
 426 0068 90E0      		ldi r25,0
 638:vty.c         **** }
 428               	.LM23:
 429 006a 0895      		ret
 431               	.Lscope4:
 433               		.stabd	78,0,0
 437               	readRamFIleFunction:
 438               		.stabd	46,0,0
 639:vty.c         **** 
 640:vty.c         **** 
 641:vty.c         **** static cliExRes_t flashExModuleFunction(cmdState_t *state)
 642:vty.c         **** {
 643:vty.c         ****   if (state->argc != 2)
 644:vty.c         ****     return SYNTAX_ERROR;
 645:vty.c         **** 
 646:vty.c         ****   uint8_t  nrUrzadzenia = cmdlineGetArgInt(1, state);
 647:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 648:vty.c         ****   uint8_t  blad;
 649:vty.c         **** 
 650:vty.c         ****   // Sprawdzanie, czy moduł wykonawczy odpowiada
 651:vty.c         ****   if (rs485ping(nrUrzadzenia) != 0)
 652:vty.c         ****   {
 653:vty.c         ****     state->errno = noRemoteDevice;
 654:vty.c         ****     printErrorInfo(state);
 655:vty.c         ****     return ERROR_INFORM;
 656:vty.c         ****   }
 657:vty.c         **** 
 658:vty.c         ****   //Sprawdzanie, czy istnieje odpowiedni plik z firmware
 659:vty.c         ****   if (ramDyskOtworzPlik(nazwaPliku, &fdVty) != 0)
 660:vty.c         ****   {
 661:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, nazwaPliku);
 662:vty.c         ****     return ERROR_INFORM;
 663:vty.c         ****   }
 664:vty.c         **** 
 665:vty.c         ****   blad = rs485xModemFlash(&fdVty, nrUrzadzenia, state->myStdInOut);
 666:vty.c         **** 
 667:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 668:vty.c         **** 
 669:vty.c         ****   if (blad != 0)
 670:vty.c         ****     return ERROR_INFORM;
 671:vty.c         **** 
 672:vty.c         ****   return OK_SILENT;
 673:vty.c         **** }
 674:vty.c         **** 
 675:vty.c         **** static cliExRes_t goXmodemWyslijFunction(cmdState_t *state) // TODO add code in xModem
 676:vty.c         **** {
 677:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 678:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 679:vty.c         ****   {
 680:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 681:vty.c         ****     return ERROR_INFORM;
 682:vty.c         ****   }
 683:vty.c         ****   return OK_SILENT;
 684:vty.c         **** }
 685:vty.c         **** 
 686:vty.c         **** static cliExRes_t goXmodemOdbierzFunction(cmdState_t *state) //TODO move to xmodem
 687:vty.c         **** {
 688:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 689:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 690:vty.c         ****   {
 691:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 692:vty.c         ****     return ERROR_INFORM;
 693:vty.c         ****   }
 694:vty.c         **** 
 695:vty.c         ****   uint8_t  i = 25;
 696:vty.c         **** 
 697:vty.c         ****   uint8_t  temp1;
 698:vty.c         **** //  uint8_t  temp2;
 699:vty.c         **** 
 700:vty.c         ****   uint8_t  c;
 701:vty.c         ****   uint8_t  liczbaProb;
 702:vty.c         ****   uint8_t  *zapPtr;
 703:vty.c         ****   uint8_t  *zapPtrKopia;
 704:vty.c         **** 
 705:vty.c         ****   uint16_t crcLokalne;
 706:vty.c         ****   uint8_t nrBloku;
 707:vty.c         **** 
 708:vty.c         ****   uint8_t nrBlokuZdalny;
 709:vty.c         ****   uint8_t nrBlokuZdalnyNeg;
 710:vty.c         **** 
 711:vty.c         ****   uint8_t crcHi;
 712:vty.c         ****   uint8_t crcLo;
 713:vty.c         **** 
 714:vty.c         ****   state->err1=0;
 715:vty.c         ****   state->err2=0;
 716:vty.c         ****   liczbaProb = 20;
 717:vty.c         ****   for ( ; ; )
 718:vty.c         ****   {
 719:vty.c         ****     fputc('C'              , state->myStdInOut);
 720:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 721:vty.c         **** 
 722:vty.c         ****     if(xQueueReceive(xVtyRec, &c, 100))
 723:vty.c         ****       if (c == SOH)
 724:vty.c         ****         break;                                                   //Rozpoczynamy transmisje
 725:vty.c         **** 
 726:vty.c         ****     liczbaProb--;
 727:vty.c         ****     if (liczbaProb == 0)
 728:vty.c         ****     {
 729:vty.c         ****       ramDyskZamknijPlik(&fdVty);
 730:vty.c         ****       state->errno = (uint8_t)(AllOK);
 731:vty.c         ****       return ERROR_INFORM;
 732:vty.c         ****     }
 733:vty.c         ****   }
 734:vty.c         **** 
 735:vty.c         ****   nrBloku = 1;
 736:vty.c         ****   liczbaProb = 10;
 737:vty.c         **** 
 738:vty.c         ****   zapPtr          = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 739:vty.c         ****   zapPtrKopia     = zapPtr;
 740:vty.c         ****   for ( ; ; )
 741:vty.c         ****   {
 742:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalny, 100))
 743:vty.c         ****     {
 744:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 745:vty.c         ****       break;
 746:vty.c         ****     }
 747:vty.c         **** 
 748:vty.c         ****     if (!xQueueReceive(xVtyRec, &nrBlokuZdalnyNeg, 1))
 749:vty.c         ****     {
 750:vty.c         ****       state->errno = (uint8_t)(xModemByteSendTimeout);
 751:vty.c         ****       break;
 752:vty.c         ****     }
 753:vty.c         **** 
 754:vty.c         ****     //1 Sprawdzanie, czy pasuje numer bloku z numerem bloku w usupełnieniu bitowym do 1
 755:vty.c         ****     c = 255-nrBlokuZdalnyNeg;
 756:vty.c         ****     if (nrBlokuZdalny != c)
 757:vty.c         ****     {
 758:vty.c         ****       state->errno = (uint8_t)(xModemFrameFrameNoCorrectionNotMatch);
 759:vty.c         ****       state->err1 = nrBlokuZdalny;
 760:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 761:vty.c         ****       break;
 762:vty.c         ****     }
 763:vty.c         **** 
 764:vty.c         ****     //Sprawdzenie, czy nie jest wznowiona transmisja poprzedniego bloku lub nie zaczęła się od b
 765:vty.c         ****     c = nrBloku-1;
 766:vty.c         ****     if (nrBlokuZdalny == c)
 767:vty.c         ****     {
 768:vty.c         ****       nrBloku = c;    //Cofnięcie nr aktualnego bloku o 1
 769:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 770:vty.c         ****       zapPtrKopia = zapPtr;
 771:vty.c         ****     }
 772:vty.c         **** 
 773:vty.c         ****     //2 Sprawdzanie, czy pasuje numer bloku
 774:vty.c         ****     if (nrBlokuZdalny != nrBloku)
 775:vty.c         ****     {
 776:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 777:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 778:vty.c         ****       state->err2 = nrBloku;
 779:vty.c         ****       break;
 780:vty.c         ****     }
 781:vty.c         **** 
 782:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 783:vty.c         ****     {
 784:vty.c         ****       if(xQueueReceive(xVtyRec, &c, 10))
 785:vty.c         ****         *(zapPtr++) = c;
 786:vty.c         ****       else
 787:vty.c         ****       {
 788:vty.c         ****         state->errno = (uint8_t)(xModemByteSendTimeout);
 789:vty.c         ****         break;
 790:vty.c         ****       }
 791:vty.c         ****     }
 792:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcHi, 10))
 793:vty.c         ****     {
 794:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 795:vty.c         ****         state->err1 = 2;
 796:vty.c         ****         break;
 797:vty.c         ****     }
 798:vty.c         ****     if (!xQueueReceive(xVtyRec, &crcLo, 10))
 799:vty.c         ****     {
 800:vty.c         ****         state->errno = (uint8_t)(xModemFrameCrc);
 801:vty.c         ****         state->err1 = 1;
 802:vty.c         ****         break;
 803:vty.c         ****     }
 804:vty.c         **** 
 805:vty.c         ****     //3 Zerowanie CRC
 806:vty.c         ****     crcLokalne=0;
 807:vty.c         **** 
 808:vty.c         ****     //4 Obliczanie CRC
 809:vty.c         ****     for (i=0; i < XMODEM_BUFFER_SIZE; i++)
 810:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 811:vty.c         **** 
 812:vty.c         ****     //5 Srawdzanie CRC
 813:vty.c         ****     if ((crcHi == crcLokalne / 256) && (crcLo == crcLokalne % 256))
 814:vty.c         ****     {
 815:vty.c         ****       liczbaProb = 10;
 816:vty.c         ****       uartVtySendByte(ACK);
 817:vty.c         ****     }
 818:vty.c         ****     else
 819:vty.c         ****     {
 820:vty.c         ****       liczbaProb--;
 821:vty.c         ****       nrBloku--;
 822:vty.c         ****       uartVtySendByte(NAK);
 823:vty.c         ****     }
 824:vty.c         **** 
 825:vty.c         ****     if (liczbaProb == 0)
 826:vty.c         ****     {
 827:vty.c         ****       state->err1 = nrBlokuZdalny;
 828:vty.c         ****       state->err2 = nrBloku;
 829:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 830:vty.c         ****       break;
 831:vty.c         ****     }
 832:vty.c         **** 
 833:vty.c         ****     if (!xQueueReceive(xVtyRec, &temp1, 100))
 834:vty.c         ****     {
 835:vty.c         ****       state->errno = (uint8_t)(xModemFrameStartTimeout);
 836:vty.c         ****       break;
 837:vty.c         ****     }
 838:vty.c         **** 
 839:vty.c         ****     if (temp1 == SOH)
 840:vty.c         ****     {
 841:vty.c         ****       nrBloku++;
 842:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 843:vty.c         ****       zapPtrKopia = zapPtr;
 844:vty.c         ****       state->errno = (uint8_t)(AllOK);
 845:vty.c         ****       continue;
 846:vty.c         ****     }
 847:vty.c         **** 
 848:vty.c         ****     if (temp1 == CAN)
 849:vty.c         ****     {
 850:vty.c         ****       state->err1 = nrBloku;
 851:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 852:vty.c         ****       break;
 853:vty.c         ****     }
 854:vty.c         ****     if (temp1 == EOT)
 855:vty.c         ****     {
 856:vty.c         ****       uartVtySendByte(NAK);
 857:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 858:vty.c         ****       {
 859:vty.c         ****         if (temp1 == EOT)
 860:vty.c         ****           uartVtySendByte(ACK);
 861:vty.c         ****       }
 862:vty.c         ****       state->errno = (uint8_t)(AllOK);
 863:vty.c         ****       break;
 864:vty.c         ****     }
 865:vty.c         ****     state->errno = (uint8_t)(xModemUnknownResponse);
 866:vty.c         ****     state->err1 = temp1;
 867:vty.c         ****     break;
 868:vty.c         ****   }
 869:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 870:vty.c         ****   return OK_SILENT;
 871:vty.c         **** }
 872:vty.c         **** 
 873:vty.c         **** static cliExRes_t eraseRamFileFunction(cmdState_t *state)
 874:vty.c         **** {
 875:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 876:vty.c         ****     return OK_INFORM;
 877:vty.c         **** 
 878:vty.c         ****   printErrorInfo(state);
 879:vty.c         ****   return ERROR_INFORM;
 880:vty.c         **** }
 881:vty.c         **** 
 882:vty.c         **** static cliExRes_t dodajRamPlikFunction(cmdState_t *state)
 883:vty.c         **** {
 884:vty.c         ****   if (state->argc != 1)
 885:vty.c         ****     return SYNTAX_ERROR;
 886:vty.c         **** 
 887:vty.c         ****   if (ramDyskUtworzPlik(cmdlineGetArgStr(1, state)) == 0)
 888:vty.c         ****   {
 889:vty.c         ****     return OK_INFORM;
 890:vty.c         ****   }
 891:vty.c         ****   printErrorInfo(state);
 892:vty.c         ****   return ERROR_INFORM;
 893:vty.c         **** }
 894:vty.c         **** 
 895:vty.c         **** static cliExRes_t writeRamFileFunction(cmdState_t *state)
 896:vty.c         **** {
 897:vty.c         ****   ramDyskDir(state->myStdInOut);
 898:vty.c         ****   return OK_SILENT;
 899:vty.c         **** }
 900:vty.c         **** 
 901:vty.c         **** static cliExRes_t editRamFileFunction(cmdState_t *state)
 902:vty.c         **** {
 903:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 904:vty.c         ****   {
 905:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 906:vty.c         ****     return ERROR_INFORM;
 907:vty.c         ****   }
 908:vty.c         ****   ramDyskUstawWskaznikNaKoniec(&fdVty);
 909:vty.c         ****   uint8_t znak = 0;
 910:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 911:vty.c         ****   while(1)
 912:vty.c         ****   {
 913:vty.c         ****     if(!xQueueReceive( xVtyRec, &znak, portMAX_DELAY))
 914:vty.c         ****       continue;
 915:vty.c         **** 
 916:vty.c         ****     if (znak == 0x03)                                       // ^C
 917:vty.c         ****       break;
 918:vty.c         **** 
 919:vty.c         ****     uartVtySendByte(znak);                                  //Echo
 920:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 921:vty.c         ****   }
 922:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 923:vty.c         ****   return OK_SILENT;
 924:vty.c         **** }
 925:vty.c         **** 
 926:vty.c         **** static cliExRes_t readRamFIleFunction(cmdState_t *state) //TODO move this code to fat8
 927:vty.c         **** {
 440               	.LM24:
 441               	.LFBB5:
 442 006c FF92      		push r15
 443 006e 0F93      		push r16
 444 0070 1F93      		push r17
 445 0072 CF93      		push r28
 446 0074 DF93      		push r29
 447 0076 1F92      		push __zero_reg__
 448 0078 CDB7      		in r28,__SP_L__
 449 007a DEB7      		in r29,__SP_H__
 450               	/* prologue: function */
 451               	/* frame size = 1 */
 452               	/* stack size = 6 */
 453               	.L__stack_usage = 6
 454 007c 8C01      		movw r16,r24
 928:vty.c         ****   uint8_t rezultat;
 929:vty.c         ****   uint8_t znak = ' ';
 456               	.LM25:
 457 007e 80E2      		ldi r24,lo8(32)
 458 0080 8983      		std Y+1,r24
 930:vty.c         ****   if ((rezultat = ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty)) != 0)
 460               	.LM26:
 461 0082 B801      		movw r22,r16
 462 0084 81E0      		ldi r24,lo8(1)
 463 0086 0E94 0000 		call cmdlineGetArgStr
 464 008a 60E0      		ldi r22,lo8(fdVty)
 465 008c 70E0      		ldi r23,hi8(fdVty)
 466 008e 0E94 0000 		call ramDyskOtworzPlik
 467 0092 8823      		tst r24
 468 0094 01F0      		breq .L17
 931:vty.c         ****   {
 932:vty.c         ****     fprintf_P(state->myStdInOut, errorOpenFile, cmdlineGetArgStr(1, state));
 470               	.LM27:
 471 0096 B801      		movw r22,r16
 472 0098 81E0      		ldi r24,lo8(1)
 473 009a 0E94 0000 		call cmdlineGetArgStr
 474 009e 9F93      		push r25
 475 00a0 8F93      		push r24
 476 00a2 80E0      		ldi r24,lo8(errorOpenFile)
 477 00a4 90E0      		ldi r25,hi8(errorOpenFile)
 478 00a6 9F93      		push r25
 479 00a8 8F93      		push r24
 480 00aa F801      		movw r30,r16
 481 00ac 838D      		ldd r24,Z+27
 482 00ae 8F93      		push r24
 483 00b0 828D      		ldd r24,Z+26
 484 00b2 8F93      		push r24
 485 00b4 0E94 0000 		call fprintf_P
 933:vty.c         ****     return ERROR_INFORM;
 487               	.LM28:
 488 00b8 0F90      		pop __tmp_reg__
 489 00ba 0F90      		pop __tmp_reg__
 490 00bc 0F90      		pop __tmp_reg__
 491 00be 0F90      		pop __tmp_reg__
 492 00c0 0F90      		pop __tmp_reg__
 493 00c2 0F90      		pop __tmp_reg__
 494 00c4 84E0      		ldi r24,lo8(4)
 495 00c6 90E0      		ldi r25,0
 496 00c8 00C0      		rjmp .L18
 497               	.L17:
 934:vty.c         ****   }
 935:vty.c         ****   uint16_t rozmiar = fdVty.wpis->rozmiarHi * 256 + fdVty.wpis->rozmiarLo;
 499               	.LM29:
 500 00ca E091 0000 		lds r30,fdVty+4
 501 00ce F091 0000 		lds r31,fdVty+4+1
 502 00d2 8281      		ldd r24,Z+2
 503 00d4 90E0      		ldi r25,0
 504 00d6 982F      		mov r25,r24
 505 00d8 8827      		clr r24
 506 00da 2181      		ldd r18,Z+1
 507 00dc 820F      		add r24,r18
 508 00de 911D      		adc r25,__zero_reg__
 936:vty.c         ****   fprintf_P(state->myStdInOut, readRamFIleLenStr , rozmiar);
 510               	.LM30:
 511 00e0 9F93      		push r25
 512 00e2 8F93      		push r24
 513 00e4 80E0      		ldi r24,lo8(readRamFIleLenStr)
 514 00e6 90E0      		ldi r25,hi8(readRamFIleLenStr)
 515 00e8 9F93      		push r25
 516 00ea 8F93      		push r24
 517 00ec F801      		movw r30,r16
 518 00ee 838D      		ldd r24,Z+27
 519 00f0 8F93      		push r24
 520 00f2 828D      		ldd r24,Z+26
 521 00f4 8F93      		push r24
 522 00f6 0E94 0000 		call fprintf_P
 523 00fa 0F90      		pop __tmp_reg__
 524 00fc 0F90      		pop __tmp_reg__
 525 00fe 0F90      		pop __tmp_reg__
 526 0100 0F90      		pop __tmp_reg__
 527 0102 0F90      		pop __tmp_reg__
 528 0104 0F90      		pop __tmp_reg__
 529               	.L20:
 937:vty.c         ****   while (rezultat == 0)
 938:vty.c         ****   {
 939:vty.c         ****     rezultat = ramDyskCzytajBajtZPliku(&fdVty, &znak);
 531               	.LM31:
 532 0106 BE01      		movw r22,r28
 533 0108 6F5F      		subi r22,-1
 534 010a 7F4F      		sbci r23,-1
 535 010c 80E0      		ldi r24,lo8(fdVty)
 536 010e 90E0      		ldi r25,hi8(fdVty)
 537 0110 0E94 0000 		call ramDyskCzytajBajtZPliku
 538 0114 F82E      		mov r15,r24
 940:vty.c         **** 
 941:vty.c         ****     uartVtySendByte(znak);
 540               	.LM32:
 541 0116 8981      		ldd r24,Y+1
 542 0118 0E94 0000 		call uartVtySendByte
 942:vty.c         ****     if (znak == '\r')
 544               	.LM33:
 545 011c 8981      		ldd r24,Y+1
 546 011e 8D30      		cpi r24,lo8(13)
 547 0120 01F4      		brne .L19
 943:vty.c         ****       uartVtySendByte('\n');
 549               	.LM34:
 550 0122 8AE0      		ldi r24,lo8(10)
 551 0124 0E94 0000 		call uartVtySendByte
 552               	.L19:
 937:vty.c         ****   {
 554               	.LM35:
 555 0128 FF20      		tst r15
 556 012a 01F0      		breq .L20
 944:vty.c         ****   }
 945:vty.c         ****   fprintf_P(state->myStdInOut, nlStr);
 558               	.LM36:
 559 012c 80E0      		ldi r24,lo8(nlStr)
 560 012e 90E0      		ldi r25,hi8(nlStr)
 561 0130 9F93      		push r25
 562 0132 8F93      		push r24
 563 0134 F801      		movw r30,r16
 564 0136 838D      		ldd r24,Z+27
 565 0138 8F93      		push r24
 566 013a 828D      		ldd r24,Z+26
 567 013c 8F93      		push r24
 568 013e 0E94 0000 		call fprintf_P
 946:vty.c         ****   ramDyskZamknijPlik(&fdVty);
 570               	.LM37:
 571 0142 80E0      		ldi r24,lo8(fdVty)
 572 0144 90E0      		ldi r25,hi8(fdVty)
 573 0146 0E94 0000 		call ramDyskZamknijPlik
 947:vty.c         ****   return OK_SILENT;
 575               	.LM38:
 576 014a 0F90      		pop __tmp_reg__
 577 014c 0F90      		pop __tmp_reg__
 578 014e 0F90      		pop __tmp_reg__
 579 0150 0F90      		pop __tmp_reg__
 580 0152 80E0      		ldi r24,0
 581 0154 90E0      		ldi r25,0
 582               	.L18:
 583               	/* epilogue start */
 948:vty.c         **** }
 585               	.LM39:
 586 0156 0F90      		pop __tmp_reg__
 587 0158 DF91      		pop r29
 588 015a CF91      		pop r28
 589 015c 1F91      		pop r17
 590 015e 0F91      		pop r16
 591 0160 FF90      		pop r15
 592 0162 0895      		ret
 597               	.Lscope5:
 599               		.stabd	78,0,0
 603               	writeRamFileFunction:
 604               		.stabd	46,0,0
 896:vty.c         ****   ramDyskDir(state->myStdInOut);
 606               	.LM40:
 607               	.LFBB6:
 608               	/* prologue: function */
 609               	/* frame size = 0 */
 610               	/* stack size = 0 */
 611               	.L__stack_usage = 0
 897:vty.c         ****   return OK_SILENT;
 613               	.LM41:
 614 0164 FC01      		movw r30,r24
 615 0166 828D      		ldd r24,Z+26
 616 0168 938D      		ldd r25,Z+27
 617 016a 0E94 0000 		call ramDyskDir
 899:vty.c         **** 
 619               	.LM42:
 620 016e 80E0      		ldi r24,0
 621 0170 90E0      		ldi r25,0
 622 0172 0895      		ret
 624               	.Lscope6:
 626               		.stabd	78,0,0
 630               	pokazCzasFunction:
 631               		.stabd	46,0,0
 298:vty.c         ****   readTimeDecoded((timeDecoded_t *)(&czasRtc));
 633               	.LM43:
 634               	.LFBB7:
 635 0174 CF93      		push r28
 636 0176 DF93      		push r29
 637               	/* prologue: function */
 638               	/* frame size = 0 */
 639               	/* stack size = 2 */
 640               	.L__stack_usage = 2
 641 0178 EC01      		movw r28,r24
 299:vty.c         ****   uint8_t godzina = 10*czasRtc.hours.syst24.cDzies + czasRtc.hours.syst24.cJedn;
 643               	.LM44:
 644 017a 80E0      		ldi r24,lo8(czasRtc)
 645 017c 90E0      		ldi r25,hi8(czasRtc)
 646 017e 0E94 0000 		call readTimeDecoded
 300:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 648               	.LM45:
 649 0182 E0E0      		ldi r30,lo8(czasRtc+2)
 650 0184 F0E0      		ldi r31,hi8(czasRtc+2)
 651 0186 9081      		ld r25,Z
 652 0188 9695      		lsr r25
 653 018a 9695      		lsr r25
 654 018c 9695      		lsr r25
 655 018e 8081      		ld r24,Z
 656 0190 8F70      		andi r24,lo8(15)
 301:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 658               	.LM46:
 659 0192 E0E0      		ldi r30,lo8(czasRtc+1)
 660 0194 F0E0      		ldi r31,hi8(czasRtc+1)
 661 0196 2081      		ld r18,Z
 662 0198 2695      		lsr r18
 663 019a 2695      		lsr r18
 664 019c 2695      		lsr r18
 665 019e 4081      		ld r20,Z
 666 01a0 4F70      		andi r20,lo8(15)
 302:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Aktualny czas %d:%d:%d\r\n"), godzina, minuta, sekunda);
 668               	.LM47:
 669 01a2 E0E0      		ldi r30,lo8(czasRtc)
 670 01a4 F0E0      		ldi r31,hi8(czasRtc)
 671 01a6 3081      		ld r19,Z
 672 01a8 3695      		lsr r19
 673 01aa 3695      		lsr r19
 674 01ac 3695      		lsr r19
 675 01ae 5081      		ld r21,Z
 676 01b0 5F70      		andi r21,lo8(15)
 677 01b2 3E70      		andi r19,lo8(14)
 678 01b4 632F      		mov r22,r19
 679 01b6 660F      		lsl r22
 680 01b8 660F      		lsl r22
 681 01ba 360F      		add r19,r22
 682 01bc 350F      		add r19,r21
 303:vty.c         ****   return OK_SILENT;
 684               	.LM48:
 685 01be 1F92      		push __zero_reg__
 686 01c0 3F93      		push r19
 301:vty.c         ****   uint8_t sekunda = 10*czasRtc.seconds.cDzies + czasRtc.seconds.cJedn;
 688               	.LM49:
 689 01c2 2E70      		andi r18,lo8(14)
 690 01c4 322F      		mov r19,r18
 691 01c6 330F      		lsl r19
 692 01c8 330F      		lsl r19
 693 01ca 230F      		add r18,r19
 694 01cc 240F      		add r18,r20
 303:vty.c         ****   return OK_SILENT;
 696               	.LM50:
 697 01ce 1F92      		push __zero_reg__
 698 01d0 2F93      		push r18
 300:vty.c         ****   uint8_t minuta =  10*czasRtc.minutes.cDzies + czasRtc.minutes.cJedn;
 700               	.LM51:
 701 01d2 9670      		andi r25,lo8(6)
 702 01d4 292F      		mov r18,r25
 703 01d6 220F      		lsl r18
 704 01d8 220F      		lsl r18
 705 01da 920F      		add r25,r18
 706 01dc 980F      		add r25,r24
 303:vty.c         ****   return OK_SILENT;
 708               	.LM52:
 709 01de 1F92      		push __zero_reg__
 710 01e0 9F93      		push r25
 711 01e2 80E0      		ldi r24,lo8(__c.3649)
 712 01e4 90E0      		ldi r25,hi8(__c.3649)
 713 01e6 9F93      		push r25
 714 01e8 8F93      		push r24
 715 01ea 8B8D      		ldd r24,Y+27
 716 01ec 8F93      		push r24
 717 01ee 8A8D      		ldd r24,Y+26
 718 01f0 8F93      		push r24
 719 01f2 0E94 0000 		call fprintf_P
 304:vty.c         **** }
 721               	.LM53:
 722 01f6 8DB7      		in r24,__SP_L__
 723 01f8 9EB7      		in r25,__SP_H__
 724 01fa 0A96      		adiw r24,10
 725 01fc 0FB6      		in __tmp_reg__,__SREG__
 726 01fe F894      		cli
 727 0200 9EBF      		out __SP_H__,r25
 728 0202 0FBE      		out __SREG__,__tmp_reg__
 729 0204 8DBF      		out __SP_L__,r24
 305:vty.c         **** 
 731               	.LM54:
 732 0206 80E0      		ldi r24,0
 733 0208 90E0      		ldi r25,0
 734               	/* epilogue start */
 735 020a DF91      		pop r29
 736 020c CF91      		pop r28
 737 020e 0895      		ret
 739               	.Lscope7:
 741               		.stabd	78,0,0
 745               	helpFunction:
 746               		.stabd	46,0,0
 530:vty.c         ****   cmdPrintHelp(state);
 748               	.LM55:
 749               	.LFBB8:
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 0 */
 753               	.L__stack_usage = 0
 531:vty.c         ****   return OK_SILENT;
 755               	.LM56:
 756 0210 0E94 0000 		call cmdPrintHelp
 533:vty.c         **** 
 758               	.LM57:
 759 0214 80E0      		ldi r24,0
 760 0216 90E0      		ldi r25,0
 761 0218 0895      		ret
 763               	.Lscope8:
 765               		.stabd	78,0,0
 769               	czytajAC_Function:
 770               		.stabd	46,0,0
 522:vty.c         ****   uint8_t nrWejscia = cmdlineGetArgInt(1, state);
 772               	.LM58:
 773               	.LFBB9:
 774 021a 0F93      		push r16
 775 021c 1F93      		push r17
 776 021e CF93      		push r28
 777 0220 DF93      		push r29
 778 0222 1F92      		push __zero_reg__
 779 0224 CDB7      		in r28,__SP_L__
 780 0226 DEB7      		in r29,__SP_H__
 781               	/* prologue: function */
 782               	/* frame size = 1 */
 783               	/* stack size = 5 */
 784               	.L__stack_usage = 5
 785 0228 8C01      		movw r16,r24
 523:vty.c         ****   uint16_t wynik = MCP3008_getSampleSingle(nrWejscia);
 787               	.LM59:
 788 022a BC01      		movw r22,r24
 789 022c 81E0      		ldi r24,lo8(1)
 790 022e 0E94 0000 		call cmdlineGetArgInt
 524:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Wartosc probki na wejsciu %d: %d\r\n"), nrWejscia, wynik);
 792               	.LM60:
 793 0232 862F      		mov r24,r22
 794 0234 6983      		std Y+1,r22
 795 0236 0E94 0000 		call MCP3008_getSampleSingle
 525:vty.c         ****   return OK_SILENT;
 797               	.LM61:
 798 023a 9F93      		push r25
 799 023c 8F93      		push r24
 800 023e 1F92      		push __zero_reg__
 801 0240 6981      		ldd r22,Y+1
 802 0242 6F93      		push r22
 803 0244 80E0      		ldi r24,lo8(__c.3718)
 804 0246 90E0      		ldi r25,hi8(__c.3718)
 805 0248 9F93      		push r25
 806 024a 8F93      		push r24
 807 024c F801      		movw r30,r16
 808 024e 838D      		ldd r24,Z+27
 809 0250 8F93      		push r24
 810 0252 828D      		ldd r24,Z+26
 811 0254 8F93      		push r24
 812 0256 0E94 0000 		call fprintf_P
 526:vty.c         **** }
 814               	.LM62:
 815 025a 0FB6      		in __tmp_reg__,__SREG__
 816 025c F894      		cli
 817 025e DEBF      		out __SP_H__,r29
 818 0260 0FBE      		out __SREG__,__tmp_reg__
 819 0262 CDBF      		out __SP_L__,r28
 527:vty.c         **** 
 821               	.LM63:
 822 0264 80E0      		ldi r24,0
 823 0266 90E0      		ldi r25,0
 824               	/* epilogue start */
 825 0268 0F90      		pop __tmp_reg__
 826 026a DF91      		pop r29
 827 026c CF91      		pop r28
 828 026e 1F91      		pop r17
 829 0270 0F91      		pop r16
 830 0272 0895      		ret
 832               	.Lscope9:
 834               		.stabd	78,0,0
 838               	setTimeFunction:
 839               		.stabd	46,0,0
 396:vty.c         ****   uint8_t godzina =  cmdlineGetArgInt(1, state);
 841               	.LM64:
 842               	.LFBB10:
 843 0274 EF92      		push r14
 844 0276 FF92      		push r15
 845 0278 1F93      		push r17
 846 027a CF93      		push r28
 847 027c DF93      		push r29
 848               	/* prologue: function */
 849               	/* frame size = 0 */
 850               	/* stack size = 5 */
 851               	.L__stack_usage = 5
 852 027e 7C01      		movw r14,r24
 397:vty.c         ****   uint8_t minuta  =  cmdlineGetArgInt(2, state);
 854               	.LM65:
 855 0280 BC01      		movw r22,r24
 856 0282 81E0      		ldi r24,lo8(1)
 857 0284 0E94 0000 		call cmdlineGetArgInt
 858 0288 162F      		mov r17,r22
 398:vty.c         ****   uint8_t sekunda =  cmdlineGetArgInt(3, state);
 860               	.LM66:
 861 028a B701      		movw r22,r14
 862 028c 82E0      		ldi r24,lo8(2)
 863 028e 0E94 0000 		call cmdlineGetArgInt
 864 0292 D62F      		mov r29,r22
 399:vty.c         **** 
 866               	.LM67:
 867 0294 B701      		movw r22,r14
 868 0296 83E0      		ldi r24,lo8(3)
 869 0298 0E94 0000 		call cmdlineGetArgInt
 870 029c C62F      		mov r28,r22
 401:vty.c         **** 
 872               	.LM68:
 873 029e 0E94 0000 		call ds1305start
 403:vty.c         ****   uint8_t cJedn = godzina - cDzies*10;
 875               	.LM69:
 876 02a2 4AE0      		ldi r20,lo8(10)
 877 02a4 812F      		mov r24,r17
 878 02a6 642F      		mov r22,r20
 879 02a8 0E94 0000 		call __udivmodqi4
 405:vty.c         ****   czasRtc.hours.syst24.cJedn  = cJedn;
 881               	.LM70:
 882 02ac 982F      		mov r25,r24
 883 02ae 9370      		andi r25,lo8(3)
 884 02b0 E0E0      		ldi r30,lo8(czasRtc+2)
 885 02b2 F0E0      		ldi r31,hi8(czasRtc+2)
 886 02b4 292F      		mov r18,r25
 887 02b6 2295      		swap r18
 888 02b8 207F      		andi r18,lo8(-16)
 889 02ba 9081      		ld r25,Z
 890 02bc 9F7C      		andi r25,lo8(-49)
 891 02be 922B      		or r25,r18
 892 02c0 9083      		st Z,r25
 404:vty.c         ****   czasRtc.hours.syst24.cDzies = cDzies;
 894               	.LM71:
 895 02c2 36EF      		ldi r19,lo8(-10)
 896 02c4 839F      		mul r24,r19
 897 02c6 100D      		add r17,r0
 898 02c8 1124      		clr __zero_reg__
 406:vty.c         **** 
 900               	.LM72:
 901 02ca 812F      		mov r24,r17
 902 02cc 8F70      		andi r24,lo8(15)
 903 02ce 1081      		ld r17,Z
 904 02d0 107F      		andi r17,lo8(-16)
 905 02d2 182B      		or r17,r24
 906 02d4 1083      		st Z,r17
 408:vty.c         ****   cJedn = minuta - cDzies * 10;
 908               	.LM73:
 909 02d6 8D2F      		mov r24,r29
 910 02d8 0E94 0000 		call __udivmodqi4
 410:vty.c         ****   czasRtc.minutes.cJedn  = cJedn;
 912               	.LM74:
 913 02dc 982F      		mov r25,r24
 914 02de 9770      		andi r25,lo8(7)
 915 02e0 E0E0      		ldi r30,lo8(czasRtc+1)
 916 02e2 F0E0      		ldi r31,hi8(czasRtc+1)
 917 02e4 292F      		mov r18,r25
 918 02e6 2295      		swap r18
 919 02e8 207F      		andi r18,lo8(-16)
 920 02ea 9081      		ld r25,Z
 921 02ec 9F78      		andi r25,lo8(-113)
 922 02ee 922B      		or r25,r18
 923 02f0 9083      		st Z,r25
 409:vty.c         ****   czasRtc.minutes.cDzies = cDzies;
 925               	.LM75:
 926 02f2 839F      		mul r24,r19
 927 02f4 D00D      		add r29,r0
 928 02f6 1124      		clr __zero_reg__
 411:vty.c         **** 
 930               	.LM76:
 931 02f8 8D2F      		mov r24,r29
 932 02fa 8F70      		andi r24,lo8(15)
 933 02fc D081      		ld r29,Z
 934 02fe D07F      		andi r29,lo8(-16)
 935 0300 D82B      		or r29,r24
 936 0302 D083      		st Z,r29
 413:vty.c         ****   cJedn  = sekunda - cDzies * 10;
 938               	.LM77:
 939 0304 8C2F      		mov r24,r28
 940 0306 0E94 0000 		call __udivmodqi4
 415:vty.c         ****   czasRtc.seconds.cJedn  = cJedn;
 942               	.LM78:
 943 030a 982F      		mov r25,r24
 944 030c 9770      		andi r25,lo8(7)
 945 030e E0E0      		ldi r30,lo8(czasRtc)
 946 0310 F0E0      		ldi r31,hi8(czasRtc)
 947 0312 292F      		mov r18,r25
 948 0314 2295      		swap r18
 949 0316 207F      		andi r18,lo8(-16)
 950 0318 9081      		ld r25,Z
 951 031a 9F78      		andi r25,lo8(-113)
 952 031c 922B      		or r25,r18
 953 031e 9083      		st Z,r25
 414:vty.c         ****   czasRtc.seconds.cDzies = cDzies;
 955               	.LM79:
 956 0320 839F      		mul r24,r19
 957 0322 C00D      		add r28,r0
 958 0324 1124      		clr __zero_reg__
 416:vty.c         **** 
 960               	.LM80:
 961 0326 8C2F      		mov r24,r28
 962 0328 8F70      		andi r24,lo8(15)
 963 032a C081      		ld r28,Z
 964 032c C07F      		andi r28,lo8(-16)
 965 032e C82B      		or r28,r24
 966 0330 C083      		st Z,r28
 418:vty.c         ****   return OK_SILENT;
 968               	.LM81:
 969 0332 CF01      		movw r24,r30
 970 0334 0E94 0000 		call setTimeDecoded
 420:vty.c         **** 
 972               	.LM82:
 973 0338 80E0      		ldi r24,0
 974 033a 90E0      		ldi r25,0
 975               	/* epilogue start */
 976 033c DF91      		pop r29
 977 033e CF91      		pop r28
 978 0340 1F91      		pop r17
 979 0342 FF90      		pop r15
 980 0344 EF90      		pop r14
 981 0346 0895      		ret
 983               	.Lscope10:
 985               		.stabd	78,0,0
 989               	ustawPortExtBFunction:
 990               		.stabd	46,0,0
 591:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 992               	.LM83:
 993               	.LFBB11:
 994 0348 CF93      		push r28
 995               	/* prologue: function */
 996               	/* frame size = 0 */
 997               	/* stack size = 1 */
 998               	.L__stack_usage = 1
 592:vty.c         ****   MPC23s17SetDirB(0x00, 0);
 1000               	.LM84:
 1001 034a BC01      		movw r22,r24
 1002 034c 81E0      		ldi r24,lo8(1)
 1003 034e 0E94 0000 		call cmdlineGetArgInt
 1004 0352 C62F      		mov r28,r22
 593:vty.c         ****   MPC23s17SetPortB(wyjscie, 0);
 1006               	.LM85:
 1007 0354 60E0      		ldi r22,0
 1008 0356 80E0      		ldi r24,0
 1009 0358 0E94 0000 		call MPC23s17SetDirB
 594:vty.c         ****   return OK_SILENT;
 1011               	.LM86:
 1012 035c 60E0      		ldi r22,0
 1013 035e 8C2F      		mov r24,r28
 1014 0360 0E94 0000 		call MPC23s17SetPortB
 596:vty.c         **** 
 1016               	.LM87:
 1017 0364 80E0      		ldi r24,0
 1018 0366 90E0      		ldi r25,0
 1019               	/* epilogue start */
 1020 0368 CF91      		pop r28
 1021 036a 0895      		ret
 1023               	.Lscope11:
 1025               		.stabd	78,0,0
 1029               	ustawPortExtAFunction:
 1030               		.stabd	46,0,0
 583:vty.c         ****   uint8_t wyjscie = cmdlineGetArgInt(1, state);
 1032               	.LM88:
 1033               	.LFBB12:
 1034 036c CF93      		push r28
 1035               	/* prologue: function */
 1036               	/* frame size = 0 */
 1037               	/* stack size = 1 */
 1038               	.L__stack_usage = 1
 584:vty.c         ****   MPC23s17SetDirA(0x00, 0);
 1040               	.LM89:
 1041 036e BC01      		movw r22,r24
 1042 0370 81E0      		ldi r24,lo8(1)
 1043 0372 0E94 0000 		call cmdlineGetArgInt
 1044 0376 C62F      		mov r28,r22
 585:vty.c         ****   MPC23s17SetPortA(wyjscie, 0);
 1046               	.LM90:
 1047 0378 60E0      		ldi r22,0
 1048 037a 80E0      		ldi r24,0
 1049 037c 0E94 0000 		call MPC23s17SetDirA
 586:vty.c         ****   return OK_SILENT;
 1051               	.LM91:
 1052 0380 60E0      		ldi r22,0
 1053 0382 8C2F      		mov r24,r28
 1054 0384 0E94 0000 		call MPC23s17SetPortA
 588:vty.c         **** 
 1056               	.LM92:
 1057 0388 80E0      		ldi r24,0
 1058 038a 90E0      		ldi r25,0
 1059               	/* epilogue start */
 1060 038c CF91      		pop r28
 1061 038e 0895      		ret
 1063               	.Lscope12:
 1065               		.stabd	78,0,0
 1069               	curtainDownFunction:
 1070               		.stabd	46,0,0
 536:vty.c         ****   uint8_t nrRolety;
 1072               	.LM93:
 1073               	.LFBB13:
 1074 0390 FF92      		push r15
 1075 0392 0F93      		push r16
 1076 0394 1F93      		push r17
 1077 0396 CF93      		push r28
 1078 0398 DF93      		push r29
 1079               	/* prologue: function */
 1080               	/* frame size = 0 */
 1081               	/* stack size = 5 */
 1082               	.L__stack_usage = 5
 1083 039a EC01      		movw r28,r24
 541:vty.c         ****   nrRolety = cmdlineGetArgInt(2, state);
 1085               	.LM94:
 1086 039c BC01      		movw r22,r24
 1087 039e 81E0      		ldi r24,lo8(1)
 1088 03a0 0E94 0000 		call cmdlineGetArgInt
 1089 03a4 F62E      		mov r15,r22
 542:vty.c         ****   nrRolety &= 0x01;
 1091               	.LM95:
 1092 03a6 BE01      		movw r22,r28
 1093 03a8 82E0      		ldi r24,lo8(2)
 1094 03aa 0E94 0000 		call cmdlineGetArgInt
 543:vty.c         ****   wartosc = cmdlineGetArgInt(3, state);
 1096               	.LM96:
 1097 03ae 162F      		mov r17,r22
 1098 03b0 1170      		andi r17,lo8(1)
 544:vty.c         **** 
 1100               	.LM97:
 1101 03b2 BE01      		movw r22,r28
 1102 03b4 83E0      		ldi r24,lo8(3)
 1103 03b6 0E94 0000 		call cmdlineGetArgInt
 1104 03ba 062F      		mov r16,r22
 546:vty.c         **** 
 1106               	.LM98:
 1107 03bc 212F      		mov r18,r17
 1108 03be 30E0      		ldi r19,0
 1109 03c0 2F5F      		subi r18,-1
 1110 03c2 3F4F      		sbci r19,-1
 1111 03c4 3F93      		push r19
 1112 03c6 2F93      		push r18
 1113 03c8 1F92      		push __zero_reg__
 1114 03ca FF92      		push r15
 1115 03cc 80E0      		ldi r24,lo8(movingCurtainDownStr)
 1116 03ce 90E0      		ldi r25,hi8(movingCurtainDownStr)
 1117 03d0 9F93      		push r25
 1118 03d2 8F93      		push r24
 1119 03d4 8B8D      		ldd r24,Y+27
 1120 03d6 8F93      		push r24
 1121 03d8 8A8D      		ldd r24,Y+26
 1122 03da 8F93      		push r24
 1123 03dc 0E94 0000 		call fprintf_P
 548:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1125               	.LM99:
 1126 03e0 8FEF      		ldi r24,lo8(-1)
 1127 03e2 800F      		add r24,r16
 1128 03e4 2DB7      		in r18,__SP_L__
 1129 03e6 3EB7      		in r19,__SP_H__
 1130 03e8 285F      		subi r18,-8
 1131 03ea 3F4F      		sbci r19,-1
 1132 03ec 0FB6      		in __tmp_reg__,__SREG__
 1133 03ee F894      		cli
 1134 03f0 3EBF      		out __SP_H__,r19
 1135 03f2 0FBE      		out __SREG__,__tmp_reg__
 1136 03f4 2DBF      		out __SP_L__,r18
 1137 03f6 8436      		cpi r24,lo8(100)
 1138 03f8 00F4      		brsh .L31
 549:vty.c         **** 
 1140               	.LM100:
 1141 03fa 1F92      		push __zero_reg__
 1142 03fc 0F93      		push r16
 1143 03fe 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1144 0400 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1145 0402 9F93      		push r25
 1146 0404 8F93      		push r24
 1147 0406 8B8D      		ldd r24,Y+27
 1148 0408 8F93      		push r24
 1149 040a 8A8D      		ldd r24,Y+26
 1150 040c 8F93      		push r24
 1151 040e 0E94 0000 		call fprintf_P
 1152 0412 0F90      		pop __tmp_reg__
 1153 0414 0F90      		pop __tmp_reg__
 1154 0416 0F90      		pop __tmp_reg__
 1155 0418 0F90      		pop __tmp_reg__
 1156 041a 0F90      		pop __tmp_reg__
 1157 041c 0F90      		pop __tmp_reg__
 1158               	.L31:
 551:vty.c         **** 
 1160               	.LM101:
 1161 041e 402F      		mov r20,r16
 1162 0420 612F      		mov r22,r17
 1163 0422 8F2D      		mov r24,r15
 1164 0424 0E94 0000 		call rs485curtainDown
 553:vty.c         ****     return OK_INFORM;
 1166               	.LM102:
 1167 0428 8823      		tst r24
 1168 042a 01F0      		breq .L33
 556:vty.c         **** }
 1170               	.LM103:
 1171 042c 83E0      		ldi r24,lo8(3)
 1172 042e 90E0      		ldi r25,0
 1173 0430 00C0      		rjmp .L32
 1174               	.L33:
 554:vty.c         **** 
 1176               	.LM104:
 1177 0432 81E0      		ldi r24,lo8(1)
 1178 0434 90E0      		ldi r25,0
 1179               	.L32:
 1180               	/* epilogue start */
 557:vty.c         **** 
 1182               	.LM105:
 1183 0436 DF91      		pop r29
 1184 0438 CF91      		pop r28
 1185 043a 1F91      		pop r17
 1186 043c 0F91      		pop r16
 1187 043e FF90      		pop r15
 1188 0440 0895      		ret
 1194               	.Lscope13:
 1196               		.stabd	78,0,0
 1200               	statusEncFunction:
 1201               		.stabd	46,0,0
 292:vty.c         ****   nicRegDump(state->myStdInOut);
 1203               	.LM106:
 1204               	.LFBB14:
 1205               	/* prologue: function */
 1206               	/* frame size = 0 */
 1207               	/* stack size = 0 */
 1208               	.L__stack_usage = 0
 293:vty.c         ****   return OK_SILENT;
 1210               	.LM107:
 1211 0442 FC01      		movw r30,r24
 1212 0444 828D      		ldd r24,Z+26
 1213 0446 938D      		ldd r25,Z+27
 1214 0448 0E94 0000 		call nicRegDump
 295:vty.c         **** 
 1216               	.LM108:
 1217 044c 80E0      		ldi r24,0
 1218 044e 90E0      		ldi r25,0
 1219 0450 0895      		ret
 1221               	.Lscope14:
 1223               		.stabd	78,0,0
 1227               	saveConfigFunction:
 1228               		.stabd	46,0,0
 949:vty.c         **** 
 950:vty.c         **** static cliExRes_t saveConfigFunction(cmdState_t *state)
 951:vty.c         **** {
 1230               	.LM109:
 1231               	.LFBB15:
 1232               	/* prologue: function */
 1233               	/* frame size = 0 */
 1234               	/* stack size = 0 */
 1235               	.L__stack_usage = 0
 952:vty.c         ****   (void) state;
 953:vty.c         ****   saveConfiguration();
 1237               	.LM110:
 1238 0452 0E94 0000 		call saveConfiguration
 954:vty.c         ****   return OK_SILENT;
 955:vty.c         **** }
 1240               	.LM111:
 1241 0456 80E0      		ldi r24,0
 1242 0458 90E0      		ldi r25,0
 1243 045a 0895      		ret
 1245               	.Lscope15:
 1247               		.stabd	78,0,0
 1251               	goXmodemWyslijFunction:
 1252               		.stabd	46,0,0
 676:vty.c         ****   fprintf_P(state->myStdInOut, xwyslijStartStr);
 1254               	.LM112:
 1255               	.LFBB16:
 1256 045c CF93      		push r28
 1257 045e DF93      		push r29
 1258               	/* prologue: function */
 1259               	/* frame size = 0 */
 1260               	/* stack size = 2 */
 1261               	.L__stack_usage = 2
 1262 0460 EC01      		movw r28,r24
 677:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1264               	.LM113:
 1265 0462 80E0      		ldi r24,lo8(xwyslijStartStr)
 1266 0464 90E0      		ldi r25,hi8(xwyslijStartStr)
 1267 0466 9F93      		push r25
 1268 0468 8F93      		push r24
 1269 046a 8B8D      		ldd r24,Y+27
 1270 046c 8F93      		push r24
 1271 046e 8A8D      		ldd r24,Y+26
 1272 0470 8F93      		push r24
 1273 0472 0E94 0000 		call fprintf_P
 678:vty.c         ****   {
 1275               	.LM114:
 1276 0476 BE01      		movw r22,r28
 1277 0478 81E0      		ldi r24,lo8(1)
 1278 047a 0E94 0000 		call cmdlineGetArgStr
 1279 047e 60E0      		ldi r22,lo8(fdVty)
 1280 0480 70E0      		ldi r23,hi8(fdVty)
 1281 0482 0E94 0000 		call ramDyskOtworzPlik
 1282 0486 0F90      		pop __tmp_reg__
 1283 0488 0F90      		pop __tmp_reg__
 1284 048a 0F90      		pop __tmp_reg__
 1285 048c 0F90      		pop __tmp_reg__
 1286 048e 8823      		tst r24
 1287 0490 01F0      		breq .L38
 1288               	.LBB15:
 1289               	.LBB16:
 680:vty.c         ****     return ERROR_INFORM;
 1291               	.LM115:
 1292 0492 BE01      		movw r22,r28
 1293 0494 81E0      		ldi r24,lo8(1)
 1294 0496 0E94 0000 		call cmdlineGetArgStr
 1295 049a 9F93      		push r25
 1296 049c 8F93      		push r24
 1297 049e 80E0      		ldi r24,lo8(errorOpenFile)
 1298 04a0 90E0      		ldi r25,hi8(errorOpenFile)
 1299 04a2 9F93      		push r25
 1300 04a4 8F93      		push r24
 1301 04a6 8B8D      		ldd r24,Y+27
 1302 04a8 8F93      		push r24
 1303 04aa 8A8D      		ldd r24,Y+26
 1304 04ac 8F93      		push r24
 1305 04ae 0E94 0000 		call fprintf_P
 1306 04b2 0F90      		pop __tmp_reg__
 1307 04b4 0F90      		pop __tmp_reg__
 1308 04b6 0F90      		pop __tmp_reg__
 1309 04b8 0F90      		pop __tmp_reg__
 1310 04ba 0F90      		pop __tmp_reg__
 1311 04bc 0F90      		pop __tmp_reg__
 1312 04be 84E0      		ldi r24,lo8(4)
 1313 04c0 90E0      		ldi r25,0
 1314 04c2 00C0      		rjmp .L37
 1315               	.L38:
 1316               	.LBE16:
 1317               	.LBE15:
 683:vty.c         **** }
 1319               	.LM116:
 1320 04c4 80E0      		ldi r24,0
 1321 04c6 90E0      		ldi r25,0
 1322               	.L37:
 1323               	/* epilogue start */
 684:vty.c         **** 
 1325               	.LM117:
 1326 04c8 DF91      		pop r29
 1327 04ca CF91      		pop r28
 1328 04cc 0895      		ret
 1330               	.Lscope16:
 1332               		.stabd	78,0,0
 1336               	zapiszModWykFunction:
 1337               		.stabd	46,0,0
 497:vty.c         ****   if (state->argc < 1)
 1339               	.LM118:
 1340               	.LFBB17:
 1341               	/* prologue: function */
 1342               	/* frame size = 0 */
 1343               	/* stack size = 0 */
 1344               	.L__stack_usage = 0
 498:vty.c         ****     return SYNTAX_ERROR;
 1346               	.LM119:
 1347 04ce FC01      		movw r30,r24
 1348 04d0 218D      		ldd r18,Z+25
 1349 04d2 2223      		tst r18
 1350 04d4 01F0      		breq .L41
 1351 04d6 BC01      		movw r22,r24
 1352               	.LBB19:
 1353               	.LBB20:
 501:vty.c         ****   saveSettings(adres);
 1355               	.LM120:
 1356 04d8 81E0      		ldi r24,lo8(1)
 1357 04da 0E94 0000 		call cmdlineGetArgInt
 1358 04de 862F      		mov r24,r22
 502:vty.c         ****   return OK_SILENT;
 1360               	.LM121:
 1361 04e0 0E94 0000 		call saveSettings
 1362 04e4 80E0      		ldi r24,0
 1363 04e6 90E0      		ldi r25,0
 1364 04e8 0895      		ret
 1365               	.L41:
 1366               	.LBE20:
 1367               	.LBE19:
 499:vty.c         **** 
 1369               	.LM122:
 1370 04ea 82E0      		ldi r24,lo8(2)
 1371 04ec 90E0      		ldi r25,0
 504:vty.c         **** 
 1373               	.LM123:
 1374 04ee 0895      		ret
 1376               	.Lscope17:
 1378               		.stabd	78,0,0
 1382               	ustawModWykFunction:
 1383               		.stabd	46,0,0
 485:vty.c         ****   if (state->argc < 2)
 1385               	.LM124:
 1386               	.LFBB18:
 1387 04f0 1F93      		push r17
 1388 04f2 CF93      		push r28
 1389 04f4 DF93      		push r29
 1390               	/* prologue: function */
 1391               	/* frame size = 0 */
 1392               	/* stack size = 3 */
 1393               	.L__stack_usage = 3
 486:vty.c         ****     return SYNTAX_ERROR;
 1395               	.LM125:
 1396 04f6 FC01      		movw r30,r24
 1397 04f8 218D      		ldd r18,Z+25
 1398 04fa 2230      		cpi r18,lo8(2)
 1399 04fc 00F0      		brlo .L44
 1400 04fe EC01      		movw r28,r24
 1401               	.LBB23:
 1402               	.LBB24:
 489:vty.c         ****   uint8_t wartosc = cmdlineGetArgHex(2, state);
 1404               	.LM126:
 1405 0500 BC01      		movw r22,r24
 1406 0502 81E0      		ldi r24,lo8(1)
 1407 0504 0E94 0000 		call cmdlineGetArgInt
 1408 0508 162F      		mov r17,r22
 490:vty.c         **** 
 1410               	.LM127:
 1411 050a BE01      		movw r22,r28
 1412 050c 82E0      		ldi r24,lo8(2)
 1413 050e 0E94 0000 		call cmdlineGetArgHex
 492:vty.c         **** 
 1415               	.LM128:
 1416 0512 812F      		mov r24,r17
 1417 0514 0E94 0000 		call sendSettings
 1418 0518 80E0      		ldi r24,0
 1419 051a 90E0      		ldi r25,0
 1420 051c 00C0      		rjmp .L43
 1421               	.L44:
 1422               	.LBE24:
 1423               	.LBE23:
 487:vty.c         **** 
 1425               	.LM129:
 1426 051e 82E0      		ldi r24,lo8(2)
 1427 0520 90E0      		ldi r25,0
 1428               	.L43:
 1429               	/* epilogue start */
 495:vty.c         **** static cliExRes_t zapiszModWykFunction(cmdState_t *state)
 1431               	.LM130:
 1432 0522 DF91      		pop r29
 1433 0524 CF91      		pop r28
 1434 0526 1F91      		pop r17
 1435 0528 0895      		ret
 1437               	.Lscope18:
 1439               		.stabd	78,0,0
 1443               	ustawPortRezystor:
 1444               		.stabd	46,0,0
 599:vty.c         ****   if (state->argc < 1)
 1446               	.LM131:
 1447               	.LFBB19:
 1448               	/* prologue: function */
 1449               	/* frame size = 0 */
 1450               	/* stack size = 0 */
 1451               	.L__stack_usage = 0
 600:vty.c         ****     return SYNTAX_ERROR;
 1453               	.LM132:
 1454 052a FC01      		movw r30,r24
 1455 052c 218D      		ldd r18,Z+25
 1456 052e 2223      		tst r18
 1457 0530 01F0      		breq .L47
 1458 0532 BC01      		movw r22,r24
 1459               	.LBB27:
 1460               	.LBB28:
 603:vty.c         **** 
 1462               	.LM133:
 1463 0534 81E0      		ldi r24,lo8(1)
 1464 0536 0E94 0000 		call cmdlineGetArgInt
 1465 053a 862F      		mov r24,r22
 605:vty.c         **** 
 1467               	.LM134:
 1468 053c 0E94 0000 		call MCP4150_setValue
 1469 0540 80E0      		ldi r24,0
 1470 0542 90E0      		ldi r25,0
 1471 0544 0895      		ret
 1472               	.L47:
 1473               	.LBE28:
 1474               	.LBE27:
 601:vty.c         **** 
 1476               	.LM135:
 1477 0546 82E0      		ldi r24,lo8(2)
 1478 0548 90E0      		ldi r25,0
 608:vty.c         **** 
 1480               	.LM136:
 1481 054a 0895      		ret
 1483               	.Lscope19:
 1485               		.stabd	78,0,0
 1489               	curtainUpFunction:
 1490               		.stabd	46,0,0
 560:vty.c         ****   if (state->argc < 2)
 1492               	.LM137:
 1493               	.LFBB20:
 1494 054c FF92      		push r15
 1495 054e 0F93      		push r16
 1496 0550 1F93      		push r17
 1497 0552 CF93      		push r28
 1498 0554 DF93      		push r29
 1499               	/* prologue: function */
 1500               	/* frame size = 0 */
 1501               	/* stack size = 5 */
 1502               	.L__stack_usage = 5
 561:vty.c         ****     return SYNTAX_ERROR;
 1504               	.LM138:
 1505 0556 FC01      		movw r30,r24
 1506 0558 218D      		ldd r18,Z+25
 1507 055a 2230      		cpi r18,lo8(2)
 1508 055c 00F4      		brsh .+2
 1509 055e 00C0      		rjmp .L52
 1510 0560 EC01      		movw r28,r24
 1511               	.LBB31:
 1512               	.LBB32:
 564:vty.c         ****   uint8_t nrRolety     = (cmdlineGetArgInt(2, state) & 0x01);
 1514               	.LM139:
 1515 0562 BC01      		movw r22,r24
 1516 0564 81E0      		ldi r24,lo8(1)
 1517 0566 0E94 0000 		call cmdlineGetArgInt
 1518 056a 162F      		mov r17,r22
 1519 056c 1F73      		andi r17,lo8(63)
 565:vty.c         ****   uint8_t wartosc = 255;
 1521               	.LM140:
 1522 056e BE01      		movw r22,r28
 1523 0570 82E0      		ldi r24,lo8(2)
 1524 0572 0E94 0000 		call cmdlineGetArgInt
 1525 0576 062F      		mov r16,r22
 1526 0578 0170      		andi r16,lo8(1)
 567:vty.c         ****     wartosc = cmdlineGetArgInt(3, state);
 1528               	.LM141:
 1529 057a 898D      		ldd r24,Y+25
 1530 057c 8330      		cpi r24,lo8(3)
 1531 057e 00F0      		brlo .L53
 568:vty.c         **** 
 1533               	.LM142:
 1534 0580 BE01      		movw r22,r28
 1535 0582 83E0      		ldi r24,lo8(3)
 1536 0584 0E94 0000 		call cmdlineGetArgInt
 1537 0588 F62E      		mov r15,r22
 1538 058a 00C0      		rjmp .L50
 1539               	.L53:
 566:vty.c         ****   if (state->argc > 2)
 1541               	.LM143:
 1542 058c FF24      		clr r15
 1543 058e FA94      		dec r15
 1544               	.L50:
 570:vty.c         ****   if ((wartosc > 0) && (wartosc <=100))
 1546               	.LM144:
 1547 0590 802F      		mov r24,r16
 1548 0592 90E0      		ldi r25,0
 1549 0594 0196      		adiw r24,1
 1550 0596 9F93      		push r25
 1551 0598 8F93      		push r24
 1552 059a 1F92      		push __zero_reg__
 1553 059c 1F93      		push r17
 1554 059e 80E0      		ldi r24,lo8(movingCurtainUpStr)
 1555 05a0 90E0      		ldi r25,hi8(movingCurtainUpStr)
 1556 05a2 9F93      		push r25
 1557 05a4 8F93      		push r24
 1558 05a6 8B8D      		ldd r24,Y+27
 1559 05a8 8F93      		push r24
 1560 05aa 8A8D      		ldd r24,Y+26
 1561 05ac 8F93      		push r24
 1562 05ae 0E94 0000 		call fprintf_P
 571:vty.c         ****     fprintf_P(state->myStdInOut, movingCurtainPosStr, wartosc);
 1564               	.LM145:
 1565 05b2 8DB7      		in r24,__SP_L__
 1566 05b4 9EB7      		in r25,__SP_H__
 1567 05b6 0896      		adiw r24,8
 1568 05b8 0FB6      		in __tmp_reg__,__SREG__
 1569 05ba F894      		cli
 1570 05bc 9EBF      		out __SP_H__,r25
 1571 05be 0FBE      		out __SREG__,__tmp_reg__
 1572 05c0 8DBF      		out __SP_L__,r24
 1573 05c2 8FEF      		ldi r24,lo8(-1)
 1574 05c4 8F0D      		add r24,r15
 1575 05c6 8436      		cpi r24,lo8(100)
 1576 05c8 00F4      		brsh .L51
 572:vty.c         **** 
 1578               	.LM146:
 1579 05ca 1F92      		push __zero_reg__
 1580 05cc FF92      		push r15
 1581 05ce 80E0      		ldi r24,lo8(movingCurtainPosStr)
 1582 05d0 90E0      		ldi r25,hi8(movingCurtainPosStr)
 1583 05d2 9F93      		push r25
 1584 05d4 8F93      		push r24
 1585 05d6 8B8D      		ldd r24,Y+27
 1586 05d8 8F93      		push r24
 1587 05da 8A8D      		ldd r24,Y+26
 1588 05dc 8F93      		push r24
 1589 05de 0E94 0000 		call fprintf_P
 1590 05e2 0F90      		pop __tmp_reg__
 1591 05e4 0F90      		pop __tmp_reg__
 1592 05e6 0F90      		pop __tmp_reg__
 1593 05e8 0F90      		pop __tmp_reg__
 1594 05ea 0F90      		pop __tmp_reg__
 1595 05ec 0F90      		pop __tmp_reg__
 1596               	.L51:
 574:vty.c         **** 
 1598               	.LM147:
 1599 05ee 4F2D      		mov r20,r15
 1600 05f0 602F      		mov r22,r16
 1601 05f2 812F      		mov r24,r17
 1602 05f4 0E94 0000 		call rs485curtainUp
 576:vty.c         ****     return OK_INFORM;
 1604               	.LM148:
 1605 05f8 8823      		tst r24
 1606 05fa 01F0      		breq .L54
 579:vty.c         **** }
 1608               	.LM149:
 1609 05fc 83E0      		ldi r24,lo8(3)
 1610 05fe 90E0      		ldi r25,0
 1611 0600 00C0      		rjmp .L49
 1612               	.L52:
 1613               	.LBE32:
 1614               	.LBE31:
 562:vty.c         **** 
 1616               	.LM150:
 1617 0602 82E0      		ldi r24,lo8(2)
 1618 0604 90E0      		ldi r25,0
 1619 0606 00C0      		rjmp .L49
 1620               	.L54:
 1621               	.LBB34:
 1622               	.LBB33:
 577:vty.c         **** 
 1624               	.LM151:
 1625 0608 81E0      		ldi r24,lo8(1)
 1626 060a 90E0      		ldi r25,0
 1627               	.L49:
 1628               	/* epilogue start */
 1629               	.LBE33:
 1630               	.LBE34:
 580:vty.c         **** 
 1632               	.LM152:
 1633 060c DF91      		pop r29
 1634 060e CF91      		pop r28
 1635 0610 1F91      		pop r17
 1636 0612 0F91      		pop r16
 1637 0614 FF90      		pop r15
 1638 0616 0895      		ret
 1650               	.Lscope20:
 1652               		.stabd	78,0,0
 1656               	editRamFileFunction:
 1657               		.stabd	46,0,0
 902:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1659               	.LM153:
 1660               	.LFBB21:
 1661 0618 0F93      		push r16
 1662 061a 1F93      		push r17
 1663 061c CF93      		push r28
 1664 061e DF93      		push r29
 1665 0620 1F92      		push __zero_reg__
 1666 0622 CDB7      		in r28,__SP_L__
 1667 0624 DEB7      		in r29,__SP_H__
 1668               	/* prologue: function */
 1669               	/* frame size = 1 */
 1670               	/* stack size = 5 */
 1671               	.L__stack_usage = 5
 1672 0626 8C01      		movw r16,r24
 903:vty.c         ****   {
 1674               	.LM154:
 1675 0628 BC01      		movw r22,r24
 1676 062a 81E0      		ldi r24,lo8(1)
 1677 062c 0E94 0000 		call cmdlineGetArgStr
 1678 0630 60E0      		ldi r22,lo8(fdVty)
 1679 0632 70E0      		ldi r23,hi8(fdVty)
 1680 0634 0E94 0000 		call ramDyskOtworzPlik
 1681 0638 8823      		tst r24
 1682 063a 01F0      		breq .L56
 905:vty.c         ****     return ERROR_INFORM;
 1684               	.LM155:
 1685 063c B801      		movw r22,r16
 1686 063e 81E0      		ldi r24,lo8(1)
 1687 0640 0E94 0000 		call cmdlineGetArgStr
 1688 0644 9F93      		push r25
 1689 0646 8F93      		push r24
 1690 0648 80E0      		ldi r24,lo8(errorOpenFile)
 1691 064a 90E0      		ldi r25,hi8(errorOpenFile)
 1692 064c 9F93      		push r25
 1693 064e 8F93      		push r24
 1694 0650 F801      		movw r30,r16
 1695 0652 838D      		ldd r24,Z+27
 1696 0654 8F93      		push r24
 1697 0656 828D      		ldd r24,Z+26
 1698 0658 8F93      		push r24
 1699 065a 0E94 0000 		call fprintf_P
 906:vty.c         ****   }
 1701               	.LM156:
 1702 065e 0F90      		pop __tmp_reg__
 1703 0660 0F90      		pop __tmp_reg__
 1704 0662 0F90      		pop __tmp_reg__
 1705 0664 0F90      		pop __tmp_reg__
 1706 0666 0F90      		pop __tmp_reg__
 1707 0668 0F90      		pop __tmp_reg__
 1708 066a 84E0      		ldi r24,lo8(4)
 1709 066c 90E0      		ldi r25,0
 1710 066e 00C0      		rjmp .L57
 1711               	.L56:
 1712               	.LBB37:
 1713               	.LBB38:
 908:vty.c         ****   uint8_t znak = 0;
 1715               	.LM157:
 1716 0670 80E0      		ldi r24,lo8(fdVty)
 1717 0672 90E0      		ldi r25,hi8(fdVty)
 1718 0674 0E94 0000 		call ramDyskUstawWskaznikNaKoniec
 909:vty.c         ****   fprintf_P(state->myStdInOut, editRamFileIntroStr);
 1720               	.LM158:
 1721 0678 1982      		std Y+1,__zero_reg__
 910:vty.c         ****   while(1)
 1723               	.LM159:
 1724 067a 80E0      		ldi r24,lo8(editRamFileIntroStr)
 1725 067c 90E0      		ldi r25,hi8(editRamFileIntroStr)
 1726 067e 9F93      		push r25
 1727 0680 8F93      		push r24
 1728 0682 F801      		movw r30,r16
 1729 0684 838D      		ldd r24,Z+27
 1730 0686 8F93      		push r24
 1731 0688 828D      		ldd r24,Z+26
 1732 068a 8F93      		push r24
 1733 068c 0E94 0000 		call fprintf_P
 1734 0690 0F90      		pop __tmp_reg__
 1735 0692 0F90      		pop __tmp_reg__
 1736 0694 0F90      		pop __tmp_reg__
 1737 0696 0F90      		pop __tmp_reg__
 1738               	.L58:
 913:vty.c         ****       continue;
 1740               	.LM160:
 1741 0698 20E0      		ldi r18,0
 1742 069a 4FEF      		ldi r20,lo8(-1)
 1743 069c 5FEF      		ldi r21,lo8(-1)
 1744 069e BE01      		movw r22,r28
 1745 06a0 6F5F      		subi r22,-1
 1746 06a2 7F4F      		sbci r23,-1
 1747 06a4 8091 0000 		lds r24,xVtyRec
 1748 06a8 9091 0000 		lds r25,xVtyRec+1
 1749 06ac 0E94 0000 		call xQueueGenericReceive
 1750 06b0 8823      		tst r24
 1751 06b2 01F0      		breq .L58
 916:vty.c         ****       break;
 1753               	.LM161:
 1754 06b4 8981      		ldd r24,Y+1
 1755 06b6 8330      		cpi r24,lo8(3)
 1756 06b8 01F0      		breq .L59
 919:vty.c         ****     ramDyskZapiszBajtDoPliku(&fdVty, znak);
 1758               	.LM162:
 1759 06ba 0E94 0000 		call uartVtySendByte
 920:vty.c         ****   }
 1761               	.LM163:
 1762 06be 6981      		ldd r22,Y+1
 1763 06c0 80E0      		ldi r24,lo8(fdVty)
 1764 06c2 90E0      		ldi r25,hi8(fdVty)
 1765 06c4 0E94 0000 		call ramDyskZapiszBajtDoPliku
 1766 06c8 00C0      		rjmp .L58
 1767               	.L59:
 922:vty.c         ****   return OK_SILENT;
 1769               	.LM164:
 1770 06ca 80E0      		ldi r24,lo8(fdVty)
 1771 06cc 90E0      		ldi r25,hi8(fdVty)
 1772 06ce 0E94 0000 		call ramDyskZamknijPlik
 1773 06d2 80E0      		ldi r24,0
 1774 06d4 90E0      		ldi r25,0
 1775               	.L57:
 1776               	/* epilogue start */
 1777               	.LBE38:
 1778               	.LBE37:
 924:vty.c         **** 
 1780               	.LM165:
 1781 06d6 0F90      		pop __tmp_reg__
 1782 06d8 DF91      		pop r29
 1783 06da CF91      		pop r28
 1784 06dc 1F91      		pop r17
 1785 06de 0F91      		pop r16
 1786 06e0 0895      		ret
 1791               	.Lscope21:
 1793               		.stabd	78,0,0
 1797               	goXmodemOdbierzFunction:
 1798               		.stabd	46,0,0
 687:vty.c         ****   fprintf_P(state->myStdInOut, PSTR("Xmodem: rozpoczynanie odbioru\r\n"));
 1800               	.LM166:
 1801               	.LFBB22:
 1802 06e2 8F92      		push r8
 1803 06e4 9F92      		push r9
 1804 06e6 AF92      		push r10
 1805 06e8 BF92      		push r11
 1806 06ea CF92      		push r12
 1807 06ec DF92      		push r13
 1808 06ee EF92      		push r14
 1809 06f0 FF92      		push r15
 1810 06f2 0F93      		push r16
 1811 06f4 1F93      		push r17
 1812 06f6 CF93      		push r28
 1813 06f8 DF93      		push r29
 1814 06fa 00D0      		rcall .
 1815 06fc 00D0      		rcall .
 1816 06fe 00D0      		rcall .
 1817 0700 CDB7      		in r28,__SP_L__
 1818 0702 DEB7      		in r29,__SP_H__
 1819               	/* prologue: function */
 1820               	/* frame size = 6 */
 1821               	/* stack size = 18 */
 1822               	.L__stack_usage = 18
 1823 0704 8C01      		movw r16,r24
 688:vty.c         ****   if (ramDyskOtworzPlik(cmdlineGetArgStr(1, state), &fdVty) != 0)
 1825               	.LM167:
 1826 0706 80E0      		ldi r24,lo8(__c.3768)
 1827 0708 90E0      		ldi r25,hi8(__c.3768)
 1828 070a 9F93      		push r25
 1829 070c 8F93      		push r24
 1830 070e F801      		movw r30,r16
 1831 0710 838D      		ldd r24,Z+27
 1832 0712 8F93      		push r24
 1833 0714 828D      		ldd r24,Z+26
 1834 0716 8F93      		push r24
 1835 0718 0E94 0000 		call fprintf_P
 689:vty.c         ****   {
 1837               	.LM168:
 1838 071c B801      		movw r22,r16
 1839 071e 81E0      		ldi r24,lo8(1)
 1840 0720 0E94 0000 		call cmdlineGetArgStr
 1841 0724 60E0      		ldi r22,lo8(fdVty)
 1842 0726 70E0      		ldi r23,hi8(fdVty)
 1843 0728 0E94 0000 		call ramDyskOtworzPlik
 1844 072c 0F90      		pop __tmp_reg__
 1845 072e 0F90      		pop __tmp_reg__
 1846 0730 0F90      		pop __tmp_reg__
 1847 0732 0F90      		pop __tmp_reg__
 1848 0734 8823      		tst r24
 1849 0736 01F0      		breq .L64
 691:vty.c         ****     return ERROR_INFORM;
 1851               	.LM169:
 1852 0738 B801      		movw r22,r16
 1853 073a 81E0      		ldi r24,lo8(1)
 1854 073c 0E94 0000 		call cmdlineGetArgStr
 1855 0740 9F93      		push r25
 1856 0742 8F93      		push r24
 1857 0744 80E0      		ldi r24,lo8(errorOpenFile)
 1858 0746 90E0      		ldi r25,hi8(errorOpenFile)
 1859 0748 9F93      		push r25
 1860 074a 8F93      		push r24
 1861 074c F801      		movw r30,r16
 1862 074e 838D      		ldd r24,Z+27
 1863 0750 8F93      		push r24
 1864 0752 828D      		ldd r24,Z+26
 1865 0754 8F93      		push r24
 1866 0756 0E94 0000 		call fprintf_P
 692:vty.c         ****   }
 1868               	.LM170:
 1869 075a 0F90      		pop __tmp_reg__
 1870 075c 0F90      		pop __tmp_reg__
 1871 075e 0F90      		pop __tmp_reg__
 1872 0760 0F90      		pop __tmp_reg__
 1873 0762 0F90      		pop __tmp_reg__
 1874 0764 0F90      		pop __tmp_reg__
 1875 0766 00C0      		rjmp .L107
 1876               	.L64:
 1877               	.LBB45:
 1878               	.LBB46:
 714:vty.c         ****   state->err2=0;
 1880               	.LM171:
 1881 0768 F801      		movw r30,r16
 1882 076a 168E      		std Z+30,__zero_reg__
 1883 076c 158E      		std Z+29,__zero_reg__
 715:vty.c         ****   liczbaProb = 20;
 1885               	.LM172:
 1886 076e 178E      		std Z+31,__zero_reg__
 1887 0770 74E1      		ldi r23,lo8(20)
 1888 0772 F72E      		mov r15,r23
 1889               	.L69:
 719:vty.c         ****     while(!(UCSR1A & (1 << TXC1)));                              //Czekanie na opróżnienie bufora
 1891               	.LM173:
 1892 0774 F801      		movw r30,r16
 1893 0776 628D      		ldd r22,Z+26
 1894 0778 738D      		ldd r23,Z+27
 1895 077a 83E4      		ldi r24,lo8(67)
 1896 077c 90E0      		ldi r25,0
 1897 077e 0E94 0000 		call fputc
 1898               	.L66:
 720:vty.c         **** 
 1900               	.LM174:
 1901 0782 8091 9B00 		lds r24,155
 1902 0786 86FF      		sbrs r24,6
 1903 0788 00C0      		rjmp .L66
 722:vty.c         ****       if (c == SOH)
 1905               	.LM175:
 1906 078a 20E0      		ldi r18,0
 1907 078c 44E6      		ldi r20,lo8(100)
 1908 078e 50E0      		ldi r21,0
 1909 0790 BE01      		movw r22,r28
 1910 0792 6B5F      		subi r22,-5
 1911 0794 7F4F      		sbci r23,-1
 1912 0796 8091 0000 		lds r24,xVtyRec
 1913 079a 9091 0000 		lds r25,xVtyRec+1
 1914 079e 0E94 0000 		call xQueueGenericReceive
 1915 07a2 8823      		tst r24
 1916 07a4 01F0      		breq .L67
 723:vty.c         ****         break;                                                   //Rozpoczynamy transmisje
 1918               	.LM176:
 1919 07a6 8D81      		ldd r24,Y+5
 1920 07a8 8130      		cpi r24,lo8(1)
 1921 07aa 01F0      		breq .L68
 1922               	.L67:
 1923 07ac FA94      		dec r15
 727:vty.c         ****     {
 1925               	.LM177:
 1926 07ae F110      		cpse r15,__zero_reg__
 1927 07b0 00C0      		rjmp .L69
 729:vty.c         ****       state->errno = (uint8_t)(AllOK);
 1929               	.LM178:
 1930 07b2 80E0      		ldi r24,lo8(fdVty)
 1931 07b4 90E0      		ldi r25,hi8(fdVty)
 1932 07b6 0E94 0000 		call ramDyskZamknijPlik
 730:vty.c         ****       return ERROR_INFORM;
 1934               	.LM179:
 1935 07ba F801      		movw r30,r16
 1936 07bc 148E      		std Z+28,__zero_reg__
 1937               	.L107:
 731:vty.c         ****     }
 1939               	.LM180:
 1940 07be 84E0      		ldi r24,lo8(4)
 1941 07c0 90E0      		ldi r25,0
 1942 07c2 00C0      		rjmp .L65
 1943               	.L68:
 738:vty.c         ****   zapPtrKopia     = zapPtr;
 1945               	.LM181:
 1946 07c4 61E0      		ldi r22,lo8(1)
 1947 07c6 70E0      		ldi r23,0
 1948 07c8 80E0      		ldi r24,lo8(fdVty)
 1949 07ca 90E0      		ldi r25,hi8(fdVty)
 1950 07cc 0E94 0000 		call ramDyskDodajBlokXmodem
 1951 07d0 4C01      		movw r8,r24
 735:vty.c         ****   liczbaProb = 10;
 1953               	.LM182:
 1954 07d2 EE24      		clr r14
 1955 07d4 E394      		inc r14
 736:vty.c         **** 
 1957               	.LM183:
 1958 07d6 5AE0      		ldi r21,lo8(10)
 1959 07d8 B52E      		mov r11,r21
 788:vty.c         ****         break;
 1961               	.LM184:
 1962 07da 63E0      		ldi r22,lo8(3)
 1963 07dc A62E      		mov r10,r22
 1964               	.L86:
 742:vty.c         ****     {
 1966               	.LM185:
 1967 07de 20E0      		ldi r18,0
 1968 07e0 44E6      		ldi r20,lo8(100)
 1969 07e2 50E0      		ldi r21,0
 1970 07e4 BE01      		movw r22,r28
 1971 07e6 6C5F      		subi r22,-4
 1972 07e8 7F4F      		sbci r23,-1
 1973 07ea 8091 0000 		lds r24,xVtyRec
 1974 07ee 9091 0000 		lds r25,xVtyRec+1
 1975 07f2 0E94 0000 		call xQueueGenericReceive
 1976 07f6 8111      		cpse r24,__zero_reg__
 1977 07f8 00C0      		rjmp .L71
 1978               	.L84:
 744:vty.c         ****       break;
 1980               	.LM186:
 1981 07fa 82E0      		ldi r24,lo8(2)
 1982 07fc 00C0      		rjmp .L108
 1983               	.L71:
 748:vty.c         ****     {
 1985               	.LM187:
 1986 07fe 20E0      		ldi r18,0
 1987 0800 41E0      		ldi r20,lo8(1)
 1988 0802 50E0      		ldi r21,0
 1989 0804 BE01      		movw r22,r28
 1990 0806 6D5F      		subi r22,-3
 1991 0808 7F4F      		sbci r23,-1
 1992 080a 8091 0000 		lds r24,xVtyRec
 1993 080e 9091 0000 		lds r25,xVtyRec+1
 1994 0812 0E94 0000 		call xQueueGenericReceive
 1995 0816 8111      		cpse r24,__zero_reg__
 1996 0818 00C0      		rjmp .L73
 750:vty.c         ****       break;
 1998               	.LM188:
 1999 081a 83E0      		ldi r24,lo8(3)
 2000               	.L108:
 2001 081c F801      		movw r30,r16
 2002 081e 00C0      		rjmp .L105
 2003               	.L73:
 755:vty.c         ****     if (nrBlokuZdalny != c)
 2005               	.LM189:
 2006 0820 2B81      		ldd r18,Y+3
 2007 0822 822F      		mov r24,r18
 2008 0824 8095      		com r24
 2009 0826 8D83      		std Y+5,r24
 756:vty.c         ****     {
 2011               	.LM190:
 2012 0828 FC80      		ldd r15,Y+4
 2013 082a F816      		cp r15,r24
 2014 082c 01F0      		breq .L74
 758:vty.c         ****       state->err1 = nrBlokuZdalny;
 2016               	.LM191:
 2017 082e 85E0      		ldi r24,lo8(5)
 2018 0830 F801      		movw r30,r16
 2019 0832 848F      		std Z+28,r24
 759:vty.c         ****       state->err2 = nrBlokuZdalnyNeg;
 2021               	.LM192:
 2022 0834 8F2D      		mov r24,r15
 2023 0836 90E0      		ldi r25,0
 2024 0838 968F      		std Z+30,r25
 2025 083a 858F      		std Z+29,r24
 760:vty.c         ****       break;
 2027               	.LM193:
 2028 083c 278F      		std Z+31,r18
 2029 083e 00C0      		rjmp .L72
 2030               	.L74:
 765:vty.c         ****     if (nrBlokuZdalny == c)
 2032               	.LM194:
 2033 0840 8FEF      		ldi r24,lo8(-1)
 2034 0842 8E0D      		add r24,r14
 2035 0844 8D83      		std Y+5,r24
 766:vty.c         ****     {
 2037               	.LM195:
 2038 0846 F812      		cpse r15,r24
 2039 0848 00C0      		rjmp .L75
 769:vty.c         ****       zapPtrKopia = zapPtr;
 2041               	.LM196:
 2042 084a 6F2D      		mov r22,r15
 2043 084c 70E0      		ldi r23,0
 2044 084e 80E0      		ldi r24,lo8(fdVty)
 2045 0850 90E0      		ldi r25,hi8(fdVty)
 2046 0852 0E94 0000 		call ramDyskDodajBlokXmodem
 2047 0856 4C01      		movw r8,r24
 2048 0858 EF2C      		mov r14,r15
 2049               	.L75:
 774:vty.c         ****     {
 2051               	.LM197:
 2052 085a FC80      		ldd r15,Y+4
 2053 085c FE14      		cp r15,r14
 2054 085e 01F0      		breq .L76
 776:vty.c         ****       state->err1 = nrBlokuZdalnyNeg;
 2056               	.LM198:
 2057 0860 84E0      		ldi r24,lo8(4)
 2058 0862 F801      		movw r30,r16
 2059 0864 848F      		std Z+28,r24
 777:vty.c         ****       state->err2 = nrBloku;
 2061               	.LM199:
 2062 0866 8B81      		ldd r24,Y+3
 2063 0868 90E0      		ldi r25,0
 2064 086a 968F      		std Z+30,r25
 2065 086c 858F      		std Z+29,r24
 778:vty.c         ****       break;
 2067               	.LM200:
 2068 086e E78E      		std Z+31,r14
 2069 0870 00C0      		rjmp .L72
 2070               	.L76:
 2071 0872 6401      		movw r12,r8
 774:vty.c         ****     {
 2073               	.LM201:
 2074 0874 E12C      		mov r14,__zero_reg__
 2075               	.L78:
 784:vty.c         ****         *(zapPtr++) = c;
 2077               	.LM202:
 2078 0876 20E0      		ldi r18,0
 2079 0878 4AE0      		ldi r20,lo8(10)
 2080 087a 50E0      		ldi r21,0
 2081 087c BE01      		movw r22,r28
 2082 087e 6B5F      		subi r22,-5
 2083 0880 7F4F      		sbci r23,-1
 2084 0882 8091 0000 		lds r24,xVtyRec
 2085 0886 9091 0000 		lds r25,xVtyRec+1
 2086 088a 0E94 0000 		call xQueueGenericReceive
 2087 088e 8823      		tst r24
 2088 0890 01F0      		breq .L77
 785:vty.c         ****       else
 2090               	.LM203:
 2091 0892 8D81      		ldd r24,Y+5
 2092 0894 F401      		movw r30,r8
 2093 0896 8193      		st Z+,r24
 2094 0898 4F01      		movw r8,r30
 782:vty.c         ****     {
 2096               	.LM204:
 2097 089a E394      		inc r14
 2098 089c F0E8      		ldi r31,lo8(-128)
 2099 089e EF12      		cpse r14,r31
 2100 08a0 00C0      		rjmp .L78
 2101 08a2 00C0      		rjmp .L79
 2102               	.L77:
 788:vty.c         ****         break;
 2104               	.LM205:
 2105 08a4 F801      		movw r30,r16
 2106 08a6 A48E      		std Z+28,r10
 2107               	.L79:
 792:vty.c         ****     {
 2109               	.LM206:
 2110 08a8 20E0      		ldi r18,0
 2111 08aa 4AE0      		ldi r20,lo8(10)
 2112 08ac 50E0      		ldi r21,0
 2113 08ae BE01      		movw r22,r28
 2114 08b0 6E5F      		subi r22,-2
 2115 08b2 7F4F      		sbci r23,-1
 2116 08b4 8091 0000 		lds r24,xVtyRec
 2117 08b8 9091 0000 		lds r25,xVtyRec+1
 2118 08bc 0E94 0000 		call xQueueGenericReceive
 2119 08c0 8111      		cpse r24,__zero_reg__
 2120 08c2 00C0      		rjmp .L80
 794:vty.c         ****         state->err1 = 2;
 2122               	.LM207:
 2123 08c4 86E0      		ldi r24,lo8(6)
 2124 08c6 F801      		movw r30,r16
 2125 08c8 848F      		std Z+28,r24
 795:vty.c         ****         break;
 2127               	.LM208:
 2128 08ca 82E0      		ldi r24,lo8(2)
 2129 08cc 90E0      		ldi r25,0
 2130 08ce 00C0      		rjmp .L106
 2131               	.L80:
 798:vty.c         ****     {
 2133               	.LM209:
 2134 08d0 20E0      		ldi r18,0
 2135 08d2 4AE0      		ldi r20,lo8(10)
 2136 08d4 50E0      		ldi r21,0
 2137 08d6 BE01      		movw r22,r28
 2138 08d8 6F5F      		subi r22,-1
 2139 08da 7F4F      		sbci r23,-1
 2140 08dc 8091 0000 		lds r24,xVtyRec
 2141 08e0 9091 0000 		lds r25,xVtyRec+1
 2142 08e4 0E94 0000 		call xQueueGenericReceive
 2143 08e8 8111      		cpse r24,__zero_reg__
 2144 08ea 00C0      		rjmp .L90
 800:vty.c         ****         state->err1 = 1;
 2146               	.LM210:
 2147 08ec 86E0      		ldi r24,lo8(6)
 2148 08ee F801      		movw r30,r16
 2149 08f0 848F      		std Z+28,r24
 801:vty.c         ****         break;
 2151               	.LM211:
 2152 08f2 81E0      		ldi r24,lo8(1)
 2153 08f4 90E0      		ldi r25,0
 2154 08f6 00C0      		rjmp .L106
 2155               	.L90:
 798:vty.c         ****     {
 2157               	.LM212:
 2158 08f8 30E0      		ldi r19,0
 2159 08fa 80E0      		ldi r24,0
 2160 08fc 90E0      		ldi r25,0
 2161               	.L81:
 810:vty.c         **** 
 2163               	.LM213:
 2164 08fe F601      		movw r30,r12
 2165 0900 2191      		ld r18,Z+
 2166 0902 6F01      		movw r12,r30
 2167               	.LBB47:
 2168               	.LBB48:
 2170               	.Ltext1:
   1:/usr/lib/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Dave Hylands
   4:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Frederic Nadeau
   5:/usr/lib/avr/include/util/crc16.h ****    All rights reserved.
   6:/usr/lib/avr/include/util/crc16.h **** 
   7:/usr/lib/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   8:/usr/lib/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   9:/usr/lib/avr/include/util/crc16.h **** 
  10:/usr/lib/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
  11:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  12:/usr/lib/avr/include/util/crc16.h **** 
  13:/usr/lib/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  14:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  15:/usr/lib/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  16:/usr/lib/avr/include/util/crc16.h ****      distribution.
  17:/usr/lib/avr/include/util/crc16.h **** 
  18:/usr/lib/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  19:/usr/lib/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  20:/usr/lib/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  21:/usr/lib/avr/include/util/crc16.h **** 
  22:/usr/lib/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  23:/usr/lib/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  24:/usr/lib/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  25:/usr/lib/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  26:/usr/lib/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  27:/usr/lib/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  28:/usr/lib/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  29:/usr/lib/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  30:/usr/lib/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  31:/usr/lib/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:/usr/lib/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  33:/usr/lib/avr/include/util/crc16.h **** 
  34:/usr/lib/avr/include/util/crc16.h **** /* $Id$ */
  35:/usr/lib/avr/include/util/crc16.h **** 
  36:/usr/lib/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  37:/usr/lib/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  38:/usr/lib/avr/include/util/crc16.h **** 
  39:/usr/lib/avr/include/util/crc16.h **** #include <stdint.h>
  40:/usr/lib/avr/include/util/crc16.h **** 
  41:/usr/lib/avr/include/util/crc16.h **** /** \file */
  42:/usr/lib/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  43:/usr/lib/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  44:/usr/lib/avr/include/util/crc16.h **** 
  45:/usr/lib/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  46:/usr/lib/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  47:/usr/lib/avr/include/util/crc16.h **** 
  48:/usr/lib/avr/include/util/crc16.h ****     \par References:
  49:/usr/lib/avr/include/util/crc16.h **** 
  50:/usr/lib/avr/include/util/crc16.h ****     \par
  51:/usr/lib/avr/include/util/crc16.h **** 
  52:/usr/lib/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  53:/usr/lib/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  54:/usr/lib/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  55:/usr/lib/avr/include/util/crc16.h **** 
  56:/usr/lib/avr/include/util/crc16.h ****     \par
  57:/usr/lib/avr/include/util/crc16.h **** 
  58:/usr/lib/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  59:/usr/lib/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  60:/usr/lib/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  61:/usr/lib/avr/include/util/crc16.h ****     obtain a copy.
  62:/usr/lib/avr/include/util/crc16.h **** 
  63:/usr/lib/avr/include/util/crc16.h ****     A typical application would look like:
  64:/usr/lib/avr/include/util/crc16.h **** 
  65:/usr/lib/avr/include/util/crc16.h ****     \code
  66:/usr/lib/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  67:/usr/lib/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  68:/usr/lib/avr/include/util/crc16.h **** 
  69:/usr/lib/avr/include/util/crc16.h ****     int
  70:/usr/lib/avr/include/util/crc16.h ****     checkcrc(void)
  71:/usr/lib/avr/include/util/crc16.h ****     {
  72:/usr/lib/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  73:/usr/lib/avr/include/util/crc16.h **** 
  74:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  75:/usr/lib/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  76:/usr/lib/avr/include/util/crc16.h **** 
  77:/usr/lib/avr/include/util/crc16.h **** 	return crc; // must be 0
  78:/usr/lib/avr/include/util/crc16.h ****     }
  79:/usr/lib/avr/include/util/crc16.h ****     \endcode
  80:/usr/lib/avr/include/util/crc16.h **** */
  81:/usr/lib/avr/include/util/crc16.h **** 
  82:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
  83:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  84:/usr/lib/avr/include/util/crc16.h **** 
  85:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  86:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
  87:/usr/lib/avr/include/util/crc16.h **** 
  88:/usr/lib/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  89:/usr/lib/avr/include/util/crc16.h **** 
  90:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  91:/usr/lib/avr/include/util/crc16.h **** 
  92:/usr/lib/avr/include/util/crc16.h ****     \code
  93:/usr/lib/avr/include/util/crc16.h ****     uint16_t
  94:/usr/lib/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  95:/usr/lib/avr/include/util/crc16.h ****     {
  96:/usr/lib/avr/include/util/crc16.h **** 	int i;
  97:/usr/lib/avr/include/util/crc16.h **** 
  98:/usr/lib/avr/include/util/crc16.h **** 	crc ^= a;
  99:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
 100:/usr/lib/avr/include/util/crc16.h **** 	{
 101:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 1)
 102:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 103:/usr/lib/avr/include/util/crc16.h **** 	    else
 104:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 105:/usr/lib/avr/include/util/crc16.h **** 	}
 106:/usr/lib/avr/include/util/crc16.h **** 
 107:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 108:/usr/lib/avr/include/util/crc16.h ****     }
 109:/usr/lib/avr/include/util/crc16.h **** 
 110:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 111:/usr/lib/avr/include/util/crc16.h **** 
 112:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 113:/usr/lib/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 114:/usr/lib/avr/include/util/crc16.h **** {
 115:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __tmp;
 116:/usr/lib/avr/include/util/crc16.h **** 	uint16_t __ret;
 117:/usr/lib/avr/include/util/crc16.h **** 
 118:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 119:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 120:/usr/lib/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 121:/usr/lib/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 122:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 123:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 124:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 125:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 126:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 127:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 128:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 129:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 130:/usr/lib/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 131:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 132:/usr/lib/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 133:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 134:/usr/lib/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 135:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 136:/usr/lib/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 137:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 138:/usr/lib/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 139:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 140:/usr/lib/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 141:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1"
 142:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 143:/usr/lib/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 144:/usr/lib/avr/include/util/crc16.h **** 		: "r0"
 145:/usr/lib/avr/include/util/crc16.h **** 	);
 146:/usr/lib/avr/include/util/crc16.h **** 	return __ret;
 147:/usr/lib/avr/include/util/crc16.h **** }
 148:/usr/lib/avr/include/util/crc16.h **** 
 149:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 150:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 151:/usr/lib/avr/include/util/crc16.h **** 
 152:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 153:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 154:/usr/lib/avr/include/util/crc16.h **** 
 155:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 156:/usr/lib/avr/include/util/crc16.h **** 
 157:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 158:/usr/lib/avr/include/util/crc16.h **** 
 159:/usr/lib/avr/include/util/crc16.h ****     \code
 160:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 161:/usr/lib/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 162:/usr/lib/avr/include/util/crc16.h ****     {
 163:/usr/lib/avr/include/util/crc16.h ****         int i;
 164:/usr/lib/avr/include/util/crc16.h **** 
 165:/usr/lib/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 166:/usr/lib/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 167:/usr/lib/avr/include/util/crc16.h ****         {
 168:/usr/lib/avr/include/util/crc16.h ****             if (crc & 0x8000)
 169:/usr/lib/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 170:/usr/lib/avr/include/util/crc16.h ****             else
 171:/usr/lib/avr/include/util/crc16.h ****                 crc <<= 1;
 172:/usr/lib/avr/include/util/crc16.h ****         }
 173:/usr/lib/avr/include/util/crc16.h **** 
 174:/usr/lib/avr/include/util/crc16.h ****         return crc;
 175:/usr/lib/avr/include/util/crc16.h ****     }
 176:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 177:/usr/lib/avr/include/util/crc16.h **** 
 178:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 179:/usr/lib/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 180:/usr/lib/avr/include/util/crc16.h **** {
 181:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 182:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 183:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 184:/usr/lib/avr/include/util/crc16.h ****                                 /* %3  __data */
 185:/usr/lib/avr/include/util/crc16.h **** 
 186:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 2172               	.LM214:
 2173               	/* #APP */
 2174               	 ;  186 "/usr/lib/avr/include/util/crc16.h" 1
 2175 0904 9227      		eor    r25,r18
 2176 0906 092E      		mov    __tmp_reg__,r25
 2177 0908 0294      		swap   __tmp_reg__
 2178 090a 202D      		mov    r18,__tmp_reg__
 2179 090c 2F70      		andi   r18,0x0f
 2180 090e 2927      		eor    r18,r25
 2181 0910 492F      		mov    r20,r25
 2182 0912 4025      		eor    r20,__tmp_reg__
 2183 0914 440F      		lsl    r20
 2184 0916 407E      		andi   r20,0xe0
 2185 0918 2427      		eor    r18,r20
 2186 091a 402D      		mov    r20,__tmp_reg__
 2187 091c 4927      		eor    r20,r25
 2188 091e 407F      		andi   r20,0xf0
 2189 0920 4695      		lsr    r20
 2190 0922 092E      		mov    __tmp_reg__,r25
 2191 0924 000C      		lsl    __tmp_reg__
 2192 0926 441F      		rol    r20
 2193 0928 9695      		lsr    r25
 2194 092a 9695      		lsr    r25
 2195 092c 9695      		lsr    r25
 2196 092e 9F71      		andi   r25,0x1f
 2197 0930 9427      		eor    r25,r20
 2198 0932 9827      		eor    r25,r24
 2199 0934 822F      		mov    r24,r18
 2200               		
 2201               	 ;  0 "" 2
 2202               	/* #NOAPP */
 2203               	.LBE48:
 2204               	.LBE47:
 2206               	.Ltext2:
 809:vty.c         ****       crcLokalne = _crc_xmodem_update(crcLokalne, *(zapPtrKopia++));
 2208               	.LM215:
 2209 0936 3F5F      		subi r19,lo8(-(1))
 2210 0938 3038      		cpi r19,lo8(-128)
 2211 093a 01F4      		brne .L81
 813:vty.c         ****     {
 2213               	.LM216:
 2214 093c 2A81      		ldd r18,Y+2
 2215 093e 30E0      		ldi r19,0
 2216 0940 492F      		mov r20,r25
 2217 0942 5527      		clr r21
 2218 0944 2417      		cp r18,r20
 2219 0946 3507      		cpc r19,r21
 2220 0948 01F4      		brne .L82
 2221 094a 2981      		ldd r18,Y+1
 2222 094c 30E0      		ldi r19,0
 2223 094e 9927      		clr r25
 2224 0950 2817      		cp r18,r24
 2225 0952 3907      		cpc r19,r25
 2226 0954 01F4      		brne .L82
 816:vty.c         ****     }
 2228               	.LM217:
 2229 0956 86E0      		ldi r24,lo8(6)
 2230 0958 0E94 0000 		call uartVtySendByte
 815:vty.c         ****       uartVtySendByte(ACK);
 2232               	.LM218:
 2233 095c 8AE0      		ldi r24,lo8(10)
 2234 095e B82E      		mov r11,r24
 2235 0960 00C0      		rjmp .L83
 2236               	.L82:
 820:vty.c         ****       nrBloku--;
 2238               	.LM219:
 2239 0962 BA94      		dec r11
 821:vty.c         ****       uartVtySendByte(NAK);
 2241               	.LM220:
 2242 0964 FA94      		dec r15
 822:vty.c         ****     }
 2244               	.LM221:
 2245 0966 85E1      		ldi r24,lo8(21)
 2246 0968 0E94 0000 		call uartVtySendByte
 825:vty.c         ****     {
 2248               	.LM222:
 2249 096c B110      		cpse r11,__zero_reg__
 2250 096e 00C0      		rjmp .L83
 827:vty.c         ****       state->err2 = nrBloku;
 2252               	.LM223:
 2253 0970 8C81      		ldd r24,Y+4
 2254 0972 90E0      		ldi r25,0
 2255 0974 F801      		movw r30,r16
 2256 0976 968F      		std Z+30,r25
 2257 0978 858F      		std Z+29,r24
 828:vty.c         ****       state->errno = (uint8_t)(xModemWrongFrameNo);
 2259               	.LM224:
 2260 097a F78E      		std Z+31,r15
 829:vty.c         ****       break;
 2262               	.LM225:
 2263 097c 84E0      		ldi r24,lo8(4)
 2264 097e 00C0      		rjmp .L105
 2265               	.L83:
 833:vty.c         ****     {
 2267               	.LM226:
 2268 0980 20E0      		ldi r18,0
 2269 0982 44E6      		ldi r20,lo8(100)
 2270 0984 50E0      		ldi r21,0
 2271 0986 BE01      		movw r22,r28
 2272 0988 6A5F      		subi r22,-6
 2273 098a 7F4F      		sbci r23,-1
 2274 098c 8091 0000 		lds r24,xVtyRec
 2275 0990 9091 0000 		lds r25,xVtyRec+1
 2276 0994 0E94 0000 		call xQueueGenericReceive
 2277 0998 8823      		tst r24
 2278 099a 01F4      		brne .+2
 2279 099c 00C0      		rjmp .L84
 839:vty.c         ****     {
 2281               	.LM227:
 2282 099e 8E81      		ldd r24,Y+6
 2283 09a0 8130      		cpi r24,lo8(1)
 2284 09a2 01F4      		brne .L85
 841:vty.c         ****       zapPtr = ramDyskDodajBlokXmodem(&fdVty, nrBloku);
 2286               	.LM228:
 2287 09a4 EE24      		clr r14
 2288 09a6 E394      		inc r14
 2289 09a8 EF0C      		add r14,r15
 842:vty.c         ****       zapPtrKopia = zapPtr;
 2291               	.LM229:
 2292 09aa 6E2D      		mov r22,r14
 2293 09ac 70E0      		ldi r23,0
 2294 09ae 80E0      		ldi r24,lo8(fdVty)
 2295 09b0 90E0      		ldi r25,hi8(fdVty)
 2296 09b2 0E94 0000 		call ramDyskDodajBlokXmodem
 2297 09b6 4C01      		movw r8,r24
 844:vty.c         ****       continue;
 2299               	.LM230:
 2300 09b8 F801      		movw r30,r16
 2301 09ba 148E      		std Z+28,__zero_reg__
 2302 09bc 00C0      		rjmp .L86
 2303               	.L85:
 848:vty.c         ****     {
 2305               	.LM231:
 2306 09be 8831      		cpi r24,lo8(24)
 2307 09c0 01F4      		brne .L87
 850:vty.c         ****       state->errno = (uint8_t)(xModemRemoteSideCan);
 2309               	.LM232:
 2310 09c2 8F2D      		mov r24,r15
 2311 09c4 90E0      		ldi r25,0
 2312 09c6 F801      		movw r30,r16
 2313 09c8 968F      		std Z+30,r25
 2314 09ca 858F      		std Z+29,r24
 851:vty.c         ****       break;
 2316               	.LM233:
 2317 09cc 87E0      		ldi r24,lo8(7)
 2318               	.L105:
 2319 09ce 848F      		std Z+28,r24
 2320 09d0 00C0      		rjmp .L72
 2321               	.L87:
 854:vty.c         ****     {
 2323               	.LM234:
 2324 09d2 8430      		cpi r24,lo8(4)
 2325 09d4 01F4      		brne .L88
 856:vty.c         ****       if (xQueueReceive(xVtyRec, &temp1, 10))
 2327               	.LM235:
 2328 09d6 85E1      		ldi r24,lo8(21)
 2329 09d8 0E94 0000 		call uartVtySendByte
 857:vty.c         ****       {
 2331               	.LM236:
 2332 09dc 20E0      		ldi r18,0
 2333 09de 4AE0      		ldi r20,lo8(10)
 2334 09e0 50E0      		ldi r21,0
 2335 09e2 BE01      		movw r22,r28
 2336 09e4 6A5F      		subi r22,-6
 2337 09e6 7F4F      		sbci r23,-1
 2338 09e8 8091 0000 		lds r24,xVtyRec
 2339 09ec 9091 0000 		lds r25,xVtyRec+1
 2340 09f0 0E94 0000 		call xQueueGenericReceive
 2341 09f4 8823      		tst r24
 2342 09f6 01F0      		breq .L89
 859:vty.c         ****           uartVtySendByte(ACK);
 2344               	.LM237:
 2345 09f8 8E81      		ldd r24,Y+6
 2346 09fa 8430      		cpi r24,lo8(4)
 2347 09fc 01F4      		brne .L89
 860:vty.c         ****       }
 2349               	.LM238:
 2350 09fe 86E0      		ldi r24,lo8(6)
 2351 0a00 0E94 0000 		call uartVtySendByte
 2352               	.L89:
 862:vty.c         ****       break;
 2354               	.LM239:
 2355 0a04 F801      		movw r30,r16
 2356 0a06 148E      		std Z+28,__zero_reg__
 2357 0a08 00C0      		rjmp .L72
 2358               	.L88:
 865:vty.c         ****     state->err1 = temp1;
 2360               	.LM240:
 2361 0a0a 98E0      		ldi r25,lo8(8)
 2362 0a0c F801      		movw r30,r16
 2363 0a0e 948F      		std Z+28,r25
 866:vty.c         ****     break;
 2365               	.LM241:
 2366 0a10 90E0      		ldi r25,0
 2367               	.L106:
 2368 0a12 968F      		std Z+30,r25
 2369 0a14 858F      		std Z+29,r24
 2370               	.L72:
 869:vty.c         ****   return OK_SILENT;
 2372               	.LM242:
 2373 0a16 80E0      		ldi r24,lo8(fdVty)
 2374 0a18 90E0      		ldi r25,hi8(fdVty)
 2375 0a1a 0E94 0000 		call ramDyskZamknijPlik
 870:vty.c         **** }
 2377               	.LM243:
 2378 0a1e 80E0      		ldi r24,0
 2379 0a20 90E0      		ldi r25,0
 2380               	.L65:
 2381               	/* epilogue start */
 2382               	.LBE46:
 2383               	.LBE45:
 871:vty.c         **** 
 2385               	.LM244:
 2386 0a22 2696      		adiw r28,6
 2387 0a24 0FB6      		in __tmp_reg__,__SREG__
 2388 0a26 F894      		cli
 2389 0a28 DEBF      		out __SP_H__,r29
 2390 0a2a 0FBE      		out __SREG__,__tmp_reg__
 2391 0a2c CDBF      		out __SP_L__,r28
 2392 0a2e DF91      		pop r29
 2393 0a30 CF91      		pop r28
 2394 0a32 1F91      		pop r17
 2395 0a34 0F91      		pop r16
 2396 0a36 FF90      		pop r15
 2397 0a38 EF90      		pop r14
 2398 0a3a DF90      		pop r13
 2399 0a3c CF90      		pop r12
 2400 0a3e BF90      		pop r11
 2401 0a40 AF90      		pop r10
 2402 0a42 9F90      		pop r9
 2403 0a44 8F90      		pop r8
 2404 0a46 0895      		ret
 2416               	.Lscope22:
 2418               		.stabd	78,0,0
 2422               	debugFunction:
 2423               		.stabd	46,0,0
 308:vty.c         ****   if (state->argc < 2)
 2425               	.LM245:
 2426               	.LFBB23:
 2427 0a48 FF92      		push r15
 2428 0a4a 0F93      		push r16
 2429 0a4c 1F93      		push r17
 2430 0a4e CF93      		push r28
 2431 0a50 DF93      		push r29
 2432               	/* prologue: function */
 2433               	/* frame size = 0 */
 2434               	/* stack size = 5 */
 2435               	.L__stack_usage = 5
 309:vty.c         ****     return SYNTAX_ERROR;
 2437               	.LM246:
 2438 0a52 FC01      		movw r30,r24
 2439 0a54 218D      		ldd r18,Z+25
 2440 0a56 2230      		cpi r18,lo8(2)
 2441 0a58 00F4      		brsh .L110
 2442               	.L117:
 310:vty.c         **** 
 2444               	.LM247:
 2445 0a5a 82E0      		ldi r24,lo8(2)
 2446 0a5c 90E0      		ldi r25,0
 2447 0a5e 00C0      		rjmp .L111
 2448               	.L110:
 2449 0a60 EC01      		movw r28,r24
 2450               	.LBB61:
 2451               	.LBB62:
 312:vty.c         ****   const char *str = (const char*)cmdlineGetArgStr(1, state);
 2453               	.LM248:
 2454 0a62 BC01      		movw r22,r24
 2455 0a64 82E0      		ldi r24,lo8(2)
 2456 0a66 0E94 0000 		call cmdlineGetArgInt
 2457 0a6a F62E      		mov r15,r22
 313:vty.c         ****   if (level == 0)
 2459               	.LM249:
 2460 0a6c BE01      		movw r22,r28
 2461 0a6e 81E0      		ldi r24,lo8(1)
 2462 0a70 0E94 0000 		call cmdlineGetArgStr
 2463 0a74 182F      		mov r17,r24
 2464 0a76 092F      		mov r16,r25
 316:vty.c         ****     {
 2466               	.LM250:
 2467 0a78 43E0      		ldi r20,lo8(3)
 2468 0a7a 50E0      		ldi r21,0
 314:vty.c         ****   {
 2470               	.LM251:
 2471 0a7c F110      		cpse r15,__zero_reg__
 2472 0a7e 00C0      		rjmp .L112
 316:vty.c         ****     {
 2474               	.LM252:
 2475 0a80 60E0      		ldi r22,lo8(__c.3656)
 2476 0a82 70E0      		ldi r23,hi8(__c.3656)
 2477 0a84 0E94 0000 		call strncmp_P
 2478 0a88 892B      		or r24,r25
 2479 0a8a 01F4      		brne .L113
 318:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 2481               	.LM253:
 2482 0a8c 60E0      		ldi r22,0
 2483 0a8e 80E0      		ldi r24,0
 2484 0a90 90E0      		ldi r25,0
 2485 0a92 0E94 0000 		call setArpDebug
 2486 0a96 00C0      		rjmp .L124
 2487               	.L113:
 323:vty.c         ****     {
 2489               	.LM254:
 2490 0a98 42E0      		ldi r20,lo8(2)
 2491 0a9a 50E0      		ldi r21,0
 2492 0a9c 60E0      		ldi r22,lo8(__c.3658)
 2493 0a9e 70E0      		ldi r23,hi8(__c.3658)
 2494 0aa0 812F      		mov r24,r17
 2495 0aa2 902F      		mov r25,r16
 2496 0aa4 0E94 0000 		call strncmp_P
 2497 0aa8 892B      		or r24,r25
 2498 0aaa 01F4      		brne .L114
 325:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 2500               	.LM255:
 2501 0aac 60E0      		ldi r22,0
 2502 0aae 80E0      		ldi r24,0
 2503 0ab0 90E0      		ldi r25,0
 2504 0ab2 0E94 0000 		call setIpDebug
 2505 0ab6 00C0      		rjmp .L124
 2506               	.L114:
 330:vty.c         ****     {
 2508               	.LM256:
 2509 0ab8 42E0      		ldi r20,lo8(2)
 2510 0aba 50E0      		ldi r21,0
 2511 0abc 60E0      		ldi r22,lo8(__c.3660)
 2512 0abe 70E0      		ldi r23,hi8(__c.3660)
 2513 0ac0 812F      		mov r24,r17
 2514 0ac2 902F      		mov r25,r16
 2515 0ac4 0E94 0000 		call strncmp_P
 2516 0ac8 892B      		or r24,r25
 2517 0aca 01F4      		brne .L115
 332:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 2519               	.LM257:
 2520 0acc 60E0      		ldi r22,0
 2521 0ace 80E0      		ldi r24,0
 2522 0ad0 90E0      		ldi r25,0
 2523 0ad2 0E94 0000 		call setIcmpDebug
 2524 0ad6 00C0      		rjmp .L124
 2525               	.L115:
 337:vty.c         ****     {
 2527               	.LM258:
 2528 0ad8 42E0      		ldi r20,lo8(2)
 2529 0ada 50E0      		ldi r21,0
 2530 0adc 60E0      		ldi r22,lo8(__c.3662)
 2531 0ade 70E0      		ldi r23,hi8(__c.3662)
 2532 0ae0 812F      		mov r24,r17
 2533 0ae2 902F      		mov r25,r16
 2534 0ae4 0E94 0000 		call strncmp_P
 2535 0ae8 892B      		or r24,r25
 2536 0aea 01F4      		brne .L116
 339:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 2538               	.LM259:
 2539 0aec 60E0      		ldi r22,0
 2540 0aee 80E0      		ldi r24,0
 2541 0af0 90E0      		ldi r25,0
 2542 0af2 0E94 0000 		call setTcpDebug
 2543               	.L124:
 340:vty.c         ****       return OK_SILENT;
 2545               	.LM260:
 2546 0af6 0F93      		push r16
 2547 0af8 1F93      		push r17
 2548 0afa 80E0      		ldi r24,lo8(debugDisabledInfoStr)
 2549 0afc 90E0      		ldi r25,hi8(debugDisabledInfoStr)
 2550 0afe 00C0      		rjmp .L122
 2551               	.L116:
 344:vty.c         ****     {
 2553               	.LM261:
 2554 0b00 42E0      		ldi r20,lo8(2)
 2555 0b02 50E0      		ldi r21,0
 2556 0b04 60E0      		ldi r22,lo8(__c.3664)
 2557 0b06 70E0      		ldi r23,hi8(__c.3664)
 2558 0b08 812F      		mov r24,r17
 2559 0b0a 902F      		mov r25,r16
 2560 0b0c 0E94 0000 		call strncmp_P
 2561 0b10 892B      		or r24,r25
 2562 0b12 01F0      		breq .+2
 2563 0b14 00C0      		rjmp .L117
 346:vty.c         ****       fprintf_P(state->myStdInOut, debugDisabledInfoStr, str);
 2565               	.LM262:
 2566 0b16 60E0      		ldi r22,0
 2567 0b18 80E0      		ldi r24,0
 2568 0b1a 90E0      		ldi r25,0
 2569 0b1c 0E94 0000 		call setUdpDebug
 2570 0b20 00C0      		rjmp .L124
 2571               	.L112:
 355:vty.c         ****     {
 2573               	.LM263:
 2574 0b22 60E0      		ldi r22,lo8(__c.3666)
 2575 0b24 70E0      		ldi r23,hi8(__c.3666)
 2576 0b26 0E94 0000 		call strncmp_P
 2577 0b2a 892B      		or r24,r25
 2578 0b2c 01F4      		brne .L118
 357:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 2580               	.LM264:
 2581 0b2e 6F2D      		mov r22,r15
 2582 0b30 8A8D      		ldd r24,Y+26
 2583 0b32 9B8D      		ldd r25,Y+27
 2584 0b34 0E94 0000 		call setArpDebug
 2585 0b38 00C0      		rjmp .L123
 2586               	.L118:
 362:vty.c         ****     {
 2588               	.LM265:
 2589 0b3a 42E0      		ldi r20,lo8(2)
 2590 0b3c 50E0      		ldi r21,0
 2591 0b3e 60E0      		ldi r22,lo8(__c.3668)
 2592 0b40 70E0      		ldi r23,hi8(__c.3668)
 2593 0b42 812F      		mov r24,r17
 2594 0b44 902F      		mov r25,r16
 2595 0b46 0E94 0000 		call strncmp_P
 2596 0b4a 892B      		or r24,r25
 2597 0b4c 01F4      		brne .L119
 364:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 2599               	.LM266:
 2600 0b4e 6F2D      		mov r22,r15
 2601 0b50 8A8D      		ldd r24,Y+26
 2602 0b52 9B8D      		ldd r25,Y+27
 2603 0b54 0E94 0000 		call setIpDebug
 2604 0b58 00C0      		rjmp .L123
 2605               	.L119:
 369:vty.c         ****     {
 2607               	.LM267:
 2608 0b5a 42E0      		ldi r20,lo8(2)
 2609 0b5c 50E0      		ldi r21,0
 2610 0b5e 60E0      		ldi r22,lo8(__c.3670)
 2611 0b60 70E0      		ldi r23,hi8(__c.3670)
 2612 0b62 812F      		mov r24,r17
 2613 0b64 902F      		mov r25,r16
 2614 0b66 0E94 0000 		call strncmp_P
 2615 0b6a 892B      		or r24,r25
 2616 0b6c 01F4      		brne .L120
 371:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 2618               	.LM268:
 2619 0b6e 6F2D      		mov r22,r15
 2620 0b70 8A8D      		ldd r24,Y+26
 2621 0b72 9B8D      		ldd r25,Y+27
 2622 0b74 0E94 0000 		call setIcmpDebug
 2623 0b78 00C0      		rjmp .L123
 2624               	.L120:
 376:vty.c         ****     {
 2626               	.LM269:
 2627 0b7a 42E0      		ldi r20,lo8(2)
 2628 0b7c 50E0      		ldi r21,0
 2629 0b7e 60E0      		ldi r22,lo8(__c.3672)
 2630 0b80 70E0      		ldi r23,hi8(__c.3672)
 2631 0b82 812F      		mov r24,r17
 2632 0b84 902F      		mov r25,r16
 2633 0b86 0E94 0000 		call strncmp_P
 2634 0b8a 892B      		or r24,r25
 2635 0b8c 01F4      		brne .L121
 378:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 2637               	.LM270:
 2638 0b8e 6F2D      		mov r22,r15
 2639 0b90 8A8D      		ldd r24,Y+26
 2640 0b92 9B8D      		ldd r25,Y+27
 2641 0b94 0E94 0000 		call setTcpDebug
 2642 0b98 00C0      		rjmp .L123
 2643               	.L121:
 383:vty.c         ****     {
 2645               	.LM271:
 2646 0b9a 42E0      		ldi r20,lo8(2)
 2647 0b9c 50E0      		ldi r21,0
 2648 0b9e 60E0      		ldi r22,lo8(__c.3674)
 2649 0ba0 70E0      		ldi r23,hi8(__c.3674)
 2650 0ba2 812F      		mov r24,r17
 2651 0ba4 902F      		mov r25,r16
 2652 0ba6 0E94 0000 		call strncmp_P
 2653 0baa 892B      		or r24,r25
 2654 0bac 01F0      		breq .+2
 2655 0bae 00C0      		rjmp .L117
 385:vty.c         ****       fprintf_P(state->myStdInOut, debugEnabledInfoStr, str);
 2657               	.LM272:
 2658 0bb0 6F2D      		mov r22,r15
 2659 0bb2 8A8D      		ldd r24,Y+26
 2660 0bb4 9B8D      		ldd r25,Y+27
 2661 0bb6 0E94 0000 		call setUdpDebug
 2662               	.L123:
 386:vty.c         ****       return OK_SILENT;
 2664               	.LM273:
 2665 0bba 0F93      		push r16
 2666 0bbc 1F93      		push r17
 2667 0bbe 80E0      		ldi r24,lo8(debugEnabledInfoStr)
 2668 0bc0 90E0      		ldi r25,hi8(debugEnabledInfoStr)
 2669               	.L122:
 2670 0bc2 9F93      		push r25
 2671 0bc4 8F93      		push r24
 2672 0bc6 8B8D      		ldd r24,Y+27
 2673 0bc8 8F93      		push r24
 2674 0bca 8A8D      		ldd r24,Y+26
 2675 0bcc 8F93      		push r24
 2676 0bce 0E94 0000 		call fprintf_P
 2677 0bd2 0F90      		pop __tmp_reg__
 2678 0bd4 0F90      		pop __tmp_reg__
 2679 0bd6 0F90      		pop __tmp_reg__
 2680 0bd8 0F90      		pop __tmp_reg__
 2681 0bda 0F90      		pop __tmp_reg__
 2682 0bdc 0F90      		pop __tmp_reg__
 387:vty.c         ****     }
 2684               	.LM274:
 2685 0bde 80E0      		ldi r24,0
 2686 0be0 90E0      		ldi r25,0
 2687               	.L111:
 2688               	/* epilogue start */
 2689               	.LBE62:
 2690               	.LBE61:
 392:vty.c         **** 
 2692               	.LM275:
 2693 0be2 DF91      		pop r29
 2694 0be4 CF91      		pop r28
 2695 0be6 1F91      		pop r17
 2696 0be8 0F91      		pop r16
 2697 0bea FF90      		pop r15
 2698 0bec 0895      		ret
 2700               	.Lscope23:
 2702               		.stabd	78,0,0
 2706               	setMacAddrFunction:
 2707               		.stabd	46,0,0
 507:vty.c         ****   if (state->argc < 6)
 2709               	.LM276:
 2710               	.LFBB24:
 2711 0bee CF93      		push r28
 2712 0bf0 DF93      		push r29
 2713               	/* prologue: function */
 2714               	/* frame size = 0 */
 2715               	/* stack size = 2 */
 2716               	.L__stack_usage = 2
 508:vty.c         ****     return SYNTAX_ERROR;
 2718               	.LM277:
 2719 0bf2 FC01      		movw r30,r24
 2720 0bf4 218D      		ldd r18,Z+25
 2721 0bf6 2630      		cpi r18,lo8(6)
 2722 0bf8 00F0      		brlo .L127
 2723 0bfa EC01      		movw r28,r24
 2724               	.LBB65:
 2725               	.LBB66:
 511:vty.c         ****   nicState.mac.addr[1] = cmdlineGetArgHex(2, state);
 2727               	.LM278:
 2728 0bfc BC01      		movw r22,r24
 2729 0bfe 81E0      		ldi r24,lo8(1)
 2730 0c00 0E94 0000 		call cmdlineGetArgHex
 2731 0c04 6093 0000 		sts nicState+2,r22
 512:vty.c         ****   nicState.mac.addr[2] = cmdlineGetArgHex(3, state);
 2733               	.LM279:
 2734 0c08 BE01      		movw r22,r28
 2735 0c0a 82E0      		ldi r24,lo8(2)
 2736 0c0c 0E94 0000 		call cmdlineGetArgHex
 2737 0c10 6093 0000 		sts nicState+3,r22
 513:vty.c         ****   nicState.mac.addr[3] = cmdlineGetArgHex(4, state);
 2739               	.LM280:
 2740 0c14 BE01      		movw r22,r28
 2741 0c16 83E0      		ldi r24,lo8(3)
 2742 0c18 0E94 0000 		call cmdlineGetArgHex
 2743 0c1c 6093 0000 		sts nicState+4,r22
 514:vty.c         ****   nicState.mac.addr[4] = cmdlineGetArgHex(5, state);
 2745               	.LM281:
 2746 0c20 BE01      		movw r22,r28
 2747 0c22 84E0      		ldi r24,lo8(4)
 2748 0c24 0E94 0000 		call cmdlineGetArgHex
 2749 0c28 6093 0000 		sts nicState+5,r22
 515:vty.c         ****   nicState.mac.addr[5] = cmdlineGetArgHex(6, state);
 2751               	.LM282:
 2752 0c2c BE01      		movw r22,r28
 2753 0c2e 85E0      		ldi r24,lo8(5)
 2754 0c30 0E94 0000 		call cmdlineGetArgHex
 2755 0c34 6093 0000 		sts nicState+6,r22
 516:vty.c         ****   nicSetMacAddress(nicState.mac.addr);
 2757               	.LM283:
 2758 0c38 BE01      		movw r22,r28
 2759 0c3a 86E0      		ldi r24,lo8(6)
 2760 0c3c 0E94 0000 		call cmdlineGetArgHex
 2761 0c40 6093 0000 		sts nicState+7,r22
 517:vty.c         ****   return OK_SILENT;
 2763               	.LM284:
 2764 0c44 80E0      		ldi r24,lo8(nicState+2)
 2765 0c46 90E0      		ldi r25,hi8(nicState+2)
 2766 0c48 0E94 0000 		call nicSetMacAddress
 2767 0c4c 80E0      		ldi r24,0
 2768 0c4e 90E0      		ldi r25,0
 2769 0c50 00C0      		rjmp .L126
 2770               	.L127:
 2771               	.LBE66:
 2772               	.LBE65:
 509:vty.c         **** 
 2774               	.LM285:
 2775 0c52 82E0      		ldi r24,lo8(2)
 2776 0c54 90E0      		ldi r25,0
 2777               	.L126:
 2778               	/* epilogue start */
 519:vty.c         **** 
 2780               	.LM286:
 2781 0c56 DF91      		pop r29
 2782 0c58 CF91      		pop r28
 2783 0c5a 0895      		ret
 2785               	.Lscope24:
 2787               		.stabd	78,0,0
 2791               	setUdpFunction:
 2792               		.stabd	46,0,0
 437:vty.c         ****   if (state->argc < 5)
 2794               	.LM287:
 2795               	.LFBB25:
 2796 0c5c 8F92      		push r8
 2797 0c5e 9F92      		push r9
 2798 0c60 AF92      		push r10
 2799 0c62 BF92      		push r11
 2800 0c64 CF92      		push r12
 2801 0c66 DF92      		push r13
 2802 0c68 EF92      		push r14
 2803 0c6a FF92      		push r15
 2804 0c6c CF93      		push r28
 2805 0c6e DF93      		push r29
 2806               	/* prologue: function */
 2807               	/* frame size = 0 */
 2808               	/* stack size = 10 */
 2809               	.L__stack_usage = 10
 438:vty.c         ****     return SYNTAX_ERROR;
 2811               	.LM288:
 2812 0c70 FC01      		movw r30,r24
 2813 0c72 218D      		ldd r18,Z+25
 2814 0c74 2530      		cpi r18,lo8(5)
 2815 0c76 00F4      		brsh .+2
 2816 0c78 00C0      		rjmp .L130
 2817 0c7a EC01      		movw r28,r24
 2818               	.LBB69:
 2819               	.LBB70:
 441:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 2821               	.LM289:
 2822 0c7c BC01      		movw r22,r24
 2823 0c7e 81E0      		ldi r24,lo8(1)
 2824 0c80 0E94 0000 		call cmdlineGetArgInt
 2825 0c84 6B01      		movw r12,r22
 2826 0c86 7C01      		movw r14,r24
 442:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 2828               	.LM290:
 2829 0c88 BE01      		movw r22,r28
 2830 0c8a 82E0      		ldi r24,lo8(2)
 2831 0c8c 0E94 0000 		call cmdlineGetArgInt
 2832 0c90 4B01      		movw r8,r22
 2833 0c92 5C01      		movw r10,r24
 443:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 2835               	.LM291:
 2836 0c94 BE01      		movw r22,r28
 2837 0c96 83E0      		ldi r24,lo8(3)
 2838 0c98 0E94 0000 		call cmdlineGetArgInt
 442:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 2840               	.LM292:
 2841 0c9c BA2C      		mov r11,r10
 2842 0c9e A92C      		mov r10,r9
 2843 0ca0 982C      		mov r9,r8
 2844 0ca2 8824      		clr r8
 443:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 2846               	.LM293:
 2847 0ca4 5527      		clr r21
 2848 0ca6 4427      		clr r20
 2849 0ca8 D501      		movw r26,r10
 2850 0caa C401      		movw r24,r8
 2851 0cac 840F      		add r24,r20
 2852 0cae 951F      		adc r25,r21
 2853 0cb0 A61F      		adc r26,r22
 2854 0cb2 B71F      		adc r27,r23
 442:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 2856               	.LM294:
 2857 0cb4 C80E      		add r12,r24
 2858 0cb6 D91E      		adc r13,r25
 2859 0cb8 EA1E      		adc r14,r26
 2860 0cba FB1E      		adc r15,r27
 444:vty.c         ****   udpSocket->dstIp = ip;
 2862               	.LM295:
 2863 0cbc BE01      		movw r22,r28
 2864 0cbe 84E0      		ldi r24,lo8(4)
 2865 0cc0 0E94 0000 		call cmdlineGetArgInt
 445:vty.c         **** 
 2867               	.LM296:
 2868 0cc4 E091 0000 		lds r30,udpSocket
 2869 0cc8 F091 0000 		lds r31,udpSocket+1
 444:vty.c         ****   udpSocket->dstIp = ip;
 2871               	.LM297:
 2872 0ccc B62F      		mov r27,r22
 2873 0cce AA27      		clr r26
 2874 0cd0 9927      		clr r25
 2875 0cd2 8827      		clr r24
 441:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 2877               	.LM298:
 2878 0cd4 8C0D      		add r24,r12
 2879 0cd6 9D1D      		adc r25,r13
 2880 0cd8 AE1D      		adc r26,r14
 2881 0cda BF1D      		adc r27,r15
 445:vty.c         **** 
 2883               	.LM299:
 2884 0cdc 8683      		std Z+6,r24
 2885 0cde 9783      		std Z+7,r25
 2886 0ce0 A087      		std Z+8,r26
 2887 0ce2 B187      		std Z+9,r27
 447:vty.c         ****   udpSocket->srcPort = htons(port);
 2889               	.LM300:
 2890 0ce4 BE01      		movw r22,r28
 2891 0ce6 85E0      		ldi r24,lo8(5)
 2892 0ce8 0E94 0000 		call cmdlineGetArgInt
 448:vty.c         **** 
 2894               	.LM301:
 2895 0cec E090 0000 		lds r14,udpSocket
 2896 0cf0 F090 0000 		lds r15,udpSocket+1
 2897 0cf4 CB01      		movw r24,r22
 2898 0cf6 0E94 0000 		call htons
 2899 0cfa F701      		movw r30,r14
 2900 0cfc 9583      		std Z+5,r25
 2901 0cfe 8483      		std Z+4,r24
 450:vty.c         ****   {
 2903               	.LM302:
 2904 0d00 898D      		ldd r24,Y+25
 2905 0d02 8630      		cpi r24,lo8(6)
 2906 0d04 00F0      		brlo .L131
 452:vty.c         ****     udpSocket->dstPort = htons(port);
 2908               	.LM303:
 2909 0d06 BE01      		movw r22,r28
 2910 0d08 86E0      		ldi r24,lo8(6)
 2911 0d0a 0E94 0000 		call cmdlineGetArgInt
 453:vty.c         ****   }
 2913               	.LM304:
 2914 0d0e C091 0000 		lds r28,udpSocket
 2915 0d12 D091 0000 		lds r29,udpSocket+1
 2916 0d16 CB01      		movw r24,r22
 2917 0d18 0E94 0000 		call htons
 2918 0d1c 9B83      		std Y+3,r25
 2919 0d1e 8A83      		std Y+2,r24
 2920 0d20 00C0      		rjmp .L131
 2921               	.L130:
 2922               	.LBE70:
 2923               	.LBE69:
 439:vty.c         **** 
 2925               	.LM305:
 2926 0d22 82E0      		ldi r24,lo8(2)
 2927 0d24 90E0      		ldi r25,0
 2928 0d26 00C0      		rjmp .L129
 2929               	.L131:
 2930               	.LBB72:
 2931               	.LBB71:
 450:vty.c         ****   {
 2933               	.LM306:
 2934 0d28 80E0      		ldi r24,0
 2935 0d2a 90E0      		ldi r25,0
 2936               	.L129:
 2937               	/* epilogue start */
 2938               	.LBE71:
 2939               	.LBE72:
 456:vty.c         **** 
 2941               	.LM307:
 2942 0d2c DF91      		pop r29
 2943 0d2e CF91      		pop r28
 2944 0d30 FF90      		pop r15
 2945 0d32 EF90      		pop r14
 2946 0d34 DF90      		pop r13
 2947 0d36 CF90      		pop r12
 2948 0d38 BF90      		pop r11
 2949 0d3a AF90      		pop r10
 2950 0d3c 9F90      		pop r9
 2951 0d3e 8F90      		pop r8
 2952 0d40 0895      		ret
 2954               	.Lscope25:
 2956               		.stabd	78,0,0
 2960               	setIpGwFunction:
 2961               		.stabd	46,0,0
 472:vty.c         ****   if (state->argc < 4)
 2963               	.LM308:
 2964               	.LFBB26:
 2965 0d42 8F92      		push r8
 2966 0d44 9F92      		push r9
 2967 0d46 AF92      		push r10
 2968 0d48 BF92      		push r11
 2969 0d4a CF92      		push r12
 2970 0d4c DF92      		push r13
 2971 0d4e EF92      		push r14
 2972 0d50 FF92      		push r15
 2973 0d52 CF93      		push r28
 2974 0d54 DF93      		push r29
 2975               	/* prologue: function */
 2976               	/* frame size = 0 */
 2977               	/* stack size = 10 */
 2978               	.L__stack_usage = 10
 473:vty.c         ****     return SYNTAX_ERROR;
 2980               	.LM309:
 2981 0d56 FC01      		movw r30,r24
 2982 0d58 218D      		ldd r18,Z+25
 2983 0d5a 2430      		cpi r18,lo8(4)
 2984 0d5c 00F0      		brlo .L134
 2985 0d5e EC01      		movw r28,r24
 2986               	.LBB75:
 2987               	.LBB76:
 476:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 2989               	.LM310:
 2990 0d60 BC01      		movw r22,r24
 2991 0d62 81E0      		ldi r24,lo8(1)
 2992 0d64 0E94 0000 		call cmdlineGetArgInt
 2993 0d68 6B01      		movw r12,r22
 2994 0d6a 7C01      		movw r14,r24
 477:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 2996               	.LM311:
 2997 0d6c BE01      		movw r22,r28
 2998 0d6e 82E0      		ldi r24,lo8(2)
 2999 0d70 0E94 0000 		call cmdlineGetArgInt
 3000 0d74 4B01      		movw r8,r22
 3001 0d76 5C01      		movw r10,r24
 478:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 3003               	.LM312:
 3004 0d78 BE01      		movw r22,r28
 3005 0d7a 83E0      		ldi r24,lo8(3)
 3006 0d7c 0E94 0000 		call cmdlineGetArgInt
 477:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 3008               	.LM313:
 3009 0d80 BA2C      		mov r11,r10
 3010 0d82 A92C      		mov r10,r9
 3011 0d84 982C      		mov r9,r8
 3012 0d86 8824      		clr r8
 478:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 3014               	.LM314:
 3015 0d88 5527      		clr r21
 3016 0d8a 4427      		clr r20
 3017 0d8c D501      		movw r26,r10
 3018 0d8e C401      		movw r24,r8
 3019 0d90 840F      		add r24,r20
 3020 0d92 951F      		adc r25,r21
 3021 0d94 A61F      		adc r26,r22
 3022 0d96 B71F      		adc r27,r23
 477:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16)  +
 3024               	.LM315:
 3025 0d98 C80E      		add r12,r24
 3026 0d9a D91E      		adc r13,r25
 3027 0d9c EA1E      		adc r14,r26
 3028 0d9e FB1E      		adc r15,r27
 479:vty.c         ****   ipSetConfigGw(gw);
 3030               	.LM316:
 3031 0da0 BE01      		movw r22,r28
 3032 0da2 84E0      		ldi r24,lo8(4)
 3033 0da4 0E94 0000 		call cmdlineGetArgInt
 3034 0da8 B62F      		mov r27,r22
 3035 0daa AA27      		clr r26
 3036 0dac 9927      		clr r25
 3037 0dae 8827      		clr r24
 476:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 3039               	.LM317:
 3040 0db0 BC01      		movw r22,r24
 3041 0db2 CD01      		movw r24,r26
 3042 0db4 6C0D      		add r22,r12
 3043 0db6 7D1D      		adc r23,r13
 3044 0db8 8E1D      		adc r24,r14
 3045 0dba 9F1D      		adc r25,r15
 480:vty.c         ****   return OK_SILENT;
 3047               	.LM318:
 3048 0dbc 0E94 0000 		call ipSetConfigGw
 3049 0dc0 80E0      		ldi r24,0
 3050 0dc2 90E0      		ldi r25,0
 3051 0dc4 00C0      		rjmp .L133
 3052               	.L134:
 3053               	.LBE76:
 3054               	.LBE75:
 474:vty.c         **** 
 3056               	.LM319:
 3057 0dc6 82E0      		ldi r24,lo8(2)
 3058 0dc8 90E0      		ldi r25,0
 3059               	.L133:
 3060               	/* epilogue start */
 482:vty.c         **** 
 3062               	.LM320:
 3063 0dca DF91      		pop r29
 3064 0dcc CF91      		pop r28
 3065 0dce FF90      		pop r15
 3066 0dd0 EF90      		pop r14
 3067 0dd2 DF90      		pop r13
 3068 0dd4 CF90      		pop r12
 3069 0dd6 BF90      		pop r11
 3070 0dd8 AF90      		pop r10
 3071 0dda 9F90      		pop r9
 3072 0ddc 8F90      		pop r8
 3073 0dde 0895      		ret
 3075               	.Lscope26:
 3077               		.stabd	78,0,0
 3081               	setIpMaskFunction:
 3082               		.stabd	46,0,0
 460:vty.c         ****   if (state->argc < 1)
 3084               	.LM321:
 3085               	.LFBB27:
 3086               	/* prologue: function */
 3087               	/* frame size = 0 */
 3088               	/* stack size = 0 */
 3089               	.L__stack_usage = 0
 461:vty.c         ****     return SYNTAX_ERROR;
 3091               	.LM322:
 3092 0de0 FC01      		movw r30,r24
 3093 0de2 218D      		ldd r18,Z+25
 3094 0de4 2223      		tst r18
 3095 0de6 01F0      		breq .L137
 3096 0de8 BC01      		movw r22,r24
 3097               	.LBB79:
 3098               	.LBB80:
 464:vty.c         **** 
 3100               	.LM323:
 3101 0dea 81E0      		ldi r24,lo8(1)
 3102 0dec 0E94 0000 		call cmdlineGetArgInt
 3103 0df0 20E2      		ldi r18,lo8(32)
 3104 0df2 30E0      		ldi r19,0
 3105 0df4 261B      		sub r18,r22
 3106 0df6 370B      		sbc r19,r23
 3107 0df8 8FEF      		ldi r24,lo8(-1)
 3108 0dfa 9FEF      		ldi r25,lo8(-1)
 3109 0dfc DC01      		movw r26,r24
 3110 0dfe BC01      		movw r22,r24
 3111 0e00 CD01      		movw r24,r26
 3112 0e02 00C0      		rjmp 2f
 3113               		1:
 3114 0e04 9695      		lsr r25
 3115 0e06 8795      		ror r24
 3116 0e08 7795      		ror r23
 3117 0e0a 6795      		ror r22
 3118               		2:
 3119 0e0c 2A95      		dec r18
 3120 0e0e 02F4      		brpl 1b
 466:vty.c         ****   return OK_SILENT;
 3122               	.LM324:
 3123 0e10 0E94 0000 		call ipSetConfigMask
 3124 0e14 80E0      		ldi r24,0
 3125 0e16 90E0      		ldi r25,0
 3126 0e18 0895      		ret
 3127               	.L137:
 3128               	.LBE80:
 3129               	.LBE79:
 462:vty.c         **** 
 3131               	.LM325:
 3132 0e1a 82E0      		ldi r24,lo8(2)
 3133 0e1c 90E0      		ldi r25,0
 468:vty.c         **** 
 3135               	.LM326:
 3136 0e1e 0895      		ret
 3138               	.Lscope27:
 3140               		.stabd	78,0,0
 3144               	setIpFunction:
 3145               		.stabd	46,0,0
 423:vty.c         ****   if (state->argc < 4)
 3147               	.LM327:
 3148               	.LFBB28:
 3149 0e20 8F92      		push r8
 3150 0e22 9F92      		push r9
 3151 0e24 AF92      		push r10
 3152 0e26 BF92      		push r11
 3153 0e28 CF92      		push r12
 3154 0e2a DF92      		push r13
 3155 0e2c EF92      		push r14
 3156 0e2e FF92      		push r15
 3157 0e30 CF93      		push r28
 3158 0e32 DF93      		push r29
 3159               	/* prologue: function */
 3160               	/* frame size = 0 */
 3161               	/* stack size = 10 */
 3162               	.L__stack_usage = 10
 424:vty.c         ****     return SYNTAX_ERROR;
 3164               	.LM328:
 3165 0e34 FC01      		movw r30,r24
 3166 0e36 218D      		ldd r18,Z+25
 3167 0e38 2430      		cpi r18,lo8(4)
 3168 0e3a 00F0      		brlo .L140
 3169 0e3c EC01      		movw r28,r24
 3170               	.LBB83:
 3171               	.LBB84:
 427:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 3173               	.LM329:
 3174 0e3e BC01      		movw r22,r24
 3175 0e40 81E0      		ldi r24,lo8(1)
 3176 0e42 0E94 0000 		call cmdlineGetArgInt
 3177 0e46 6B01      		movw r12,r22
 3178 0e48 7C01      		movw r14,r24
 428:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 3180               	.LM330:
 3181 0e4a BE01      		movw r22,r28
 3182 0e4c 82E0      		ldi r24,lo8(2)
 3183 0e4e 0E94 0000 		call cmdlineGetArgInt
 3184 0e52 4B01      		movw r8,r22
 3185 0e54 5C01      		movw r10,r24
 429:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 3187               	.LM331:
 3188 0e56 BE01      		movw r22,r28
 3189 0e58 83E0      		ldi r24,lo8(3)
 3190 0e5a 0E94 0000 		call cmdlineGetArgInt
 428:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 3192               	.LM332:
 3193 0e5e BA2C      		mov r11,r10
 3194 0e60 A92C      		mov r10,r9
 3195 0e62 982C      		mov r9,r8
 3196 0e64 8824      		clr r8
 429:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(4, state)))<<24);
 3198               	.LM333:
 3199 0e66 5527      		clr r21
 3200 0e68 4427      		clr r20
 3201 0e6a D501      		movw r26,r10
 3202 0e6c C401      		movw r24,r8
 3203 0e6e 840F      		add r24,r20
 3204 0e70 951F      		adc r25,r21
 3205 0e72 A61F      		adc r26,r22
 3206 0e74 B71F      		adc r27,r23
 428:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(3, state)))<<16) +
 3208               	.LM334:
 3209 0e76 C80E      		add r12,r24
 3210 0e78 D91E      		adc r13,r25
 3211 0e7a EA1E      		adc r14,r26
 3212 0e7c FB1E      		adc r15,r27
 430:vty.c         **** 
 3214               	.LM335:
 3215 0e7e BE01      		movw r22,r28
 3216 0e80 84E0      		ldi r24,lo8(4)
 3217 0e82 0E94 0000 		call cmdlineGetArgInt
 3218 0e86 B62F      		mov r27,r22
 3219 0e88 AA27      		clr r26
 3220 0e8a 9927      		clr r25
 3221 0e8c 8827      		clr r24
 427:vty.c         ****                 (((uint32_t)(cmdlineGetArgInt(2, state)))<< 8) +
 3223               	.LM336:
 3224 0e8e BC01      		movw r22,r24
 3225 0e90 CD01      		movw r24,r26
 3226 0e92 6C0D      		add r22,r12
 3227 0e94 7D1D      		adc r23,r13
 3228 0e96 8E1D      		adc r24,r14
 3229 0e98 9F1D      		adc r25,r15
 432:vty.c         ****   return OK_SILENT;
 3231               	.LM337:
 3232 0e9a 0E94 0000 		call ipSetConfigIp
 3233 0e9e 80E0      		ldi r24,0
 3234 0ea0 90E0      		ldi r25,0
 3235 0ea2 00C0      		rjmp .L139
 3236               	.L140:
 3237               	.LBE84:
 3238               	.LBE83:
 425:vty.c         **** 
 3240               	.LM338:
 3241 0ea4 82E0      		ldi r24,lo8(2)
 3242 0ea6 90E0      		ldi r25,0
 3243               	.L139:
 3244               	/* epilogue start */
 434:vty.c         **** 
 3246               	.LM339:
 3247 0ea8 DF91      		pop r29
 3248 0eaa CF91      		pop r28
 3249 0eac FF90      		pop r15
 3250 0eae EF90      		pop r14
 3251 0eb0 DF90      		pop r13
 3252 0eb2 CF90      		pop r12
 3253 0eb4 BF90      		pop r11
 3254 0eb6 AF90      		pop r10
 3255 0eb8 9F90      		pop r9
 3256 0eba 8F90      		pop r8
 3257 0ebc 0895      		ret
 3259               	.Lscope28:
 3261               		.stabd	78,0,0
 3265               	.global	VtyInit
 3267               	VtyInit:
 3268               		.stabd	46,0,0
 165:vty.c         ****   cmdStateConfigure(state, (char *)(CLI_1_BUF_ADDR), CLI_BUF_TOT_LEN, stream, &cmdListNormal[0], NR
 3270               	.LM340:
 3271               	.LFBB29:
 3272 0ebe EF92      		push r14
 3273 0ec0 0F93      		push r16
 3274 0ec2 1F93      		push r17
 3275               	/* prologue: function */
 3276               	/* frame size = 0 */
 3277               	/* stack size = 3 */
 3278               	.L__stack_usage = 3
 3279 0ec4 9B01      		movw r18,r22
 166:vty.c         **** }
 3281               	.LM341:
 3282 0ec6 E12C      		mov r14,__zero_reg__
 3283 0ec8 00E0      		ldi r16,lo8(cmdListNormal)
 3284 0eca 10E0      		ldi r17,hi8(cmdListNormal)
 3285 0ecc 40E0      		ldi r20,0
 3286 0ece 51E0      		ldi r21,lo8(1)
 3287 0ed0 60E0      		ldi r22,0
 3288 0ed2 78E2      		ldi r23,lo8(40)
 3289 0ed4 0E94 0000 		call cmdStateConfigure
 3290               	/* epilogue start */
 167:vty.c         **** 
 3292               	.LM342:
 3293 0ed8 1F91      		pop r17
 3294 0eda 0F91      		pop r16
 3295 0edc EF90      		pop r14
 3296 0ede 0895      		ret
 3298               	.Lscope29:
 3300               		.stabd	78,0,0
 3303               	.global	printErrorInfo
 3305               	printErrorInfo:
 3306               		.stabd	46,0,0
 170:vty.c         ****   if (state->errno != 0)
 3308               	.LM343:
 3309               	.LFBB30:
 3310 0ee0 CF93      		push r28
 3311 0ee2 DF93      		push r29
 3312               	/* prologue: function */
 3313               	/* frame size = 0 */
 3314               	/* stack size = 2 */
 3315               	.L__stack_usage = 2
 3316 0ee4 EC01      		movw r28,r24
 171:vty.c         ****   {
 3318               	.LM344:
 3319 0ee6 EC8D      		ldd r30,Y+28
 3320 0ee8 EE23      		tst r30
 3321 0eea 01F0      		breq .L143
 3322               	.LBB85:
 173:vty.c         ****   }
 3324               	.LM345:
 3325 0eec F0E0      		ldi r31,0
 3326 0eee EE0F      		lsl r30
 3327 0ef0 FF1F      		rol r31
 3328 0ef2 E050      		subi r30,lo8(-(errorStrings))
 3329 0ef4 F040      		sbci r31,hi8(-(errorStrings))
 3330               	/* #APP */
 3331               	 ;  173 "vty.c" 1
 3332 0ef6 8591      		lpm r24, Z+
 3333 0ef8 9491      		lpm r25, Z
 3334               		
 3335               	 ;  0 "" 2
 3336               	/* #NOAPP */
 3337               	.LBE85:
 3338 0efa 2F8D      		ldd r18,Y+31
 3339 0efc 1F92      		push __zero_reg__
 3340 0efe 2F93      		push r18
 3341 0f00 2E8D      		ldd r18,Y+30
 3342 0f02 2F93      		push r18
 3343 0f04 2D8D      		ldd r18,Y+29
 3344 0f06 2F93      		push r18
 3345 0f08 9F93      		push r25
 3346 0f0a 8F93      		push r24
 3347 0f0c 8B8D      		ldd r24,Y+27
 3348 0f0e 8F93      		push r24
 3349 0f10 8A8D      		ldd r24,Y+26
 3350 0f12 8F93      		push r24
 3351 0f14 0E94 0000 		call fprintf_P
 3352 0f18 8DB7      		in r24,__SP_L__
 3353 0f1a 9EB7      		in r25,__SP_H__
 3354 0f1c 0896      		adiw r24,8
 3355 0f1e 0FB6      		in __tmp_reg__,__SREG__
 3356 0f20 F894      		cli
 3357 0f22 9EBF      		out __SP_H__,r25
 3358 0f24 0FBE      		out __SREG__,__tmp_reg__
 3359 0f26 8DBF      		out __SP_L__,r24
 3360               	.L143:
 175:vty.c         ****   state->err1 = 0;
 3362               	.LM346:
 3363 0f28 1C8E      		std Y+28,__zero_reg__
 176:vty.c         ****   state->err2 = 0;
 3365               	.LM347:
 3366 0f2a 1E8E      		std Y+30,__zero_reg__
 3367 0f2c 1D8E      		std Y+29,__zero_reg__
 177:vty.c         **** }
 3369               	.LM348:
 3370 0f2e 1F8E      		std Y+31,__zero_reg__
 3371               	/* epilogue start */
 178:vty.c         **** 
 3373               	.LM349:
 3374 0f30 DF91      		pop r29
 3375 0f32 CF91      		pop r28
 3376 0f34 0895      		ret
 3381               	.Lscope30:
 3383               		.stabd	78,0,0
 3387               	rpingFunction:
 3388               		.stabd	46,0,0
 611:vty.c         ****   if (state->argc < 1)
 3390               	.LM350:
 3391               	.LFBB31:
 3392 0f36 0F93      		push r16
 3393 0f38 1F93      		push r17
 3394 0f3a CF93      		push r28
 3395 0f3c DF93      		push r29
 3396 0f3e 1F92      		push __zero_reg__
 3397 0f40 CDB7      		in r28,__SP_L__
 3398 0f42 DEB7      		in r29,__SP_H__
 3399               	/* prologue: function */
 3400               	/* frame size = 1 */
 3401               	/* stack size = 5 */
 3402               	.L__stack_usage = 5
 612:vty.c         ****     return SYNTAX_ERROR;
 3404               	.LM351:
 3405 0f44 FC01      		movw r30,r24
 3406 0f46 218D      		ldd r18,Z+25
 3407 0f48 2223      		tst r18
 3408 0f4a 01F0      		breq .L149
 3409 0f4c 8C01      		movw r16,r24
 3410               	.LBB88:
 3411               	.LBB89:
 615:vty.c         ****   if ((state->err2 = rs485ping(nrSterownika)) == 0)
 3413               	.LM352:
 3414 0f4e BC01      		movw r22,r24
 3415 0f50 81E0      		ldi r24,lo8(1)
 3416 0f52 0E94 0000 		call cmdlineGetArgInt
 616:vty.c         ****     return OK_INFORM;
 3418               	.LM353:
 3419 0f56 862F      		mov r24,r22
 3420 0f58 6983      		std Y+1,r22
 3421 0f5a 0E94 0000 		call rs485ping
 3422 0f5e F801      		movw r30,r16
 3423 0f60 878F      		std Z+31,r24
 3424 0f62 6981      		ldd r22,Y+1
 3425 0f64 8823      		tst r24
 3426 0f66 01F0      		breq .L150
 619:vty.c         ****   state->err1 = nrSterownika;
 3428               	.LM354:
 3429 0f68 89E0      		ldi r24,lo8(9)
 3430 0f6a 848F      		std Z+28,r24
 620:vty.c         ****   printErrorInfo(state);
 3432               	.LM355:
 3433 0f6c 70E0      		ldi r23,0
 3434 0f6e 768F      		std Z+30,r23
 3435 0f70 658F      		std Z+29,r22
 621:vty.c         ****   return OK_SILENT;
 3437               	.LM356:
 3438 0f72 C801      		movw r24,r16
 3439 0f74 0E94 0000 		call printErrorInfo
 622:vty.c         **** }
 3441               	.LM357:
 3442 0f78 80E0      		ldi r24,0
 3443 0f7a 90E0      		ldi r25,0
 3444 0f7c 00C0      		rjmp .L148
 3445               	.L149:
 3446               	.LBE89:
 3447               	.LBE88:
 613:vty.c         **** 
 3449               	.LM358:
 3450 0f7e 82E0      		ldi r24,lo8(2)
 3451 0f80 90E0      		ldi r25,0
 3452 0f82 00C0      		rjmp .L148
 3453               	.L150:
 3454               	.LBB91:
 3455               	.LBB90:
 617:vty.c         **** 
 3457               	.LM359:
 3458 0f84 81E0      		ldi r24,lo8(1)
 3459 0f86 90E0      		ldi r25,0
 3460               	.L148:
 3461               	/* epilogue start */
 3462               	.LBE90:
 3463               	.LBE91:
 623:vty.c         **** 
 3465               	.LM360:
 3466 0f88 0F90      		pop __tmp_reg__
 3467 0f8a DF91      		pop r29
 3468 0f8c CF91      		pop r28
 3469 0f8e 1F91      		pop r17
 3470 0f90 0F91      		pop r16
 3471 0f92 0895      		ret
 3473               	.Lscope31:
 3475               		.stabd	78,0,0
 3479               	eraseRamFileFunction:
 3480               		.stabd	46,0,0
 874:vty.c         ****   if (ramDyskUsunPlik(cmdlineGetArgStr(1, state)) == 0)
 3482               	.LM361:
 3483               	.LFBB32:
 3484 0f94 CF93      		push r28
 3485 0f96 DF93      		push r29
 3486               	/* prologue: function */
 3487               	/* frame size = 0 */
 3488               	/* stack size = 2 */
 3489               	.L__stack_usage = 2
 3490 0f98 EC01      		movw r28,r24
 875:vty.c         ****     return OK_INFORM;
 3492               	.LM362:
 3493 0f9a BC01      		movw r22,r24
 3494 0f9c 81E0      		ldi r24,lo8(1)
 3495 0f9e 0E94 0000 		call cmdlineGetArgStr
 3496 0fa2 0E94 0000 		call ramDyskUsunPlik
 3497 0fa6 8823      		tst r24
 3498 0fa8 01F0      		breq .L153
 878:vty.c         ****   return ERROR_INFORM;
 3500               	.LM363:
 3501 0faa CE01      		movw r24,r28
 3502 0fac 0E94 0000 		call printErrorInfo
 879:vty.c         **** }
 3504               	.LM364:
 3505 0fb0 84E0      		ldi r24,lo8(4)
 3506 0fb2 90E0      		ldi r25,0
 3507 0fb4 00C0      		rjmp .L152
 3508               	.L153:
 876:vty.c         **** 
 3510               	.LM365:
 3511 0fb6 81E0      		ldi r24,lo8(1)
 3512 0fb8 90E0      		ldi r25,0
 3513               	.L152:
 3514               	/* epilogue start */
 880:vty.c         **** 
 3516               	.LM366:
 3517 0fba DF91      		pop r29
 3518 0fbc CF91      		pop r28
 3519 0fbe 0895      		ret
 3521               	.Lscope32:
 3523               		.stabd	78,0,0
 3527               	dodajRamPlikFunction:
 3528               		.stabd	46,0,0
 883:vty.c         ****   if (state->argc != 1)
 3530               	.LM367:
 3531               	.LFBB33:
 3532 0fc0 CF93      		push r28
 3533 0fc2 DF93      		push r29
 3534               	/* prologue: function */
 3535               	/* frame size = 0 */
 3536               	/* stack size = 2 */
 3537               	.L__stack_usage = 2
 884:vty.c         ****     return SYNTAX_ERROR;
 3539               	.LM368:
 3540 0fc4 FC01      		movw r30,r24
 3541 0fc6 218D      		ldd r18,Z+25
 3542 0fc8 2130      		cpi r18,lo8(1)
 3543 0fca 01F4      		brne .L156
 3544 0fcc EC01      		movw r28,r24
 3545               	.LBB94:
 3546               	.LBB95:
 887:vty.c         ****   {
 3548               	.LM369:
 3549 0fce BC01      		movw r22,r24
 3550 0fd0 81E0      		ldi r24,lo8(1)
 3551 0fd2 0E94 0000 		call cmdlineGetArgStr
 3552 0fd6 0E94 0000 		call ramDyskUtworzPlik
 3553 0fda 8823      		tst r24
 3554 0fdc 01F0      		breq .L157
 891:vty.c         ****   return ERROR_INFORM;
 3556               	.LM370:
 3557 0fde CE01      		movw r24,r28
 3558 0fe0 0E94 0000 		call printErrorInfo
 892:vty.c         **** }
 3560               	.LM371:
 3561 0fe4 84E0      		ldi r24,lo8(4)
 3562 0fe6 90E0      		ldi r25,0
 3563 0fe8 00C0      		rjmp .L155
 3564               	.L156:
 3565               	.LBE95:
 3566               	.LBE94:
 885:vty.c         **** 
 3568               	.LM372:
 3569 0fea 82E0      		ldi r24,lo8(2)
 3570 0fec 90E0      		ldi r25,0
 3571 0fee 00C0      		rjmp .L155
 3572               	.L157:
 3573               	.LBB97:
 3574               	.LBB96:
 889:vty.c         ****   }
 3576               	.LM373:
 3577 0ff0 81E0      		ldi r24,lo8(1)
 3578 0ff2 90E0      		ldi r25,0
 3579               	.L155:
 3580               	/* epilogue start */
 3581               	.LBE96:
 3582               	.LBE97:
 893:vty.c         **** 
 3584               	.LM374:
 3585 0ff4 DF91      		pop r29
 3586 0ff6 CF91      		pop r28
 3587 0ff8 0895      		ret
 3589               	.Lscope33:
 3591               		.stabd	78,0,0
 3595               	flashExModuleFunction:
 3596               		.stabd	46,0,0
 642:vty.c         ****   if (state->argc != 2)
 3598               	.LM375:
 3599               	.LFBB34:
 3600 0ffa FF92      		push r15
 3601 0ffc 0F93      		push r16
 3602 0ffe 1F93      		push r17
 3603 1000 CF93      		push r28
 3604 1002 DF93      		push r29
 3605               	/* prologue: function */
 3606               	/* frame size = 0 */
 3607               	/* stack size = 5 */
 3608               	.L__stack_usage = 5
 643:vty.c         ****     return SYNTAX_ERROR;
 3610               	.LM376:
 3611 1004 FC01      		movw r30,r24
 3612 1006 218D      		ldd r18,Z+25
 3613 1008 2230      		cpi r18,lo8(2)
 3614 100a 01F0      		breq .+2
 3615 100c 00C0      		rjmp .L162
 3616 100e EC01      		movw r28,r24
 3617               	.LBB100:
 3618               	.LBB101:
 646:vty.c         ****   char *nazwaPliku      = cmdlineGetArgStr(2, state);
 3620               	.LM377:
 3621 1010 BC01      		movw r22,r24
 3622 1012 81E0      		ldi r24,lo8(1)
 3623 1014 0E94 0000 		call cmdlineGetArgInt
 3624 1018 162F      		mov r17,r22
 647:vty.c         ****   uint8_t  blad;
 3626               	.LM378:
 3627 101a BE01      		movw r22,r28
 3628 101c 82E0      		ldi r24,lo8(2)
 3629 101e 0E94 0000 		call cmdlineGetArgStr
 3630 1022 082F      		mov r16,r24
 3631 1024 F92E      		mov r15,r25
 651:vty.c         ****   {
 3633               	.LM379:
 3634 1026 812F      		mov r24,r17
 3635 1028 0E94 0000 		call rs485ping
 3636 102c 8823      		tst r24
 3637 102e 01F0      		breq .L160
 653:vty.c         ****     printErrorInfo(state);
 3639               	.LM380:
 3640 1030 89E0      		ldi r24,lo8(9)
 3641 1032 8C8F      		std Y+28,r24
 654:vty.c         ****     return ERROR_INFORM;
 3643               	.LM381:
 3644 1034 CE01      		movw r24,r28
 3645 1036 0E94 0000 		call printErrorInfo
 3646 103a 00C0      		rjmp .L163
 3647               	.L160:
 659:vty.c         ****   {
 3649               	.LM382:
 3650 103c 60E0      		ldi r22,lo8(fdVty)
 3651 103e 70E0      		ldi r23,hi8(fdVty)
 3652 1040 802F      		mov r24,r16
 3653 1042 9F2D      		mov r25,r15
 3654 1044 0E94 0000 		call ramDyskOtworzPlik
 3655 1048 8823      		tst r24
 3656 104a 01F0      		breq .L161
 661:vty.c         ****     return ERROR_INFORM;
 3658               	.LM383:
 3659 104c FF92      		push r15
 3660 104e 0F93      		push r16
 3661 1050 80E0      		ldi r24,lo8(errorOpenFile)
 3662 1052 90E0      		ldi r25,hi8(errorOpenFile)
 3663 1054 9F93      		push r25
 3664 1056 8F93      		push r24
 3665 1058 8B8D      		ldd r24,Y+27
 3666 105a 8F93      		push r24
 3667 105c 8A8D      		ldd r24,Y+26
 3668 105e 8F93      		push r24
 3669 1060 0E94 0000 		call fprintf_P
 3670 1064 0F90      		pop __tmp_reg__
 3671 1066 0F90      		pop __tmp_reg__
 3672 1068 0F90      		pop __tmp_reg__
 3673 106a 0F90      		pop __tmp_reg__
 3674 106c 0F90      		pop __tmp_reg__
 3675 106e 0F90      		pop __tmp_reg__
 3676 1070 00C0      		rjmp .L163
 3677               	.L161:
 665:vty.c         **** 
 3679               	.LM384:
 3680 1072 4A8D      		ldd r20,Y+26
 3681 1074 5B8D      		ldd r21,Y+27
 3682 1076 612F      		mov r22,r17
 3683 1078 80E0      		ldi r24,lo8(fdVty)
 3684 107a 90E0      		ldi r25,hi8(fdVty)
 3685 107c 0E94 0000 		call rs485xModemFlash
 3686 1080 C82F      		mov r28,r24
 667:vty.c         **** 
 3688               	.LM385:
 3689 1082 80E0      		ldi r24,lo8(fdVty)
 3690 1084 90E0      		ldi r25,hi8(fdVty)
 3691 1086 0E94 0000 		call ramDyskZamknijPlik
 669:vty.c         ****     return ERROR_INFORM;
 3693               	.LM386:
 3694 108a C111      		cpse r28,__zero_reg__
 3695 108c 00C0      		rjmp .L163
 672:vty.c         **** }
 3697               	.LM387:
 3698 108e 80E0      		ldi r24,0
 3699 1090 90E0      		ldi r25,0
 3700 1092 00C0      		rjmp .L159
 3701               	.L162:
 3702               	.LBE101:
 3703               	.LBE100:
 644:vty.c         **** 
 3705               	.LM388:
 3706 1094 82E0      		ldi r24,lo8(2)
 3707 1096 90E0      		ldi r25,0
 3708 1098 00C0      		rjmp .L159
 3709               	.L163:
 3710               	.LBB103:
 3711               	.LBB102:
 670:vty.c         **** 
 3713               	.LM389:
 3714 109a 84E0      		ldi r24,lo8(4)
 3715 109c 90E0      		ldi r25,0
 3716               	.L159:
 3717               	/* epilogue start */
 3718               	.LBE102:
 3719               	.LBE103:
 673:vty.c         **** 
 3721               	.LM390:
 3722 109e DF91      		pop r29
 3723 10a0 CF91      		pop r28
 3724 10a2 1F91      		pop r17
 3725 10a4 0F91      		pop r16
 3726 10a6 FF90      		pop r15
 3727 10a8 0895      		ret
 3735               	.Lscope34:
 3737               		.stabd	78,0,0
 3739               	.global	printStatus
 3741               	printStatus:
 3742               		.stabd	46,0,0
 212:vty.c         ****   fprintf_P(stream, PSTR(SYSTEM_NAME" ver "S_VERSION" build: "__DATE__", "__TIME__"\r\n"));
 3744               	.LM391:
 3745               	.LFBB35:
 3746 10aa CF93      		push r28
 3747 10ac DF93      		push r29
 3748               	/* prologue: function */
 3749               	/* frame size = 0 */
 3750               	/* stack size = 2 */
 3751               	.L__stack_usage = 2
 3752 10ae D82F      		mov r29,r24
 3753 10b0 C92F      		mov r28,r25
 213:vty.c         ****   //Print system state
 3755               	.LM392:
 3756 10b2 80E0      		ldi r24,lo8(__c.3625)
 3757 10b4 90E0      		ldi r25,hi8(__c.3625)
 3758 10b6 9F93      		push r25
 3759 10b8 8F93      		push r24
 3760 10ba CF93      		push r28
 3761 10bc DF93      		push r29
 3762 10be 0E94 0000 		call fprintf_P
 215:vty.c         ****   fprintf_P(stream, statusNumberOfTasksStr,    uxTaskGetNumberOfTasks());
 3764               	.LM393:
 3765 10c2 80E0      		ldi r24,lo8(systemStateStr)
 3766 10c4 90E0      		ldi r25,hi8(systemStateStr)
 3767 10c6 9F93      		push r25
 3768 10c8 8F93      		push r24
 3769 10ca CF93      		push r28
 3770 10cc DF93      		push r29
 3771 10ce 0E94 0000 		call fprintf_P
 216:vty.c         ****   fprintf_P(stream, statusStaticHeapStateStr,  xPortGetFreeHeapSize(), configTOTAL_HEAP_SIZE);
 3773               	.LM394:
 3774 10d2 0E94 0000 		call uxTaskGetNumberOfTasks
 3775 10d6 1F92      		push __zero_reg__
 3776 10d8 8F93      		push r24
 3777 10da 80E0      		ldi r24,lo8(statusNumberOfTasksStr)
 3778 10dc 90E0      		ldi r25,hi8(statusNumberOfTasksStr)
 3779 10de 9F93      		push r25
 3780 10e0 8F93      		push r24
 3781 10e2 CF93      		push r28
 3782 10e4 DF93      		push r29
 3783 10e6 0E94 0000 		call fprintf_P
 217:vty.c         ****   fprintf_P(stream, statusDynamicHeapStateStr, xmallocAvailable(),   HEAP_SIZE);
 3785               	.LM395:
 3786 10ea 0E94 0000 		call xPortGetFreeHeapSize
 3787 10ee 2CE0      		ldi r18,lo8(12)
 3788 10f0 2F93      		push r18
 3789 10f2 2CE1      		ldi r18,lo8(28)
 3790 10f4 2F93      		push r18
 3791 10f6 9F93      		push r25
 3792 10f8 8F93      		push r24
 3793 10fa 80E0      		ldi r24,lo8(statusStaticHeapStateStr)
 3794 10fc 90E0      		ldi r25,hi8(statusStaticHeapStateStr)
 3795 10fe 9F93      		push r25
 3796 1100 8F93      		push r24
 3797 1102 CF93      		push r28
 3798 1104 DF93      		push r29
 3799 1106 0E94 0000 		call fprintf_P
 218:vty.c         ****   fprintf_P(stream, statusTemperatureStr, temperature);
 3801               	.LM396:
 3802 110a 0E94 0000 		call xmallocAvailable
 3803 110e 27E1      		ldi r18,lo8(23)
 3804 1110 2F93      		push r18
 3805 1112 1F92      		push __zero_reg__
 3806 1114 9F93      		push r25
 3807 1116 8F93      		push r24
 3808 1118 80E0      		ldi r24,lo8(statusDynamicHeapStateStr)
 3809 111a 90E0      		ldi r25,hi8(statusDynamicHeapStateStr)
 3810 111c 9F93      		push r25
 3811 111e 8F93      		push r24
 3812 1120 CF93      		push r28
 3813 1122 DF93      		push r29
 3814 1124 0E94 0000 		call fprintf_P
 219:vty.c         ****   fprintf_P(stream, statusVoltageStr, voltage);
 3816               	.LM397:
 3817 1128 8091 0000 		lds r24,temperature
 3818 112c 1F92      		push __zero_reg__
 3819 112e 8F93      		push r24
 3820 1130 80E0      		ldi r24,lo8(statusTemperatureStr)
 3821 1132 90E0      		ldi r25,hi8(statusTemperatureStr)
 3822 1134 9F93      		push r25
 3823 1136 8F93      		push r24
 3824 1138 CF93      		push r28
 3825 113a DF93      		push r29
 3826 113c 0E94 0000 		call fprintf_P
 220:vty.c         **** 
 3828               	.LM398:
 3829 1140 8091 0000 		lds r24,voltage
 3830 1144 2DB7      		in r18,__SP_L__
 3831 1146 3EB7      		in r19,__SP_H__
 3832 1148 2C5D      		subi r18,-36
 3833 114a 3F4F      		sbci r19,-1
 3834 114c 0FB6      		in __tmp_reg__,__SREG__
 3835 114e F894      		cli
 3836 1150 3EBF      		out __SP_H__,r19
 3837 1152 0FBE      		out __SREG__,__tmp_reg__
 3838 1154 2DBF      		out __SP_L__,r18
 3839 1156 1F92      		push __zero_reg__
 3840 1158 8F93      		push r24
 3841 115a 80E0      		ldi r24,lo8(statusVoltageStr)
 3842 115c 90E0      		ldi r25,hi8(statusVoltageStr)
 3843 115e 9F93      		push r25
 3844 1160 8F93      		push r24
 3845 1162 CF93      		push r28
 3846 1164 DF93      		push r29
 3847 1166 0E94 0000 		call fprintf_P
 222:vty.c         ****   fprintf_P(stream, statusRamDiskStateStr,     tmp,  L_KLASTROW);
 3849               	.LM399:
 3850 116a 0E94 0000 		call ramDyskLiczbaWolnychKlastrow
 223:vty.c         **** //  printErrorInfo(state); //TODO fix and uncomment
 3852               	.LM400:
 3853 116e 1F92      		push __zero_reg__
 3854 1170 90E8      		ldi r25,lo8(-128)
 3855 1172 9F93      		push r25
 3856 1174 1F92      		push __zero_reg__
 3857 1176 8F93      		push r24
 3858 1178 80E0      		ldi r24,lo8(statusRamDiskStateStr)
 3859 117a 90E0      		ldi r25,hi8(statusRamDiskStateStr)
 3860 117c 9F93      		push r25
 3861 117e 8F93      		push r24
 3862 1180 CF93      		push r28
 3863 1182 DF93      		push r29
 3864 1184 0E94 0000 		call fprintf_P
 227:vty.c         **** 
 3866               	.LM401:
 3867 1188 80E0      		ldi r24,lo8(systemRamConfigStr)
 3868 118a 90E0      		ldi r25,hi8(systemRamConfigStr)
 3869 118c 9F93      		push r25
 3870 118e 8F93      		push r24
 3871 1190 CF93      		push r28
 3872 1192 DF93      		push r29
 3873 1194 0E94 0000 		call fprintf_P
 229:vty.c         ****   netPrintEthAddr(stream, &nicState.mac);
 3875               	.LM402:
 3876 1198 80E0      		ldi r24,lo8(statusMacStr)
 3877 119a 90E0      		ldi r25,hi8(statusMacStr)
 3878 119c 9F93      		push r25
 3879 119e 8F93      		push r24
 3880 11a0 CF93      		push r28
 3881 11a2 DF93      		push r29
 3882 11a4 0E94 0000 		call fprintf_P
 230:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3884               	.LM403:
 3885 11a8 60E0      		ldi r22,lo8(nicState+2)
 3886 11aa 70E0      		ldi r23,hi8(nicState+2)
 3887 11ac 8D2F      		mov r24,r29
 3888 11ae 9C2F      		mov r25,r28
 3889 11b0 0E94 0000 		call netPrintEthAddr
 231:vty.c         **** 
 3891               	.LM404:
 3892 11b4 80E0      		ldi r24,lo8(__c.3628)
 3893 11b6 90E0      		ldi r25,hi8(__c.3628)
 3894 11b8 9F93      		push r25
 3895 11ba 8F93      		push r24
 3896 11bc CF93      		push r28
 3897 11be DF93      		push r29
 3898 11c0 0E94 0000 		call fprintf_P
 233:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->ip);
 3900               	.LM405:
 3901 11c4 80E0      		ldi r24,lo8(statusIpStr)
 3902 11c6 90E0      		ldi r25,hi8(statusIpStr)
 3903 11c8 9F93      		push r25
 3904 11ca 8F93      		push r24
 3905 11cc CF93      		push r28
 3906 11ce DF93      		push r29
 3907 11d0 0E94 0000 		call fprintf_P
 234:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3909               	.LM406:
 3910 11d4 0E94 0000 		call ipGetConfig
 3911 11d8 FC01      		movw r30,r24
 3912 11da 4081      		ld r20,Z
 3913 11dc 5181      		ldd r21,Z+1
 3914 11de 6281      		ldd r22,Z+2
 3915 11e0 7381      		ldd r23,Z+3
 3916 11e2 8D2F      		mov r24,r29
 3917 11e4 9C2F      		mov r25,r28
 3918 11e6 0E94 0000 		call netPrintIPAddr
 235:vty.c         **** 
 3920               	.LM407:
 3921 11ea 80E0      		ldi r24,lo8(__c.3630)
 3922 11ec 90E0      		ldi r25,hi8(__c.3630)
 3923 11ee 9F93      		push r25
 3924 11f0 8F93      		push r24
 3925 11f2 CF93      		push r28
 3926 11f4 DF93      		push r29
 3927 11f6 0E94 0000 		call fprintf_P
 237:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->netmask);
 3929               	.LM408:
 3930 11fa 2DB7      		in r18,__SP_L__
 3931 11fc 3EB7      		in r19,__SP_H__
 3932 11fe 2E5D      		subi r18,-34
 3933 1200 3F4F      		sbci r19,-1
 3934 1202 0FB6      		in __tmp_reg__,__SREG__
 3935 1204 F894      		cli
 3936 1206 3EBF      		out __SP_H__,r19
 3937 1208 0FBE      		out __SREG__,__tmp_reg__
 3938 120a 2DBF      		out __SP_L__,r18
 3939 120c 80E0      		ldi r24,lo8(statusIpMaskStr)
 3940 120e 90E0      		ldi r25,hi8(statusIpMaskStr)
 3941 1210 9F93      		push r25
 3942 1212 8F93      		push r24
 3943 1214 CF93      		push r28
 3944 1216 DF93      		push r29
 3945 1218 0E94 0000 		call fprintf_P
 238:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3947               	.LM409:
 3948 121c 0E94 0000 		call ipGetConfig
 3949 1220 FC01      		movw r30,r24
 3950 1222 4481      		ldd r20,Z+4
 3951 1224 5581      		ldd r21,Z+5
 3952 1226 6681      		ldd r22,Z+6
 3953 1228 7781      		ldd r23,Z+7
 3954 122a 8D2F      		mov r24,r29
 3955 122c 9C2F      		mov r25,r28
 3956 122e 0E94 0000 		call netPrintIPAddr
 239:vty.c         **** 
 3958               	.LM410:
 3959 1232 80E0      		ldi r24,lo8(__c.3632)
 3960 1234 90E0      		ldi r25,hi8(__c.3632)
 3961 1236 9F93      		push r25
 3962 1238 8F93      		push r24
 3963 123a CF93      		push r28
 3964 123c DF93      		push r29
 3965 123e 0E94 0000 		call fprintf_P
 241:vty.c         ****   netPrintIPAddr(stream, ipGetConfig()->gateway);
 3967               	.LM411:
 3968 1242 80E0      		ldi r24,lo8(statusIpGwStr)
 3969 1244 90E0      		ldi r25,hi8(statusIpGwStr)
 3970 1246 9F93      		push r25
 3971 1248 8F93      		push r24
 3972 124a CF93      		push r28
 3973 124c DF93      		push r29
 3974 124e 0E94 0000 		call fprintf_P
 242:vty.c         ****   fprintf_P(stream, PSTR("\r\n"));
 3976               	.LM412:
 3977 1252 0E94 0000 		call ipGetConfig
 3978 1256 FC01      		movw r30,r24
 3979 1258 4085      		ldd r20,Z+8
 3980 125a 5185      		ldd r21,Z+9
 3981 125c 6285      		ldd r22,Z+10
 3982 125e 7385      		ldd r23,Z+11
 3983 1260 8D2F      		mov r24,r29
 3984 1262 9C2F      		mov r25,r28
 3985 1264 0E94 0000 		call netPrintIPAddr
 243:vty.c         **** 
 3987               	.LM413:
 3988 1268 80E0      		ldi r24,lo8(__c.3634)
 3989 126a 90E0      		ldi r25,hi8(__c.3634)
 3990 126c 9F93      		push r25
 3991 126e 8F93      		push r24
 3992 1270 CF93      		push r28
 3993 1272 DF93      		push r29
 3994 1274 0E94 0000 		call fprintf_P
 246:vty.c         **** //  tmp = printRs485devices(stream);
 3996               	.LM414:
 3997 1278 80E0      		ldi r24,lo8(statusRs485listStr)
 3998 127a 90E0      		ldi r25,hi8(statusRs485listStr)
 3999 127c 9F93      		push r25
 4000 127e 8F93      		push r24
 4001 1280 CF93      		push r28
 4002 1282 DF93      		push r29
 4003 1284 0E94 0000 		call fprintf_P
 252:vty.c         ****   tmp = printLockers(stream);
 4005               	.LM415:
 4006 1288 80E0      		ldi r24,lo8(statusLockerSensorsStr)
 4007 128a 90E0      		ldi r25,hi8(statusLockerSensorsStr)
 4008 128c 9F93      		push r25
 4009 128e 8F93      		push r24
 4010 1290 CF93      		push r28
 4011 1292 DF93      		push r29
 4012 1294 0E94 0000 		call fprintf_P
 253:vty.c         ****   if (tmp == 0)
 4014               	.LM416:
 4015 1298 8D2F      		mov r24,r29
 4016 129a 9C2F      		mov r25,r28
 4017 129c 0E94 0000 		call printLockers
 254:vty.c         ****     fprintf_P(stream, statusLockerSensorsDisStr);
 4019               	.LM417:
 4020 12a0 2DB7      		in r18,__SP_L__
 4021 12a2 3EB7      		in r19,__SP_H__
 4022 12a4 285E      		subi r18,-24
 4023 12a6 3F4F      		sbci r19,-1
 4024 12a8 0FB6      		in __tmp_reg__,__SREG__
 4025 12aa F894      		cli
 4026 12ac 3EBF      		out __SP_H__,r19
 4027 12ae 0FBE      		out __SREG__,__tmp_reg__
 4028 12b0 2DBF      		out __SP_L__,r18
 4029 12b2 8111      		cpse r24,__zero_reg__
 4030 12b4 00C0      		rjmp .L165
 255:vty.c         **** 
 4032               	.LM418:
 4033 12b6 80E0      		ldi r24,lo8(statusLockerSensorsDisStr)
 4034 12b8 90E0      		ldi r25,hi8(statusLockerSensorsDisStr)
 4035 12ba 9F93      		push r25
 4036 12bc 8F93      		push r24
 4037 12be CF93      		push r28
 4038 12c0 DF93      		push r29
 4039 12c2 0E94 0000 		call fprintf_P
 4040 12c6 0F90      		pop __tmp_reg__
 4041 12c8 0F90      		pop __tmp_reg__
 4042 12ca 0F90      		pop __tmp_reg__
 4043 12cc 0F90      		pop __tmp_reg__
 4044               	.L165:
 264:vty.c         **** //  arpPrintTable(stream);
 4046               	.LM419:
 4047 12ce 8D2F      		mov r24,r29
 4048 12d0 9C2F      		mov r25,r28
 4049               	/* epilogue start */
 266:vty.c         **** 
 4051               	.LM420:
 4052 12d2 DF91      		pop r29
 4053 12d4 CF91      		pop r28
 264:vty.c         **** //  arpPrintTable(stream);
 4055               	.LM421:
 4056 12d6 0C94 0000 		jmp udpPrintStatus
 4058               	.Lscope35:
 4060               		.stabd	78,0,0
 4064               	statusFunction:
 4065               		.stabd	46,0,0
 272:vty.c         ****   if (state->argc < 1)
 4067               	.LM422:
 4068               	.LFBB36:
 4069 12da 0F93      		push r16
 4070 12dc 1F93      		push r17
 4071 12de CF93      		push r28
 4072 12e0 DF93      		push r29
 4073 12e2 CDB7      		in r28,__SP_L__
 4074 12e4 DEB7      		in r29,__SP_H__
 4075 12e6 2E97      		sbiw r28,14
 4076 12e8 0FB6      		in __tmp_reg__,__SREG__
 4077 12ea F894      		cli
 4078 12ec DEBF      		out __SP_H__,r29
 4079 12ee 0FBE      		out __SREG__,__tmp_reg__
 4080 12f0 CDBF      		out __SP_L__,r28
 4081               	/* prologue: function */
 4082               	/* frame size = 14 */
 4083               	/* stack size = 18 */
 4084               	.L__stack_usage = 18
 4085 12f2 8C01      		movw r16,r24
 273:vty.c         ****   {
 4087               	.LM423:
 4088 12f4 FC01      		movw r30,r24
 4089 12f6 818D      		ldd r24,Z+25
 4090 12f8 8111      		cpse r24,__zero_reg__
 4091 12fa 00C0      		rjmp .L167
 275:vty.c         ****     return OK_SILENT;
 4093               	.LM424:
 4094 12fc 828D      		ldd r24,Z+26
 4095 12fe 938D      		ldd r25,Z+27
 4096 1300 0E94 0000 		call printStatus
 4097 1304 00C0      		rjmp .L170
 4098               	.L167:
 280:vty.c         ****   {
 4100               	.LM425:
 4101 1306 B801      		movw r22,r16
 4102 1308 81E0      		ldi r24,lo8(1)
 4103 130a 0E94 0000 		call cmdlineGetArgStr
 4104 130e 23E0      		ldi r18,lo8(3)
 4105 1310 AE01      		movw r20,r28
 4106 1312 4F5F      		subi r20,-1
 4107 1314 5F4F      		sbci r21,-1
 4108 1316 60E0      		ldi r22,lo8(fdVty)
 4109 1318 70E0      		ldi r23,hi8(fdVty)
 4110 131a 0E94 0000 		call ramDyskOtworzPlikStdIo
 4111 131e 8823      		tst r24
 4112 1320 01F0      		breq .L169
 4113               	.LBB106:
 4114               	.LBB107:
 282:vty.c         ****     return ERROR_INFORM;
 4116               	.LM426:
 4117 1322 B801      		movw r22,r16
 4118 1324 81E0      		ldi r24,lo8(1)
 4119 1326 0E94 0000 		call cmdlineGetArgStr
 4120 132a 9F93      		push r25
 4121 132c 8F93      		push r24
 4122 132e 80E0      		ldi r24,lo8(errorOpenFile)
 4123 1330 90E0      		ldi r25,hi8(errorOpenFile)
 4124 1332 9F93      		push r25
 4125 1334 8F93      		push r24
 4126 1336 F801      		movw r30,r16
 4127 1338 838D      		ldd r24,Z+27
 4128 133a 8F93      		push r24
 4129 133c 828D      		ldd r24,Z+26
 4130 133e 8F93      		push r24
 4131 1340 0E94 0000 		call fprintf_P
 4132 1344 0F90      		pop __tmp_reg__
 4133 1346 0F90      		pop __tmp_reg__
 4134 1348 0F90      		pop __tmp_reg__
 4135 134a 0F90      		pop __tmp_reg__
 4136 134c 0F90      		pop __tmp_reg__
 4137 134e 0F90      		pop __tmp_reg__
 4138 1350 84E0      		ldi r24,lo8(4)
 4139 1352 90E0      		ldi r25,0
 4140 1354 00C0      		rjmp .L168
 4141               	.L169:
 4142               	.LBE107:
 4143               	.LBE106:
 286:vty.c         ****   ramDyskZamknijPlikStdIo(&stream);
 4145               	.LM427:
 4146 1356 CE01      		movw r24,r28
 4147 1358 0196      		adiw r24,1
 4148 135a 0E94 0000 		call printStatus
 287:vty.c         ****   return OK_SILENT;
 4150               	.LM428:
 4151 135e CE01      		movw r24,r28
 4152 1360 0196      		adiw r24,1
 4153 1362 0E94 0000 		call ramDyskZamknijPlikStdIo
 4154               	.L170:
 288:vty.c         **** }
 4156               	.LM429:
 4157 1366 80E0      		ldi r24,0
 4158 1368 90E0      		ldi r25,0
 4159               	.L168:
 4160               	/* epilogue start */
 289:vty.c         **** 
 4162               	.LM430:
 4163 136a 2E96      		adiw r28,14
 4164 136c 0FB6      		in __tmp_reg__,__SREG__
 4165 136e F894      		cli
 4166 1370 DEBF      		out __SP_H__,r29
 4167 1372 0FBE      		out __SREG__,__tmp_reg__
 4168 1374 CDBF      		out __SP_L__,r28
 4169 1376 DF91      		pop r29
 4170 1378 CF91      		pop r28
 4171 137a 1F91      		pop r17
 4172 137c 0F91      		pop r16
 4173 137e 0895      		ret
 4178               	.Lscope36:
 4180               		.stabd	78,0,0
 4181               		.section	.progmem.data,"a",@progbits
 4184               	__c.3634:
 4185 0000 0D0A 00   		.string	"\r\n"
 4188               	__c.3632:
 4189 0003 0D0A 00   		.string	"\r\n"
 4192               	__c.3630:
 4193 0006 0D0A 00   		.string	"\r\n"
 4196               	__c.3628:
 4197 0009 0D0A 00   		.string	"\r\n"
 4200               	__c.3625:
 4201 000c 4672 6565 		.string	"FreeRtos+ ver 0.31 build: Aug 18 2017, 16:12:44\r\n"
 4201      5274 6F73 
 4201      2B20 7665 
 4201      7220 302E 
 4201      3331 2062 
 4204               	__c.3674:
 4205 003e 7564 7000 		.string	"udp"
 4208               	__c.3672:
 4209 0042 7463 7000 		.string	"tcp"
 4212               	__c.3670:
 4213 0046 6963 6D70 		.string	"icmp"
 4213      00
 4216               	__c.3668:
 4217 004b 6970 00   		.string	"ip"
 4220               	__c.3666:
 4221 004e 6172 7000 		.string	"arp"
 4224               	__c.3664:
 4225 0052 7564 7000 		.string	"udp"
 4228               	__c.3662:
 4229 0056 7463 7000 		.string	"tcp"
 4232               	__c.3660:
 4233 005a 6963 6D70 		.string	"icmp"
 4233      00
 4236               	__c.3658:
 4237 005f 6970 00   		.string	"ip"
 4240               	__c.3656:
 4241 0062 6172 7000 		.string	"arp"
 4244               	__c.3768:
 4245 0066 586D 6F64 		.string	"Xmodem: rozpoczynanie odbioru\r\n"
 4245      656D 3A20 
 4245      726F 7A70 
 4245      6F63 7A79 
 4245      6E61 6E69 
 4248               	__c.3718:
 4249 0086 5761 7274 		.string	"Wartosc probki na wejsciu %d: %d\r\n"
 4249      6F73 6320 
 4249      7072 6F62 
 4249      6B69 206E 
 4249      6120 7765 
 4252               	__c.3649:
 4253 00a9 416B 7475 		.string	"Aktualny czas %d:%d:%d\r\n"
 4253      616C 6E79 
 4253      2063 7A61 
 4253      7320 2564 
 4253      3A25 643A 
 4254               	.global	cmdListConfigure
 4257               	cmdListConfigure:
 4258 00c2 0000      		.word	cmd_help
 4259 00c4 0000      		.word	cmd_help_help
 4260 00c6 0000      		.word	gs(helpFunction)
 4261 00c8 0000      		.word	cmd_status
 4262 00ca 0000      		.word	cmd_help_status
 4263 00cc 0000      		.word	gs(statusFunction)
 4264 00ce 0000      		.word	cmd_time
 4265 00d0 0000      		.word	cmd_help_time
 4266 00d2 0000      		.word	gs(pokazCzasFunction)
 4267 00d4 0000      		.word	cmd_settime
 4268 00d6 0000      		.word	cmd_help_settime
 4269 00d8 0000      		.word	gs(setTimeFunction)
 4270 00da 0000      		.word	cmd_conf_ip
 4271 00dc 0000      		.word	cmd_help_conf_ip
 4272 00de 0000      		.word	gs(setIpFunction)
 4273 00e0 0000      		.word	cmd_conf_ip_mask
 4274 00e2 0000      		.word	cmd_conf_ip_mask_help
 4275 00e4 0000      		.word	gs(setIpMaskFunction)
 4276 00e6 0000      		.word	cmd_conf_ip_gw
 4277 00e8 0000      		.word	cmd_conf_ip_gw_help
 4278 00ea 0000      		.word	gs(setIpGwFunction)
 4279 00ec 0000      		.word	cmd_conf_udp
 4280 00ee 0000      		.word	cmd_help_conf_udp
 4281 00f0 0000      		.word	gs(setUdpFunction)
 4282 00f2 0000      		.word	cmd_conf_mac
 4283 00f4 0000      		.word	cmd_help_conf_mac
 4284 00f6 0000      		.word	gs(setMacAddrFunction)
 4285 00f8 0000      		.word	cmd_conf_save
 4286 00fa 0000      		.word	cmd_help_conf_save
 4287 00fc 0000      		.word	gs(saveConfigFunction)
 4288 00fe 0000      		.word	cmd_enable
 4289 0100 0000      		.word	cmd_help_enable
 4290 0102 0000      		.word	gs(enableFunction)
 4291 0104 0000      		.word	cmd_disable
 4292 0106 0000      		.word	cmd_help_disable
 4293 0108 0000      		.word	gs(disableFunction)
 4294 010a 0000      		.word	0
 4295 010c 0000      		.word	0
 4296 010e 0000      		.word	0
 4297               	.global	cmdListEnable
 4300               	cmdListEnable:
 4301 0110 0000      		.word	cmd_help
 4302 0112 0000      		.word	cmd_help_help
 4303 0114 0000      		.word	gs(helpFunction)
 4304 0116 0000      		.word	cmd_status
 4305 0118 0000      		.word	cmd_help_status
 4306 011a 0000      		.word	gs(statusFunction)
 4307 011c 0000      		.word	cmd_enc_stat
 4308 011e 0000      		.word	cmd_help_enc_stat
 4309 0120 0000      		.word	gs(statusEncFunction)
 4310 0122 0000      		.word	cmd_time
 4311 0124 0000      		.word	cmd_help_time
 4312 0126 0000      		.word	gs(pokazCzasFunction)
 4313 0128 0000      		.word	cmd_net_dbg
 4314 012a 0000      		.word	cmd_help_net_dbg
 4315 012c 0000      		.word	gs(debugFunction)
 4316 012e 0000      		.word	cmd_rping
 4317 0130 0000      		.word	cmd_help_rping
 4318 0132 0000      		.word	gs(rpingFunction)
 4319 0134 0000      		.word	cmd_ping
 4320 0136 0000      		.word	cmd_help_ping
 4321 0138 0000      		.word	gs(pingFunction)
 4322 013a 0000      		.word	cmd_xRec
 4323 013c 0000      		.word	cmd_help_xRec
 4324 013e 0000      		.word	gs(goXmodemOdbierzFunction)
 4325 0140 0000      		.word	cmd_xSend
 4326 0142 0000      		.word	cmd_help_xSend
 4327 0144 0000      		.word	gs(goXmodemWyslijFunction)
 4328 0146 0000      		.word	cmd_xflash
 4329 0148 0000      		.word	cmd_help_xflash
 4330 014a 0000      		.word	gs(flashExModuleFunction)
 4331 014c 0000      		.word	cmd_dir_rf
 4332 014e 0000      		.word	cmd_help_dir_rf
 4333 0150 0000      		.word	gs(writeRamFileFunction)
 4334 0152 0000      		.word	cmd_create_rf
 4335 0154 0000      		.word	cmd_help_create_rf
 4336 0156 0000      		.word	gs(dodajRamPlikFunction)
 4337 0158 0000      		.word	cmd_erase_rf
 4338 015a 0000      		.word	cmd_help_erase_rf
 4339 015c 0000      		.word	gs(eraseRamFileFunction)
 4340 015e 0000      		.word	cmd_edit_rf
 4341 0160 0000      		.word	cmd_help_edit_rf
 4342 0162 0000      		.word	gs(editRamFileFunction)
 4343 0164 0000      		.word	cmd_read_rf
 4344 0166 0000      		.word	cmd_help_read_rf
 4345 0168 0000      		.word	gs(readRamFIleFunction)
 4346 016a 0000      		.word	cmd_up
 4347 016c 0000      		.word	cmd_help_up
 4348 016e 0000      		.word	gs(curtainUpFunction)
 4349 0170 0000      		.word	cmd_down
 4350 0172 0000      		.word	cmd_help_down
 4351 0174 0000      		.word	gs(curtainDownFunction)
 4352 0176 0000      		.word	cmd_spa
 4353 0178 0000      		.word	cmd_help_spa
 4354 017a 0000      		.word	gs(ustawPortExtAFunction)
 4355 017c 0000      		.word	cmd_spb
 4356 017e 0000      		.word	cmd_help_spb
 4357 0180 0000      		.word	gs(ustawPortExtBFunction)
 4358 0182 0000      		.word	cmd_ustawR
 4359 0184 0000      		.word	cmd_help_ustawR
 4360 0186 0000      		.word	gs(ustawPortRezystor)
 4361 0188 0000      		.word	cmd_settime
 4362 018a 0000      		.word	cmd_help_settime
 4363 018c 0000      		.word	gs(setTimeFunction)
 4364 018e 0000      		.word	cmd_ac
 4365 0190 0000      		.word	cmd_help_ac
 4366 0192 0000      		.word	gs(czytajAC_Function)
 4367 0194 0000      		.word	cmd_disable
 4368 0196 0000      		.word	cmd_help_disable
 4369 0198 0000      		.word	gs(disableFunction)
 4370 019a 0000      		.word	cmd_configure
 4371 019c 0000      		.word	cmd_help_configure
 4372 019e 0000      		.word	gs(configureModeFunction)
 4373 01a0 0000      		.word	cmd_ustawMW
 4374 01a2 0000      		.word	cmd_help_ustawMW
 4375 01a4 0000      		.word	gs(ustawModWykFunction)
 4376 01a6 0000      		.word	cmd_zapiszMW
 4377 01a8 0000      		.word	cmd_help_zapiszMW
 4378 01aa 0000      		.word	gs(zapiszModWykFunction)
 4379 01ac 0000      		.word	0
 4380 01ae 0000      		.word	0
 4381 01b0 0000      		.word	0
 4382               	.global	cmdListNormal
 4385               	cmdListNormal:
 4386 01b2 0000      		.word	cmd_help
 4387 01b4 0000      		.word	cmd_help_help
 4388 01b6 0000      		.word	gs(helpFunction)
 4389 01b8 0000      		.word	cmd_status
 4390 01ba 0000      		.word	cmd_help_status
 4391 01bc 0000      		.word	gs(statusFunction)
 4392 01be 0000      		.word	cmd_time
 4393 01c0 0000      		.word	cmd_help_time
 4394 01c2 0000      		.word	gs(pokazCzasFunction)
 4395 01c4 0000      		.word	cmd_rping
 4396 01c6 0000      		.word	cmd_help_rping
 4397 01c8 0000      		.word	gs(rpingFunction)
 4398 01ca 0000      		.word	cmd_ping
 4399 01cc 0000      		.word	cmd_help_ping
 4400 01ce 0000      		.word	gs(pingFunction)
 4401 01d0 0000      		.word	cmd_dir_rf
 4402 01d2 0000      		.word	cmd_help_dir_rf
 4403 01d4 0000      		.word	gs(writeRamFileFunction)
 4404 01d6 0000      		.word	cmd_read_rf
 4405 01d8 0000      		.word	cmd_help_read_rf
 4406 01da 0000      		.word	gs(readRamFIleFunction)
 4407 01dc 0000      		.word	cmd_enable
 4408 01de 0000      		.word	cmd_help_enable
 4409 01e0 0000      		.word	gs(enableFunction)
 4410 01e2 0000      		.word	0
 4411 01e4 0000      		.word	0
 4412 01e6 0000      		.word	0
 4413               	.global	errorStrings
 4416               	errorStrings:
 4417 01e8 0000      		.word	errorOK
 4418 01ea 0000      		.word	errorNoFile
 4419 01ec 0000      		.word	errorxModemFrameStartTimeout
 4420 01ee 0000      		.word	errorxModemByteSendTimeout
 4421 01f0 0000      		.word	errorxModemWrongFrameNo
 4422 01f2 0000      		.word	errorxModemFrameFrameNoCorrectionNotMatch
 4423 01f4 0000      		.word	errorxModemFrameCrc
 4424 01f6 0000      		.word	errorxModemRemoteSideCan
 4425 01f8 0000      		.word	errorxModemUnknownResponse
 4426 01fa 0000      		.word	errorNoRemoteDevice
 4427 01fc 0000      		.word	errorBootloaderNotResponding
 4428 01fe 0000      		.word	errorOpenFile
 4429               	.global	BladBuforaPozostaloBajtowStr
 4432               	BladBuforaPozostaloBajtowStr:
 4433 0200 2121 2120 		.string	"!!! W budorze Rs485 pozostalo %d bajtow\r\n"
 4433      5720 6275 
 4433      646F 727A 
 4433      6520 5273 
 4433      3438 3520 
 4434               	.global	nlStr
 4437               	nlStr:
 4438 022a 0D0A 00   		.string	"\r\n"
 4439               	.global	okStr
 4442               	okStr:
 4443 022d 4F4B 0D0A 		.string	"OK\r\n"
 4443      00
 4444               		.comm	fdVty,6,1
 4445               	.global	cmd_help_zapiszMW
 4448               	cmd_help_zapiszMW:
 4449 0232 5B41 5D20 		.string	"[A] save execution module settings"
 4449      7361 7665 
 4449      2065 7865 
 4449      6375 7469 
 4449      6F6E 206D 
 4450               	.global	cmd_zapiszMW
 4453               	cmd_zapiszMW:
 4454 0255 7273 6176 		.string	"rsave"
 4454      6500 
 4455               	.global	cmd_help_ustawMW
 4458               	cmd_help_ustawMW:
 4459 025b 5B41 5D20 		.string	"[A] [C] set execution module"
 4459      5B43 5D20 
 4459      7365 7420 
 4459      6578 6563 
 4459      7574 696F 
 4460               	.global	cmd_ustawMW
 4463               	cmd_ustawMW:
 4464 0278 7273 6574 		.string	"rset"
 4464      00
 4465               	.global	cmd_help_ustawR
 4468               	cmd_help_ustawR:
 4469 027d 5B76 616C 		.string	"[value] set resistance value"
 4469      7565 5D20 
 4469      7365 7420 
 4469      7265 7369 
 4469      7374 616E 
 4470               	.global	cmd_ustawR
 4473               	cmd_ustawR:
 4474 029a 7365 7472 		.string	"setr"
 4474      00
 4475               	.global	cmd_help_conf_save
 4478               	cmd_help_conf_save:
 4479 029f 5361 7665 		.string	"Save configuration"
 4479      2063 6F6E 
 4479      6669 6775 
 4479      7261 7469 
 4479      6F6E 00
 4480               	.global	cmd_conf_save
 4483               	cmd_conf_save:
 4484 02b2 7361 7665 		.string	"save"
 4484      00
 4485               	.global	cmd_help_conf_mac
 4488               	cmd_help_conf_mac:
 4489 02b7 5B41 315D 		.string	"[A1] [A2] [A3] [A4] [A5] [A6] set MAC address"
 4489      205B 4132 
 4489      5D20 5B41 
 4489      335D 205B 
 4489      4134 5D20 
 4490               	.global	cmd_conf_mac
 4493               	cmd_conf_mac:
 4494 02e5 6D61 6300 		.string	"mac"
 4495               	.global	cmd_conf_ip_gw_help
 4498               	cmd_conf_ip_gw_help:
 4499 02e9 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set default gateway"
 4499      205B 4132 
 4499      5D20 5B41 
 4499      335D 205B 
 4499      4134 5D20 
 4500               	.global	cmd_conf_ip_gw
 4503               	cmd_conf_ip_gw:
 4504 0311 6777 00   		.string	"gw"
 4505               	.global	cmd_conf_ip_mask_help
 4508               	cmd_conf_ip_mask_help:
 4509 0314 5B6D 6173 		.string	"[mask] set mask"
 4509      6B5D 2073 
 4509      6574 206D 
 4509      6173 6B00 
 4510               	.global	cmd_conf_ip_mask
 4513               	cmd_conf_ip_mask:
 4514 0324 6D61 736B 		.string	"mask"
 4514      00
 4515               	.global	cmd_help_conf_udp
 4518               	cmd_help_conf_udp:
 4519 0329 5B41 315D 		.string	"[A1] [A2] [A3] [A4] [src port] {dst port} set udp client IP address and ports"
 4519      205B 4132 
 4519      5D20 5B41 
 4519      335D 205B 
 4519      4134 5D20 
 4520               	.global	cmd_conf_udp
 4523               	cmd_conf_udp:
 4524 0377 7564 7000 		.string	"udp"
 4525               	.global	cmd_help_conf_ip
 4528               	cmd_help_conf_ip:
 4529 037b 5B41 315D 		.string	"[A1] [A2] [A3] [A4] set IP address"
 4529      205B 4132 
 4529      5D20 5B41 
 4529      335D 205B 
 4529      4134 5D20 
 4530               	.global	cmd_conf_ip
 4533               	cmd_conf_ip:
 4534 039e 6970 00   		.string	"ip"
 4535               	.global	cmd_help_configure
 4538               	cmd_help_configure:
 4539 03a1 436F 6E66 		.string	"Configure mode"
 4539      6967 7572 
 4539      6520 6D6F 
 4539      6465 00
 4540               	.global	cmd_configure
 4543               	cmd_configure:
 4544 03b0 636F 6E66 		.string	"config"
 4544      6967 00
 4545               	.global	cmd_help_disable
 4548               	cmd_help_disable:
 4549 03b7 5669 6577 		.string	"View mode"
 4549      206D 6F64 
 4549      6500 
 4550               	.global	cmd_disable
 4553               	cmd_disable:
 4554 03c1 6469 7361 		.string	"disable"
 4554      626C 6500 
 4555               	.global	cmd_help_enable
 4558               	cmd_help_enable:
 4559 03c9 456E 6162 		.string	"Enable mode"
 4559      6C65 206D 
 4559      6F64 6500 
 4560               	.global	cmd_enable
 4563               	cmd_enable:
 4564 03d5 656E 6162 		.string	"enable"
 4564      6C65 00
 4565               	.global	cmd_help_ac
 4568               	cmd_help_ac:
 4569 03dc 5B63 6861 		.string	"[channel 0-7] read analog value"
 4569      6E6E 656C 
 4569      2030 2D37 
 4569      5D20 7265 
 4569      6164 2061 
 4570               	.global	cmd_ac
 4573               	cmd_ac:
 4574 03fc 6163 00   		.string	"ac"
 4575               	.global	cmd_help_settime
 4578               	cmd_help_settime:
 4579 03ff 5B68 5D20 		.string	"[h] [m] [s] set time (24h format)"
 4579      5B6D 5D20 
 4579      5B73 5D20 
 4579      7365 7420 
 4579      7469 6D65 
 4580               	.global	cmd_settime
 4583               	cmd_settime:
 4584 0421 7365 7474 		.string	"settime"
 4584      696D 6500 
 4585               	.global	cmd_help_spb
 4588               	cmd_help_spb:
 4589 0429 5B76 616C 		.string	"[value] set port B"
 4589      7565 5D20 
 4589      7365 7420 
 4589      706F 7274 
 4589      2042 00
 4590               	.global	cmd_spb
 4593               	cmd_spb:
 4594 043c 7370 6200 		.string	"spb"
 4595               	.global	cmd_help_spa
 4598               	cmd_help_spa:
 4599 0440 5B76 616C 		.string	"[value] set port A"
 4599      7565 5D20 
 4599      7365 7420 
 4599      706F 7274 
 4599      2041 00
 4600               	.global	cmd_spa
 4603               	cmd_spa:
 4604 0453 7370 6100 		.string	"spa"
 4605               	.global	cmd_help_down
 4608               	cmd_help_down:
 4609 0457 5B64 7269 		.string	"[driver no] [channel] {value} move down"
 4609      7665 7220 
 4609      6E6F 5D20 
 4609      5B63 6861 
 4609      6E6E 656C 
 4610               	.global	cmd_down
 4613               	cmd_down:
 4614 047f 646F 776E 		.string	"down"
 4614      00
 4615               	.global	cmd_help_up
 4618               	cmd_help_up:
 4619 0484 5B64 7269 		.string	"[driver no] [channel] {value} move up"
 4619      7665 7220 
 4619      6E6F 5D20 
 4619      5B63 6861 
 4619      6E6E 656C 
 4620               	.global	cmd_up
 4623               	cmd_up:
 4624 04aa 7570 00   		.string	"up"
 4625               	.global	cmd_help_read_rf
 4628               	cmd_help_read_rf:
 4629 04ad 5B66 696C 		.string	"[file name] read file located on ram disk"
 4629      6520 6E61 
 4629      6D65 5D20 
 4629      7265 6164 
 4629      2066 696C 
 4630               	.global	cmd_read_rf
 4633               	cmd_read_rf:
 4634 04d7 7265 6164 		.string	"readrf"
 4634      7266 00
 4635               	.global	cmd_help_edit_rf
 4638               	cmd_help_edit_rf:
 4639 04de 5B66 696C 		.string	"[file name] edit file located on ram disk"
 4639      6520 6E61 
 4639      6D65 5D20 
 4639      6564 6974 
 4639      2066 696C 
 4640               	.global	cmd_edit_rf
 4643               	cmd_edit_rf:
 4644 0508 6564 6974 		.string	"editrf"
 4644      7266 00
 4645               	.global	cmd_help_erase_rf
 4648               	cmd_help_erase_rf:
 4649 050f 5B66 696C 		.string	"[file name] erase file from ram disk"
 4649      6520 6E61 
 4649      6D65 5D20 
 4649      6572 6173 
 4649      6520 6669 
 4650               	.global	cmd_erase_rf
 4653               	cmd_erase_rf:
 4654 0534 6572 6173 		.string	"eraserf"
 4654      6572 6600 
 4655               	.global	cmd_help_create_rf
 4658               	cmd_help_create_rf:
 4659 053c 5B66 696C 		.string	"[file name] create ram file"
 4659      6520 6E61 
 4659      6D65 5D20 
 4659      6372 6561 
 4659      7465 2072 
 4660               	.global	cmd_create_rf
 4663               	cmd_create_rf:
 4664 0558 6372 6600 		.string	"crf"
 4665               	.global	cmd_help_dir_rf
 4668               	cmd_help_dir_rf:
 4669 055c 5072 696E 		.string	"Print ramdisk files"
 4669      7420 7261 
 4669      6D64 6973 
 4669      6B20 6669 
 4669      6C65 7300 
 4670               	.global	cmd_dir_rf
 4673               	cmd_dir_rf:
 4674 0570 6469 7272 		.string	"dirrf"
 4674      6600 
 4675               	.global	cmd_help_xflash
 4678               	cmd_help_xflash:
 4679 0576 5B64 6576 		.string	"[device no] [file name] flash device connected to Rs485"
 4679      6963 6520 
 4679      6E6F 5D20 
 4679      5B66 696C 
 4679      6520 6E61 
 4680               	.global	cmd_xflash
 4683               	cmd_xflash:
 4684 05ae 7866 6C61 		.string	"xflash"
 4684      7368 00
 4685               	.global	cmd_help_xSend
 4688               	cmd_help_xSend:
 4689 05b5 5B66 696C 		.string	"[file name] send file using xModem"
 4689      6520 6E61 
 4689      6D65 5D20 
 4689      7365 6E64 
 4689      2066 696C 
 4690               	.global	cmd_xSend
 4693               	cmd_xSend:
 4694 05d8 7873 656E 		.string	"xsend"
 4694      6400 
 4695               	.global	cmd_help_xRec
 4698               	cmd_help_xRec:
 4699 05de 5B66 696C 		.string	"[file name] receive file using xModem"
 4699      6520 6E61 
 4699      6D65 5D20 
 4699      7265 6365 
 4699      6976 6520 
 4700               	.global	cmd_xRec
 4703               	cmd_xRec:
 4704 0604 7872 6563 		.string	"xrec"
 4704      00
 4705               	.global	cmd_help_ping
 4708               	cmd_help_ping:
 4709 0609 5B41 315D 		.string	"[A1] [A2] [A3] [A4] Sends ping throught ethernet"
 4709      205B 4132 
 4709      5D20 5B41 
 4709      335D 205B 
 4709      4134 5D20 
 4710               	.global	cmd_ping
 4713               	cmd_ping:
 4714 063a 7069 6E67 		.string	"ping"
 4714      00
 4715               	.global	cmd_help_rping
 4718               	cmd_help_rping:
 4719 063f 5B44 6576 		.string	"[Device no] Send ping to Rs485 device"
 4719      6963 6520 
 4719      6E6F 5D20 
 4719      5365 6E64 
 4719      2070 696E 
 4720               	.global	cmd_rping
 4723               	cmd_rping:
 4724 0665 7270 696E 		.string	"rping"
 4724      6700 
 4725               	.global	cmd_help_net_dbg
 4728               	cmd_help_net_dbg:
 4729 066b 5B61 7270 		.string	"[arp|icmp|ip|tcp|udp] [level] write debug info. Level 0 disable debuging"
 4729      7C69 636D 
 4729      707C 6970 
 4729      7C74 6370 
 4729      7C75 6470 
 4730               	.global	cmd_net_dbg
 4733               	cmd_net_dbg:
 4734 06b4 6465 6275 		.string	"debug"
 4734      6700 
 4735               	.global	cmd_help_time
 4738               	cmd_help_time:
 4739 06ba 5072 696E 		.string	"Print time"
 4739      7420 7469 
 4739      6D65 00
 4740               	.global	cmd_time
 4743               	cmd_time:
 4744 06c5 7469 6D65 		.string	"time"
 4744      00
 4745               	.global	cmd_help_enc_stat
 4748               	cmd_help_enc_stat:
 4749 06ca 5072 696E 		.string	"Print Enc 28j60 registers"
 4749      7420 456E 
 4749      6320 3238 
 4749      6A36 3020 
 4749      7265 6769 
 4750               	.global	cmd_enc_stat
 4753               	cmd_enc_stat:
 4754 06e4 656E 6373 		.string	"encstat"
 4754      7461 7400 
 4755               	.global	cmd_help_status
 4758               	cmd_help_status:
 4759 06ec 7B66 696C 		.string	"{filename} Print device status on VTY or write to file"
 4759      656E 616D 
 4759      657D 2050 
 4759      7269 6E74 
 4759      2064 6576 
 4760               	.global	cmd_status
 4763               	cmd_status:
 4764 0723 7374 6174 		.string	"status"
 4764      7573 00
 4765               	.global	cmd_help_help
 4768               	cmd_help_help:
 4769 072a 5072 696E 		.string	"Print help string"
 4769      7420 6865 
 4769      6C70 2073 
 4769      7472 696E 
 4769      6700 
 4770               	.global	cmd_help
 4773               	cmd_help:
 4774 073c 6865 6C70 		.string	"help"
 4774      00
 4775               	.global	debugDisabledInfoStr
 4778               	debugDisabledInfoStr:
 4779 0741 4469 7361 		.string	"Disabled %s debug\r\n"
 4779      626C 6564 
 4779      2025 7320 
 4779      6465 6275 
 4779      670D 0A00 
 4780               	.global	debugEnabledInfoStr
 4783               	debugEnabledInfoStr:
 4784 0755 456E 6162 		.string	"Enabled %s debug\r\n"
 4784      6C65 6420 
 4784      2573 2064 
 4784      6562 7567 
 4784      0D0A 00
 4785               	.global	movingCurtainPosStr
 4788               	movingCurtainPosStr:
 4789 0768 0970 6F7A 		.string	"\tpozycja   %d\r\n"
 4789      7963 6A61 
 4789      2020 2025 
 4789      640D 0A00 
 4790               	.global	movingCurtainDownStr
 4793               	movingCurtainDownStr:
 4794 0778 4F70 7573 		.string	"Opuszczanie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4794      7A63 7A61 
 4794      6E69 6520 
 4794      726F 6C65 
 4794      7479 0D0A 
 4795               	.global	movingCurtainUpStr
 4798               	movingCurtainUpStr:
 4799 07ab 506F 646E 		.string	"Podnoszenie rolety\r\n\tsterownik %d\r\n\troleta    %d\r\n"
 4799      6F73 7A65 
 4799      6E69 6520 
 4799      726F 6C65 
 4799      7479 0D0A 
 4800               	.global	xwyslijStartStr
 4803               	xwyslijStartStr:
 4804 07de 586D 6F64 		.string	"Xmodem: Transmission start\r\n"
 4804      656D 3A20 
 4804      5472 616E 
 4804      736D 6973 
 4804      7369 6F6E 
 4805               	.global	readRamFIleLenStr
 4808               	readRamFIleLenStr:
 4809 07fb 4669 6C65 		.string	"File length: %d\r\n"
 4809      206C 656E 
 4809      6774 683A 
 4809      2025 640D 
 4809      0A00 
 4810               	.global	editRamFileIntroStr
 4813               	editRamFileIntroStr:
 4814 080d 5772 6974 		.string	"Writing to file. Press CTRL+C to quit\r\n"
 4814      696E 6720 
 4814      746F 2066 
 4814      696C 652E 
 4814      2050 7265 
 4815               	.global	statusLockerSensorsDisStr
 4818               	statusLockerSensorsDisStr:
 4819 0835 2020 4C6F 		.string	"  Locker sensors disabled\r\n"
 4819      636B 6572 
 4819      2073 656E 
 4819      736F 7273 
 4819      2064 6973 
 4820               	.global	statusLockerSensorsStr
 4823               	statusLockerSensorsStr:
 4824 0851 4C6F 636B 		.string	"Locker sensors states:\r\n"
 4824      6572 2073 
 4824      656E 736F 
 4824      7273 2073 
 4824      7461 7465 
 4825               	.global	statusNoRs485Dev
 4828               	statusNoRs485Dev:
 4829 086a 2020 4361 		.string	"  Can't find any device\r\n"
 4829      6E27 7420 
 4829      6669 6E64 
 4829      2061 6E79 
 4829      2064 6576 
 4830               	.global	statusRs485listStr
 4833               	statusRs485listStr:
 4834 0884 4465 7465 		.string	"Detected RS 485 devices:\r\n"
 4834      6374 6564 
 4834      2052 5320 
 4834      3438 3520 
 4834      6465 7669 
 4835               	.global	statusIpGwStr
 4838               	statusIpGwStr:
 4839 089f 2020 6761 		.string	"  gateway         : "
 4839      7465 7761 
 4839      7920 2020 
 4839      2020 2020 
 4839      2020 3A20 
 4840               	.global	statusIpMaskStr
 4843               	statusIpMaskStr:
 4844 08b4 2020 6D61 		.string	"  mask            : "
 4844      736B 2020 
 4844      2020 2020 
 4844      2020 2020 
 4844      2020 3A20 
 4845               	.global	statusIpStr
 4848               	statusIpStr:
 4849 08c9 2020 4950 		.string	"  IP address      : "
 4849      2061 6464 
 4849      7265 7373 
 4849      2020 2020 
 4849      2020 3A20 
 4850               	.global	statusMacStr
 4853               	statusMacStr:
 4854 08de 2020 4D61 		.string	"  Mac address     : "
 4854      6320 6164 
 4854      6472 6573 
 4854      7320 2020 
 4854      2020 3A20 
 4855               	.global	systemRamConfigStr
 4858               	systemRamConfigStr:
 4859 08f3 5379 7374 		.string	"System settings:\r\n"
 4859      656D 2073 
 4859      6574 7469 
 4859      6E67 733A 
 4859      0D0A 00
 4860               	.global	statusVoltageStr
 4863               	statusVoltageStr:
 4864 0906 2020 566F 		.string	"  Voltage         : %d V\r\n"
 4864      6C74 6167 
 4864      6520 2020 
 4864      2020 2020 
 4864      2020 3A20 
 4865               	.global	statusTemperatureStr
 4868               	statusTemperatureStr:
 4869 0921 2020 5465 		.string	"  Temperature     : %d C\r\n"
 4869      6D70 6572 
 4869      6174 7572 
 4869      6520 2020 
 4869      2020 3A20 
 4870               	.global	statusRamDiskStateStr
 4873               	statusRamDiskStateStr:
 4874 093c 2020 5261 		.string	"  Ram disc space  : %d free of %d clusters\r\n"
 4874      6D20 6469 
 4874      7363 2073 
 4874      7061 6365 
 4874      2020 3A20 
 4875               	.global	statusDynamicHeapStateStr
 4878               	statusDynamicHeapStateStr:
 4879 0969 2020 4D61 		.string	"  Malloc heap     : %d free of %d bytes\r\n"
 4879      6C6C 6F63 
 4879      2068 6561 
 4879      7020 2020 
 4879      2020 3A20 
 4880               	.global	statusStaticHeapStateStr
 4883               	statusStaticHeapStateStr:
 4884 0993 2020 4672 		.string	"  FreeRtos heap   : %d free of %d bytes\r\n"
 4884      6565 5274 
 4884      6F73 2068 
 4884      6561 7020 
 4884      2020 3A20 
 4885               	.global	statusNumberOfTasksStr
 4888               	statusNumberOfTasksStr:
 4889 09bd 2020 4E75 		.string	"  Number of tasks : %d\r\n"
 4889      6D62 6572 
 4889      206F 6620 
 4889      7461 736B 
 4889      7320 3A20 
 4890               	.global	systemStateStr
 4893               	systemStateStr:
 4894 09d6 5379 7374 		.string	"System state:\r\n"
 4894      656D 2073 
 4894      7461 7465 
 4894      3A0D 0A00 
 4895               	.global	errorOpenFile
 4898               	errorOpenFile:
 4899 09e6 4361 6E27 		.string	"Can't open file %s\r\n"
 4899      7420 6F70 
 4899      656E 2066 
 4899      696C 6520 
 4899      2573 0D0A 
 4900               	.global	errorBootloaderNotResponding
 4903               	errorBootloaderNotResponding:
 4904 09fb 426F 6F74 		.string	"Bootloader is not responding\r\n"
 4904      6C6F 6164 
 4904      6572 2069 
 4904      7320 6E6F 
 4904      7420 7265 
 4905               	.global	errorNoRemoteDevice
 4908               	errorNoRemoteDevice:
 4909 0a1a 4465 7669 		.string	"Device %d is not responding (%d)\r\n"
 4909      6365 2025 
 4909      6420 6973 
 4909      206E 6F74 
 4909      2072 6573 
 4910               	.global	errorxModemUnknownResponse
 4913               	errorxModemUnknownResponse:
 4914 0a3d 784D 6F64 		.string	"xModem unknown response 0x%x\r\n"
 4914      656D 2075 
 4914      6E6B 6E6F 
 4914      776E 2072 
 4914      6573 706F 
 4915               	.global	errorxModemRemoteSideCan
 4918               	errorxModemRemoteSideCan:
 4919 0a5c 5265 6D6F 		.string	"Remote side cancelled at frame no %d\r\n"
 4919      7465 2073 
 4919      6964 6520 
 4919      6361 6E63 
 4919      656C 6C65 
 4920               	.global	errorxModemFrameCrc
 4923               	errorxModemFrameCrc:
 4924 0a83 784D 6F64 		.string	"xModem CRC error\r\n"
 4924      656D 2043 
 4924      5243 2065 
 4924      7272 6F72 
 4924      0D0A 00
 4925               	.global	errorxModemFrameFrameNoCorrectionNotMatch
 4928               	errorxModemFrameFrameNoCorrectionNotMatch:
 4929 0a96 0D0A 00   		.string	"\r\n"
 4930               	.global	errorxModemWrongFrameNo
 4933               	errorxModemWrongFrameNo:
 4934 0a99 0D0A 00   		.string	"\r\n"
 4935               	.global	errorxModemByteSendTimeout
 4938               	errorxModemByteSendTimeout:
 4939 0a9c 0D0A 00   		.string	"\r\n"
 4940               	.global	errorxModemFrameStartTimeout
 4943               	errorxModemFrameStartTimeout:
 4944 0a9f 0D0A 00   		.string	"\r\n"
 4945               	.global	errorNoFile
 4948               	errorNoFile:
 4949 0aa2 4E6F 2046 		.string	"No File\r\n"
 4949      696C 650D 
 4949      0A00 
 4950               	.global	errorOK
 4953               	errorOK:
 4954 0aac 416C 6C20 		.string	"All OK\r\n"
 4954      4F4B 0D0A 
 4954      00
 4955               		.comm	czasRtc,7,1
 4956               		.comm	sockets,2,1
 4957               		.comm	tcpDebugLevel,1,1
 4958               		.comm	tcpDebugStream,2,1
 4959               		.comm	IpMyConfig,15,1
 4960               		.comm	udpDbgLevel,1,1
 4961               		.comm	udpDbgStream,2,1
 4962               		.comm	udpSocket,2,1
 4963               		.comm	icmpDebugLevel,1,1
 4964               		.comm	icmpDebug,2,1
 4965               		.comm	arpDebugLevel,1,1
 4966               		.comm	arpDebug,2,1
 4967               		.comm	nicState,14,1
 4968               		.comm	xSemaphoreRs485,2,1
 4969               		.comm	lockSensors,2,1
 4970               		.comm	portB,1,1
 4971               		.comm	portA,1,1
 4972               		.comm	xSemaphoreSpiSS,2,1
 4973               		.comm	rollers,2,1
 4974               		.comm	wwwport,1,1
 4975               		.comm	klastry,128,1
 5107               		.weak	nicSetMacAddress
 5108               		.weak	nicRegDump
 5109               		.text
 5111               	.Letext0:
 5112               		.ident	"GCC: (GNU) 4.9.2"
 5113               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 vty.c
     /tmp/cc7Bb8kr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7Bb8kr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7Bb8kr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7Bb8kr.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc7Bb8kr.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7Bb8kr.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7Bb8kr.s:275    .text:0000000000000000 enableFunction
     /tmp/cc7Bb8kr.s:4300   .progmem.data:0000000000000110 cmdListEnable
     /tmp/cc7Bb8kr.s:320    .text:0000000000000020 disableFunction
     /tmp/cc7Bb8kr.s:4385   .progmem.data:00000000000001b2 cmdListNormal
     /tmp/cc7Bb8kr.s:357    .text:0000000000000038 configureModeFunction
     /tmp/cc7Bb8kr.s:4257   .progmem.data:00000000000000c2 cmdListConfigure
     /tmp/cc7Bb8kr.s:402    .text:0000000000000058 pingFunction
     /tmp/cc7Bb8kr.s:437    .text:000000000000006c readRamFIleFunction
                            *COM*:0000000000000006 fdVty
     /tmp/cc7Bb8kr.s:4898   .progmem.data:00000000000009e6 errorOpenFile
     /tmp/cc7Bb8kr.s:4808   .progmem.data:00000000000007fb readRamFIleLenStr
     /tmp/cc7Bb8kr.s:4437   .progmem.data:000000000000022a nlStr
     /tmp/cc7Bb8kr.s:603    .text:0000000000000164 writeRamFileFunction
     /tmp/cc7Bb8kr.s:630    .text:0000000000000174 pokazCzasFunction
                            *COM*:0000000000000007 czasRtc
     /tmp/cc7Bb8kr.s:4252   .progmem.data:00000000000000a9 __c.3649
     /tmp/cc7Bb8kr.s:745    .text:0000000000000210 helpFunction
     /tmp/cc7Bb8kr.s:769    .text:000000000000021a czytajAC_Function
     /tmp/cc7Bb8kr.s:4248   .progmem.data:0000000000000086 __c.3718
     /tmp/cc7Bb8kr.s:838    .text:0000000000000274 setTimeFunction
     /tmp/cc7Bb8kr.s:989    .text:0000000000000348 ustawPortExtBFunction
     /tmp/cc7Bb8kr.s:1029   .text:000000000000036c ustawPortExtAFunction
     /tmp/cc7Bb8kr.s:1069   .text:0000000000000390 curtainDownFunction
     /tmp/cc7Bb8kr.s:4793   .progmem.data:0000000000000778 movingCurtainDownStr
     /tmp/cc7Bb8kr.s:4788   .progmem.data:0000000000000768 movingCurtainPosStr
     /tmp/cc7Bb8kr.s:1200   .text:0000000000000442 statusEncFunction
     /tmp/cc7Bb8kr.s:1227   .text:0000000000000452 saveConfigFunction
     /tmp/cc7Bb8kr.s:1251   .text:000000000000045c goXmodemWyslijFunction
     /tmp/cc7Bb8kr.s:4803   .progmem.data:00000000000007de xwyslijStartStr
     /tmp/cc7Bb8kr.s:1336   .text:00000000000004ce zapiszModWykFunction
     /tmp/cc7Bb8kr.s:1382   .text:00000000000004f0 ustawModWykFunction
     /tmp/cc7Bb8kr.s:1443   .text:000000000000052a ustawPortRezystor
     /tmp/cc7Bb8kr.s:1489   .text:000000000000054c curtainUpFunction
     /tmp/cc7Bb8kr.s:4798   .progmem.data:00000000000007ab movingCurtainUpStr
     /tmp/cc7Bb8kr.s:1656   .text:0000000000000618 editRamFileFunction
     /tmp/cc7Bb8kr.s:4813   .progmem.data:000000000000080d editRamFileIntroStr
     /tmp/cc7Bb8kr.s:1797   .text:00000000000006e2 goXmodemOdbierzFunction
     /tmp/cc7Bb8kr.s:4244   .progmem.data:0000000000000066 __c.3768
     /tmp/cc7Bb8kr.s:2422   .text:0000000000000a48 debugFunction
     /tmp/cc7Bb8kr.s:4240   .progmem.data:0000000000000062 __c.3656
     /tmp/cc7Bb8kr.s:4236   .progmem.data:000000000000005f __c.3658
     /tmp/cc7Bb8kr.s:4232   .progmem.data:000000000000005a __c.3660
     /tmp/cc7Bb8kr.s:4228   .progmem.data:0000000000000056 __c.3662
     /tmp/cc7Bb8kr.s:4778   .progmem.data:0000000000000741 debugDisabledInfoStr
     /tmp/cc7Bb8kr.s:4224   .progmem.data:0000000000000052 __c.3664
     /tmp/cc7Bb8kr.s:4220   .progmem.data:000000000000004e __c.3666
     /tmp/cc7Bb8kr.s:4216   .progmem.data:000000000000004b __c.3668
     /tmp/cc7Bb8kr.s:4212   .progmem.data:0000000000000046 __c.3670
     /tmp/cc7Bb8kr.s:4208   .progmem.data:0000000000000042 __c.3672
     /tmp/cc7Bb8kr.s:4204   .progmem.data:000000000000003e __c.3674
     /tmp/cc7Bb8kr.s:4783   .progmem.data:0000000000000755 debugEnabledInfoStr
     /tmp/cc7Bb8kr.s:2706   .text:0000000000000bee setMacAddrFunction
                            *COM*:000000000000000e nicState
     /tmp/cc7Bb8kr.s:2791   .text:0000000000000c5c setUdpFunction
                            *COM*:0000000000000002 udpSocket
     /tmp/cc7Bb8kr.s:2960   .text:0000000000000d42 setIpGwFunction
     /tmp/cc7Bb8kr.s:3081   .text:0000000000000de0 setIpMaskFunction
     /tmp/cc7Bb8kr.s:3144   .text:0000000000000e20 setIpFunction
     /tmp/cc7Bb8kr.s:3267   .text:0000000000000ebe VtyInit
     /tmp/cc7Bb8kr.s:3305   .text:0000000000000ee0 printErrorInfo
     /tmp/cc7Bb8kr.s:4416   .progmem.data:00000000000001e8 errorStrings
     /tmp/cc7Bb8kr.s:3387   .text:0000000000000f36 rpingFunction
     /tmp/cc7Bb8kr.s:3479   .text:0000000000000f94 eraseRamFileFunction
     /tmp/cc7Bb8kr.s:3527   .text:0000000000000fc0 dodajRamPlikFunction
     /tmp/cc7Bb8kr.s:3595   .text:0000000000000ffa flashExModuleFunction
     /tmp/cc7Bb8kr.s:3741   .text:00000000000010aa printStatus
     /tmp/cc7Bb8kr.s:4200   .progmem.data:000000000000000c __c.3625
     /tmp/cc7Bb8kr.s:4893   .progmem.data:00000000000009d6 systemStateStr
     /tmp/cc7Bb8kr.s:4888   .progmem.data:00000000000009bd statusNumberOfTasksStr
     /tmp/cc7Bb8kr.s:4883   .progmem.data:0000000000000993 statusStaticHeapStateStr
     /tmp/cc7Bb8kr.s:4878   .progmem.data:0000000000000969 statusDynamicHeapStateStr
     /tmp/cc7Bb8kr.s:4868   .progmem.data:0000000000000921 statusTemperatureStr
     /tmp/cc7Bb8kr.s:4863   .progmem.data:0000000000000906 statusVoltageStr
     /tmp/cc7Bb8kr.s:4873   .progmem.data:000000000000093c statusRamDiskStateStr
     /tmp/cc7Bb8kr.s:4858   .progmem.data:00000000000008f3 systemRamConfigStr
     /tmp/cc7Bb8kr.s:4853   .progmem.data:00000000000008de statusMacStr
     /tmp/cc7Bb8kr.s:4196   .progmem.data:0000000000000009 __c.3628
     /tmp/cc7Bb8kr.s:4848   .progmem.data:00000000000008c9 statusIpStr
     /tmp/cc7Bb8kr.s:4192   .progmem.data:0000000000000006 __c.3630
     /tmp/cc7Bb8kr.s:4843   .progmem.data:00000000000008b4 statusIpMaskStr
     /tmp/cc7Bb8kr.s:4188   .progmem.data:0000000000000003 __c.3632
     /tmp/cc7Bb8kr.s:4838   .progmem.data:000000000000089f statusIpGwStr
     /tmp/cc7Bb8kr.s:4184   .progmem.data:0000000000000000 __c.3634
     /tmp/cc7Bb8kr.s:4833   .progmem.data:0000000000000884 statusRs485listStr
     /tmp/cc7Bb8kr.s:4823   .progmem.data:0000000000000851 statusLockerSensorsStr
     /tmp/cc7Bb8kr.s:4818   .progmem.data:0000000000000835 statusLockerSensorsDisStr
     /tmp/cc7Bb8kr.s:4064   .text:00000000000012da statusFunction
     /tmp/cc7Bb8kr.s:4773   .progmem.data:000000000000073c cmd_help
     /tmp/cc7Bb8kr.s:4768   .progmem.data:000000000000072a cmd_help_help
     /tmp/cc7Bb8kr.s:4763   .progmem.data:0000000000000723 cmd_status
     /tmp/cc7Bb8kr.s:4758   .progmem.data:00000000000006ec cmd_help_status
     /tmp/cc7Bb8kr.s:4743   .progmem.data:00000000000006c5 cmd_time
     /tmp/cc7Bb8kr.s:4738   .progmem.data:00000000000006ba cmd_help_time
     /tmp/cc7Bb8kr.s:4583   .progmem.data:0000000000000421 cmd_settime
     /tmp/cc7Bb8kr.s:4578   .progmem.data:00000000000003ff cmd_help_settime
     /tmp/cc7Bb8kr.s:4533   .progmem.data:000000000000039e cmd_conf_ip
     /tmp/cc7Bb8kr.s:4528   .progmem.data:000000000000037b cmd_help_conf_ip
     /tmp/cc7Bb8kr.s:4513   .progmem.data:0000000000000324 cmd_conf_ip_mask
     /tmp/cc7Bb8kr.s:4508   .progmem.data:0000000000000314 cmd_conf_ip_mask_help
     /tmp/cc7Bb8kr.s:4503   .progmem.data:0000000000000311 cmd_conf_ip_gw
     /tmp/cc7Bb8kr.s:4498   .progmem.data:00000000000002e9 cmd_conf_ip_gw_help
     /tmp/cc7Bb8kr.s:4523   .progmem.data:0000000000000377 cmd_conf_udp
     /tmp/cc7Bb8kr.s:4518   .progmem.data:0000000000000329 cmd_help_conf_udp
     /tmp/cc7Bb8kr.s:4493   .progmem.data:00000000000002e5 cmd_conf_mac
     /tmp/cc7Bb8kr.s:4488   .progmem.data:00000000000002b7 cmd_help_conf_mac
     /tmp/cc7Bb8kr.s:4483   .progmem.data:00000000000002b2 cmd_conf_save
     /tmp/cc7Bb8kr.s:4478   .progmem.data:000000000000029f cmd_help_conf_save
     /tmp/cc7Bb8kr.s:4563   .progmem.data:00000000000003d5 cmd_enable
     /tmp/cc7Bb8kr.s:4558   .progmem.data:00000000000003c9 cmd_help_enable
     /tmp/cc7Bb8kr.s:4553   .progmem.data:00000000000003c1 cmd_disable
     /tmp/cc7Bb8kr.s:4548   .progmem.data:00000000000003b7 cmd_help_disable
     /tmp/cc7Bb8kr.s:4753   .progmem.data:00000000000006e4 cmd_enc_stat
     /tmp/cc7Bb8kr.s:4748   .progmem.data:00000000000006ca cmd_help_enc_stat
     /tmp/cc7Bb8kr.s:4733   .progmem.data:00000000000006b4 cmd_net_dbg
     /tmp/cc7Bb8kr.s:4728   .progmem.data:000000000000066b cmd_help_net_dbg
     /tmp/cc7Bb8kr.s:4723   .progmem.data:0000000000000665 cmd_rping
     /tmp/cc7Bb8kr.s:4718   .progmem.data:000000000000063f cmd_help_rping
     /tmp/cc7Bb8kr.s:4713   .progmem.data:000000000000063a cmd_ping
     /tmp/cc7Bb8kr.s:4708   .progmem.data:0000000000000609 cmd_help_ping
     /tmp/cc7Bb8kr.s:4703   .progmem.data:0000000000000604 cmd_xRec
     /tmp/cc7Bb8kr.s:4698   .progmem.data:00000000000005de cmd_help_xRec
     /tmp/cc7Bb8kr.s:4693   .progmem.data:00000000000005d8 cmd_xSend
     /tmp/cc7Bb8kr.s:4688   .progmem.data:00000000000005b5 cmd_help_xSend
     /tmp/cc7Bb8kr.s:4683   .progmem.data:00000000000005ae cmd_xflash
     /tmp/cc7Bb8kr.s:4678   .progmem.data:0000000000000576 cmd_help_xflash
     /tmp/cc7Bb8kr.s:4673   .progmem.data:0000000000000570 cmd_dir_rf
     /tmp/cc7Bb8kr.s:4668   .progmem.data:000000000000055c cmd_help_dir_rf
     /tmp/cc7Bb8kr.s:4663   .progmem.data:0000000000000558 cmd_create_rf
     /tmp/cc7Bb8kr.s:4658   .progmem.data:000000000000053c cmd_help_create_rf
     /tmp/cc7Bb8kr.s:4653   .progmem.data:0000000000000534 cmd_erase_rf
     /tmp/cc7Bb8kr.s:4648   .progmem.data:000000000000050f cmd_help_erase_rf
     /tmp/cc7Bb8kr.s:4643   .progmem.data:0000000000000508 cmd_edit_rf
     /tmp/cc7Bb8kr.s:4638   .progmem.data:00000000000004de cmd_help_edit_rf
     /tmp/cc7Bb8kr.s:4633   .progmem.data:00000000000004d7 cmd_read_rf
     /tmp/cc7Bb8kr.s:4628   .progmem.data:00000000000004ad cmd_help_read_rf
     /tmp/cc7Bb8kr.s:4623   .progmem.data:00000000000004aa cmd_up
     /tmp/cc7Bb8kr.s:4618   .progmem.data:0000000000000484 cmd_help_up
     /tmp/cc7Bb8kr.s:4613   .progmem.data:000000000000047f cmd_down
     /tmp/cc7Bb8kr.s:4608   .progmem.data:0000000000000457 cmd_help_down
     /tmp/cc7Bb8kr.s:4603   .progmem.data:0000000000000453 cmd_spa
     /tmp/cc7Bb8kr.s:4598   .progmem.data:0000000000000440 cmd_help_spa
     /tmp/cc7Bb8kr.s:4593   .progmem.data:000000000000043c cmd_spb
     /tmp/cc7Bb8kr.s:4588   .progmem.data:0000000000000429 cmd_help_spb
     /tmp/cc7Bb8kr.s:4473   .progmem.data:000000000000029a cmd_ustawR
     /tmp/cc7Bb8kr.s:4468   .progmem.data:000000000000027d cmd_help_ustawR
     /tmp/cc7Bb8kr.s:4573   .progmem.data:00000000000003fc cmd_ac
     /tmp/cc7Bb8kr.s:4568   .progmem.data:00000000000003dc cmd_help_ac
     /tmp/cc7Bb8kr.s:4543   .progmem.data:00000000000003b0 cmd_configure
     /tmp/cc7Bb8kr.s:4538   .progmem.data:00000000000003a1 cmd_help_configure
     /tmp/cc7Bb8kr.s:4463   .progmem.data:0000000000000278 cmd_ustawMW
     /tmp/cc7Bb8kr.s:4458   .progmem.data:000000000000025b cmd_help_ustawMW
     /tmp/cc7Bb8kr.s:4453   .progmem.data:0000000000000255 cmd_zapiszMW
     /tmp/cc7Bb8kr.s:4448   .progmem.data:0000000000000232 cmd_help_zapiszMW
     /tmp/cc7Bb8kr.s:4953   .progmem.data:0000000000000aac errorOK
     /tmp/cc7Bb8kr.s:4948   .progmem.data:0000000000000aa2 errorNoFile
     /tmp/cc7Bb8kr.s:4943   .progmem.data:0000000000000a9f errorxModemFrameStartTimeout
     /tmp/cc7Bb8kr.s:4938   .progmem.data:0000000000000a9c errorxModemByteSendTimeout
     /tmp/cc7Bb8kr.s:4933   .progmem.data:0000000000000a99 errorxModemWrongFrameNo
     /tmp/cc7Bb8kr.s:4928   .progmem.data:0000000000000a96 errorxModemFrameFrameNoCorrectionNotMatch
     /tmp/cc7Bb8kr.s:4923   .progmem.data:0000000000000a83 errorxModemFrameCrc
     /tmp/cc7Bb8kr.s:4918   .progmem.data:0000000000000a5c errorxModemRemoteSideCan
     /tmp/cc7Bb8kr.s:4913   .progmem.data:0000000000000a3d errorxModemUnknownResponse
     /tmp/cc7Bb8kr.s:4908   .progmem.data:0000000000000a1a errorNoRemoteDevice
     /tmp/cc7Bb8kr.s:4903   .progmem.data:00000000000009fb errorBootloaderNotResponding
     /tmp/cc7Bb8kr.s:4432   .progmem.data:0000000000000200 BladBuforaPozostaloBajtowStr
     /tmp/cc7Bb8kr.s:4442   .progmem.data:000000000000022d okStr
     /tmp/cc7Bb8kr.s:4828   .progmem.data:000000000000086a statusNoRs485Dev
                            *COM*:0000000000000002 sockets
                            *COM*:0000000000000001 tcpDebugLevel
                            *COM*:0000000000000002 tcpDebugStream
                            *COM*:000000000000000f IpMyConfig
                            *COM*:0000000000000001 udpDbgLevel
                            *COM*:0000000000000002 udpDbgStream
                            *COM*:0000000000000001 icmpDebugLevel
                            *COM*:0000000000000002 icmpDebug
                            *COM*:0000000000000001 arpDebugLevel
                            *COM*:0000000000000002 arpDebug
                            *COM*:0000000000000002 xSemaphoreRs485
                            *COM*:0000000000000002 lockSensors
                            *COM*:0000000000000001 portB
                            *COM*:0000000000000001 portA
                            *COM*:0000000000000002 xSemaphoreSpiSS
                            *COM*:0000000000000002 rollers
                            *COM*:0000000000000001 wwwport
                            *COM*:0000000000000080 klastry

UNDEFINED SYMBOLS
cmdlineGetArgStr
ramDyskOtworzPlik
fprintf_P
ramDyskCzytajBajtZPliku
uartVtySendByte
ramDyskZamknijPlik
ramDyskDir
readTimeDecoded
cmdPrintHelp
cmdlineGetArgInt
MCP3008_getSampleSingle
ds1305start
__udivmodqi4
setTimeDecoded
MPC23s17SetDirB
MPC23s17SetPortB
MPC23s17SetDirA
MPC23s17SetPortA
rs485curtainDown
nicRegDump
saveConfiguration
saveSettings
cmdlineGetArgHex
sendSettings
MCP4150_setValue
rs485curtainUp
ramDyskUstawWskaznikNaKoniec
xVtyRec
xQueueGenericReceive
ramDyskZapiszBajtDoPliku
fputc
ramDyskDodajBlokXmodem
strncmp_P
setArpDebug
setIpDebug
setIcmpDebug
setTcpDebug
setUdpDebug
nicSetMacAddress
htons
ipSetConfigGw
ipSetConfigMask
ipSetConfigIp
cmdStateConfigure
rs485ping
ramDyskUsunPlik
ramDyskUtworzPlik
rs485xModemFlash
uxTaskGetNumberOfTasks
xPortGetFreeHeapSize
xmallocAvailable
temperature
voltage
ramDyskLiczbaWolnychKlastrow
netPrintEthAddr
ipGetConfig
netPrintIPAddr
printLockers
udpPrintStatus
ramDyskOtworzPlikStdIo
ramDyskZamknijPlikStdIo
__do_clear_bss
